/* Copyright 2019 Axel Huebl, David Grote, Maxence Thevenet
 * Remi Lehe, Weiqun Zhang, Michael Rowan
 *
 * This file is part of WarpX.
 *
 * License: BSD-3-Clause-LBNL
 */
 #ifndef WARPX_CURRENTDEPOSITION_H_
 #define WARPX_CURRENTDEPOSITION_H_
 
 #include "Particles/Deposition/SharedDepositionUtils.H"
 #include "ablastr/parallelization/KernelTimer.H"
 #include "Particles/Pusher/GetAndSetPosition.H"
 #include "Particles/ShapeFactors.H"
 #include "Utils/TextMsg.H"
 #include "Utils/WarpXAlgorithmSelection.H"
 #include "Utils/WarpXConst.H"
 #ifdef WARPX_DIM_RZ
 #   include "Utils/WarpX_Complex.H"
 #endif
 
 #include "WarpX.H" // todo: remove include and pass globals as args
 
 #include <AMReX.H>
 #include <AMReX_Arena.H>
 #include <AMReX_Array4.H>
 #include <AMReX_Dim3.H>
 #include <AMReX_REAL.H>
 #include <chrono>
 
 #include <RankSortStats.H>
 #include "Utils/WarpXProfilerWrapper.H"
 
 #include <arm_sve.h>
 #include <arm_sme.h>
 
 typedef svfloat64_t svec __attribute__((arm_sve_vector_bits(__ARM_FEATURE_SVE_BITS)));
 typedef svint64_t svecint __attribute__((arm_sve_vector_bits(__ARM_FEATURE_SVE_BITS)));
 typedef svuint64_t svecuint __attribute__((arm_sve_vector_bits(__ARM_FEATURE_SVE_BITS)));
 //  _attribute_((armsve_vector_bits(_ARW_FEATURE_SVE_BITS)));
 // typedef svint64_t svecint;
 // typedef svuint64_t svecuint;
 
inline uint64_t rdtscv(void) {
    uint64_t val;
    asm volatile("mrs %0, cntvct_el0" : "=r" (val) : : "memory");
    return val;
}

inline uint64_t rdtscm(void) __arm_preserves("za") __arm_streaming {
    uint64_t val;
    asm volatile("mrs %0, cntvct_el0" : "=r" (val) : : "memory");
    return val;
}

static inline uint64_t rdtscm1(void) __arm_preserves("za") __arm_streaming {
    uint64_t val;
    asm volatile("isb        \n\t"      /* 确保之前的所有指令完成 */
                "mrs %0, cntvct_el0\n\t"  /* 读取计数器 */
                "isb        \n\t"      /* 确保读取完成 */
                : "=r"(val)
                :
                : "memory");
    return val;
}
 
 class Vec {
 private:
     svec v_;  // 假设 svec 是 svfloat64_t 的别名
 
 public:
     // 默认构造函数
     Vec() = default;
 
     // 从 svfloat64_t 构造
     Vec(svfloat64_t v) : v_(v) {}
 
     // 从 double 构造
     Vec(double v) : v_(svdup_f64(v)) {}
 
     // 转换为 svfloat64_t
     operator svfloat64_t() const {
         return v_;
     }
 
     // 向量加法赋值
     void operator+=(const Vec& rhs) {
         v_ = svadd_f64_x(svptrue_b64(), v_, rhs.v_);
     }
 
     // 向量减法赋值
     void operator-=(const Vec& rhs) {
         v_ = svsub_f64_x(svptrue_b64(), v_, rhs.v_);
     }
 
     // 向量乘法赋值
     void operator*=(const Vec& rhs) {
         v_ = svmul_f64_x(svptrue_b64(), v_, rhs.v_);
     }
 
     // 向量加法
     Vec operator+(const Vec &rhs) const {
         return Vec(svadd_f64_x(svptrue_b64(), v_, rhs.v_));
     }
 
     // 向量减法
     Vec operator-(const Vec &rhs) const {
         return Vec(svsub_f64_x(svptrue_b64(), v_, rhs.v_));
     }
 
     // 向量乘法
     Vec operator*(const Vec &rhs) const {
         return Vec(svmul_f64_x(svptrue_b64(), v_, rhs.v_));
     }
 
     // 向量除法
     Vec operator/(const Vec &rhs) const {
         return Vec(svdiv_f64_x(svptrue_b64(), v_, rhs.v_));
     }
 
     // 向量取负
     Vec operator-() const {
         return Vec(svneg_f64_x(svptrue_b64(), v_));
     }
 
     // 向量平方根
     Vec Sqrt() const {
         return Vec(svsqrt_f64_x(svptrue_b64(), v_));
     }
 
     // 向量加标量
     Vec operator+(double rhs) const {
         return *this + Vec(rhs);
     }
 
     // 向量减标量
     Vec operator-(double rhs) const {
         return *this - Vec(rhs);
     }
 
     // 向量乘标量
     Vec operator*(double rhs) const {
         return *this * Vec(rhs);
     }
 
     // 向量除标量
     Vec operator/(double rhs) const {
         return *this / Vec(rhs);
     }
 
     // 友元函数：标量加向量
     friend Vec operator+(double lhs, const Vec &rhs) {
         return Vec(lhs) + rhs;
     }
 
     // 友元函数：标量减向量
     friend Vec operator-(double lhs, const Vec &rhs) {
         return Vec(lhs) - rhs;
     }
 
     // 友元函数：标量乘向量
     friend Vec operator*(double lhs, const Vec &rhs) {
         return Vec(lhs) * rhs;
     }
 
     // 友元函数：标量除向量
     friend Vec operator/(double lhs, const Vec &rhs) {
         return Vec(lhs) / rhs;
     }
 
     // 存储向量到内存
     void Store(svbool_t p, double *mem) const {
         svst1_f64(p, mem, v_);
     }
 
     // 从内存加载向量
     static Vec Load(svbool_t p, const double *mem) {
         return Vec(svld1_f64(p, mem));
     }
 };
 
 class MVec {
 private:
     // svfloat64_t v_;
     svec v_;
 
 public:
     MVec() __arm_preserves("za") __arm_streaming = default;
 
     // 从 svfloat64_t 构造
     MVec(svec v) __arm_preserves("za") __arm_streaming : v_(v) {}
     MVec(double v) __arm_preserves("za") __arm_streaming : v_(svdup_f64(v)) {}
 
     operator svec() const __arm_preserves("za") __arm_streaming {
         return v_;
     }
 
     // __attribute__((arm_preserves("za")))
     // __attribute__((arm_streaming_compatible))
     void operator+=(const MVec &rhs) __arm_preserves("za") __arm_streaming {
         v_ = svadd_f64_x(svptrue_b64(), v_, rhs.v_);
     }
 
     // void operator+=(const MVec &rhs) __arm_preserves("za") __arm_streaming {
     //     v_ = svadd_f64_x(svptrue_b64(), v_, rhs.v_);
     // }
 
     // __attribute__((arm_preserves("za")))
     // __attribute__((arm_streaming_compatible))
     void operator-=(const MVec &rhs) __arm_preserves("za") __arm_streaming {
         v_ = svsub_f64_x(svptrue_b64(), v_, rhs.v_);
     }
 
     // __attribute__((arm_preserves("za")))
     // __attribute__((arm_streaming_compatible))
     void operator*=(const MVec &rhs) __arm_preserves("za") __arm_streaming {
         v_ = svmul_f64_x(svptrue_b64(), v_, rhs.v_);
     }
 
     // __attribute__((arm_preserves("za")))
     // __attribute__((arm_streaming_compatible))
     MVec operator+(const MVec &rhs) const __arm_preserves("za") __arm_streaming {
         return svadd_f64_x(svptrue_b64(), v_, rhs.v_);
     }
 
     // __attribute__((arm_preserves("za")))
     // __attribute__((arm_streaming_compatible))
     MVec operator-(const MVec &rhs) const __arm_preserves("za") __arm_streaming {
         return svsub_f64_x(svptrue_b64(), v_, rhs.v_);
     }
 
     // __attribute__((arm_preserves("za")))
     // __attribute__((arm_streaming_compatible))
     MVec operator*(const MVec &rhs) const __arm_preserves("za") __arm_streaming {
         return svmul_f64_x(svptrue_b64(), v_, rhs.v_);
     }
 
     // __attribute__((arm_preserves("za")))
     // __attribute__((arm_streaming_compatible))
     MVec operator-() const __arm_preserves("za") __arm_streaming {
         return svneg_f64_x(svptrue_b64(), v_);
     }
 
     // __attribute__((arm_preserves("za")))
     // __attribute__((arm_streaming_compatible))
     MVec operator+(double rhs) const __arm_preserves("za") __arm_streaming {
         return *this + MVec(rhs);
     }
 
     // __attribute__((arm_preserves("za")))
     // __attribute__((arm_streaming_compatible))
     MVec operator-(double rhs) const __arm_preserves("za") __arm_streaming {
         return *this - MVec(rhs);
     }
 
     // __attribute__((arm_preserves("za")))
     // __attribute__((arm_streaming_compatible))
     MVec operator*(double rhs) const __arm_preserves("za") __arm_streaming {
         return *this * MVec(rhs);
     }
 
     MVec operator/(const MVec &rhs) const __arm_preserves("za") __arm_streaming {
         return MVec(svdiv_f64_x(svptrue_b64(), v_, rhs.v_));
     }
 
     MVec operator/(double rhs) const __arm_preserves("za") __arm_streaming {
         return *this / MVec(rhs);
     }
 
     friend MVec operator/(double lhs, const MVec &rhs) __arm_preserves("za") __arm_streaming {
         return MVec(lhs) / rhs;
     }
 
     MVec Sqrt() const __arm_preserves("za") __arm_streaming {
         return MVec(svsqrt_f64_x(svptrue_b64(), v_));
     }
 
     // __attribute__((arm_preserves("za")))
     // __attribute__((arm_streaming_compatible))
     friend MVec operator+(double lhs, const MVec &rhs) __arm_preserves("za") __arm_streaming {
         return MVec(lhs) + rhs;
     }
 
     // __attribute__((arm_preserves("za")))
     // __attribute__((arm_streaming_compatible))
     friend MVec operator-(double lhs, const MVec &rhs) __arm_preserves("za") __arm_streaming {
         return MVec(lhs) - rhs;
     }
 
     // __attribute__((arm_preserves("za")))
     // __attribute__((arm_streaming_compatible))
     friend MVec operator*(double lhs, const MVec &rhs) __arm_preserves("za") __arm_streaming {
         return MVec(lhs) * rhs;
     }
 
     // __attribute__((arm_preserves("za")))
     // __attribute__((arm_streaming_compatible))
     void Store(svbool_t p, double *mem) const __arm_preserves("za") __arm_streaming {
         svst1_f64(p, mem, v_);
     }
 
     // __attribute__((arm_preserves("za")))
     // __attribute__((arm_streaming_compatible))
     static MVec Load(svbool_t p, const double *mem) __arm_preserves("za") __arm_streaming {
         return svld1_f64(p, mem);
     }
 
     // __attribute__((arm_preserves("za")))
     // __attribute__((arm_streaming_compatible))
     double ReduceSum() const __arm_preserves("za") __arm_streaming {
         return svaddv_f64(svptrue_b64(), v_);
     }
 };
 
 class UintVec {
 private:
     svecuint v_;  
 
 public:
     // 默认构造函数
     UintVec() = default;
 
     // 从 svuint64_t 构造
     UintVec(svuint64_t v) : v_(v) {}
 
     // 从 uint64_t 构造
     UintVec(uint64_t v) : v_(svdup_u64(v)) {}
 
     // 转换为 svfloat64_t
     operator svuint64_t() const {
         return v_;
     }
 
     // 向量加法赋值
     void operator+=(const UintVec& rhs) {
         v_ = svadd_u64_x(svptrue_b64(), v_, rhs.v_);
     }
 
     // 向量减法赋值
     void operator-=(const UintVec& rhs) {
         v_ = svsub_u64_x(svptrue_b64(), v_, rhs.v_);
     }
 
     // 向量乘法赋值
     void operator*=(const UintVec& rhs) {
         v_ = svmul_u64_x(svptrue_b64(), v_, rhs.v_);
     }
 
     // 向量加法
     UintVec operator+(const UintVec &rhs) const {
         return UintVec(svadd_u64_x(svptrue_b64(), v_, rhs.v_));
     }
 
     // 向量减法
     UintVec operator-(const UintVec &rhs) const {
         return UintVec(svsub_u64_x(svptrue_b64(), v_, rhs.v_));
     }
 
     // 向量乘法
     UintVec operator*(const UintVec &rhs) const {
         return UintVec(svmul_u64_x(svptrue_b64(), v_, rhs.v_));
     }
 
     // 向量除法
     UintVec operator/(const UintVec &rhs) const {
         return UintVec(svdiv_u64_x(svptrue_b64(), v_, rhs.v_));
     }
 
     // 向量取负
     // UintVec operator-() const {
     //     return UintVec(svneg_u64_x(svptrue_b64(), v_));
     // }
 
     // 向量平方根
     // UintVec Sqrt() const {
     //     return UintVec(svsqrt_u64_x(svptrue_b64(), v_));
     // }
 
     // 向量加标量
     UintVec operator+(uint64_t rhs) const {
         return *this + UintVec(rhs);
     }
 
     // 向量减标量
     UintVec operator-(uint64_t rhs) const {
         return *this - UintVec(rhs);
     }
 
     // 向量乘标量
     UintVec operator*(uint64_t rhs) const {
         return *this * UintVec(rhs);
     }
 
     // 向量除标量
     UintVec operator/(uint64_t rhs) const {
         return *this / UintVec(rhs);
     }
 
     // 友元函数：标量加向量
     friend UintVec operator+(uint64_t lhs, const UintVec &rhs) {
         return UintVec(lhs) + rhs;
     }
 
     // 友元函数：标量减向量
     friend UintVec operator-(uint64_t lhs, const UintVec &rhs) {
         return UintVec(lhs) - rhs;
     }
 
     // 友元函数：标量乘向量
     friend UintVec operator*(uint64_t lhs, const UintVec &rhs) {
         return UintVec(lhs) * rhs;
     }
 
     // 友元函数：标量除向量
     friend UintVec operator/(uint64_t lhs, const UintVec &rhs) {
         return UintVec(lhs) / rhs;
     }
 
     // 存储向量到内存
     void Store(svbool_t p, uint64_t *mem) const {
         svst1_u64(p, mem, v_);
     }
 
     // 从内存加载向量
     static UintVec Load(svbool_t p, const uint64_t *mem) {
         return UintVec(svld1_u64(p, mem));
     }
 };
 
 class intVec {
 private:
     svecint  v_;  
 
 public:
     // 默认构造函数
     intVec() = default;
 
     // 从 svint64_t 构造
     intVec(svint64_t v) : v_(v) {}
 
     // 从 int64_t 构造
     intVec(int64_t v) : v_(svdup_s64(v)) {}
 
     // 转换为 svfloat64_t
     operator svint64_t() const {
         return v_;
     }
 
     // 向量加法赋值
     void operator+=(const intVec& rhs) {
         v_ = svadd_s64_x(svptrue_b64(), v_, rhs.v_);
     }
 
     // 向量减法赋值
     void operator-=(const intVec& rhs) {
         v_ = svsub_s64_x(svptrue_b64(), v_, rhs.v_);
     }
 
     // 向量乘法赋值
     void operator*=(const intVec& rhs) {
         v_ = svmul_s64_x(svptrue_b64(), v_, rhs.v_);
     }
 
     // 向量加法
     intVec operator+(const intVec &rhs) const {
         return intVec(svadd_s64_x(svptrue_b64(), v_, rhs.v_));
     }
 
     // 向量减法
     intVec operator-(const intVec &rhs) const {
         return intVec(svsub_s64_x(svptrue_b64(), v_, rhs.v_));
     }
 
     // 向量乘法
     intVec operator*(const intVec &rhs) const {
         return intVec(svmul_s64_x(svptrue_b64(), v_, rhs.v_));
     }
 
     // 向量除法
     intVec operator/(const intVec &rhs) const {
         return intVec(svdiv_s64_x(svptrue_b64(), v_, rhs.v_));
     }
 
     // 向量取负
     intVec operator-() const {
         return intVec(svneg_s64_x(svptrue_b64(), v_));
     }
 
     // 向量平方根
     // intVec Sqrt() const {
     //     return intVec(svsqrt_s64_x(svptrue_b64(), v_));
     // }
 
     // 向量加标量
     intVec operator+(int64_t rhs) const {
         return *this + intVec(rhs);
     }
 
     // 向量减标量
     intVec operator-(int64_t rhs) const {
         return *this - intVec(rhs);
     }
 
     // 向量乘标量
     intVec operator*(int64_t rhs) const {
         return *this * intVec(rhs);
     }
 
     // 向量除标量
     intVec operator/(int64_t rhs) const {
         return *this / intVec(rhs);
     }
 
     // 友元函数：标量加向量
     friend intVec operator+(int64_t lhs, const intVec &rhs) {
         return intVec(lhs) + rhs;
     }
 
     // 友元函数：标量减向量
     friend intVec operator-(int64_t lhs, const intVec &rhs) {
         return intVec(lhs) - rhs;
     }
 
     // 友元函数：标量乘向量
     friend intVec operator*(int64_t lhs, const intVec &rhs) {
         return intVec(lhs) * rhs;
     }
 
     // 友元函数：标量除向量
     friend intVec operator/(int64_t lhs, const intVec &rhs) {
         return intVec(lhs) / rhs;
     }
 
     // 存储向量到内存
     void Store(svbool_t p, int64_t *mem) const {
         svst1_s64(p, mem, v_);
     }
 
     // 从内存加载向量
     static intVec Load(svbool_t p, const int64_t *mem) {
         return intVec(svld1_s64(p, mem));
     }
 };
 
 /**
  * \brief Kernel for the direct current deposition for thread thread_num
  * \tparam depos_order deposition order
  * \param xp, yp, zp    The particle positions.
  * \param wq            The charge of the macroparticle
  * \param vx,vy,vz      The particle velocities
  * \param jx_arr,jy_arr,jz_arr Array4 of current density, either full array or tile.
  * \param jx_type,jy_type,jz_type The grid types along each direction, either NODE or CELL
  * \param relative_time Time at which to deposit J, relative to the time of the
  *                      current positions of the particles. When different than 0,
  *                      the particle position will be temporarily modified to match
  *                      the time of the deposition.
  * \param dinv          3D cell size inverse
  * \param xyzmin        The lower bounds of the domain
  * \param invvol        The inverse volume of a grid cell
  * \param lo            Index lower bounds of domain.
  * \param n_rz_azimuthal_modes Number of azimuthal modes when using RZ geometry.
  */
 template <int depos_order>
 AMREX_GPU_HOST_DEVICE AMREX_INLINE
 void doDepositionShapeNKernel([[maybe_unused]] const amrex::ParticleReal xp,
                               [[maybe_unused]] const amrex::ParticleReal yp,
                               [[maybe_unused]] const amrex::ParticleReal zp,
                               const amrex::ParticleReal wq,
                               const amrex::ParticleReal vx,
                               const amrex::ParticleReal vy,
                               const amrex::ParticleReal vz,
                               amrex::Array4<amrex::Real> const& jx_arr,
                               amrex::Array4<amrex::Real> const& jy_arr,
                               amrex::Array4<amrex::Real> const& jz_arr,
                               amrex::IntVect const& jx_type,
                               amrex::IntVect const& jy_type,
                               amrex::IntVect const& jz_type,
                               const amrex::Real relative_time,
                               const amrex::XDim3 & dinv,
                               const amrex::XDim3 & xyzmin,
                               const amrex::Real invvol,
                               const amrex::Dim3 lo,
                               [[maybe_unused]] const int n_rz_azimuthal_modes)
 {
     using namespace amrex::literals;
 
     constexpr int NODE = amrex::IndexType::NODE;
     constexpr int CELL = amrex::IndexType::CELL;
 
     // wqx, wqy wqz are particle current in each direction
 #if defined(WARPX_DIM_RZ)
     // In RZ, wqx is actually wqr, and wqy is wqtheta
     // Convert to cylindrical at the mid point
     const amrex::Real xpmid = xp + relative_time*vx;
     const amrex::Real ypmid = yp + relative_time*vy;
     const amrex::Real rpmid = std::sqrt(xpmid*xpmid + ypmid*ypmid);
     const amrex::Real costheta = (rpmid > 0._rt ? xpmid/rpmid : 1._rt);
     const amrex::Real sintheta = (rpmid > 0._rt ? ypmid/rpmid : 0._rt);
     const Complex xy0 = Complex{costheta, sintheta};
     const amrex::Real wqx = wq*invvol*(+vx*costheta + vy*sintheta);
     const amrex::Real wqy = wq*invvol*(-vx*sintheta + vy*costheta);
 #else
     const amrex::Real wqx = wq*invvol*vx;
     const amrex::Real wqy = wq*invvol*vy;
 #endif
     const amrex::Real wqz = wq*invvol*vz;
 
     // --- Compute shape factors
     Compute_shape_factor< depos_order > const compute_shape_factor;
 #if (AMREX_SPACEDIM >= 2)
     // x direction
     // Get particle position after 1/2 push back in position
     // Keep these double to avoid bug in single precision
 #if defined(WARPX_DIM_RZ)
     const double xmid = (rpmid - xyzmin.x)*dinv.x;
 #else
     const double xmid = ((xp - xyzmin.x) + relative_time*vx)*dinv.x;
 #endif
 
     // j_j[xyz] leftmost grid point in x that the particle touches for the centering of each current
     // sx_j[xyz] shape factor along x for the centering of each current
     // There are only two possible centerings, node or cell centered, so at most only two shape factor
     // arrays will be needed.
     // Keep these double to avoid bug in single precision
     double sx_node[depos_order + 1] = {0.};
     double sx_cell[depos_order + 1] = {0.};
     int j_node = 0;
     int j_cell = 0;
     if (jx_type[0] == NODE || jy_type[0] == NODE || jz_type[0] == NODE) {
         j_node = compute_shape_factor(sx_node, xmid);
     }
     if (jx_type[0] == CELL || jy_type[0] == CELL || jz_type[0] == CELL) {
         j_cell = compute_shape_factor(sx_cell, xmid - 0.5);
     }
 
     amrex::Real sx_jx[depos_order + 1] = {0._rt};
     amrex::Real sx_jy[depos_order + 1] = {0._rt};
     amrex::Real sx_jz[depos_order + 1] = {0._rt};
     for (int ix=0; ix<=depos_order; ix++)
     {
         sx_jx[ix] = ((jx_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
         sx_jy[ix] = ((jy_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
         sx_jz[ix] = ((jz_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
     }
 
     int const j_jx = ((jx_type[0] == NODE) ? j_node : j_cell);
     int const j_jy = ((jy_type[0] == NODE) ? j_node : j_cell);
     int const j_jz = ((jz_type[0] == NODE) ? j_node : j_cell);
 #endif //AMREX_SPACEDIM >= 2
 
 #if defined(WARPX_DIM_3D)
     // y direction
     // Keep these double to avoid bug in single precision
     const double ymid = ((yp - xyzmin.y) + relative_time*vy)*dinv.y;
     double sy_node[depos_order + 1] = {0.};
     double sy_cell[depos_order + 1] = {0.};
     int k_node = 0;
     int k_cell = 0;
     if (jx_type[1] == NODE || jy_type[1] == NODE || jz_type[1] == NODE) {
         k_node = compute_shape_factor(sy_node, ymid);
     }
     if (jx_type[1] == CELL || jy_type[1] == CELL || jz_type[1] == CELL) {
         k_cell = compute_shape_factor(sy_cell, ymid - 0.5);
     }
     amrex::Real sy_jx[depos_order + 1] = {0._rt};
     amrex::Real sy_jy[depos_order + 1] = {0._rt};
     amrex::Real sy_jz[depos_order + 1] = {0._rt};
     for (int iy=0; iy<=depos_order; iy++)
     {
         sy_jx[iy] = ((jx_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
         sy_jy[iy] = ((jy_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
         sy_jz[iy] = ((jz_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
     }
     int const k_jx = ((jx_type[1] == NODE) ? k_node : k_cell);
     int const k_jy = ((jy_type[1] == NODE) ? k_node : k_cell);
     int const k_jz = ((jz_type[1] == NODE) ? k_node : k_cell);
 #endif
 
     // z direction
     // Keep these double to avoid bug in single precision
     constexpr int zdir = WARPX_ZINDEX;
     const double zmid = ((zp - xyzmin.z) + relative_time*vz)*dinv.z;
     double sz_node[depos_order + 1] = {0.};
     double sz_cell[depos_order + 1] = {0.};
     int l_node = 0;
     int l_cell = 0;
     if (jx_type[zdir] == NODE || jy_type[zdir] == NODE || jz_type[zdir] == NODE) {
         l_node = compute_shape_factor(sz_node, zmid);
     }
     if (jx_type[zdir] == CELL || jy_type[zdir] == CELL || jz_type[zdir] == CELL) {
         l_cell = compute_shape_factor(sz_cell, zmid - 0.5);
     }
     amrex::Real sz_jx[depos_order + 1] = {0._rt};
     amrex::Real sz_jy[depos_order + 1] = {0._rt};
     amrex::Real sz_jz[depos_order + 1] = {0._rt};
     for (int iz=0; iz<=depos_order; iz++)
     {
         sz_jx[iz] = ((jx_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
         sz_jy[iz] = ((jy_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
         sz_jz[iz] = ((jz_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
     }
     int const l_jx = ((jx_type[zdir] == NODE) ? l_node : l_cell);
     int const l_jy = ((jy_type[zdir] == NODE) ? l_node : l_cell);
     int const l_jz = ((jz_type[zdir] == NODE) ? l_node : l_cell);
 
     // Deposit current into jx_arr, jy_arr and jz_arr
 #if defined(WARPX_DIM_1D_Z)
     for (int iz=0; iz<=depos_order; iz++){
         amrex::Gpu::Atomic::AddNoRet(
             &jx_arr(lo.x+l_jx+iz, 0, 0, 0),
             sz_jx[iz]*wqx);
         amrex::Gpu::Atomic::AddNoRet(
             &jy_arr(lo.x+l_jy+iz, 0, 0, 0),
             sz_jy[iz]*wqy);
         amrex::Gpu::Atomic::AddNoRet(
             &jz_arr(lo.x+l_jz+iz, 0, 0, 0),
             sz_jz[iz]*wqz);
     }
 #endif
 #if defined(WARPX_DIM_XZ) || defined(WARPX_DIM_RZ)
     for (int iz=0; iz<=depos_order; iz++){
         for (int ix=0; ix<=depos_order; ix++){
             amrex::Gpu::Atomic::AddNoRet(
                 &jx_arr(lo.x+j_jx+ix, lo.y+l_jx+iz, 0, 0),
                 sx_jx[ix]*sz_jx[iz]*wqx);
             amrex::Gpu::Atomic::AddNoRet(
                 &jy_arr(lo.x+j_jy+ix, lo.y+l_jy+iz, 0, 0),
                 sx_jy[ix]*sz_jy[iz]*wqy);
             amrex::Gpu::Atomic::AddNoRet(
                 &jz_arr(lo.x+j_jz+ix, lo.y+l_jz+iz, 0, 0),
                 sx_jz[ix]*sz_jz[iz]*wqz);
 #if defined(WARPX_DIM_RZ)
             Complex xy = xy0; // Note that xy is equal to e^{i m theta}
             for (int imode=1 ; imode < n_rz_azimuthal_modes ; imode++) {
                 // The factor 2 on the weighting comes from the normalization of the modes
                 amrex::Gpu::Atomic::AddNoRet( &jx_arr(lo.x+j_jx+ix, lo.y+l_jx+iz, 0, 2*imode-1), 2._rt*sx_jx[ix]*sz_jx[iz]*wqx*xy.real());
                 amrex::Gpu::Atomic::AddNoRet( &jx_arr(lo.x+j_jx+ix, lo.y+l_jx+iz, 0, 2*imode  ), 2._rt*sx_jx[ix]*sz_jx[iz]*wqx*xy.imag());
                 amrex::Gpu::Atomic::AddNoRet( &jy_arr(lo.x+j_jy+ix, lo.y+l_jy+iz, 0, 2*imode-1), 2._rt*sx_jy[ix]*sz_jy[iz]*wqy*xy.real());
                 amrex::Gpu::Atomic::AddNoRet( &jy_arr(lo.x+j_jy+ix, lo.y+l_jy+iz, 0, 2*imode  ), 2._rt*sx_jy[ix]*sz_jy[iz]*wqy*xy.imag());
                 amrex::Gpu::Atomic::AddNoRet( &jz_arr(lo.x+j_jz+ix, lo.y+l_jz+iz, 0, 2*imode-1), 2._rt*sx_jz[ix]*sz_jz[iz]*wqz*xy.real());
                 amrex::Gpu::Atomic::AddNoRet( &jz_arr(lo.x+j_jz+ix, lo.y+l_jz+iz, 0, 2*imode  ), 2._rt*sx_jz[ix]*sz_jz[iz]*wqz*xy.imag());
                 xy = xy*xy0;
             }
 #endif
         }
     }
 #elif defined(WARPX_DIM_3D)
     for (int iz=0; iz<=depos_order; iz++){
         for (int iy=0; iy<=depos_order; iy++){
             for (int ix=0; ix<=depos_order; ix++){
                 amrex::Gpu::Atomic::AddNoRet(
                     &jx_arr(lo.x+j_jx+ix, lo.y+k_jx+iy, lo.z+l_jx+iz),
                     sx_jx[ix]*sy_jx[iy]*sz_jx[iz]*wqx);
                 amrex::Gpu::Atomic::AddNoRet(
                     &jy_arr(lo.x+j_jy+ix, lo.y+k_jy+iy, lo.z+l_jy+iz),
                     sx_jy[ix]*sy_jy[iy]*sz_jy[iz]*wqy);
                 amrex::Gpu::Atomic::AddNoRet(
                     &jz_arr(lo.x+j_jz+ix, lo.y+k_jz+iy, lo.z+l_jz+iz),
                     sx_jz[ix]*sy_jz[iy]*sz_jz[iz]*wqz);
             }
         }
     }
 #endif
 }
 
 /**
  * \brief Current Deposition for thread thread_num
  * \tparam depos_order deposition order
  * \param GetPosition  A functor for returning the particle position.
  * \param wp           Pointer to array of particle weights.
  * \param uxp,uyp,uzp  Pointer to arrays of particle momentum.
  * \param ion_lev      Pointer to array of particle ionization level. This is
                          required to have the charge of each macroparticle
                          since q is a scalar. For non-ionizable species,
                          ion_lev is a null pointer.
  * \param jx_fab,jy_fab,jz_fab FArrayBox of current density, either full array or tile.
  * \param np_to_deposit Number of particles for which current is deposited.
  * \param relative_time Time at which to deposit J, relative to the time of the
  *                      current positions of the particles. When different than 0,
  *                      the particle position will be temporarily modified to match
  *                      the time of the deposition.
  * \param dinv         3D cell size inverse
  * \param xyzmin       Physical lower bounds of domain.
  * \param lo           Index lower bounds of domain.
  * \param q            species charge.
  * \param n_rz_azimuthal_modes Number of azimuthal modes when using RZ geometry.
  */
 template <int depos_order>
 void doDepositionShapeN_1 (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Real q,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     using namespace amrex::literals;
     WARPX_PROFILE("[0] USER org()");
     WARPX_PROFILE_VAR_NS("[1] USER org_sortanrpre", bl_sort);
     WARPX_PROFILE_VAR_NS("[2] USER org_kernal", bl_sme);
     WARPX_PROFILE_VAR_NS("[3] USER org_post", bl_post);
     
     // Whether ion_lev is a null pointer (do_ionization=0) or a real pointer
     // (do_ionization=1)
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z;
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
     amrex::IntVect const jx_type = jx_fab.box().type();
     amrex::IntVect const jy_type = jy_fab.box().type();
     amrex::IntVect const jz_type = jz_fab.box().type();
 
     // Loop over particles and deposit into jx_fab, jy_fab and jz_fab
     amrex::ParallelFor(
         np_to_deposit,
         [=] AMREX_GPU_DEVICE (long ip) {
             // WARPX_PROFILE_VAR_START(bl_sort);
             amrex::ParticleReal xp, yp, zp;
             GetPosition(ip, xp, yp, zp);
 
             // --- Get particle quantities
             const amrex::Real gaminv = 1.0_rt/std::sqrt(1.0_rt + uxp[ip]*uxp[ip]*clightsq
                                                         + uyp[ip]*uyp[ip]*clightsq
                                                         + uzp[ip]*uzp[ip]*clightsq);
             const amrex::Real vx  = uxp[ip]*gaminv;
             const amrex::Real vy  = uyp[ip]*gaminv;
             const amrex::Real vz  = uzp[ip]*gaminv;
 
             amrex::Real wq  = q*wp[ip];
             if (do_ionization){
                 wq *= ion_lev[ip];
             }
             // WARPX_PROFILE_VAR_STOP(bl_sort);
 
             doDepositionShapeNKernel<depos_order>(xp, yp, zp, wq, vx, vy, vz, jx_arr, jy_arr, jz_arr,
                                                   jx_type, jy_type, jz_type,
                                                   relative_time, dinv, xyzmin,
                                                   invvol, lo, n_rz_azimuthal_modes);
 
         }
     );
 }
 
 template <int depos_order>
 void doDepositionShapeN_org (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Real q,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     using namespace amrex::literals;
     WARPX_PROFILE("[0] USER org()");
     WARPX_PROFILE_VAR_NS("[1] USER org_sortanrpre", bl_sort);
     WARPX_PROFILE_VAR_NS("[2] USER org_kernal", bl_sme);
     WARPX_PROFILE_VAR_NS("[3] USER org_post", bl_post);
     
     // Whether ion_lev is a null pointer (do_ionization=0) or a real pointer
     // (do_ionization=1)
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z;
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
     amrex::IntVect const jx_type = jx_fab.box().type();
     amrex::IntVect const jy_type = jy_fab.box().type();
     amrex::IntVect const jz_type = jz_fab.box().type();
 
     // Loop over particles and deposit into jx_fab, jy_fab and jz_fab
     amrex::ParallelFor(
         np_to_deposit,
         [=] AMREX_GPU_DEVICE (long ip) {
         // WARPX_PROFILE_VAR_START(bl_sort);
         amrex::ParticleReal xp, yp, zp;
         GetPosition(ip, xp, yp, zp);
 
         // --- Get particle quantities
         const amrex::Real gaminv = 1.0_rt/std::sqrt(1.0_rt + uxp[ip]*uxp[ip]*clightsq
                                                     + uyp[ip]*uyp[ip]*clightsq
                                                     + uzp[ip]*uzp[ip]*clightsq);
         const amrex::Real vx  = uxp[ip]*gaminv;
         const amrex::Real vy  = uyp[ip]*gaminv;
         const amrex::Real vz  = uzp[ip]*gaminv;
 
         amrex::Real wq  = q*wp[ip];
         if (do_ionization){
             wq *= ion_lev[ip];
         }
         // WARPX_PROFILE_VAR_STOP(bl_sort);
 
         using namespace amrex::literals;
 
         constexpr int NODE = amrex::IndexType::NODE;
         constexpr int CELL = amrex::IndexType::CELL;
 
         // wqx, wqy wqz are particle current in each direction
 
         const amrex::Real wqx = wq*invvol*vx;
         const amrex::Real wqy = wq*invvol*vy;
         const amrex::Real wqz = wq*invvol*vz;
 
         // --- Compute shape factors
         Compute_shape_factor< depos_order > const compute_shape_factor;
 
         // x direction
         // Get particle position after 1/2 push back in position
         // Keep these double to avoid bug in single precision
 
         const double xmid = ((xp - xyzmin.x) + relative_time*vx)*dinv.x;
 
 
         // j_j[xyz] leftmost grid point in x that the particle touches for the centering of each current
         // sx_j[xyz] shape factor along x for the centering of each current
         // There are only two possible centerings, node or cell centered, so at most only two shape factor
         // arrays will be needed.
         // Keep these double to avoid bug in single precision
         double sx_node[depos_order + 1] = {0.};
         double sx_cell[depos_order + 1] = {0.};
         int j_node = 0;
         int j_cell = 0;
         if (jx_type[0] == NODE || jy_type[0] == NODE || jz_type[0] == NODE) {
             j_node = compute_shape_factor(sx_node, xmid);
         }
         if (jx_type[0] == CELL || jy_type[0] == CELL || jz_type[0] == CELL) {
             j_cell = compute_shape_factor(sx_cell, xmid - 0.5);
         }
 
         amrex::Real sx_jx[depos_order + 1] = {0._rt};
         amrex::Real sx_jy[depos_order + 1] = {0._rt};
         amrex::Real sx_jz[depos_order + 1] = {0._rt};
         for (int ix=0; ix<=depos_order; ix++)
         {
             sx_jx[ix] = ((jx_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
             sx_jy[ix] = ((jy_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
             sx_jz[ix] = ((jz_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
         }
 
         int const j_jx = ((jx_type[0] == NODE) ? j_node : j_cell);
         int const j_jy = ((jy_type[0] == NODE) ? j_node : j_cell);
         int const j_jz = ((jz_type[0] == NODE) ? j_node : j_cell);
 
 
 
         // y direction
         // Keep these double to avoid bug in single precision
         const double ymid = ((yp - xyzmin.y) + relative_time*vy)*dinv.y;
         double sy_node[depos_order + 1] = {0.};
         double sy_cell[depos_order + 1] = {0.};
         int k_node = 0;
         int k_cell = 0;
         if (jx_type[1] == NODE || jy_type[1] == NODE || jz_type[1] == NODE) {
             k_node = compute_shape_factor(sy_node, ymid);
         }
         if (jx_type[1] == CELL || jy_type[1] == CELL || jz_type[1] == CELL) {
             k_cell = compute_shape_factor(sy_cell, ymid - 0.5);
         }
         amrex::Real sy_jx[depos_order + 1] = {0._rt};
         amrex::Real sy_jy[depos_order + 1] = {0._rt};
         amrex::Real sy_jz[depos_order + 1] = {0._rt};
         for (int iy=0; iy<=depos_order; iy++)
         {
             sy_jx[iy] = ((jx_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
             sy_jy[iy] = ((jy_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
             sy_jz[iy] = ((jz_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
         }
         int const k_jx = ((jx_type[1] == NODE) ? k_node : k_cell);
         int const k_jy = ((jy_type[1] == NODE) ? k_node : k_cell);
         int const k_jz = ((jz_type[1] == NODE) ? k_node : k_cell);
 
 
         // z direction
         // Keep these double to avoid bug in single precision
         constexpr int zdir = WARPX_ZINDEX;
         const double zmid = ((zp - xyzmin.z) + relative_time*vz)*dinv.z;
         double sz_node[depos_order + 1] = {0.};
         double sz_cell[depos_order + 1] = {0.};
         int l_node = 0;
         int l_cell = 0;
         if (jx_type[zdir] == NODE || jy_type[zdir] == NODE || jz_type[zdir] == NODE) {
             l_node = compute_shape_factor(sz_node, zmid);
         }
         if (jx_type[zdir] == CELL || jy_type[zdir] == CELL || jz_type[zdir] == CELL) {
             l_cell = compute_shape_factor(sz_cell, zmid - 0.5);
         }
         amrex::Real sz_jx[depos_order + 1] = {0._rt};
         amrex::Real sz_jy[depos_order + 1] = {0._rt};
         amrex::Real sz_jz[depos_order + 1] = {0._rt};
         for (int iz=0; iz<=depos_order; iz++)
         {
             sz_jx[iz] = ((jx_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
             sz_jy[iz] = ((jy_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
             sz_jz[iz] = ((jz_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
         }
         int const l_jx = ((jx_type[zdir] == NODE) ? l_node : l_cell);
         int const l_jy = ((jy_type[zdir] == NODE) ? l_node : l_cell);
         int const l_jz = ((jz_type[zdir] == NODE) ? l_node : l_cell);
     });
     // Deposit current into jx_arr, jy_arr and jz_arr
     // amrex::ParallelFor(
     //     np_to_deposit,
     //     [=] AMREX_GPU_DEVICE (long ip) {
     //         for (int iz=0; iz<=depos_order; iz++){
     //             for (int iy=0; iy<=depos_order; iy++){
     //                 for (int ix=0; ix<=depos_order; ix++){
     //                     amrex::Gpu::Atomic::AddNoRet(
     //                         &jx_arr(lo.x+j_jx+ix, lo.y+k_jx+iy, lo.z+l_jx+iz),
     //                         sx_jx[ix]*sy_jx[iy]*sz_jx[iz]*wqx);
     //                     amrex::Gpu::Atomic::AddNoRet(
     //                         &jy_arr(lo.x+j_jy+ix, lo.y+k_jy+iy, lo.z+l_jy+iz),
     //                         sx_jy[ix]*sy_jy[iy]*sz_jy[iz]*wqy);
     //                     amrex::Gpu::Atomic::AddNoRet(
     //                         &jz_arr(lo.x+j_jz+ix, lo.y+k_jz+iy, lo.z+l_jz+iz),
     //                         sx_jz[ix]*sy_jz[iy]*sz_jz[iz]*wqz);
     //                 }
     //             }
     //         }
     //     }
     // );
 }
 
 // 辅助函数将粒子数据转换为SoA布局
 template <int depos_order>
 void Precompute_shape_factors(
     double* sx_cell, double* sy_cell, double* sz_cell,
     int* j_cell, int* k_cell, int* l_cell,
     const long np_to_deposit,
     const amrex::Real* vx, const amrex::Real* vy, const amrex::Real* vz,
     const amrex::Real relative_time,
     const amrex::XDim3 &  xyzmin,
     const amrex::XDim3 &  dinv,
     const GetParticlePosition<PIdx>& GetPosition)
 {
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
     Compute_shape_factor<depos_order> compute_shape_factor;
     constexpr int nshapes = depos_order + 1;
 
     #pragma omp parallel for simd
     for (long ip = 0; ip < np_to_deposit; ++ip) {
         // 计算位置偏移
         const double xmid = ((mx[ip] - xyzmin.x) + relative_time * vx[ip]) * dinv.x - 0.5;
         const double ymid = ((my[ip] - xyzmin.y) + relative_time * vy[ip]) * dinv.y - 0.5;
         const double zmid = ((mz[ip] - xyzmin.z) + relative_time * vz[ip]) * dinv.z - 0.5;
 
         // 计算形状因子
         double sx[nshapes], sy[nshapes], sz[nshapes];
         j_cell[ip] = compute_shape_factor(sx, xmid);
         k_cell[ip] = compute_shape_factor(sy, ymid);
         l_cell[ip] = compute_shape_factor(sz, zmid);
 
         // 存储到SoA布局
         for (int i = 0; i < nshapes; ++i) {
             sx_cell[i * np_to_deposit + ip] = sx[i];
             sy_cell[i * np_to_deposit + ip] = sy[i];
             sz_cell[i * np_to_deposit + ip] = sz[i];
         }
     }
 }
 
 // 向量化沉积核心
 template <int depos_order>
 void VectorizedDeposit(
     amrex::Array4<amrex::Real> const& jx_arr,
     amrex::Array4<amrex::Real> const& jy_arr,
     amrex::Array4<amrex::Real> const& jz_arr,
     const long np_to_deposit,
     const double* sx_cell, const double* sy_cell, const double* sz_cell,
     const int* j_cell, const int* k_cell, const int* l_cell,
     const amrex::Real* wqx, const amrex::Real* wqy, const amrex::Real* wqz,
     const amrex::Dim3 lo)
 {
     constexpr int nshapes = depos_order + 1;
     constexpr int VEC_WIDTH = 8;
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
     #pragma omp parallel for collapse(3) schedule(dynamic, 4)
     for (int iz = 0; iz < nshapes; ++iz) {
         for (int iy = 0; iy < nshapes; ++iy) {
             for (int ix = 0; ix < nshapes; ++ix) {
                 // 分块处理粒子
                 for (long ip_base = 0; ip_base < np_to_deposit; ip_base += VEC_WIDTH) {
                     const int vec_len = std::min(VEC_WIDTH, static_cast<int>(np_to_deposit - ip_base));
                     alignas(64) double jx_vals[VEC_WIDTH] = {0};
                     alignas(64) double jy_vals[VEC_WIDTH] = {0};
                     alignas(64) double jz_vals[VEC_WIDTH] = {0};
                     alignas(64) long   xoffsets[VEC_WIDTH];
                     alignas(64) long   yoffsets[VEC_WIDTH];
                     alignas(64) long   zoffsets[VEC_WIDTH];
 
                     // 向量化计算块
                     #pragma omp simd
                     for (int iv = 0; iv < vec_len; ++iv) {
                         const long ip = ip_base + iv;
                         const double s = sx_cell[ix * np_to_deposit + ip] 
                                        * sy_cell[iy * np_to_deposit + ip] 
                                        * sz_cell[iz * np_to_deposit + ip];
 
                         jx_vals[iv] = s * wqx[ip];
                         jy_vals[iv] = s * wqy[ip];
                         jz_vals[iv] = s * wqz[ip];
 
                         // 计算网格偏移（优化版本）
                         const int j = lo.x + j_cell[ip] + ix;
                         const int k = lo.y + k_cell[ip] + iy;
                         const int l = lo.z + l_cell[ip] + iz;
                         xoffsets[iv] = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                         yoffsets[iv] = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
                         zoffsets[iv] = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
                     }
 
                     // 向量化原子添加使用AVX512内在函数
                     // #if defined(__AVX512F__)
                     // __m512d vjx = _mm512_load_pd(jx_vals);
                     // __m512d vjy = _mm512_load_pd(jy_vals);
                     // __m512d vjz = _mm512_load_pd(jz_vals);
                     // __m512i voff = _mm512_load_epi64(offsets);
 
                     // _mm512_i64scatter_pd(jx_arr.dataPtr(), voff, vjx, _MM_SCALE_8);
                     // _mm512_i64scatter_pd(jy_arr.dataPtr(), voff, vjy, _MM_SCALE_8);
                     // _mm512_i64scatter_pd(jz_arr.dataPtr(), voff, vjz, _MM_SCALE_8);
                     // #else
                     // 后备方案使用OpenMP原子操作
                     // #pragma omp simd
                     for (int iv = 0; iv < vec_len; ++iv) {
                         // #pragma omp atomic
                         // jx_arr.p[xoffsets[iv]] += jx_vals[iv];
                         // #pragma omp atomic
                         // jy_arr.p[yoffsets[iv]] += jy_vals[iv];
                         // #pragma omp atomic
                         // jz_arr.p[zoffsets[iv]] += jz_vals[iv];
                         amrex::Gpu::Atomic::AddNoRet(&jx_arr.p[xoffsets[iv]], jx_vals[iv]);
                         amrex::Gpu::Atomic::AddNoRet(&jy_arr.p[yoffsets[iv]], jy_vals[iv]);
                         amrex::Gpu::Atomic::AddNoRet(&jz_arr.p[zoffsets[iv]], jz_vals[iv]);
                     }
                     // #endif
                     // for (int iv = 0; iv < vec_len; ++iv) {
                     //     amrex::Print()<< "xoffset : "<<xoffsets[iv]<< "\n";
                     //     amrex::Print()<< "yoffset : "<<yoffsets[iv]<< "\n";
                     //     amrex::Print()<< "zoffset : "<<zoffsets[iv]<< "\n";
                     //     amrex::Print()<< "jx :"<<jx_vals[iv]<< std::endl;
                     // }
                     
                     // amrex::Abort("END SIMD!");
                 }
             }
         }
     }
 }
 
 template <int depos_order>
 void doDepositionShapeN (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Real q,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     using namespace amrex::literals;
 
     // Whether ion_lev is a null pointer (do_ionization=0) or a real pointer
     // (do_ionization=1)
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z;
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
     
 #if 0
     // amrex::ParticleReal xparr[np_to_deposit+1];
     // amrex::ParticleReal yparr[np_to_deposit+1];
     // amrex::ParticleReal zparr[np_to_deposit+1];
     // #pragma omp parallel for
     // for (long ip = 0; ip < np_to_deposit; ++ip) {
     //     // 加载粒子数据SoA结构保证向量加载效率
     //     GetPosition(ip, xparr[ip], yparr[ip], zparr[ip]);
     // }
     // // 前置条件粒子数据采用SoA布局，保证内存连续性
     // #pragma omp parallel for
     // for (long ip = 0; ip < np_to_deposit; ++ip) {
     //     // 加载粒子数据SoA结构保证向量加载效率
     //     const amrex::ParticleReal xp = xparr[ip];
     //     const amrex::ParticleReal yp = yparr[ip];
     //     const amrex::ParticleReal zp = zparr[ip];
     //     // amrex::ParticleReal xp, yp, zp;
     //     // GetPosition(ip, xp, yp, zp);    
     //     // 计算gamma逆
     //     const amrex::Real ux = uxp[ip];
     //     const amrex::Real uy = uyp[ip];
     //     const amrex::Real uz = uzp[ip];
     //     const amrex::Real gaminv = 1.0_rt / std::sqrt(1.0_rt + (ux*ux + uy*uy + uz*uz)*clightsq); 
     //     // 计算权重
     //     amrex::Real wq = q * wp[ip];
     //     if (do_ionization) wq *= ion_lev[ip];      
     //     // 预计算3D形状因子
     //     Compute_shape_factor<depos_order> compute_shape_factor;      
     //     // X方向
     //     const double xmid = ((xp  xyzmin.x) + relative_time*(ux*gaminv)) * dinv.x;
     //     double sx_cell[depos_order + 1];
     //     const int j_cell = compute_shape_factor(sx_cell, xmid  0.5);      
     //     // Y方向
     //     const double ymid = ((yp  xyzmin.y) + relative_time*(uy*gaminv)) * dinv.y;
     //     double sy_cell[depos_order + 1];
     //     const int k_cell = compute_shape_factor(sy_cell, ymid  0.5);     
     //     // Z方向
     //     const double zmid = ((zp  xyzmin.z) + relative_time*(uz*gaminv)) * dinv.z;
     //     double sz_cell[depos_order + 1];
     //     const int l_cell = compute_shape_factor(sz_cell, zmid  0.5);    
     //     // 展开的网格贡献计算
     //     const amrex::Real wqx = wq * invvol * (ux * gaminv);
     //     const amrex::Real wqy = wq * invvol * (uy * gaminv);
     //     const amrex::Real wqz = wq * invvol * (uz * gaminv);     
     //     // 预计算所有可能的形状因子乘积
     //     amrex::Real s_products[(depos_order+1)*(depos_order+1)*(depos_order+1)];
     //     int idx = 0;
     //     // 手动展开三维循环以depos_order=4为例
     //     #pragma unroll
     //     for (int iz = 0; iz <= depos_order; ++iz) {
     //         const amrex::Real sz = sz_cell[iz];
     //         #pragma unroll
     //         for (int iy = 0; iy <= depos_order; ++iy) {
     //             const amrex::Real sy = sy_cell[iy];
     //             #pragma unroll
     //             for (int ix = 0; ix <= depos_order; ++ix) {
     //                 s_products[idx++] = sx_cell[ix] * sy * sz;
     //             }
     //         }
     //     }     
     //     // 原子累加阶段
     //     idx = 0;
     //     #pragma unroll
     //     for (int iz = 0; iz <= depos_order; ++iz) {
     //         const int z_offset = (l_cell + iz  jx_arr.begin.z) * jx_arr.kstride;
     //         #pragma unroll
     //         for (int iy = 0; iy <= depos_order; ++iy) {
     //             const int y_offset = (k_cell + iy  jx_arr.begin.y) * jx_arr.jstride;
     //             #pragma unroll
     //             for (int ix = 0; ix <= depos_order; ++ix) {
     //                 const int x_offset = j_cell + ix  jx_arr.begin.x;
     //                 const long jx_addr = (lo.x + x_offset) + (lo.y + y_offset) + (lo.z + z_offset);              
     //                 const amrex::Real s = s_products[idx++];
     //                 amrex::Gpu::Atomic::AddNoRet(&jx_arr.p[jx_addr], s * wqx);
     //                 amrex::Gpu::Atomic::AddNoRet(&jy_arr.p[jx_addr], s * wqy); // 假设jy/jz地址计算类似
     //                 amrex::Gpu::Atomic::AddNoRet(&jz_arr.p[jx_addr], s * wqz);
     //             }
     //         }
     //     }
     // }
     // Loop over particles and deposit into jx_fab, jy_fab and jz_fab
     
     amrex::IntVect const jx_type = jx_fab.box().type();
     amrex::IntVect const jy_type = jy_fab.box().type();
     amrex::IntVect const jz_type = jz_fab.box().type();
     amrex::ParallelFor(
         np_to_deposit,
         [=] AMREX_GPU_DEVICE (long ip) {
             amrex::ParticleReal xp, yp, zp;
             GetPosition(ip, xp, yp, zp);
 
             //  Get particle quantities
             const amrex::Real gaminv = 1.0_rt/std::sqrt(1.0_rt + uxp[ip]*uxp[ip]*clightsq
                                                         + uyp[ip]*uyp[ip]*clightsq
                                                         + uzp[ip]*uzp[ip]*clightsq);
             const amrex::Real vx  = uxp[ip]*gaminv;
             // amrex::Print()<< "uxp[ip] :"<< uxp[ip]<< std::endl;
 
             const amrex::Real vy  = uyp[ip]*gaminv;
             const amrex::Real vz  = uzp[ip]*gaminv;
 
             amrex::Real wq  = q*wp[ip];
             if (do_ionization){
                 wq *= ion_lev[ip];
             }
 
             doDepositionShapeNKernel<depos_order>(xp, yp, zp, wq, vx, vy, vz, jx_arr, jy_arr, jz_arr,
                                                   jx_type, jy_type, jz_type,
                                                   relative_time, dinv, xyzmin,
                                                   invvol, lo, n_rz_azimuthal_modes);
 
         }
     );
 #elif 0
     // Deposit current into jx_arr, jy_arr and jz_arr
     // 预定义向量化宽度根据目标架构调整如AVX2=4, AVX512=8
     constexpr int VEC_WIDTH = 4;
 
     // 预计算数据结构
     // struct PrecomputedData {
     //     amrex::Real sx[VEC_WIDTH][depos_order + 1];
     //     amrex::Real sy[VEC_WIDTH][depos_order + 1];
     //     amrex::Real sz[VEC_WIDTH][depos_order + 1];
     //     amrex::Real wqx[VEC_WIDTH];
     //     amrex::Real wqy[VEC_WIDTH];
     //     amrex::Real wqz[VEC_WIDTH];
     //     int cell_idx[VEC_WIDTH][3]; // [j,k,l]
     // };
 
     amrex::Real wqx[np_to_deposit+1]= {0.};
     amrex::Real wqy[np_to_deposit+1]= {0.};
     amrex::Real wqz[np_to_deposit+1]= {0.};
     double sx_cell[np_to_deposit+1][depos_order + 1] = {0.};
     double sy_cell[np_to_deposit+1][depos_order + 1] = {0.};
     double sz_cell[np_to_deposit+1][depos_order + 1] = {0.};
     int j_cell[np_to_deposit+1] ={0};
     int k_cell[np_to_deposit+1] ={0};
     int l_cell[np_to_deposit+1] ={0};
 
     #pragma omp parallel for simd
     for(long ip=0;ip<np_to_deposit;ip++){
         amrex::ParticleReal xp, yp, zp;
         GetPosition(ip, xp, yp, zp);
         // xp=GetPosition.m_x[ip];
 
         //  Get particle quantities
         const amrex::Real gaminv = 1.0_rt/std::sqrt(1.0_rt + uxp[ip]*uxp[ip]*clightsq
                                                     + uyp[ip]*uyp[ip]*clightsq
                                                     + uzp[ip]*uzp[ip]*clightsq);
         const amrex::Real vx  = uxp[ip]*gaminv;
         const amrex::Real vy  = uyp[ip]*gaminv;
         const amrex::Real vz  = uzp[ip]*gaminv;
 
         amrex::Real wq  = q*wp[ip];
         if (do_ionization){
             wq *= ion_lev[ip];
         }
 
         wqx[ip] = wq*invvol*vx;
         // amrex::Print()<< "wqx :"<< wqx[ip] << std::endl;
         // amrex::Print()<< "wq :"<< wq << std::endl;
         // amrex::Print()<< "uxp[ip] :"<< uxp[ip]<< std::endl;
         // amrex::Print()<< "gaminv :"<< gaminv<< std::endl;
         wqy[ip] = wq*invvol*vy;
         wqz[ip] = wq*invvol*vz;
 
         //  Compute shape factors
         Compute_shape_factor< depos_order > const compute_shape_factor;
         const double xmid = ((xp  xyzmin.x) + relative_time*vx)*dinv.x;
         j_cell[ip] = compute_shape_factor(sx_cell[ip], xmid  0.5);
         const double ymid = ((yp  xyzmin.y) + relative_time*vy)*dinv.y;
         k_cell[ip] = compute_shape_factor(sy_cell[ip], ymid  0.5);
         const double zmid = ((zp  xyzmin.z) + relative_time*vz)*dinv.z;
         l_cell[ip] = compute_shape_factor(sz_cell[ip], zmid  0.5);
     }
 
     // 分批处理粒子
     #pragma omp parallel for schedule(guided)
     for (long ip = 0; ip < np_to_deposit; ip += VEC_WIDTH) {
         const int vec_len = std::min(VEC_WIDTH, static_cast<int>(np_to_deposit  ip));
 
         // 阶段2: 向量化沉积
         // #pragma omp simd collapse(3)
         for (int iz = 0; iz <= depos_order; ++iz) {
             for (int iy = 0; iy <= depos_order; ++iy) {
                 for (int ix = 0; ix <= depos_order; ++ix) {
                     amrex::Real jx_vals[VEC_WIDTH] = {0.};
                     amrex::Real jy_vals[VEC_WIDTH] = {0.};
                     amrex::Real jz_vals[VEC_WIDTH] = {0.};
                     long offsets[VEC_WIDTH];
                     long offsets1[VEC_WIDTH];
                     long offsets2[VEC_WIDTH];
 
                     // 向量化计算贡献
                     #pragma omp simd
                     for (int iv = 0; iv < vec_len; ++iv) {
                         const amrex::Real s = sx_cell[iv+ip][ix] * sy_cell[iv+ip][iy] * sz_cell[iv+ip][iz];
                         // amrex::Print()<< "s :"<< s << std::endl;
                         // amrex::Print()<< "sx :"<< sx_cell[iv+ip][ix] << std::endl;
                         // amrex::Print()<< "wqx :"<< wqx[iv+ip] << std::endl;
                         jx_vals[iv] = s * wqx[iv+ip];
                         jy_vals[iv] = s * wqy[iv+ip];
                         jz_vals[iv] = s * wqz[iv+ip];
                         // amrex::Print()<< "jx :"<<jx_vals[iv]<< std::endl;
                         
                         // 预计算内存偏移
                         offsets[iv] = (lo.x+j_cell[iv+ip]+ixjx_arr.begin.x) + \
                             (lo.y+k_cell[iv+ip]+iyjx_arr.begin.y)*jx_arr.jstride + \
                             (lo.z+l_cell[iv+ip]+iz jx_arr.begin.z)*jx_arr.kstride;
                         offsets1[iv] = (lo.x+j_cell[iv+ip]+ixjy_arr.begin.x) + \
                             (lo.y+k_cell[iv+ip]+iyjy_arr.begin.y)*jy_arr.jstride + \
                             (lo.z+l_cell[iv+ip]+iz jy_arr.begin.z)*jy_arr.kstride;
                         offsets2[iv] = (lo.x+j_cell[iv+ip]+ixjz_arr.begin.x) + \
                             (lo.y+k_cell[iv+ip]+iyjz_arr.begin.y)*jz_arr.jstride + \
                             (lo.z+l_cell[iv+ip]+iz jz_arr.begin.z)*jz_arr.kstride;
                     }
                     // 原子累加使用向量化友好方式
                     for (int iv = 0; iv < vec_len; ++iv) {
                         amrex::Gpu::Atomic::AddNoRet(&jx_arr.p[offsets[iv]], jx_vals[iv]);
                         amrex::Gpu::Atomic::AddNoRet(&jy_arr.p[offsets1[iv]], jy_vals[iv]);
                         amrex::Gpu::Atomic::AddNoRet(&jz_arr.p[offsets2[iv]], jz_vals[iv]);
                         // jx_arr.p[offsets[iv]]+=jx_vals[iv];
                         // jy_arr.p[offsets[iv]]+=jy_vals[iv];
                         // jz_arr.p[offsets[iv]]+=jz_vals[iv];
                         amrex::Print()<< "offset : "<<offsets[iv]<< "\n";
                         amrex::Print()<< "jx :"<<jx_vals[iv]<< std::endl;
                     }
                 }
             }
         }
         amrex::Abort("stop 2 simd");
     }
 #elif 0
 
     // constexpr int depos_order = 3; // 根据实际模板参数调整
     constexpr int nshapes = depos_order + 1;
     std::vector<double> sx_cell(nshapes * np_to_deposit, 0.0);
     std::vector<double> sy_cell(nshapes * np_to_deposit, 0.0);
     std::vector<double> sz_cell(nshapes * np_to_deposit, 0.0);
     std::vector<int> j_cell(np_to_deposit, 0);
     std::vector<int> k_cell(np_to_deposit, 0);
     std::vector<int> l_cell(np_to_deposit, 0);
     std::vector<amrex::Real> wqx(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqy(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqz(np_to_deposit, 0.0);
     std::vector<amrex::Real> vx(np_to_deposit, 0.0);
     std::vector<amrex::Real> vy(np_to_deposit, 0.0);
     std::vector<amrex::Real> vz(np_to_deposit, 0.0);
 
     // 阶段1预计算粒子数据
     #pragma omp simd
     for (long ip = 0; ip < np_to_deposit; ++ip) {
         // 计算基本物理量
         const amrex::Real gaminv = 1.0 / std::sqrt(1.0 + uxp[ip]*uxp[ip]*clightsq
                                                     + uyp[ip]*uyp[ip]*clightsq
                                                     + uzp[ip]*uzp[ip]*clightsq);
         vx[ip] = uxp[ip] * gaminv;
         vy[ip] = uyp[ip] * gaminv;
         vz[ip] = uzp[ip] * gaminv;
 
         amrex::Real wq = q * wp[ip];
         // if (do_ionization) wq *= ion_lev[ip];
 
         wqx[ip] = wq * invvol * vx[ip];
         wqy[ip] = wq * invvol * vy[ip];
         wqz[ip] = wq * invvol * vz[ip];
     }
 
     // 阶段2预计算形状因子SoA布局
     Precompute_shape_factors<depos_order>(
         sx_cell.data(), sy_cell.data(), sz_cell.data(),
         j_cell.data(), k_cell.data(), l_cell.data(),
         np_to_deposit,
         vx.data(), vy.data(), vz.data(),
         relative_time,
         xyzmin,
         dinv,
         GetPosition);
 
     // 阶段3向量化沉积
     VectorizedDeposit<depos_order>(
         jx_arr, jy_arr, jz_arr,
         np_to_deposit,
         sx_cell.data(), sy_cell.data(), sz_cell.data(),
         j_cell.data(), k_cell.data(), l_cell.data(),
         wqx.data(), wqy.data(), wqz.data(),
         lo);
 
 #elif 1
     constexpr int nshapes = 3 + 1;
     const int block_size=256;
     long n_blocks=np_to_deposit/block_size;
     const int vl=svcntd();
 
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
 
     auto compute_shape_factor_v2 = [](int64_t* i_new,double* sx[], Vec xmid, svbool_t p) {
         Vec j = svrintz_x(p, xmid);
         Vec xint = xmid - j;
         Vec temp = 1.0 - xint;
         Vec sx0 = (1.0 / 6.0) * temp * temp * temp;
         Vec sx1 = (2.0 / 3.0) - xint * xint * (1.0 - xint * 0.5);
         Vec sx2 = (2.0 / 3.0) - temp * temp * (1.0 - 0.5 *temp);
         Vec sx3 = (1.0 / 6.0) * xint * xint * xint;
         sx0.Store(p, sx[0]);
         sx1.Store(p, sx[1]);
         sx2.Store(p, sx[2]);
         sx3.Store(p, sx[3]);
         svint64_t i_newv=svsub_x(p, svcvt_s64_x(p,j), svdup_s64(1));
         svst1(p, i_new, i_newv);
         return i_newv;
     };
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
     // #pragma omp parallel for
     for(int block_id=0;block_id<n_blocks;block_id++){
 
         // std::vector<double> sx_cell(nshapes * block_size, 0.0);
         // std::vector<double> sy_cell(nshapes * block_size, 0.0);
         // std::vector<double> sz_cell(nshapes * block_size, 0.0);
         std::vector<int64_t> j_cell(block_size, 0);
         std::vector<int64_t> k_cell(block_size, 0);
         std::vector<int64_t> l_cell(block_size, 0);
         std::vector<amrex::Real> wqx(block_size, 0.0);
         std::vector<amrex::Real> wqy(block_size, 0.0);
         std::vector<amrex::Real> wqz(block_size, 0.0);
         // std::vector<amrex::Real> vx(block_size, 0.0);
         // std::vector<amrex::Real> vy(block_size, 0.0);
         // std::vector<amrex::Real> vz(block_size, 0.0);
         double sx_m[nshapes][block_size] = {0.};
         double sy_m[nshapes][block_size] = {0.};
         double sz_m[nshapes][block_size] = {0.};
 
         for(int iip=0;iip<block_size;iip+=vl){
             long ip=iip+block_id*block_size;
             // 计算基本物理量
             svbool_t p_ip=svwhilele_b64(ip,np_to_deposit);
             // Inverse of Lorentz factor gamma
             Vec uxp_v=Vec::Load(p_ip,&uxp[ip]);
             Vec uyp_v=Vec::Load(p_ip,&uyp[ip]);
             Vec uzp_v=Vec::Load(p_ip,&uzp[ip]);
             Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                         + uyp_v * uyp_v * clightsq
                                         + uzp_v * uzp_v * clightsq).Sqrt();
             // Product of particle charges and weights
             Vec wp_v=Vec::Load(p_ip,&wp[ip]);
             Vec wq_v = q * wp_v;
 
             // Current particle positions (in physical units)
             // Vec xp = Vec::Load(p_ip, &mx[ip]);
             // Vec yp = Vec::Load(p_ip, &my[ip]);
             // Vec zp = Vec::Load(p_ip, &mz[ip]);
 
             // Particle velocities
             Vec vx_v = uxp_v * gaminv;
             Vec vy_v = uyp_v * gaminv;
             Vec vz_v = uzp_v * gaminv;
 
             // if (do_ionization) wq *= ion_lev[ip];
             Vec wqx_v = wq_v * invvol * vx_v;
             Vec wqy_v = wq_v * invvol * vy_v;
             Vec wqz_v = wq_v * invvol * vz_v;
 
             wqx_v.Store(p_ip, &wqx[iip]);
             wqy_v.Store(p_ip, &wqy[iip]);
             wqz_v.Store(p_ip, &wqz[iip]);
 
             Vec xp = Vec::Load(p_ip, &mx[ip]);
             Vec yp = Vec::Load(p_ip, &my[ip]);
             Vec zp = Vec::Load(p_ip, &mz[ip]);
 
             Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x - 0.5;
             Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y - 0.5;
             Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z - 0.5;
             // TODO : 2d matrix --> 1d list
             // TODO: no need to return
             double* sx_temp[nshapes] = {&sx_m[0][iip], &sx_m[1][iip], &sx_m[2][iip], &sx_m[3][iip]};
             svint64_t j_cell_v=compute_shape_factor_v2(&j_cell[iip], sx_temp, xmid, p_ip);
             double* sy_temp[nshapes] = {&sy_m[0][iip], &sy_m[1][iip], &sy_m[2][iip], &sy_m[3][iip]};
             svint64_t k_cell_v=compute_shape_factor_v2(&k_cell[iip], sy_temp, ymid, p_ip);
             double* sz_temp[nshapes] = {&sz_m[0][iip], &sz_m[1][iip], &sz_m[2][iip], &sz_m[3][iip]};
             svint64_t l_cell_v=compute_shape_factor_v2(&l_cell[iip], sz_temp, zmid, p_ip);
             
         }
         // alignas(64) long   xoffsets[vl];
         // alignas(64) long   yoffsets[vl];
         // alignas(64) long   zoffsets[vl];
         // alignas(64) double jx_vals[vl] = {0};
         // alignas(64) double jy_vals[vl] = {0};
         // alignas(64) double jz_vals[vl] = {0};
         alignas(64) long   xoffsets[8];
         alignas(64) long   yoffsets[8];
         alignas(64) long   zoffsets[8];
         alignas(64) double jx_vals[8] = {0};
         alignas(64) double jy_vals[8] = {0};
         alignas(64) double jz_vals[8] = {0};
 
         for (int iz = 0; iz < nshapes; ++iz) {
             double* sz=sz_m[iz];
             for (int iy = 0; iy < nshapes; ++iy) {
                 double* sy=sy_m[iy];
                 for (int ix = 0; ix < nshapes; ++ix) {
                     double* sx=sx_m[ix];
                     // 分块处理粒子
                     for (long iip = 0; iip < block_size; iip += vl) {
                         long ip=iip+block_id*block_size;
                         svbool_t p=svwhilelt_b64(ip,np_to_deposit);
 
                         Vec sx_v = Vec::Load(p, &sx[iip]);
                         Vec sy_v = Vec::Load(p, &sy[iip]);
                         Vec sz_v = Vec::Load(p, &sz[iip]);
                         Vec s = sx_v * sy_v * sz_v;
 
                         Vec wqx_v = Vec::Load(p, &wqx[iip]);
                         Vec wqy_v = Vec::Load(p, &wqy[iip]);
                         Vec wqz_v = Vec::Load(p, &wqz[iip]);
 
                         Vec jx_v = s* wqx_v;
                         Vec jy_v = s* wqy_v;
                         Vec jz_v = s* wqz_v;
 
                         jx_v.Store(p,&jx_vals[0]);
                         jy_v.Store(p,&jy_vals[0]);
                         jz_v.Store(p,&jz_vals[0]);
 
                         intVec j_cell_v = intVec::Load(p, &j_cell[iip]);
                         intVec k_cell_v = intVec::Load(p, &k_cell[iip]);
                         intVec l_cell_v = intVec::Load(p, &l_cell[iip]);
 
                         intVec j = lo.x + j_cell_v + ix;
                         intVec k = lo.y + k_cell_v + iy;
                         intVec l = lo.z + l_cell_v + iz;
 
                         intVec xoffsets_v = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                         intVec yoffsets_v = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
                         intVec zoffsets_v = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
 
                         xoffsets_v.Store(p,&xoffsets[0]);
                         yoffsets_v.Store(p,&yoffsets[0]);
                         zoffsets_v.Store(p,&zoffsets[0]);
                         const int vec_len = std::min(vl, static_cast<int>(np_to_deposit - ip));
 
 
                         for (int iv = 0; iv < vec_len; ++iv) {
                             amrex::Gpu::Atomic::AddNoRet(&jx_arr.p[xoffsets[iv]], jx_vals[iv]);
                             amrex::Gpu::Atomic::AddNoRet(&jy_arr.p[yoffsets[iv]], jy_vals[iv]);
                             amrex::Gpu::Atomic::AddNoRet(&jz_arr.p[zoffsets[iv]], jz_vals[iv]);
                         }
                         
                     }
                 }
             }
         }    
     }
 
 
 
 
 
 #endif
     
 }
 
 struct ParticleMove {
     int pid;   // 粒子 ID
     int  new_bin;       // 新 bin
     // int  old_bin;       // 旧 bin
     // int  old_idx;       // 在 m_local_index 中的物理下标
 };
 static constexpr int INVALID_PARTICLE_ID = -1;
//  const int INVALID_PARTICLE_ID = std::numeric_limits<int>::max();
 using ParticleTileType = typename WarpXParticleContainer::ParticleTileType;
 // 用于临时存储无法立即放入目标 bin 的粒子
 struct OverflowParticle {
     int pid;    // 粒子 ID
     int target_bin; // 目标 bin
     // 可以添加 old_bin, old_idx 等信息，如果 Rebuild 时需要
 };
 
 
 // --- 单独的检查函数 ---
 inline bool checkRebuildConditions(const ParticleTileType& ptile, 
                             const std::vector<OverflowParticle>& m_overflow_particles,
                             double overflow_threshold_ratio = 0.05, // 5% 粒子溢出触发
                             double empty_slot_threshold_ratio = 0.10) // 10% 空槽触发
 {
     BL_PROFILE("checkRebuildConditions");
 
     // 规则 1: 是否有任何插入操作失败 (即溢出列表非空)?
     bool has_overflow = !m_overflow_particles.empty();
 
     // 规则 2: 全局空槽数量是否过低?
     int low_water_mark = static_cast<int>(ptile.m_capacity * empty_slot_threshold_ratio);
     bool low_empty_slots = ptile.m_num_empty_slots < low_water_mark;
 
     // 规则 3: 溢出粒子数量是否超过一个显著阈值?
     int significant_overflow_limit = static_cast<int>(ptile.m_num_particles * overflow_threshold_ratio);
     bool significant_overflow = m_overflow_particles.size() > significant_overflow_limit;
 
     // 决策逻辑:
     // 如果有粒子溢出 并且 全局空槽很少，则必须重组 (避免下次连溢出都放不下)
     if (has_overflow && low_empty_slots) {
         // printf("Rebuild triggered: Overflow exists AND empty slots below threshold (%d < %d).\n",
         //        ptile.m_num_empty_slots, low_water_mark);
         return true;
     }
 
     // 如果溢出粒子数量本身就很多，也触发重组 (说明局部空间分配严重不足)
     if (significant_overflow) {
         // printf("Rebuild triggered: Significant overflow (%zu > %d particles).\n",
         //        m_overflow_particles.size(), significant_overflow_limit);
         return true;
     }
 
     // 可选：即使没有溢出，如果空槽非常少，也可以预防性地重组
     if (!has_overflow && low_empty_slots) {
         //  printf("Rebuild triggered: Low empty slots (%d < %d), performing preventative rebuild.\n",
         //        ptile.m_num_empty_slots, low_water_mark);
         return true; // 取决于是否需要预防性重组
     }
 
     // 如果之前的插入都成功了，并且空槽还足够，则不重组
     return false;
 }
 
 // --- 本地 Tile 重组函数 (包含内存回收逻辑) ---
 inline void RebuildPMAWithinTile(ParticleTileType& ptile, 
                 int numcell,
                 std::vector<OverflowParticle> m_overflow_particles, // 传入溢出列表
                 double desired_gap_ratio = 0.25,
                 double recycle_threshold = 0.7 // 例如，如果实际容量 > 理论需要容量 / recycle_threshold，则回收
 ) {
     BL_PROFILE("RebuildPMAWithinTile");
     // printf("Performing local rebuild for tile...\n");
 
     // 1. 收集所有有效粒子及其当前 bin
     std::vector<std::pair<int, int>> particle_bin_pairs;
     // 预估大小
     particle_bin_pairs.reserve(ptile.m_num_particles + m_overflow_particles.size() + 10); // +10 for safety
 
     // a) 处理 m_local_index 中的粒子
     // for (int idx = 0; idx < m_capacity; ++idx) {
     //     int ip = m_local_index[idx];
     //     if (ip != INVALID_PARTICLE_ID) {
     //         // 检查 current_positions 是否包含 ip 且有效
     //         if (ip < current_positions.size()) {
     //             const auto& pos = current_positions[ip];
     //             int bin_id = computeBinId(pos[0], pos[1], pos[2], box);
     //             if (bin_id >= 0 && bin_id < numcell) {
     //                 particle_bin_pairs.push_back({bin_id, ip});
     //             } else { /* Handle particle leaving */ }
     //         } else { /* Handle invalid ip */ }
     //     }
     // }
     // a) 处理 m_local_index 中的粒子
     auto& bin_length = ptile.m_bin_lengths;
     auto& local_index = ptile.m_local_index;
     auto& bin_offsets = ptile.m_bin_offsets;
     for (int old_bin = 1; old_bin <= numcell; ++old_bin) {
         if (bin_length[old_bin-1] == 0) continue;
         int start = bin_offsets[old_bin-1];
         // int end = start+ bin_length[old_bin-1];
         int end = bin_offsets[old_bin];
         // printf("old_bin %d start %d end %d, binlength %d\n"
         //     , old_bin-1, start, end, bin_length[old_bin-1]);
 
         // int idx = start;
         for (int idx = start; idx < end; ++idx) {
         // while(idx < end){
             int ip = local_index[idx];
             // printf("ip %u\n", ip);
             if(ip==INVALID_PARTICLE_ID) continue;
             particle_bin_pairs.push_back({old_bin-1, ip});
             // printf("pushing Particle %u in bin %d at index %d\n", ip, old_bin-1, idx);
 
             // idx++;
         }
     }
     // printf("Rebuild: %d particles in local index.\n", particle_bin_pairs.size());
     // amrex::Abort("stop");
     // b) 添加溢出列表中的粒子
     for (const auto& overflow : m_overflow_particles) {
          if (overflow.target_bin >= 0 && overflow.target_bin < numcell) {
             //  particle_bin_pairs.emplace_back({overflow.target_bin, overflow.pid});
              particle_bin_pairs.push_back({overflow.target_bin, overflow.pid});
          }
     }
     // printf("Rebuild: %d overflow particles.\n", m_overflow_particles.size());
 
     // --- 内存回收决策 ---
     int total_valid_particles = particle_bin_pairs.size();
     int needed_capacity = static_cast<int>(std::ceil(total_valid_particles * (1.0 + desired_gap_ratio))+numcell);
     // printf("total_valid_particles %d, desired_capacity %d ,numcell %d\n",
     //        total_valid_particles, needed_capacity, numcell);
     int new_capacity = ptile.m_capacity; // 默认为当前容量
     // printf("needed_capacity %d, current_capacity %d\n", needed_capacity, ptile.m_capacity);
 
     if (ptile.m_capacity > 0 && needed_capacity > 0 && // 避免除零或无效计算
         static_cast<double>(needed_capacity) / ptile.m_capacity < recycle_threshold)
     {
         //  printf("Recycling PMA memory: Current capacity %d, Needed capacity %d. Shrinking.\n",
         //     ptile.m_capacity, needed_capacity);
          new_capacity = needed_capacity; // 决定缩小容量
     } else if (needed_capacity > ptile.m_capacity) {
         //  printf("Increasing PMA capacity: Current %d, Needed %d. Growing.\n",
             // ptile.m_capacity, needed_capacity);
          new_capacity = needed_capacity; // 需要增长容量
     } else {
         // printf("Keeping current PMA capacity: %d (Needed: %d).\n", ptile.m_capacity, needed_capacity);
         // 容量不变或略微缩小但不触发回收阈值
     }
     // 确保容量至少能装下所有粒子
     new_capacity = std::max(new_capacity, total_valid_particles);
 
     // --- 重建过程 ---
     // 2. 根据 bin ID 排序
     // TODO: 修改排序方式
     // std::sort(particle_bin_pairs.begin(), particle_bin_pairs.end());
     std::vector<int> final_bin_counts(numcell, 0);
     for (const auto& pair : particle_bin_pairs) {
         final_bin_counts[pair.first]++; // pair.first is bin_id
     }
     // printf("Sorted %d particles into bins.\n", particle_bin_pairs.size());
 
     // 3. 重建数据结构
     ptile.m_capacity = new_capacity; // 更新容量
     int current_offset = 0;
     ptile.m_bin_offsets[0] = 0;
     for (int b = 0; b < numcell; ++b) {
         int n_in_bin = final_bin_counts[b];
         ptile.m_bin_lengths[b] = n_in_bin; // 存储最终的有效粒子数
         int gap = (n_in_bin > 0) ? static_cast<int>(std::round(n_in_bin * desired_gap_ratio)) : 1; // 至少留一个空槽
         int block_size = n_in_bin + gap;
         current_offset += block_size;
         current_offset = std::min(current_offset, ptile.m_capacity); // 确保不超过容量
         ptile.m_bin_offsets[b + 1] = current_offset;
         // printf("Bin %d: %d particles, gap %d, block size %d, offset %d\n",
         //     b, n_in_bin, gap, block_size, current_offset
         // );
     }
      // 确保最后一个偏移量正确
     ptile.m_bin_offsets[numcell] = std::min(ptile.m_bin_offsets[numcell], ptile.m_capacity);
 
     // 4. 放置粒子 (核心区别在这里)
     //    使用一个辅助数组来追踪每个 bin 当前应该写入的位置
     std::vector<int> next_write_slot = ptile.m_bin_offsets; // 初始化为每个 bin 的起始位置
     for (const auto& pair : particle_bin_pairs) {
         int bin_id = pair.first;
         int ip = pair.second;
 
         int insert_idx = next_write_slot[bin_id];
         // 检查写入位置是否仍在当前 bin 的分配块内且未超出容量
         // (理论上不应超出 ptile.m_bin_offsets[bin_id+1]，因为 offset 是基于 count 计算的)
         // printf("insterting Particle %d to %d in bin %d at offset %d\n",ip,insert_idx, bin_id+1, ptile.m_bin_offsets[bin_id + 1]);
         if (insert_idx < ptile.m_bin_offsets[bin_id + 1] && insert_idx < ptile.m_capacity) {
             ptile.m_local_index[insert_idx] = ip;
             next_write_slot[bin_id]++; // 更新该 bin 的下一个写入位置
             // printf("placing Particle %u in bin %d at index %d\n", ip, bin_id, insert_idx);
         } else {
             // 如果发生这种情况，通常意味着 offsets 或 counts 计算有误
             printf("Critical Error during placement (No Sort): Write position %d out of bounds for bin %d (OffsetEnd: %d, Capacity: %d). Particle %u lost!\n",
                    insert_idx, bin_id, ptile.m_bin_offsets[bin_id + 1], ptile.m_capacity, ip);
             // 必须处理这个错误，否则粒子会丢失
         }
     }
     
     //  ptile.m_local_index.assign(ptile.m_capacity, INVALID_PARTICLE_ID); // 重置并调整大小
     // ptile.m_bin_offsets.assign(numcell + 1, 0);
     // ptile.m_bin_lengths.assign(numcell, 0);
 
     // int write_ptr = 0;
     // int current_bin = 0;
     // ptile.m_bin_offsets[0] = 0;
     // int particles_placed = 0;
     // printf("Rebuilding PMA with %d particles.\n", particle_bin_pairs.size());
 
     // // 4. 重新填充并插入空隙
     // for (const auto& pair : particle_bin_pairs) {
     //     int bin_id = pair.first;
     //     int ip = pair.second;
 
     //     while (current_bin < bin_id) {
     //          int n_in_last_bin = ptile.m_bin_lengths[current_bin];
     //          int gap = (n_in_last_bin > 0) ? static_cast<int>(std::round(n_in_last_bin * desired_gap_ratio)) : 0;
     //          int end_of_last_bin = ptile.m_bin_offsets[current_bin] + n_in_last_bin; // 最后一个粒子的下一个位置
     //          // 确保空隙不会让 write_ptr 超出容量，并且不超过当前 bin 的物理结束位置
     //          int physical_end_of_bin = end_of_last_bin + gap;
     //          physical_end_of_bin = std::min(physical_end_of_bin, ptile.m_capacity); // 不能超出总容量
     //          write_ptr = physical_end_of_bin; // 下一个 bin 从这里开始
 
     //          ptile.m_bin_offsets[current_bin + 1] = write_ptr;
     //          current_bin++;
     //          if (current_bin < numcell) {
     //             ptile.m_bin_offsets[current_bin] = write_ptr;
     //          }
     //     }
 
     //     // 放置粒子，检查容量
     //     if (write_ptr < ptile.m_capacity) {
     //          // 确保 write_ptr 在当前 bin 的预期逻辑位置
     //          // (如果 bin 为空，write_ptr 应该等于 m_bin_offsets[current_bin])
     //          // (如果 bin 非空，它应该是最后一个粒子的下一个位置)
     //          // 这里逻辑简化为直接在 write_ptr 写入，依赖排序确保顺序
     //          ptile.m_local_index[write_ptr] = ip;
     //          ptile.m_bin_lengths[current_bin]++;
     //          write_ptr++;
     //          particles_placed++;
     //     } else {
     //          printf("Error: Rebuild ran out of new capacity %d! Particle %u for bin %d lost.\n", ptile.m_capacity, ip, bin_id);
     //     }
     // }
     // printf("Placed %d particles.\n", particles_placed);
     // // 处理最后一个 bin 的结束偏移和可能存在的空隙
     // while (current_bin < numcell) {
     //      int n_in_last_bin = ptile.m_bin_lengths[current_bin];
     //      int gap = (n_in_last_bin > 0) ? static_cast<int>(std::round(n_in_last_bin * desired_gap_ratio)) : 0;
     //      int end_of_last_bin = ptile.m_bin_offsets[current_bin] + n_in_last_bin;
     //      int physical_end_of_bin = end_of_last_bin + gap;
     //      physical_end_of_bin = std::min(physical_end_of_bin, ptile.m_capacity);
     //      write_ptr = physical_end_of_bin;
     //      ptile.m_bin_offsets[current_bin + 1] = write_ptr;
     //      current_bin++;
     //      if (current_bin < numcell) {
     //          ptile.m_bin_offsets[current_bin] = write_ptr;
     //      }
     // }
     // // 确保最后一个 offset 正确
     // ptile.m_bin_offsets[numcell] = write_ptr;
     // 可能 write_ptr < m_capacity，剩余的是末尾的空槽
 
     ptile.m_num_particles = particle_bin_pairs.size();;
     ptile.m_num_empty_slots = ptile.m_capacity - ptile.m_num_particles;
 
     // printf("Rebuild (No Sort) complete. Placed %d particles. New Capacity %d. Empty slots: %d\n",
     //        ptile.m_num_particles, ptile.m_capacity, ptile.m_num_empty_slots);
 
     // printf("Rebuild complete. Placed %d particles. New Capacity %d. Empty slots: %d\n",
     //     ptile.m_num_particles, ptile.m_capacity, ptile.m_num_empty_slots);
     // for (int old_bin = 1; old_bin <= numcell; ++old_bin) {
     //     if (bin_length[old_bin-1] == 0) continue;
     //     int start = bin_offsets[old_bin-1];
     //     // int end = start+ bin_length[old_bin-1];
     //     int end = bin_offsets[old_bin];
 
     //     // int idx = start;
     //     for (int idx = start; idx < end; ++idx) {
     //     // while(idx < end){
     //         int ip = local_index[idx];
     //         if(ip==INVALID_PARTICLE_ID) continue;
     //         // printf("Particle %u in bin %d at index %d\n", ip, old_bin-1, idx);
     //         // idx++;
     //     }
     // }
     ptile.m_was_rebuilt_this_step = true;
     // amrex::Abort("Rebuild complete");
 }
 
  // --- 尝试通过移位插入溢出粒子 ---
 inline bool InsertOverflowByShifting(ParticleTileType& ptile, 
     const std::vector<OverflowParticle>& overflow_particles, // 只读访问
     int numcell
 ) {
     BL_PROFILE("InsertOverflowByShifting");
     printf("Inserting %d overflow particles by shifting.\n", overflow_particles.size());
 
     // 注意：这个函数需要非常小心地处理索引和偏移量的更新，
     // 特别是当多个粒子需要插入到需要移动相同后续块的位置时。
     // 简单的顺序处理可能导致 O(N^2) 的移位复杂度。
     // 更优的方法是先计算所有需要的总移位数，然后进行一次或几次大块移动。
     // 这里为了演示，采用较简单的顺序处理（效率可能不高）。
 
     for (const auto& overflow : overflow_particles) {
         int target_bin = overflow.target_bin;
         int pid = overflow.pid;
 
         // 1. 确定插入点和所需移动的起始点
         //    我们假设插入到 bin 的逻辑末尾，即 m_bin_offsets[target_bin] + m_bin_lengths[target_bin]
         //    但由于 bin 内无空槽，实际物理插入点需要腾出来。
         //    需要移动的起始点是当前 bin 的物理结束位置: m_bin_offsets[target_bin + 1]
         int shift_start_idx = ptile.m_bin_offsets[target_bin + 1];
 
         // 2. 找到最近的空槽用于终止移位
         int empty_slot_idx = -1;
         for (int i = shift_start_idx; i < ptile.m_capacity; ++i) {
             printf("Checking slot %d ", i);
             if (ptile.m_local_index[i] == INVALID_PARTICLE_ID) {
                 empty_slot_idx = i;
                 printf(" is empty\n");
                 break;
             }
             printf(" is NOT empty\n");
         }
 
         // 3. 检查是否找到空槽（即总容量是否足够）
         if (empty_slot_idx == -1) {
             printf("Error in InsertOverflowByShifting: No empty slot found anywhere after index %d. Capacity %d full?\n",
                    shift_start_idx, ptile.m_capacity);
             return false; // 无法完成移位，总容量不足
         }
 
 
 
         // 4. 执行移位 (将 [shift_start_idx, empty_slot_idx - 1] 的内容移动到
         //             [shift_start_idx + 1, empty_slot_idx])
         // 使用 copy_backward 更安全
         if (empty_slot_idx > shift_start_idx) { // 只有当空槽不在移位起点时才需要移动
             printf("Shifting %d particles from %d to %d\n", 
                 empty_slot_idx - shift_start_idx, shift_start_idx, empty_slot_idx);
             std::copy_backward(ptile.m_local_index.begin() + shift_start_idx,
                             ptile.m_local_index.begin() + empty_slot_idx, // 源范围是 [first, last)
                             ptile.m_local_index.begin() + empty_slot_idx + 1); // 目标范围的 *之后* 一个位置
         }
 
         // 5. 在腾出的位置插入粒子 (移位后的 shift_start_idx 位置是空的)
         ptile.m_local_index[shift_start_idx] = pid;
 
         // 6. 更新计数器
         ptile.m_bin_lengths[target_bin]++;
         ptile.m_num_empty_slots--; // 全局空槽少了一个
 
         // 7. 更新后续 bin 的 offsets（非常重要！）
         // for (int b = target_bin + 1; b < numcell; ++b) {
         //     ptile.m_bin_offsets[b]++;
         //     printf("Updating offset for bin %d to %d\n", b, ptile.m_bin_offsets[b]);
         // }
         // 7. 只更新真正被移动到的那些 bin 的 offset
         for (int b = target_bin + 1; b < numcell && ptile.m_bin_offsets[b] <= empty_slot_idx; ++b) {
             ++ptile.m_bin_offsets[b];
             printf("Updating offset for bin %d to %d\n", b, ptile.m_bin_offsets[b]);
         }
         // 注意：这种顺序处理方式，如果下一个溢出粒子也要插入到同一个 target_bin，
         // 或者插入到 target_bin+1，它的 m_bin_offsets 已经被更新了，逻辑应该依然正确。
         // 但效率问题依然存在。
     }
     printf("InsertOverflowByShifting complete.\n");
     return true; // 所有粒子都成功插入（虽然可能效率低）
 }
 
 // --- 插入失败处理函数 ---
 inline void RebuildOrInsert(
     ParticleTileType& ptile, 
     std::vector<OverflowParticle>& overflow_particles, // 注意：传入引用
     int numcell,
     double desired_gap_ratio = 0.25, // 用于 Rebuild
     double recycle_threshold = 0.7 // 容量大于所需 1/0.7 ≈ 142% 时才考虑回收
 ) {
     BL_PROFILE("ParticleContainer::RebuildOrInsert");
 
     if (overflow_particles.empty()) {
         return; // 没有溢出粒子需要处理
     }
 
     // 调用检查函数判断是否需要重组
     if (checkRebuildConditions(ptile,overflow_particles)) {
         // printf("Need Decision_Rebuild.\n");
         // --- 执行本地重组 ---
         BL_PROFILE("RebuildOrInsert::Decision_Rebuild");
         RebuildPMAWithinTile(ptile,numcell, overflow_particles, desired_gap_ratio, recycle_threshold);
         // 重组成功后，溢出列表的任务已完成
         overflow_particles.clear();
     } else {
         // --- 尝试通过移位插入 ---
         BL_PROFILE("RebuildOrInsert::Decision_InsertByShifting");
         bool success = InsertOverflowByShifting(ptile,overflow_particles, numcell);
 
         if (success) {
             // 移位插入成功，清空溢出列表
             overflow_particles.clear();
             printf("clear overflow_particles\n");
         } else {
             // 移位插入失败（通常意味着总容量不足）
             // 此时必须强制重组，否则粒子会丢失
             printf("Warning: InsertOverflowByShifting failed (likely out of capacity). Forcing rebuild.\n");
             BL_PROFILE("RebuildOrInsert::Forced_Rebuild");
             RebuildPMAWithinTile(ptile,numcell,overflow_particles, desired_gap_ratio, recycle_threshold);
             // 重组后清空
             overflow_particles.clear();
         }
     }
 }
 
 // 只传 numcell，box 已经在类里，有需要可再加
 inline void applyPendingMoves(int numcell,ParticleTileType& ptile, std::vector<ParticleMove>& m_pending_moves)
 {
    //  const int INVALID_PARTICLE_ID = std::numeric_limits<int>::max();
     // ----------- 1) 删除阶段 -----------
     // for (const auto& mv : m_pending_moves) {
     //     // 在旧槽位打洞
     //     ptile.m_local_index[mv.old_idx] = INVALID_PARTICLE_ID;
     //     ptile.m_bin_lengths[mv.old_bin]--;
     //     ptile.m_num_empty_slots++;
     // }
 
     // 清空上次的溢出粒子 (如果上次没有触发 rebuild)
     // 或者选择不清空，让它们累积直到 rebuild
     // 决定：先不清空，让它们累积。Rebuild 时再处理。
     // m_overflow_particles.clear(); // Option 1: Clear before processing
     bool insertion_failed = false; // 标记本次是否有插入失败
     // ----------- 2) 插入阶段 -----------
     bool need_rebuild = false;
 
     std::vector<OverflowParticle> m_overflow_particles;
 
     for (const auto& mv : m_pending_moves) {
 
         int insert_idx = ptile.findEmptySlotInBin(mv.new_bin);
 
         if (insert_idx != -1) {
             // 直接填坑
             ptile.m_local_index[insert_idx] = mv.pid;
             ptile.m_bin_lengths[mv.new_bin]++;
             ptile.m_num_empty_slots--;
             ptile.m_num_particles++;
             // printf("inserted pid %d to bin %d\n", mv.pid, mv.new_bin);
         } else {
             // 本 bin 已满，后续策略：
             //   a) 局部 shift（可实现 shiftAndInsert）
             //   b) 全局/局部重组
             insertion_failed = true;
                 // 将粒子放入溢出缓冲区
             m_overflow_particles.push_back({mv.pid, mv.new_bin});
             // printf("bin %d is full, need to rebuild ", mv.new_bin);
             // printf("inserted pid %d to overflow buffer\n", mv.pid);
         }
     }
 
     // ----------- 3) 重组阶段 -----------
     // 如果有插入失败，需要考虑是否需要重组
     if (insertion_failed){
         // 先把粒子临时放到溢出列表，或直接 push_back 到一个 append 区
         // printf("insertion failed, need to rebuild\n");
         RebuildOrInsert(ptile,m_overflow_particles,numcell);
     }
 
     // --- 阶段 3: 决定是否触发重组 (Rebuild) ---
     // (这个检查逻辑应该在 applyPendingMoves 函数 *之后* 调用，
     // 因为 rebuild 可能需要访问全局状态或在所有 tiles 处理完毕后进行。
     // 这里只设置一个标志或返回状态。)
 
     // 函数可以返回一个 bool 值指示是否建议 Rebuild
     // bool should_rebuild = checkRebuildConditions(ptile, m_overflow_particles);
     // RebuildOrInsert(ptile,m_overflow_particles,numcell);
 
 
     // 清空缓冲
     m_pending_moves.clear();
 }
 
 inline bool InsertOverflowByShifting_1(ParticleTileType& ptile, 
     const std::vector<OverflowParticle>& overflow_particles, // 只读访问
     int numcell,double empty_slot_threshold_ratio = 0.10
 ) {
     BL_PROFILE("InsertOverflowByShifting");
     // printf("Inserting %d overflow particles by shifting.\n", overflow_particles.size());
 
     // 规则 1: 是否有任何插入操作失败 (即溢出列表非空)?
     bool has_overflow = !overflow_particles.empty();
 
     // 规则 2: 全局空槽数量是否过低?
     int low_water_mark = static_cast<int>(ptile.m_capacity * empty_slot_threshold_ratio);
     bool low_empty_slots = ptile.m_num_empty_slots < low_water_mark;
     if(has_overflow || low_empty_slots) return false;
 
     std::vector<OverflowParticle> insert_particles(overflow_particles.size());
     for (const auto& overflow : overflow_particles) {
         int target_bin = overflow.target_bin+1;
         int insert_idx = ptile.findEmptySlotInBin(target_bin);
         if(insert_idx==-1) return false;
         ptile.m_free_slots[target_bin].pop_back();
         insert_particles.push_back({overflow.pid,insert_idx});
     }
     return true; // 所有粒子都成功插入（虽然可能效率低）
 }
 
 // inline bool InsertOverflowByShifting_1(ParticleTileType& ptile, 
 //         const std::vector<OverflowParticle>& overflow_particles, // 只读访问
 //         int numcell
 //     ) {
 //         BL_PROFILE("InsertOverflowByShifting");
 //         alignas(64) std::vector<int> xindex(overflow_particles.size(),-1); 
 //         alignas(64) std::vector<int> xcount(numcell,0);
 //         alignas(64) std::vector<int> xoffsets(numcell+1,0);
 //         int np=ptile.m_pid_to_bin_map.size();
 //         for (const auto& overflow : overflow_particles) {
 //             int target_bin = overflow.target_bin;
 //             xcount[target_bin]++;
 //         }
 //         for (int binID = 0; binID < numcell; ++binID) {
 //             xoffsets[binID]+=xcount[binID];
 //         }
 //         int write_ptr=0
 //         for (const auto& overflow : overflow_particles) {
 //             int target_bin = overflow.target_bin;
 //             int pid = overflow.pid;
 //             xindex[target_bin]++
 //         }
 
 
 //         for (const auto& overflow : overflow_particles) {
 //             int target_bin = overflow.target_bin;
 //             int pid = overflow.pid;
 //             int insert_idx = ptile.findEmptySlotInBin(target_bin+1);
     
 //             // 1. 确定插入点和所需移动的起始点
 //             //    我们假设插入到 bin 的逻辑末尾，即 m_bin_offsets[target_bin] + m_bin_lengths[target_bin]
 //             //    但由于 bin 内无空槽，实际物理插入点需要腾出来。
 //             //    需要移动的起始点是当前 bin 的物理结束位置: m_bin_offsets[target_bin + 1]
 //             int shift_start_idx = ptile.m_bin_offsets[target_bin + 1];
     
 //             // 2. 找到最近的空槽用于终止移位
 //             int empty_slot_idx = -1;
 //             for (int i = shift_start_idx; i < ptile.m_capacity; ++i) {
 //                 printf("Checking slot %d ", i);
 //                 if (ptile.m_local_index[i] == INVALID_PARTICLE_ID) {
 //                     empty_slot_idx = i;
 //                     printf(" is empty\n");
 //                     break;
 //                 }
 //                 printf(" is NOT empty\n");
 //             }
     
 //             // 3. 检查是否找到空槽（即总容量是否足够）
 //             if (empty_slot_idx == -1) {
 //                 printf("Error in InsertOverflowByShifting: No empty slot found anywhere after index %d. Capacity %d full?\n",
 //                        shift_start_idx, ptile.m_capacity);
 //                 return false; // 无法完成移位，总容量不足
 //             }
     
     
     
 //             // 4. 执行移位 (将 [shift_start_idx, empty_slot_idx - 1] 的内容移动到
 //             //             [shift_start_idx + 1, empty_slot_idx])
 //             // 使用 copy_backward 更安全
 //             if (empty_slot_idx > shift_start_idx) { // 只有当空槽不在移位起点时才需要移动
 //                 printf("Shifting %d particles from %d to %d\n", 
 //                     empty_slot_idx - shift_start_idx, shift_start_idx, empty_slot_idx);
 //                 std::copy_backward(ptile.m_local_index.begin() + shift_start_idx,
 //                                 ptile.m_local_index.begin() + empty_slot_idx, // 源范围是 [first, last)
 //                                 ptile.m_local_index.begin() + empty_slot_idx + 1); // 目标范围的 *之后* 一个位置
 //             }
     
 //             // 5. 在腾出的位置插入粒子 (移位后的 shift_start_idx 位置是空的)
 //             ptile.m_local_index[shift_start_idx] = pid;
     
 //             // 6. 更新计数器
 //             ptile.m_bin_lengths[target_bin]++;
 //             ptile.m_num_empty_slots--; // 全局空槽少了一个
     
 //             // 7. 更新后续 bin 的 offsets（非常重要！）
 //             // for (int b = target_bin + 1; b < numcell; ++b) {
 //             //     ptile.m_bin_offsets[b]++;
 //             //     printf("Updating offset for bin %d to %d\n", b, ptile.m_bin_offsets[b]);
 //             // }
 //             // 7. 只更新真正被移动到的那些 bin 的 offset
 //             for (int b = target_bin + 1; b < numcell && ptile.m_bin_offsets[b] <= empty_slot_idx; ++b) {
 //                 ++ptile.m_bin_offsets[b];
 //                 printf("Updating offset for bin %d to %d\n", b, ptile.m_bin_offsets[b]);
 //             }
 //             // 注意：这种顺序处理方式，如果下一个溢出粒子也要插入到同一个 target_bin，
 //             // 或者插入到 target_bin+1，它的 m_bin_offsets 已经被更新了，逻辑应该依然正确。
 //             // 但效率问题依然存在。
 //         }
 //         printf("InsertOverflowByShifting complete.\n");
 //         return true; // 所有粒子都成功插入（虽然可能效率低）
 //     }
 
 // 只传 numcell，box 已经在类里，有需要可再加
 // static void applyPendingMoves_1(int numcell,ParticleTileType& ptile, 
 
 inline void applyPendingMoves_1(int numcell,ParticleTileType& ptile, 
     std::vector<ParticleMove>& m_pending_moves)
 {
    //  const int INVALID_PARTICLE_ID = std::numeric_limits<int>::max();
 
     bool insertion_failed = false; // 标记本次是否有插入失败
     // ----------- 1) 插入阶段 -----------
     bool need_rebuild = false;
     // std::vector<OverflowParticle> m_overflow_particles;
     for (auto& mv : m_pending_moves) {
         int insert_idx = ptile.findEmptySlotInBin(mv.new_bin);
 
         if (insert_idx != -1) {
             // 直接填坑
             ptile.m_local_index[insert_idx] = mv.pid;
             ptile.m_free_slots[mv.new_bin].pop_back();
             ptile.m_bin_lengths[mv.new_bin]++;
             ptile.m_num_empty_slots--;
             ptile.m_num_particles++;
         } else {
             insertion_failed = true;
             // m_overflow_particles.push_back({mv.pid, mv.new_bin});
         }
     }
     // ----------- 2) 重组阶段 -----------
     // 如果有插入失败，需要考虑是否需要重组
     if (insertion_failed){
         // RebuildPMAWithinTile_1(ptile,numcell,overflow_particles);
 
         ////////////////////////////////////////////////////////
         std::vector<int> final_bin_counts(numcell, 0);
         auto& pid_to_bin_map = ptile.m_pid_to_bin_map;
         int np=pid_to_bin_map.size();
         for(int ip=0;ip<np;ip++){
             final_bin_counts[pid_to_bin_map[ip]]++;
         }
         int gap_ratio=0.25;
         ptile.m_capacity = np*(1+gap_ratio)+numcell*1.5;
         int current_offset = 0;
         ptile.m_bin_offsets[0] = 0;
         for (int binID = 0; binID < numcell; ++binID) {
             int np_in_bin = final_bin_counts[binID];
             ptile.m_bin_lengths[binID] = np_in_bin; // 存储最终的有效粒子数
             int gap = (np_in_bin > 0) ? static_cast<int>(std::round(np_in_bin * gap_ratio)) : 1; // 至少留一个空槽
             int block_size = np_in_bin + gap;
             // ptile.m_num_empty_slots+=gap;
             current_offset += block_size;
             for(int i = current_offset-1; i >= current_offset-gap; --i){
                 ptile.m_free_slots[binID].push_back(i);
             }
             if(current_offset>ptile.m_capacity){
                 amrex::Abort("ERROR: current_offset > m_capacity!!!");
             }
             ptile.m_bin_offsets[binID + 1] = current_offset;
         }
         if(ptile.m_bin_offsets[numcell]>=ptile.m_capacity){
             printf("ptile.m_bin_offsets[numcell] %d m_capacity %d \n"
                 ,ptile.m_bin_offsets[numcell],ptile.m_capacity);
             amrex::Abort("ERROR: m_bin_offsets[numcell] >= m_capacity!!!");
         }
         ptile.m_capacity=ptile.m_bin_offsets[numcell];
         ptile.m_num_particles=np;
         ptile.m_num_empty_slots = ptile.m_capacity - ptile.m_num_particles;
         ptile.m_local_index.assign(ptile.m_capacity, INVALID_PARTICLE_ID);
         // 初始化为每个 bin 的起始位置
         std::vector<int> next_write_slot = ptile.m_bin_offsets; 
         for(int ip=0;ip<np;ip++){
             int bin_id =pid_to_bin_map[ip];
             int insert_idx = next_write_slot[bin_id];
             ptile.m_local_index[insert_idx] = ip;
             next_write_slot[bin_id]++;
         }
         // ptile.m_local_index.resize(ptile.m_capacity, INVALID_PARTICLE_ID);
         // ptile.m_num_particles = np;
         ptile.m_was_rebuilt_this_step = true;
     }
 
     //////////////////////////////////////////////////////
     // m_overflow_particles.clear();
     m_pending_moves.clear();
 }
 
 inline void applyPendingMoves_2 (int numcell,ParticleTileType& ptile, 
     std::vector<ParticleMove>& m_pending_moves)
 {
    //  const int INVALID_PARTICLE_ID = std::numeric_limits<int>::max();
     ptile.m_was_rebuilt_this_step = false;
     bool insertion_failed = false; // 标记本次是否有插入失败
     // ----------- 1) 插入阶段 -----------
     bool need_rebuild = false;
     // std::vector<OverflowParticle> m_overflow_particles;
     for (auto& mv : m_pending_moves) {
         int insert_idx = ptile.findEmptySlotInBin(mv.new_bin);
 
         if (insert_idx != -1) {
             // 直接填坑、退槽、长度增加（map已经完成更新）
             ptile.m_local_index[insert_idx] = mv.pid;
             ptile.m_free_slots[mv.new_bin].pop_back();
             ptile.m_bin_lengths[mv.new_bin]++;
             // printf("inserted pid %d to bin %d at %d\n", mv.pid, mv.new_bin,insert_idx);
             // ptile.m_num_empty_slots--;
             // ptile.m_num_particles++;
         } else {
             insertion_failed = true;
             // m_overflow_particles.push_back({mv.pid, mv.new_bin});
             printf("bin %d is full, %d cannot insert\n ", mv.new_bin,mv.pid);
             break;
             // printf("inserted pid %d to overflow buffer\n", mv.pid);
         }
     }
     // ----------- 2) 重组阶段 -----------
     // 如果有插入失败，需要考虑是否需要重组
     // if (1){
     if (insertion_failed){
         // RebuildPMAWithinTile_1(ptile,numcell,overflow_particles);
         // amrex::Abort("ERRRRRRR!!!!!");
 
         ////////////////////////////////////////////////////////
         ptile.m_was_rebuilt_this_step = true;
         std::vector<int> final_bin_counts(numcell, 0);
         float gap_ratio=WarpX::GetInstance().m_gap_ratio;
         auto& pid_to_bin_map = ptile.m_pid_to_bin_map;
         // int np=pid_to_bin_map.size();
         int np = ptile.m_num_particles;
 
         for(int ip=0;ip<np;ip++){
             final_bin_counts[pid_to_bin_map[ip]]++;
         }
         
         // ptile.m_capacity = np*(1+gap_ratio)+numcell*1.5;
         ptile.m_capacity = static_cast<int>(std::ceil(static_cast<double>(np) * (1.0 + gap_ratio)) + 2*numcell);
 
 
         int current_offset = 0;
         ptile.m_bin_offsets[0] = 0;
         for (int binID = 0; binID < numcell; ++binID) {
             int np_in_bin = final_bin_counts[binID];
             ptile.m_bin_lengths[binID] = np_in_bin; // 存储最终的有效粒子数
             int gap = (np_in_bin > 0) ? static_cast<int>(std::ceil(np_in_bin * gap_ratio)) : 1; // 至少留一个空槽
             int block_size = np_in_bin + gap;
             // ptile.m_num_empty_slots+=gap;
             current_offset += block_size;
             ptile.m_free_slots[binID].clear();
             for(int i = current_offset-1; i >= current_offset-gap; --i){
                 ptile.m_free_slots[binID].push_back(i);
             }
             if(current_offset>ptile.m_capacity){
                 amrex::Abort("ERROR: current_offset > m_capacity!!!");
             }
             ptile.m_bin_offsets[binID + 1] = current_offset;
         }
         if(ptile.m_bin_offsets[numcell]>=ptile.m_capacity){
             printf("ptile.m_bin_offsets[numcell] %d m_capacity %d \n"
                 ,ptile.m_bin_offsets[numcell],ptile.m_capacity);
             amrex::Abort("ERROR: m_bin_offsets[numcell] >= m_capacity!!!");
         }
         ptile.m_capacity=ptile.m_bin_offsets[numcell];
         // ptile.m_num_particles=np;
         ptile.m_num_empty_slots = ptile.m_capacity - ptile.m_num_particles;
         ptile.m_local_index.assign(ptile.m_capacity, INVALID_PARTICLE_ID);
         // 初始化为每个 bin 的起始位置
         std::vector<int> next_write_slot = ptile.m_bin_offsets; 
         for(int ip=0;ip<np;ip++){
             int bin_id =pid_to_bin_map[ip];
             int insert_idx = next_write_slot[bin_id];
             ptile.m_local_index[insert_idx] = ip;
             next_write_slot[bin_id]++;
         }
         // ptile.m_local_index.resize(ptile.m_capacity, INVALID_PARTICLE_ID);
         // ptile.m_num_particles = np;
         ptile.m_was_rebuilt_this_step = true;
         // printf("rebuild!!!!!!!!!\n");
     }
 
     //////////////////////////////////////////////////////
     // m_overflow_particles.clear();
     m_pending_moves.clear();
 }
 
inline void applyPendingMoves_3 (int numcell,ParticleTileType& ptile, 
    std::unordered_map<int, std::vector<int>>& m_pending_moves)
{
    // const int INVALID_PARTICLE_ID = std::numeric_limits<int>::max();
    // ptile.m_was_rebuilt_this_step = false;
    // bool insertion_failed = false; // 标记本次是否有插入失败
    // // ----------- 1) 插入阶段 -----------
    // bool need_rebuild = false;
    // // std::vector<OverflowParticle> m_overflow_particles;
    // for (auto& mv : m_pending_moves) {
    //     int insert_idx = ptile.findEmptySlotInBin(mv.new_bin);

    //     if (insert_idx != -1) {
    //         // 直接填坑、退槽、长度增加（map已经完成更新）
    //         ptile.m_local_index[insert_idx] = mv.pid;
    //         ptile.m_free_slots[mv.new_bin].pop_back();
    //         ptile.m_bin_lengths[mv.new_bin]++;
    //         // printf("inserted pid %d to bin %d at %d\n", mv.pid, mv.new_bin,insert_idx);
    //         // ptile.m_num_empty_slots--;
    //         // ptile.m_num_particles++;
    //     } else {
    //         insertion_failed = true;
    //         // m_overflow_particles.push_back({mv.pid, mv.new_bin});
    //         printf("bin %d is full, %d cannot insert\n ", mv.new_bin,mv.pid);
    //         break;
    //         // printf("inserted pid %d to overflow buffer\n", mv.pid);
    //     }
    // }
    // // ----------- 2) 重组阶段 -----------
    // // 如果有插入失败，需要考虑是否需要重组
    // // if (1){
    // if (insertion_failed){
    //     // RebuildPMAWithinTile_1(ptile,numcell,overflow_particles);
    //     // amrex::Abort("ERRRRRRR!!!!!");

    //     ////////////////////////////////////////////////////////
    //     ptile.m_was_rebuilt_this_step = true;
    //     std::vector<int> final_bin_counts(numcell, 0);
    //     float gap_ratio=WarpX::GetInstance().m_gap_ratio;
    //     auto& pid_to_bin_map = ptile.m_pid_to_bin_map;
    //     // int np=pid_to_bin_map.size();
    //     int np = ptile.m_num_particles;

    //     for(int ip=0;ip<np;ip++){
    //         final_bin_counts[pid_to_bin_map[ip]]++;
    //     }
        
    //     // ptile.m_capacity = np*(1+gap_ratio)+numcell*1.5;
    //     ptile.m_capacity = static_cast<int>(std::ceil(static_cast<double>(np) * (1.0 + gap_ratio)) + 2*numcell);


    //     int current_offset = 0;
    //     ptile.m_bin_offsets[0] = 0;
    //     for (int binID = 0; binID < numcell; ++binID) {
    //         int np_in_bin = final_bin_counts[binID];
    //         ptile.m_bin_lengths[binID] = np_in_bin; // 存储最终的有效粒子数
    //         int gap = (np_in_bin > 0) ? static_cast<int>(std::ceil(np_in_bin * gap_ratio)) : 1; // 至少留一个空槽
    //         int block_size = np_in_bin + gap;
    //         // ptile.m_num_empty_slots+=gap;
    //         current_offset += block_size;
    //         ptile.m_free_slots[binID].clear();
    //         for(int i = current_offset-1; i >= current_offset-gap; --i){
    //             ptile.m_free_slots[binID].push_back(i);
    //         }
    //         if(current_offset>ptile.m_capacity){
    //             amrex::Abort("ERROR: current_offset > m_capacity!!!");
    //         }
    //         ptile.m_bin_offsets[binID + 1] = current_offset;
    //     }
    //     if(ptile.m_bin_offsets[numcell]>=ptile.m_capacity){
    //         printf("ptile.m_bin_offsets[numcell] %d m_capacity %d \n"
    //             ,ptile.m_bin_offsets[numcell],ptile.m_capacity);
    //         amrex::Abort("ERROR: m_bin_offsets[numcell] >= m_capacity!!!");
    //     }
    //     ptile.m_capacity=ptile.m_bin_offsets[numcell];
    //     // ptile.m_num_particles=np;
    //     ptile.m_num_empty_slots = ptile.m_capacity - ptile.m_num_particles;
    //     ptile.m_local_index.assign(ptile.m_capacity, INVALID_PARTICLE_ID);
    //     // 初始化为每个 bin 的起始位置
    //     std::vector<int> next_write_slot = ptile.m_bin_offsets; 
    //     for(int ip=0;ip<np;ip++){
    //         int bin_id =pid_to_bin_map[ip];
    //         int insert_idx = next_write_slot[bin_id];
    //         ptile.m_local_index[insert_idx] = ip;
    //         next_write_slot[bin_id]++;
    //     }
    //     // ptile.m_local_index.resize(ptile.m_capacity, INVALID_PARTICLE_ID);
    //     // ptile.m_num_particles = np;
    //     ptile.m_was_rebuilt_this_step = true;
    //     // printf("rebuild!!!!!!!!!\n");
    // }

    // //////////////////////////////////////////////////////
    // // m_overflow_particles.clear();
    // m_pending_moves.clear();
}

 inline void applyPendingMoves_special(int numcell,ParticleTileType& ptile, 
     std::vector<ParticleMove>& m_pending_moves)
 {
    //  const int INVALID_PARTICLE_ID = std::numeric_limits<int>::max();
 
     bool insertion_failed = false; // 标记本次是否有插入失败
     // ----------- 1) 插入阶段 -----------
     bool need_rebuild = false;
     // std::vector<OverflowParticle> m_overflow_particles;
     for (auto& mv : m_pending_moves) {
         int insert_idx = ptile.findEmptySlotInBin(mv.new_bin);
 
         if (insert_idx != -1) {
             // 直接填坑
             ptile.m_local_index[insert_idx] = mv.pid;
             ptile.m_free_slots[mv.new_bin].pop_back();
             ptile.m_bin_lengths[mv.new_bin]++;
             ptile.m_num_empty_slots--;
             ptile.m_num_particles++;
         } else {
             insertion_failed = true;
             // m_overflow_particles.push_back({mv.pid, mv.new_bin});
         }
     }
     // ----------- 2) 重组阶段 -----------
     // 如果有插入失败，需要考虑是否需要重组
     if (insertion_failed){
         // RebuildPMAWithinTile_1(ptile,numcell,overflow_particles);
 
         ////////////////////////////////////////////////////////
         std::vector<int> final_bin_counts(numcell, 0);
         auto& pid_to_bin_map = ptile.m_pid_to_bin_map;
         int np=pid_to_bin_map.size();
         for(int ip=0;ip<np;ip++){
             final_bin_counts[pid_to_bin_map[ip]]++;
         }
         int gap_ratio=0.5;
         ptile.m_capacity = np*(1+gap_ratio)+numcell*1.5;
         int current_offset = 0;
         ptile.m_bin_offsets[0] = 0;
         for (int binID = 0; binID < numcell; ++binID) {
             int np_in_bin = final_bin_counts[binID];
             ptile.m_bin_lengths[binID] = np_in_bin; // 存储最终的有效粒子数
             int gap = (np_in_bin > 0) ? static_cast<int>(std::round(np_in_bin * gap_ratio)) : 1; // 至少留一个空槽
             int block_size = np_in_bin + gap;
             // ptile.m_num_empty_slots+=gap;
             current_offset += block_size;
             for(int i = current_offset-1; i >= current_offset-gap; --i){
                 ptile.m_free_slots[binID].push_back(i);
             }
             if(current_offset>ptile.m_capacity){
                 amrex::Abort("ERROR: current_offset > m_capacity!!!");
             }
             ptile.m_bin_offsets[binID + 1] = current_offset;
         }
         if(ptile.m_bin_offsets[numcell]>=ptile.m_capacity){
             printf("ptile.m_bin_offsets[numcell] %d m_capacity %d \n"
                 ,ptile.m_bin_offsets[numcell],ptile.m_capacity);
             amrex::Abort("ERROR: m_bin_offsets[numcell] >= m_capacity!!!");
         }
         ptile.m_capacity=ptile.m_bin_offsets[numcell];
         ptile.m_num_particles=np;
         ptile.m_num_empty_slots = ptile.m_capacity - ptile.m_num_particles;
         ptile.m_local_index.assign(ptile.m_capacity, INVALID_PARTICLE_ID);
         // 初始化为每个 bin 的起始位置
         std::vector<int> next_write_slot = ptile.m_bin_offsets; 
         for(int ip=0;ip<np;ip++){
             int bin_id =pid_to_bin_map[ip];
             int insert_idx = next_write_slot[bin_id];
             ptile.m_local_index[insert_idx] = ip;
             next_write_slot[bin_id]++;
         }
         // ptile.m_local_index.resize(ptile.m_capacity, INVALID_PARTICLE_ID);
         // ptile.m_num_particles = np;
         ptile.m_was_rebuilt_this_step = true;
     }
 
     //////////////////////////////////////////////////////
     // m_overflow_particles.clear();
     m_pending_moves.clear();
 }
 
 inline void applyPendingMoves_nogpma(int numcell,ParticleTileType& ptile, 
     std::vector<long>& newbin, long np)
 {
     // RebuildPMAWithinTile_1(ptile,numcell,overflow_particles);
 
     ////////////////////////////////////////////////////////
     std::vector<int> final_bin_counts(numcell, 0);
     // auto& pid_to_bin_map = ptile.m_pid_to_bin_map;
     // int np=pid_to_bin_map.size();
     for(int ip=0;ip<np;ip++){
         final_bin_counts[newbin[ip]]++;
     }
     // for(int ip=0;ip<np;ip++){
     //     final_bin_counts[pid_to_bin_map[ip]]++;
     // }
     // ptile.m_capacity = np*1.25+numcell*1.5;
     int current_offset = 0;
     ptile.m_bin_offsets[0] = 0;
     ptile.m_bin_offsets.resize(numcell+1);
     for (int binID = 0; binID < numcell; ++binID) {
         int np_in_bin = final_bin_counts[binID];
         ptile.m_bin_lengths[binID] = np_in_bin; // 存储最终的有效粒子数
         int block_size = np_in_bin;
         // ptile.m_num_empty_slots+=gap;
         current_offset += block_size;
         ptile.m_bin_offsets[binID + 1] = current_offset;
     }
     // ptile.m_local_index.reserve(np);
     // 初始化为每个 bin 的起始位置
     std::vector<int> next_write_slot = ptile.m_bin_offsets; 
     for(int ip=0;ip<np;ip++){
         int bin_id =newbin[ip];
         int insert_idx = next_write_slot[bin_id];
         ptile.m_local_index[insert_idx] = ip;
         next_write_slot[bin_id]++;
     }
     // ptile.m_local_index.resize(ptile.m_capacity, INVALID_PARTICLE_ID);
     // ptile.m_num_particles = np;
     // ptile.m_was_rebuilt_this_step = true;
     
 }
 
 template <int depos_order>
 void doDepositionShapeN_3d (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Real q,
                          ParticleTileType& ptile, const amrex::Box& box,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     using namespace amrex::literals;
     WARPX_PROFILE_VAR_NS("sorttime", bl_sort);
     
 
 
     // Whether ion_lev is a null pointer (do_ionization=0) or a real pointer
     // (do_ionization=1)
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z;
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
     amrex::IntVect const jx_type = jx_fab.box().type();
     amrex::IntVect const jy_type = jy_fab.box().type();
     amrex::IntVect const jz_type = jz_fab.box().type();
 
     std::vector<amrex::Real> wqx(np_to_deposit,0.0_rt), wqy(np_to_deposit,0.0_rt), wqz(np_to_deposit,0.0_rt);
     std::vector<int> j_jx(np_to_deposit,0), j_jy(np_to_deposit,0), j_jz(np_to_deposit,0);
     std::vector<int> k_jx(np_to_deposit,0), k_jy(np_to_deposit,0), k_jz(np_to_deposit,0);
     std::vector<int> l_jx(np_to_deposit,0), l_jy(np_to_deposit,0), l_jz(np_to_deposit,0);
     std::vector<std::vector<amrex::Real>> sx_jx(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     std::vector<std::vector<amrex::Real>> sx_jy(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     std::vector<std::vector<amrex::Real>> sx_jz(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     std::vector<std::vector<amrex::Real>> sy_jx(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     std::vector<std::vector<amrex::Real>> sy_jy(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     std::vector<std::vector<amrex::Real>> sy_jz(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     std::vector<std::vector<amrex::Real>> sz_jx(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     std::vector<std::vector<amrex::Real>> sz_jy(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     std::vector<std::vector<amrex::Real>> sz_jz(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
 
 
     // const long numcell = jx_fab.box().numPts();
     // ParticleTileType& ptile = ParticlesAt(0, pti);  // <-- 正确获取粒子tile
     auto& local_index = ptile.m_local_index;
     auto& bin_offsets = ptile.m_bin_offsets;
     const long numcell = ptile.m_bin_offsets.size()-1;
     // std::cout << ptile.idd << "deposit particle m_local_index shape: " << local_index.size() << std::endl;
     // std::cout << ptile.idd << "deposit particle m_bin_offsets shape: " << bin_offsets.size() << std::endl;
     int reserve_size=np_to_deposit/10;
     std::vector<std::vector<int>> newBins(np_to_deposit);
     for (int i = 0; i < numcell; ++i) {
         newBins[i].reserve(reserve_size);
     }
     
     // 存储所有发生bin变化的粒子信息
     std::vector<ParticleMove> m_pending_moves;
 
         
     // int bx = box.smallEnd(0), by = box.smallEnd(1), bz = box.smallEnd(2);
     int bx = 2, by = 2, bz = 2;
     // int nx = box.bigEnd(0) + 1;
     // int ny = box.bigEnd(1) + 1;
     amrex::IntVect box_shape = box.length();
     // amrex::Print() << "Box shape: " << box_shape << std::endl;
     int nx = box_shape[0];
     int ny = box_shape[1];
     int nxny = nx*ny;
     // int numcell = nx*ny*nz;
     // const int binend = bin_offsets[numcell-1];
     // int removeip=0;    
     auto& bin_length = ptile.m_bin_lengths;
     // printf("numcell %d\n", numcell);
 
     // for (int old_bin = 1; old_bin <= numcell; ++old_bin) {
     //     if (bin_length[old_bin-1] == 0) continue;
     //     int start = bin_offsets[old_bin-1];
     //     // int end = start+ bin_length[old_bin-1];
     //     int end = bin_offsets[old_bin];
     //     printf("old_bin %d start %d end %d\n", old_bin-1, start, end);
 
     //     // int idx = start;
     //     for (int idx = start; idx < end; ++idx) {
     //     // while(idx < end){
     //         int ip = local_index[idx];
     //         if(ip==INVALID_PARTICLE_ID) continue;
     //         printf("Before Particle %u in bin %d at index %d\n", ip, old_bin-1, idx);
     //         // idx++;
     //     }
     // }
     // amrex::Abort("Before deposit");
     // for(int ip=0;ip<np_to_deposit;ip++){
     // // for(int ip=ptile.m_num_particles;ip<np_to_deposit;ip++){
     //     amrex::ParticleReal xp, yp, zp;
     //     GetPosition(ip, xp, yp, zp);
 
     //     // --- Get particle quantities
     //     const amrex::Real gaminv = 1.0_rt/std::sqrt(1.0_rt + uxp[ip]*uxp[ip]*clightsq
     //                                                 + uyp[ip]*uyp[ip]*clightsq
     //                                                 + uzp[ip]*uzp[ip]*clightsq);
     //     const amrex::Real vx  = uxp[ip]*gaminv;
     //     const amrex::Real vy  = uyp[ip]*gaminv;
     //     const amrex::Real vz  = uzp[ip]*gaminv;
 
     //     amrex::Real wq  = q*wp[ip];
     //     if (do_ionization){
     //         wq *= ion_lev[ip];
     //     }
 
     //     constexpr int NODE = amrex::IndexType::NODE;
     //     constexpr int CELL = amrex::IndexType::CELL;
 
     //     // wqx, wqy wqz are particle current in each direction
     //     wqx[ip] = wq*invvol*vx;
     //     wqy[ip] = wq*invvol*vy;
     //     wqz[ip] = wq*invvol*vz;
 
     //     // --- Compute shape factors
     //     Compute_shape_factor< depos_order > const compute_shape_factor;
 
     //     // const auto j = static_cast<int>(xmid);
     //     // x direction
     //     // Get particle position after 1/2 push back in position
     //     // Keep these double to avoid bug in single precision
 
     //     const double xmid = ((xp - xyzmin.x) + relative_time*vx)*dinv.x;
 
     //     double sx_node[depos_order + 1] = {0.};
     //     double sx_cell[depos_order + 1] = {0.};
     //     int j_node = 0;
     //     int j_cell = 0;
     //     if (jx_type[0] == NODE || jy_type[0] == NODE || jz_type[0] == NODE) {
     //         j_node = compute_shape_factor(sx_node, xmid);
     //     }
     //     if (jx_type[0] == CELL || jy_type[0] == CELL || jz_type[0] == CELL) {
     //         j_cell = compute_shape_factor(sx_cell, xmid - 0.5);
     //     }
 
     //     // amrex::Real sx_jx[depos_order + 1] = {0._rt};
     //     // amrex::Real sx_jy[depos_order + 1] = {0._rt};
     //     // amrex::Real sx_jz[depos_order + 1] = {0._rt};
     //     for (int ix=0; ix<=depos_order; ix++)
     //     {
     //         sx_jx[ip][ix] = ((jx_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
     //         sx_jy[ip][ix] = ((jy_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
     //         sx_jz[ip][ix] = ((jz_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
     //     }
 
     //     // int const j_jx = ((jx_type[0] == NODE) ? j_node : j_cell);
     //     j_jx[ip] = ((jx_type[0] == NODE) ? j_node : j_cell);
     //     j_jy[ip] = ((jy_type[0] == NODE) ? j_node : j_cell);
     //     j_jz[ip] = ((jz_type[0] == NODE) ? j_node : j_cell);
 
     //     // y direction
     //     // Keep these double to avoid bug in single precision
     //     const double ymid = ((yp - xyzmin.y) + relative_time*vy)*dinv.y;
     //     double sy_node[depos_order + 1] = {0.};
     //     double sy_cell[depos_order + 1] = {0.};
     //     int k_node = 0;
     //     int k_cell = 0;
     //     if (jx_type[1] == NODE || jy_type[1] == NODE || jz_type[1] == NODE) {
     //         k_node = compute_shape_factor(sy_node, ymid);
     //     }
     //     if (jx_type[1] == CELL || jy_type[1] == CELL || jz_type[1] == CELL) {
     //         k_cell = compute_shape_factor(sy_cell, ymid - 0.5);
     //     }
     //     // amrex::Real sy_jx[depos_order + 1] = {0._rt};
     //     // amrex::Real sy_jy[depos_order + 1] = {0._rt};
     //     // amrex::Real sy_jz[depos_order + 1] = {0._rt};
     //     for (int iy=0; iy<=depos_order; iy++)
     //     {
     //         sy_jx[ip][iy] = ((jx_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
     //         sy_jy[ip][iy] = ((jy_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
     //         sy_jz[ip][iy] = ((jz_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
     //     }
     //     k_jx[ip] = ((jx_type[1] == NODE) ? k_node : k_cell);
     //     k_jy[ip] = ((jy_type[1] == NODE) ? k_node : k_cell);
     //     k_jz[ip] = ((jz_type[1] == NODE) ? k_node : k_cell);
 
     //     // z direction
     //     // Keep these double to avoid bug in single precision
     //     constexpr int zdir = WARPX_ZINDEX;
     //     const double zmid = ((zp - xyzmin.z) + relative_time*vz)*dinv.z;
     //     double sz_node[depos_order + 1] = {0.};
     //     double sz_cell[depos_order + 1] = {0.};
     //     int l_node = 0;
     //     int l_cell = 0;
     //     if (jx_type[zdir] == NODE || jy_type[zdir] == NODE || jz_type[zdir] == NODE) {
     //         l_node = compute_shape_factor(sz_node, zmid);
     //     }
     //     if (jx_type[zdir] == CELL || jy_type[zdir] == CELL || jz_type[zdir] == CELL) {
     //         l_cell = compute_shape_factor(sz_cell, zmid - 0.5);
     //     }
     //     // amrex::Real sz_jx[depos_order + 1] = {0._rt};
     //     // amrex::Real sz_jy[depos_order + 1] = {0._rt};
     //     // amrex::Real sz_jz[depos_order + 1] = {0._rt};
     //     for (int iz=0; iz<=depos_order; iz++)
     //     {
     //         sz_jx[ip][iz] = ((jx_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
     //         sz_jy[ip][iz] = ((jy_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
     //         sz_jz[ip][iz] = ((jz_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
     //     }
     //     l_jx[ip] = ((jx_type[zdir] == NODE) ? l_node : l_cell);
     //     l_jy[ip] = ((jy_type[zdir] == NODE) ? l_node : l_cell);
     //     l_jz[ip] = ((jz_type[zdir] == NODE) ? l_node : l_cell);
 
     //     int new_bin = (j_jx[ip]-2 ) + (k_jx[ip]-2 ) * nx + (l_jx[ip]-2 ) * nxny;
 
     //     m_pending_moves.push_back({np_to_deposit+ip, new_bin});
     //     printf("Adding new particle %d to bin %d\n", np_to_deposit+ip, new_bin);
         
     // }
     
     for (int old_bin = 1; old_bin <= numcell; ++old_bin) {
         if (bin_length[old_bin-1] == 0) continue;
         int start = bin_offsets[old_bin-1];
         int end = bin_offsets[old_bin];
         // int end = start+ bin_length[old_bin-1];
 
         // int idx = start;
         for (int idx = start; idx < end; ++idx) {
         // while(idx < end){
             int ip = local_index[idx];
             if(ip==INVALID_PARTICLE_ID){
                 continue;
             } else if(ip> np_to_deposit){
                 ptile.m_local_index[idx] = INVALID_PARTICLE_ID;
                 ptile.m_bin_lengths[old_bin-1]--;
                 ptile.m_num_empty_slots++;
                 ptile.m_num_particles--;
                 printf("removing particle %d\n", ip);
             } else {
                 amrex::ParticleReal xp, yp, zp;
                 GetPosition(ip, xp, yp, zp);
 
                 // --- Get particle quantities
                 const amrex::Real gaminv = 1.0_rt/std::sqrt(1.0_rt + uxp[ip]*uxp[ip]*clightsq
                                                             + uyp[ip]*uyp[ip]*clightsq
                                                             + uzp[ip]*uzp[ip]*clightsq);
                 const amrex::Real vx  = uxp[ip]*gaminv;
                 const amrex::Real vy  = uyp[ip]*gaminv;
                 const amrex::Real vz  = uzp[ip]*gaminv;
 
                 amrex::Real wq  = q*wp[ip];
                 if (do_ionization){
                     wq *= ion_lev[ip];
                 }
 
                 constexpr int NODE = amrex::IndexType::NODE;
                 constexpr int CELL = amrex::IndexType::CELL;
 
                 // wqx, wqy wqz are particle current in each direction
                 wqx[ip] = wq*invvol*vx;
                 wqy[ip] = wq*invvol*vy;
                 wqz[ip] = wq*invvol*vz;
 
                 // --- Compute shape factors
                 Compute_shape_factor< depos_order > const compute_shape_factor;
 
                 // const auto j = static_cast<int>(xmid);
                 // x direction
                 // Get particle position after 1/2 push back in position
                 // Keep these double to avoid bug in single precision
 
                 const double xmid = ((xp - xyzmin.x) + relative_time*vx)*dinv.x;
 
                 double sx_node[depos_order + 1] = {0.};
                 double sx_cell[depos_order + 1] = {0.};
                 int j_node = 0;
                 int j_cell = 0;
                 if (jx_type[0] == NODE || jy_type[0] == NODE || jz_type[0] == NODE) {
                     j_node = compute_shape_factor(sx_node, xmid);
                 }
                 if (jx_type[0] == CELL || jy_type[0] == CELL || jz_type[0] == CELL) {
                     j_cell = compute_shape_factor(sx_cell, xmid - 0.5);
                 }
 
                 // amrex::Real sx_jx[depos_order + 1] = {0._rt};
                 // amrex::Real sx_jy[depos_order + 1] = {0._rt};
                 // amrex::Real sx_jz[depos_order + 1] = {0._rt};
                 for (int ix=0; ix<=depos_order; ix++)
                 {
                     sx_jx[ip][ix] = ((jx_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
                     sx_jy[ip][ix] = ((jy_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
                     sx_jz[ip][ix] = ((jz_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
                 }
 
                 // int const j_jx = ((jx_type[0] == NODE) ? j_node : j_cell);
                 j_jx[ip] = ((jx_type[0] == NODE) ? j_node : j_cell);
                 j_jy[ip] = ((jy_type[0] == NODE) ? j_node : j_cell);
                 j_jz[ip] = ((jz_type[0] == NODE) ? j_node : j_cell);
 
                 // y direction
                 // Keep these double to avoid bug in single precision
                 const double ymid = ((yp - xyzmin.y) + relative_time*vy)*dinv.y;
                 double sy_node[depos_order + 1] = {0.};
                 double sy_cell[depos_order + 1] = {0.};
                 int k_node = 0;
                 int k_cell = 0;
                 if (jx_type[1] == NODE || jy_type[1] == NODE || jz_type[1] == NODE) {
                     k_node = compute_shape_factor(sy_node, ymid);
                 }
                 if (jx_type[1] == CELL || jy_type[1] == CELL || jz_type[1] == CELL) {
                     k_cell = compute_shape_factor(sy_cell, ymid - 0.5);
                 }
                 // amrex::Real sy_jx[depos_order + 1] = {0._rt};
                 // amrex::Real sy_jy[depos_order + 1] = {0._rt};
                 // amrex::Real sy_jz[depos_order + 1] = {0._rt};
                 for (int iy=0; iy<=depos_order; iy++)
                 {
                     sy_jx[ip][iy] = ((jx_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
                     sy_jy[ip][iy] = ((jy_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
                     sy_jz[ip][iy] = ((jz_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
                 }
                 k_jx[ip] = ((jx_type[1] == NODE) ? k_node : k_cell);
                 k_jy[ip] = ((jy_type[1] == NODE) ? k_node : k_cell);
                 k_jz[ip] = ((jz_type[1] == NODE) ? k_node : k_cell);
 
                 // z direction
                 // Keep these double to avoid bug in single precision
                 constexpr int zdir = WARPX_ZINDEX;
                 const double zmid = ((zp - xyzmin.z) + relative_time*vz)*dinv.z;
                 double sz_node[depos_order + 1] = {0.};
                 double sz_cell[depos_order + 1] = {0.};
                 int l_node = 0;
                 int l_cell = 0;
                 if (jx_type[zdir] == NODE || jy_type[zdir] == NODE || jz_type[zdir] == NODE) {
                     l_node = compute_shape_factor(sz_node, zmid);
                 }
                 if (jx_type[zdir] == CELL || jy_type[zdir] == CELL || jz_type[zdir] == CELL) {
                     l_cell = compute_shape_factor(sz_cell, zmid - 0.5);
                 }
                 // amrex::Real sz_jx[depos_order + 1] = {0._rt};
                 // amrex::Real sz_jy[depos_order + 1] = {0._rt};
                 // amrex::Real sz_jz[depos_order + 1] = {0._rt};
                 for (int iz=0; iz<=depos_order; iz++)
                 {
                     sz_jx[ip][iz] = ((jx_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
                     sz_jy[ip][iz] = ((jy_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
                     sz_jz[ip][iz] = ((jz_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
                 }
                 l_jx[ip] = ((jx_type[zdir] == NODE) ? l_node : l_cell);
                 l_jy[ip] = ((jy_type[zdir] == NODE) ? l_node : l_cell);
                 l_jz[ip] = ((jz_type[zdir] == NODE) ? l_node : l_cell);
 
                 // Test Sort!
                 // if(j_jx[ip]==3&&k_jx[ip]==3&&l_jx[ip]==3){
                 // // if(j_jx[ip]==3){
                 //     j_jx[ip]-=1;
                 // }
             
                 // printf("j_jx %d, k_jx %d, l_jx %d\n", j_jx, k_jx, l_jx);
                 // printf("j_jy %d, k_jy %d, l_jy %d\n", j_jy, k_jy, l_jy);
                 // printf("j_jz %d, k_jz %d, l_jz %d\n", j_jz, k_jz, l_jz);
                 WARPX_PROFILE_VAR_START(bl_sort);
                 int new_bin = (j_jx[ip]-2 ) + (k_jx[ip]-2 ) * nx + (l_jx[ip]-2 ) * nxny;
                 // printf("new_bin %d\n",new_bin);
                 // printf("j_jx %d, k_jx %d, l_jx %d\n", j_jx[ip], k_jx[ip], l_jx[ip]);
                 // printf("bx %d, by %d, bz %d\n", bx, by, bz);
                 // printf("nx %d, ny %d\n", nx, ny);
                 // if(j_jx[ip]>box.bigEnd(0) || k_jx[ip]>box.bigEnd(1) || l_jx[ip]>box.bigEnd(2)){
                 //     printf("particle id %d, j_jx %d/%d, k_jx %d/%d, l_jx %d/%d\n", ip,j_jx[ip],box.bigEnd(0),
                 //          k_jx[ip],box.bigEnd(1), l_jx[ip],box.bigEnd(2));
                 //     printf("new_bin %d, old_bin %d\n",new_bin,old_bin);
                 // }
             
                 // printf("particle id %d/ idx %d, j_jx %d, k_jx %d, l_jx %d\n", ip,idx, j_jx, k_jx, l_jx);
                 int actual_old_bin = old_bin - 1; 
                 // printf("actual_old_bin %d, new_bin %d \n",actual_old_bin,new_bin);
 
                 if(new_bin != actual_old_bin) {
                     // 粒子改变bin，直接加入临时数组
                     m_pending_moves.push_back({ip,new_bin});
                     // printf("NO 1 change particle id %d, j_jx %d,k_jx %d,l_jx %d, old_bin %d, new_bin %d\n", 
                     //     ip, j_jx[ip]-2,k_jx[ip]-2,l_jx[ip]-2,old_bin - 1, new_bin);
                     // printf("pushing particle id %d, j_jx %d,k_jx %d,l_jx %d from old_bin %d to new_bin %d\n", 
                     //     ip, j_jx[ip]-2,k_jx[ip]-2,l_jx[ip]-2,old_bin - 1, new_bin);
                     ptile.m_local_index[idx] = INVALID_PARTICLE_ID;
                     ptile.m_bin_lengths[actual_old_bin]--;
                     ptile.m_num_empty_slots++;
                     ptile.m_num_particles--;
                 } 
                 WARPX_PROFILE_VAR_STOP(bl_sort);
                 // idx++;
             }
 
         }
     }
     WARPX_PROFILE_VAR_START(bl_sort);
     applyPendingMoves(numcell, ptile, m_pending_moves);
     WARPX_PROFILE_VAR_STOP(bl_sort);
 
 
     // for( long ip = 0; ip < np_to_deposit; ++ip){
     // for(int c=1;c<numcell;++c){
     //     int start = ptile.m_bin_offsets[c-1];
     //     int end   = ptile.m_bin_offsets[c];
     //     // printf("cell %d/%d: start %d: end %d, len: %d\n", c,numcell, start,end,end-start);
     //     if(start == end) continue;
     //     for(int idx=start;idx<end;++idx){
     //         int ip = ptile.m_local_index[idx];
 
     for (int old_bin = 1; old_bin <= numcell; ++old_bin) {
         if (bin_length[old_bin-1] == 0) continue;
         int start = bin_offsets[old_bin-1];
         int end = bin_offsets[old_bin];
         // int end = start+ bin_length[old_bin-1];
 
         // int idx = start;
         // printf("start deposit current\n");
         for (int idx = start; idx < end; ++idx) {
         // while(idx < end){
             int ip = local_index[idx];
             if(ip==INVALID_PARTICLE_ID) 
             {
                 // printf("particle idx %d id %d is invalid\n",idx, ip);
                 continue;
             }
             
             // printf("Calculate particle id %d/%d in bin %d/%d\n", ip,ptile.m_num_particles-1,old_bin-1,numcell);
 
             for (int iz=0; iz<=depos_order; iz++){
                 for (int iy=0; iy<=depos_order; iy++){
                     for (int ix=0; ix<=depos_order; ix++){
                         amrex::Gpu::Atomic::AddNoRet(
                             &jx_arr(lo.x+j_jx[ip]+ix, lo.y+k_jx[ip]+iy, lo.z+l_jx[ip]+iz),
                             sx_jx[ip][ix]*sy_jx[ip][iy]*sz_jx[ip][iz]*wqx[ip]);
                         amrex::Gpu::Atomic::AddNoRet(
                             &jy_arr(lo.x+j_jy[ip]+ix, lo.y+k_jy[ip]+iy, lo.z+l_jy[ip]+iz),
                             sx_jy[ip][ix]*sy_jy[ip][iy]*sz_jy[ip][iz]*wqy[ip]);
                         amrex::Gpu::Atomic::AddNoRet(
                             &jz_arr(lo.x+j_jz[ip]+ix, lo.y+k_jz[ip]+iy, lo.z+l_jz[ip]+iz),
                             sx_jz[ip][ix]*sy_jz[ip][iy]*sz_jz[ip][iz]*wqz[ip]);
                     }
                 }
             }
             // printf("finish calculate particle id %d \n", ip);
             // idx++;
         }
     }
     printf("finish deposit current\n");
     // amrex::Abort("stop");
     
     // );
 }
 
 // AMREX_FORCE_INLINE
 // amrex::IntVect GetCellIndices(const amrex::ParticleReal xp,
 //                                const amrex::ParticleReal yp,
 //                                const amrex::ParticleReal zp,
 //                                const amrex::XDim3& dinv,
 //                                const amrex::XDim3& xyzmin)
 // {
 //     const int j = static_cast<int>((xp - xyzmin.x) * dinv.x);
 //     const int k = static_cast<int>((yp - xyzmin.y) * dinv.y);
 //     const int l = static_cast<int>((zp - xyzmin.z) * dinv.z);
 //     return {j, k, l};
 // }
 // AMREX_FORCE_INLINE
 // void Compute_shape_factor(double* const sx, double xmid) const
 // {
 //     const int i = static_cast<int>(xmid);    
 //     const double xint = xmid - double(i);
 //     sx[0] = double(1.0) - xint;
 //     sx[1] = xint;
 // }
 
 template <int depos_order>
 void doDepositionShapeN_3d_sme_test (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Dim3 hi,
                          amrex::Dim3 len,
                          amrex::Real q,
                          std::vector<long>& test,
                          std::vector<double>& test0,
                          ParticleTileType& ptile, const amrex::Box& box,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     WARPX_PROFILE("[1] USER DEFINE doDepositionShapeN_3d_sme()");
     // uint64_t total_time[3]={0};
     using namespace std::chrono;
     using namespace amrex::literals;
     double total_time=0;
     // auto total_start=high_resolution_clock::now();
     uint64_t precompute=0;
     uint64_t cale_time=0;
     uint64_t sort_time=0;
         uint64_t count_time=0;
         uint64_t presum_time=0;
         uint64_t binlist_time=0;
     uint64_t reduce_time=0;
     uint64_t svetime[3]={0};
     uint64_t branch_time=0;
     WARPX_PROFILE_VAR_NS("doDepositionShapeN_3d_sme:applyPendingMoves", bl_sort);
     
     // Whether ion_lev is a null pointer (do_ionization=0) or a real pointer
     // (do_ionization=1)
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z;
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
     amrex::IntVect const jx_type = jx_fab.box().type();
     amrex::IntVect const jy_type = jy_fab.box().type();
     amrex::IntVect const jz_type = jz_fab.box().type();
     
 
     std::vector<amrex::Real> wqx(np_to_deposit,0.0_rt), wqy(np_to_deposit,0.0_rt), wqz(np_to_deposit,0.0_rt);
     // std::vector<int> j_jx(np_to_deposit,0), j_jy(np_to_deposit,0), j_jz(np_to_deposit,0);
     // std::vector<int> k_jx(np_to_deposit,0), k_jy(np_to_deposit,0), k_jz(np_to_deposit,0);
     // std::vector<int> l_jx(np_to_deposit,0), l_jy(np_to_deposit,0), l_jz(np_to_deposit,0);
     // std::vector<std::vector<amrex::Real>> sx_jx(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sx_jy(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sx_jz(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sy_jx(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sy_jy(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sy_jz(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sz_jx(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sz_jy(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sz_jz(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
 
 
     // const long numcell = jx_fab.box().numPts();
     // ParticleTileType& ptile = ParticlesAt(0, pti);  // <-- 正确获取粒子tile
     auto& local_index = ptile.m_local_index;
     auto& bin_offsets = ptile.m_bin_offsets;
     const long numcell = ptile.m_bin_offsets.size()-1;
     // std::cout << ptile.idd << "deposit particle m_local_index shape: " << local_index.size() << std::endl;
     // std::cout << ptile.idd << "deposit particle m_bin_offsets shape: " << bin_offsets.size() << std::endl;
     int reserve_size=np_to_deposit/10;
     std::vector<std::vector<int>> newBins(np_to_deposit);
     for (int i = 0; i < numcell; ++i) {
         newBins[i].reserve(reserve_size);
     }
     
     // 存储所有发生bin变化的粒子信息
     std::vector<ParticleMove> m_pending_moves;
 
         
     // int bx = box.smallEnd(0), by = box.smallEnd(1), bz = box.smallEnd(2);
     int bx = 2, by = 2, bz = 2;
     // int nx = box.bigEnd(0) + 1;
     // int ny = box.bigEnd(1) + 1;
     amrex::IntVect box_shape = box.length();
     // amrex::Print() << "Box shape: " << box_shape << std::endl;
     int nx = box_shape[0];
     int ny = box_shape[1];
     int nxny = nx*ny;
     // int numcell = nx*ny*nz;
     // const int binend = bin_offsets[numcell-1];
     // int removeip=0;    
     auto& bin_length = ptile.m_bin_lengths;
     // printf("numcell %d\n", numcell);
     // [1] SORT TIME
     // const std::vector<amrex::Real> vx(np_to_deposit,0.0_rt),vy(np_to_deposit,0.0_rt),vz(np_to_deposit,0.0_rt);
     // const std::vector<amrex::Real> gaminv(np_to_deposit,0.0_rt);
     std::vector<double> xmid_v(np_to_deposit,0.0),ymid_v(np_to_deposit,0.0),zmid_v(np_to_deposit,0.0);
     for (int old_bin = 1; old_bin <= numcell; ++old_bin) {
         if (bin_length[old_bin-1] == 0) continue;
         const int start = bin_offsets[old_bin-1];
         const int end   = bin_offsets[old_bin];
         // printf("st %d en %d len %d \n",start,end,bin_length[old_bin-1]);
 
         #pragma omp simd
         for (int idx = start; idx < end; ++idx) {
             const int ip = local_index[idx];
             if (ip == INVALID_PARTICLE_ID) continue;
 
             // 针对“假”粒子（>np_to_deposit）仍保持原逻辑
             if (ip >= np_to_deposit) {
                 ptile.m_local_index[idx] = INVALID_PARTICLE_ID;
                 ptile.m_bin_lengths[old_bin-1]--;
                 ptile.m_num_empty_slots++;
                 ptile.m_num_particles--;
                 continue;
             }
 
             amrex::ParticleReal xp, yp, zp;
             GetPosition(ip, xp, yp, zp);
 
             // --- Get particle quantities
             const amrex::Real gaminv = 1.0_rt/std::sqrt(1.0_rt + uxp[ip]*uxp[ip]*clightsq
                                                         + uyp[ip]*uyp[ip]*clightsq
                                                         + uzp[ip]*uzp[ip]*clightsq);
             const amrex::Real vx = uxp[ip]*gaminv;
             const amrex::Real vy = uyp[ip]*gaminv;
             const amrex::Real vz = uzp[ip]*gaminv;
 
             amrex::Real wq = q*wp[ip];
             if (do_ionization){
                 wq *= ion_lev[ip];
             }
 
             // wqx, wqy wqz are particle current in each direction
             wqx[ip] = wq*invvol*vx;
             wqy[ip] = wq*invvol*vy;
             wqz[ip] = wq*invvol*vz;
 
             // const auto xmid_v = GetCellIndices(xp, yp, zp, dinv, xyzmin);
             xmid_v[ip] = ((xp - xyzmin.x) + relative_time*vx)*dinv.x;
             ymid_v[ip] = ((yp - xyzmin.y) + relative_time*vy)*dinv.y;
             zmid_v[ip] = ((zp - xyzmin.z) + relative_time*vz)*dinv.z;
             // printf("ip %d xmid %f \n",ip,xmid_v[ip]);
 
             // const auto cell = GetCellIndices(xp, yp, zp, dinv, xyzmin);
             int i = static_cast<int>(xmid_v[ip]);
             const int j = static_cast<int>(ymid_v[ip]);
             const int k = static_cast<int>(zmid_v[ip]);
 
             // if(j_jx[ip]==3&&k_jx[ip]==3&&l_jx[ip]==3){
             // if(i==3){
             //     i-=1;
             //     xmid_v[ip]-=1;
             //     // printf("old_bin %d: i %d j %d k %d\n",old_bin-1,i,j,k);
             // }
 
             const int new_bin = (i-bx) + (j-by)*nx + (k-bz)*nxny;
             const int actual_old_bin = old_bin - 1;
 
             if (new_bin != actual_old_bin) {
                 // printf("new_bin %d actual_old_bin %d \n",new_bin,actual_old_bin);
                 // printf("ptile.m_bin_lengths[actual_old_bin] %d\n",ptile.m_bin_lengths[actual_old_bin]);
                 m_pending_moves.push_back({ip, new_bin});
                 ptile.m_local_index[idx] = INVALID_PARTICLE_ID;
                 ptile.m_bin_lengths[actual_old_bin]--;
                 ptile.m_num_empty_slots++;
                 ptile.m_num_particles--;
             }
         }
     }
     // printf("sort!!\n");
     WARPX_PROFILE_VAR_START(bl_sort);
     applyPendingMoves(numcell, ptile, m_pending_moves);
     WARPX_PROFILE_VAR_STOP(bl_sort);
 
     // constexpr int nshapes = depos_order + 1;
     // // constexpr int nshapes = 2;
     // int vl=svcntd();
 
     // const amrex::ParticleReal* mx = GetPosition.m_x;
     // const amrex::ParticleReal* my = GetPosition.m_y;
     // const amrex::ParticleReal* mz = GetPosition.m_z;
 
     auto compute_shape_factor_v2 = [](std::vector<double>* sx, Vec xmid, svbool_t p) {
         const svuint64_t sx_index = svindex_u64(0ULL, 2ULL);
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         svst1_scatter_index(p,&sx[0][0],sx_index,sx0);
         svst1_scatter_index(p,&sx[0][1],sx_index,sx1);
         // sx0.Store(p, sx[0]);
         // sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
     auto compute_shape_factor_v1 = [](double* sx, Vec xmid, svbool_t p) {
         const svuint64_t sx_index = svindex_u64(0, 2);
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // double test[8];
         // xint.Store(p,&test[0]);
         // for(int ii=0;ii<8;ii++){
         //     // printf("ii %d xind %f \n",ii,test[ii]);
         //     sx[ii][0]=1.0-test[ii];
         //     sx[ii][1]=test[ii];
         // }
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         // double sx00[8];
         // double sx01[8];
         // sx0.Store(p,&sx00[0]);
         // sx1.Store(p,&sx01[0]);
         // for(int ii=0;ii<8;ii++){
         //     // printf("ii %d xind %f \n",ii,test[ii]);
         //     sx[ii][0]=sx00[ii];
         //     sx[ii][1]=sx01[ii];
         // }
         svst1_scatter_index(p,&sx[0],sx_index,sx0);
         svst1_scatter_index(p,&sx[1],sx_index,sx1);
         // sx0.Store(p, sx[0]);
         // sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
     constexpr int NODE = amrex::IndexType::NODE;
     constexpr int CELL = amrex::IndexType::CELL;
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
     std::vector<amrex::Real> xrhocells(8*numcell, 0.0);
     std::vector<amrex::Real> yrhocells(8*numcell, 0.0);
     std::vector<amrex::Real> zrhocells(8*numcell, 0.0);
     // one roll x
     uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
     uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
     uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
     // long nx=xjstride;
     long nxy=xkstride;
     long moff[8] = {0, 1, nx, nx+1, nxy, nxy+1, nx+nxy, nx+nxy+1};
     svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
     svbool_t px = svcmpeq_n_u64(svptrue_b64(), rmx_v, 0);
     svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
     svbool_t py = svcmpeq_n_u64(svptrue_b64(), rmy_v, 0);
     svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
     svbool_t pz = svcmpeq_n_u64(svptrue_b64(), rmz_v, 0);
 
     std::vector<amrex::Real> sx_m(np_to_deposit*2, 0.);
     std::vector<amrex::Real> sy_m(np_to_deposit*2, 0.);
     std::vector<amrex::Real> sz_m(np_to_deposit*2, 0.);
 
     // some place dont have particle
     alignas(64) long xoffsets[np_to_deposit]; 
     std::vector<long> xcount(numcell,0);
 
     for (int old_bin = 1; old_bin <= numcell; ++old_bin) {
         if (bin_length[old_bin-1] == 0) continue;
         int start = bin_offsets[old_bin-1];
         int end = bin_offsets[old_bin];
         // int end = start+ bin_length[old_bin-1];
         // int idx = start;
         std::vector<int> j_jx(bin_length[old_bin-1],0), j_jy(bin_length[old_bin-1],0), j_jz(bin_length[old_bin-1],0);
         std::vector<int> k_jx(bin_length[old_bin-1],0), k_jy(bin_length[old_bin-1],0), k_jz(bin_length[old_bin-1],0);
         std::vector<int> l_jx(bin_length[old_bin-1],0), l_jy(bin_length[old_bin-1],0), l_jz(bin_length[old_bin-1],0);
         std::vector<std::vector<amrex::Real>> sx_jx(bin_length[old_bin-1], std::vector<amrex::Real>(depos_order+1, 0.0_rt));
         std::vector<std::vector<amrex::Real>> sx_jy(bin_length[old_bin-1], std::vector<amrex::Real>(depos_order+1, 0.0_rt));
         std::vector<std::vector<amrex::Real>> sx_jz(bin_length[old_bin-1], std::vector<amrex::Real>(depos_order+1, 0.0_rt));
         std::vector<std::vector<amrex::Real>> sy_jx(bin_length[old_bin-1], std::vector<amrex::Real>(depos_order+1, 0.0_rt));
         std::vector<std::vector<amrex::Real>> sy_jy(bin_length[old_bin-1], std::vector<amrex::Real>(depos_order+1, 0.0_rt));
         std::vector<std::vector<amrex::Real>> sy_jz(bin_length[old_bin-1], std::vector<amrex::Real>(depos_order+1, 0.0_rt));
         std::vector<std::vector<amrex::Real>> sz_jx(bin_length[old_bin-1], std::vector<amrex::Real>(depos_order+1, 0.0_rt));
         std::vector<std::vector<amrex::Real>> sz_jy(bin_length[old_bin-1], std::vector<amrex::Real>(depos_order+1, 0.0_rt));
         std::vector<std::vector<amrex::Real>> sz_jz(bin_length[old_bin-1], std::vector<amrex::Real>(depos_order+1, 0.0_rt));
         // printf("bin_length %d\n",bin_length[old_bin-1]);
         int ipp=0;
         for (int idx = start; idx < end; ++idx) {
         // while(idx < end){
             int ip = local_index[idx];
             if (ip == INVALID_PARTICLE_ID) continue;
             // printf("pre compute!!\n");    
             // amrex::ParticleReal xp, yp, zp;
             // GetPosition(idx, xp, yp, zp);
 
             // --- Compute shape factors
             Compute_shape_factor< depos_order > const compute_shape_factor;
 
             // const auto j = static_cast<int>(xmid);
             // x direction
             // Get particle position after 1/2 push back in position
             // Keep these double to avoid bug in single precision
 
             // const double xmid = ((xp - xyzmin.x) + relative_time*vx)*dinv.x;
 
             double sx_node[depos_order + 1] = {0.};
             double sx_cell[depos_order + 1] = {0.};
             int j_node = 0;
             int j_cell = 0;
             if (jx_type[0] == NODE || jy_type[0] == NODE || jz_type[0] == NODE) {
             // printf("ip %d ",ip);
             // printf("xmid %f \n",xmid_v[ip]);
                 j_node=compute_shape_factor(sx_node, xmid_v[ip]);
             }
             if (jx_type[0] == CELL || jy_type[0] == CELL || jz_type[0] == CELL) {
                 j_cell=compute_shape_factor(sx_cell, xmid_v[ip] - 0.5);
             }
 
             // amrex::Real sx_jx[depos_order + 1] = {0._rt};
             // amrex::Real sx_jy[depos_order + 1] = {0._rt};
             // amrex::Real sx_jz[depos_order + 1] = {0._rt};
             for (int ix=0; ix<=depos_order; ix++)
             {
                 sx_jx[ipp][ix] = ((jx_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
                 sx_jy[ipp][ix] = ((jy_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
                 sx_jz[ipp][ix] = ((jz_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
             }
 
             // int const j_jx = ((jx_type[0] == NODE) ? j_node : j_cell);
             j_jx[ipp] = ((jx_type[0] == NODE) ? j_node : j_cell);
             j_jy[ipp] = ((jy_type[0] == NODE) ? j_node : j_cell);
             j_jz[ipp] = ((jz_type[0] == NODE) ? j_node : j_cell);
 
             // y direction
             // Keep these double to avoid bug in single precision
             // const double ymid = ((yp - xyzmin.y) + relative_time*vy)*dinv.y;
             double sy_node[depos_order + 1] = {0.};
             double sy_cell[depos_order + 1] = {0.};
             int k_node = 0;
             int k_cell = 0;
             if (jx_type[1] == NODE || jy_type[1] == NODE || jz_type[1] == NODE) {
                 k_node = compute_shape_factor(sy_node, ymid_v[ip]);
             }
             if (jx_type[1] == CELL || jy_type[1] == CELL || jz_type[1] == CELL) {
                 k_cell = compute_shape_factor(sy_cell, ymid_v[ip] - 0.5);
             }
             // amrex::Real sy_jx[depos_order + 1] = {0._rt};
             // amrex::Real sy_jy[depos_order + 1] = {0._rt};
             // amrex::Real sy_jz[depos_order + 1] = {0._rt};
             for (int iy=0; iy<=depos_order; iy++)
             {
                 sy_jx[ipp][iy] = ((jx_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
                 sy_jy[ipp][iy] = ((jy_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
                 sy_jz[ipp][iy] = ((jz_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
             }
             k_jx[ipp] = ((jx_type[1] == NODE) ? k_node : k_cell);
             k_jy[ipp] = ((jy_type[1] == NODE) ? k_node : k_cell);
             k_jz[ipp] = ((jz_type[1] == NODE) ? k_node : k_cell);
 
             // z direction
             // Keep these double to avoid bug in single precision
             // constexpr int zdir = WARPX_ZINDEX;
             // const double zmid = ((zp - xyzmin.z) + relative_time*vz)*dinv.z;
             double sz_node[depos_order + 1] = {0.};
             double sz_cell[depos_order + 1] = {0.};
             int l_node = 0;
             int l_cell = 0;
             if (jx_type[2] == NODE || jy_type[2] == NODE || jz_type[2] == NODE) {
                 l_node = compute_shape_factor(sz_node, zmid_v[ip]);
             }
             if (jx_type[2] == CELL || jy_type[2] == CELL || jz_type[2] == CELL) {
                 l_cell = compute_shape_factor(sz_cell, zmid_v[ip] - 0.5);
             }
             // amrex::Real sz_jx[depos_order + 1] = {0._rt};
             // amrex::Real sz_jy[depos_order + 1] = {0._rt};
             // amrex::Real sz_jz[depos_order + 1] = {0._rt};
             for (int iz=0; iz<=depos_order; iz++)
             {
                 // printf("1 sz_node %f\n",sz_node[iz]);
                 sz_jx[ipp][iz] = ((jx_type[2] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
                 sz_jy[ipp][iz] = ((jy_type[2] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
                 // printf("ipp %d iz %d \n", ipp,iz);
                 // printf("sz_node [%d] %f \n", ipp,sz_node[iz]);
                 // printf("sz_cell [%d] %f \n", ipp,sz_cell[iz]);
                 sz_jz[ipp][iz] = ((jz_type[2] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
                 // printf("2 sz_node %f\n",sz_node[iz]);
             }
             l_jx[ipp] = ((jx_type[2] == NODE) ? l_node : l_cell);
             l_jy[ipp] = ((jy_type[2] == NODE) ? l_node : l_cell);
             l_jz[ipp] = ((jz_type[2] == NODE) ? l_node : l_cell);
             // if(j_jx[ip]==3&&k_jx[ip]==3&&l_jx[ip]==3){
             // if(j_jx[ipp]==3){
             //     j_jx[ipp]-=1;
             // }
         
             // printf("j_jx %d, k_jx %d, l_jx %d\n", j_jx, k_jx, l_jx);
             // printf("j_jy %d, k_jy %d, l_jy %d\n", j_jy, k_jy, l_jy);
             // printf("j_jz %d, k_jz %d, l_jz %d\n", j_jz, k_jz, l_jz);
             // WARPX_PROFILE_VAR_START(bl_sort);
             // int new_bin = (j_jx[ipp]-2 ) + (k_jx[ipp]-2 ) * nx + (l_jx[ipp]-2 ) * nxny;
             // printf("new_bin %d\n",new_bin);
             // printf("j_jx %d, k_jx %d, l_jx %d\n", j_jx[ip], k_jx[ip], l_jx[ip]);
             // printf("bx %d, by %d, bz %d\n", bx, by, bz);
             // printf("nx %d, ny %d\n", nx, ny);
             // if(j_jx[ip]>box.bigEnd(0) || k_jx[ip]>box.bigEnd(1) || l_jx[ip]>box.bigEnd(2)){
             //     printf("particle id %d, j_jx %d/%d, k_jx %d/%d, l_jx %d/%d\n", ip,j_jx[ip],box.bigEnd(0),
             //          k_jx[ip],box.bigEnd(1), l_jx[ip],box.bigEnd(2));
             //     printf("new_bin %d, old_bin %d\n",new_bin,old_bin);
             // }
         
             // printf("particle id %d/ ipp %d, j_jx %d, k_jx %d, l_jx %d\n", ip,ipp, j_jx, k_jx, l_jx);
             // int actual_old_bin = old_bin - 1; 
             // printf("actual_old_bin %d, new_bin %d \n",actual_old_bin,new_bin);
 
             // if(new_bin != actual_old_bin) {
             //     // 粒子改变bin，直接加入临时数组
             //     m_pending_moves.push_back({ip,new_bin});
             //     // printf("NO 1 change particle id %d, j_jx %d,k_jx %d,l_jx %d, old_bin %d, new_bin %d\n", 
             //     //     ip, j_jx[ip]-2,k_jx[ip]-2,l_jx[ip]-2,old_bin - 1, new_bin);
             //     // printf("pushing particle id %d, j_jx %d,k_jx %d,l_jx %d from old_bin %d to new_bin %d\n", 
             //         // ip, j_jx[ip]-2,k_jx[ip]-2,l_jx[ip]-2,old_bin - 1, new_bin);
             //     ptile.m_local_index[ipp] = INVALID_PARTICLE_ID;
             //     ptile.m_bin_lengths[actual_old_bin]--;
             //     ptile.m_num_empty_slots++;
             //     ptile.m_num_particles--;
             // } 
             // WARPX_PROFILE_VAR_STOP(bl_sort);
             ipp++;
             
 
         }
     // }
     // WARPX_PROFILE_VAR_START(bl_sort);
     // applyPendingMoves(numcell, ptile, m_pending_moves);
     // WARPX_PROFILE_VAR_STOP(bl_sort);
 
 
     // for( long ip = 0; ip < np_to_deposit; ++ip){
     // for(int c=1;c<numcell;++c){
     //     int start = ptile.m_bin_offsets[c-1];
     //     int end   = ptile.m_bin_offsets[c];
     //     // printf("cell %d/%d: start %d: end %d, len: %d\n", c,numcell, start,end,end-start);
     //     if(start == end) continue;
     //     for(int idx=start;idx<end;++idx){
     //         int ip = ptile.m_local_index[idx];
 
     // for (int old_bin = 1; old_bin <= numcell; ++old_bin) {
     //     if (bin_length[old_bin-1] == 0) continue;
     //     int start = bin_offsets[old_bin-1];
     //     int end = bin_offsets[old_bin];
         // int end = start+ bin_length[old_bin-1];
         // printf(" compute!!\n");    
         // int idx = start;
         // printf("start deposit current\n");
         ipp=0;
 
         for (int idx = start; idx < end; ++idx) {
         // while(idx < end){
             int ip = local_index[idx];
             if (ip == INVALID_PARTICLE_ID) continue;
             // if(ip==INVALID_PARTICLE_ID) 
             // {
             //     printf("particle idx %d id %d is invalid\n",idx, ip);
             //     continue;
             // }
             
             // printf("Calculate particle id %d/%d in bin %d/%d\n", idx,ptile.m_num_particles-1,old_bin-1,numcell);
 
             for (int iz=0; iz<=depos_order; iz++){
                 for (int iy=0; iy<=depos_order; iy++){
                     for (int ix=0; ix<=depos_order; ix++){
                         amrex::Gpu::Atomic::AddNoRet(
                             &jx_arr(lo.x+j_jx[ipp]+ix, lo.y+k_jx[ipp]+iy, lo.z+l_jx[ipp]+iz),
                             sx_jx[ipp][ix]*sy_jx[ipp][iy]*sz_jx[ipp][iz]*wqx[ip]);
                         amrex::Gpu::Atomic::AddNoRet(
                             &jy_arr(lo.x+j_jy[ipp]+ix, lo.y+k_jy[ipp]+iy, lo.z+l_jy[ipp]+iz),
                             sx_jy[ipp][ix]*sy_jy[ipp][iy]*sz_jy[ipp][iz]*wqy[ip]);
                         amrex::Gpu::Atomic::AddNoRet(
                             &jz_arr(lo.x+j_jz[ipp]+ix, lo.y+k_jz[ipp]+iy, lo.z+l_jz[ipp]+iz),
                             sx_jz[ipp][ix]*sy_jz[ipp][iy]*sz_jz[ipp][iz]*wqz[ip]);
                     }
                 }
             }
             // printf("finish calculate particle id %d \n", ip);
             // ipp++;
             ipp++;
         }
     }
     // printf("finish deposit current\n");
     // amrex::Abort("stop");
     
     // );
 }
 
 // one cell sme
 template <int depos_order>
 __arm_new("za") inline void sort_3d_sme_kernal(
     const long numcell,
     const std::vector<int>& local_index,
     const int bin_length,
     const int start,
     const int old_bin,
     std::vector<amrex::Real>& xrhocells,
     std::vector<amrex::Real>& yrhocells,
     std::vector<amrex::Real>& zrhocells,
     std::vector<amrex::Real>& sx_m,
     std::vector<amrex::Real>& sy_m,
     std::vector<amrex::Real>& sz_m,
     std::vector<amrex::Real>& wqx,
     std::vector<amrex::Real>& wqy,
     std::vector<amrex::Real>& wqz
 )__arm_streaming
 {
     using namespace amrex::literals;
     // svbool_t p=svwhilelt_b64(start,end);
     // intVec ip_v=intVec::Load(p,&local_index[idx]);
     // svbool_t pp = svcmpneq_n_s64(p, ip_v, INVALID_PARTICLE_ID);
 
     svbool_t p_4=svwhilelt_b64(0,4);
     svbool_t p_4_8=svbic_z(svptrue_b64(),svptrue_b64(),p_4);
     svbool_t p0=svwhilelt_b64(0,2);
     svbool_t p1=svbic_z(p_4,p_4, p0);
     svbool_t p = svptrue_b64();
     MVec vzero(0);
 
     svzero_za();
     const int last = bin_length%2;
     int idx1=start;
     // for(int idx=start;idx<end1;idx+=2){
     int ipp=0;
     while(ipp<bin_length-last){
         while (local_index[idx1] == INVALID_PARTICLE_ID) {
             idx1++;
             continue;
         }
         int ip1 = local_index[idx1];
         int idx2=idx1+1;
         while (local_index[idx2] == INVALID_PARTICLE_ID) {
             idx2++;
             continue;
         }
         int ip2 = local_index[idx2];
         // sx={x[0],x[1],x2[0],x2[1]}
         // sysz={y1[0]z1[0],y1[1]z1[0],y1[0]z1[1],y1[1]z1[1],y2[0]z2[0],y2[1]z2[0],y2[0]z2[1],y2[1]z2[1]}
         // int ip=xbinList[idx];
         // int ip1=xbinList[idx+1];
         // int ipp1=ipp+1;
         
         MVec sz_xv=svdup_n_f64(0);
         MVec sz_yv=svdup_n_f64(0);
         MVec sz_zv=svdup_n_f64(0);
         MVec sz_x1 = svld1(p0,&sz_m[ipp*2]);
         MVec sz_x2 = svld1(p1,&sz_m[(ipp+1)*2]);
         MVec sz_y1 = sz_x1; 
         MVec sz_y2 = sz_x2; 
         MVec sz_z1 = sz_x1;
         MVec sz_z2 = sz_x2;
         // svbool_t p1=svwhilelt_b64(2,4);
         sz_x1*=wqx[ip1];
         sz_xv=svsel(p0,sz_x1,sz_xv);
         sz_x2*=wqx[ip2];
         sz_xv=svsel(p1,sz_x2,sz_xv);
         sz_y1*=wqy[ip1];
         sz_yv=svsel(p0,sz_y1,sz_yv);
         sz_y2*=wqy[ip2];
         sz_yv=svsel(p1,sz_y2,sz_yv);
         sz_z1*=wqz[ip1];
         sz_zv=svsel(p0,sz_z1,sz_zv);
         sz_z2*=wqz[ip2];
         sz_zv=svsel(p1,sz_z2,sz_zv);
         // double vvs[8];
         // sz_xv.Store(p,&vvs[0]);
         // test[ip]=vvs[0];
         // test[ip1]=vvs[2];
 
         // test[ip]=wqx[ip];
         // test[ip1]=wqx[ip1];
 
         MVec vx1=MVec::Load(p0, &sx_m[ipp*2]);
         MVec vx2=MVec::Load(p0, &sx_m[(ipp+1)*2]);
         // double vvs[8];
         // vx1.Store(p0,&vvs[0]);
         // test[ip]=vvs[0];
         // vx2.Store(p0,&vvs[0]);
         // test[(ipp+1)]=vvs[0];
 
         MVec vy1=MVec::Load(p0, &sy_m[ipp*2]);
         MVec vy2=MVec::Load(p0, &sy_m[(ipp+1)*2]);
 
         const uint64_t x_indices[8]={0,2,0,2,1,3,1,3};
         MVec vx_broadcast=svtbl(svzip1(vx1,vx2),svld1_u64(svptrue_b64(),x_indices));
         const uint64_t y_indices[8]={0,0,2,2,1,1,3,3};
         MVec vy_broadcast=svtbl(svzip1(vy1,vy2),svld1_u64(svptrue_b64(),y_indices));
 
         MVec sxsy_v=vx_broadcast*vy_broadcast;      
 
         // svzero_za();
         svmopa_za64_m(0, p_4, svptrue_b64(), sz_xv, sxsy_v);
         svmopa_za64_m(1, p_4, svptrue_b64(), sz_yv, sxsy_v);
         svmopa_za64_m(2, p_4, svptrue_b64(), sz_zv, sxsy_v);
 
         idx1=idx2+1;
         ipp+=2;
     }
 
     // svzero_za();
     if(last){
         // int ip=xbinList[end1+1];   
         // printf("ip %d len %d \n",ip,end-start);
         int ip = local_index[idx1];
         while (local_index[idx1] == INVALID_PARTICLE_ID) {
             idx1++;
             continue;
         }
         ipp-=1;
         MVec sz_v=svdup_n_f64(0);
         MVec sz_1 = svld1(p0,&sz_m[ipp*2]);
         sz_1*=wqx[ip];
         sz_v=svsel(p0,sz_1,sz_v);
         // svbool_t p1=svwhilelt_b64(2,4);
         MVec vx1=MVec::Load(p0, &sx_m[ipp*2]);
         MVec vy1=MVec::Load(p0, &sy_m[ipp*2]);
         MVec sxsy_v=svsplice(p0,vx1,vy1);
         // svzero_za();
         svmopa_za64_m(0, p0, p_4, sz_v, sxsy_v);
     }
 
     MVec wwx = MVec::Load(p,&xrhocells[8*(old_bin-1)]);
     MVec wwy = MVec::Load(p,&yrhocells[8*(old_bin-1)]);
     MVec wwz = MVec::Load(p,&zrhocells[8*(old_bin-1)]);
     MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,0);
     MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4,0,1);
     // svfloat64x2_t ss=svcreate2_f64(wxsxsysz0,wxsxsysz0);
     // MVec B=svext(wxsxsysz1,wxsxsysz1,4);
     // MVec s=svsel(p_4,wxsxsysz0,B);
     MVec s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
     wwx+=s;
     wxsxsysz0 = svread_hor_za64_m(vzero,p_4_8,0,2);
     wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,0,3);
     MVec B=svext(wxsxsysz1,wxsxsysz1,4);
     s=svext(wxsxsysz0,B,4);
     // B=svext(wxsxsysz1,wxsxsysz1,4);
     // s=svsel(p_4,wxsxsysz0,B);
     // s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
     wwx+=s;
     wwx.Store(p,&xrhocells[8*(old_bin-1)]);
     // test[c]=xrhocells[8*c];
     wwy.Store(p,&yrhocells[8*(old_bin-1)]);
     wwz.Store(p,&zrhocells[8*(old_bin-1)]); 
 }
 
 // one cell sme
 template <int depos_order>
 __arm_new("za") static void sort_real_sme_kernal_4(
     const long numcell,
     const std::vector<int>& local_index,
     const std::vector<int>& bin_offsets,
     std::vector<amrex::Real>& xrhocells,
     std::vector<amrex::Real>& yrhocells,
     std::vector<amrex::Real>& zrhocells,
     std::vector<amrex::Real>& sx_m,
     std::vector<amrex::Real>& sy_m,
     std::vector<amrex::Real>& sz_m,
     std::vector<amrex::Real>& wqx,
     std::vector<amrex::Real>& wqy,
     std::vector<amrex::Real>& wqz
 )__arm_streaming
 {
     using namespace amrex::literals;
     // svbool_t p=svwhilelt_b64(start,end);
     // intVec ip_v=intVec::Load(p,&local_index[idx]);
     // svbool_t pp = svcmpneq_n_s64(p, ip_v, INVALID_PARTICLE_ID);
 
     svbool_t p_4=svwhilelt_b64(0,4);
     svbool_t p_4_8=svbic_z(svptrue_b64(),svptrue_b64(),p_4);
     svbool_t p0=svwhilelt_b64(0,2);
     svbool_t p1=svbic_z(p_4,p_4, p0);
     svbool_t p = svptrue_b64();
     MVec vzero(0);
     for (int old_bin = 1; old_bin <= numcell; ++old_bin) {
         int start = bin_offsets[old_bin-1];
         int end = bin_offsets[old_bin];
         if (end-start == 0) continue;
         svzero_za();
         // const int last = bin_length%2;
         // int idx2=start;
         // for(int idx=start;idx<end1;idx+=2){
         // int ipp=0;
         // while(idx1<end-last){
         // while(ipp<bin_length-last){
         // int first_idx=-1;
         int last=(end-start)%2;
         // int ip1=0;
         // int ip2=0;
         for(int i=start;i<end-last;i+=2){
             // if (local_index[i] == INVALID_PARTICLE_ID) {
             //     // idx1++;
             //     continue;
             // } 
             // if(first_idx<0){
             //     first_idx=i;
             // }else{
                 // int idx1 = first_idx;
                 // int idx2=i;
                 int ip1 = local_index[i];
                 int ip2 = local_index[i+1];
                 
                 MVec sz_xv=svdup_n_f64(0);
                 MVec sz_yv=svdup_n_f64(0);
                 MVec sz_zv=svdup_n_f64(0);
                 
                 MVec sz_x1 = svld1(p0,&sz_m[ip1*2]);
                 MVec sz_x2 = svld1(p1,&sz_m[ip1*2]);
                 MVec sz_y1 = sz_x1; 
                 MVec sz_y2 = sz_x2; 
                 MVec sz_z1 = sz_x1;
                 MVec sz_z2 = sz_x2;
                 // svbool_t p1=svwhilelt_b64(2,4);
                 // MVec sz_x1=sz_1*wqx[ip1];
                 // sz_x1=svsel(p0,sz_x1,sz_v0);
                 // MVec sz_x2=sz_2*wqx[ip2];
                 // sz_x1=svsel(p1,sz_x2,sz_v0);
 
                 // MVec sz_y1=sz_1*wqy[ip1];
                 // sz_y1=svsel(p0,sz_y1,sz_v0);
                 // MVec sz_y2=sz_2*wqy[ip2];
                 // sz_y1=svsel(p1,sz_y2,sz_v0);
 
                 // MVec sz_z1=sz_1*wqz[ip1];
                 // sz_z1=svsel(p0,sz_z1,sz_v0);
                 // MVec sz_z2=sz_2*wqz[ip2];
                 // sz_z1=svsel(p1,sz_z2,sz_v0);
 
                 // printf("i, %d, ip1 %d ip2 %d\n",i,ip1,ip2);
                 // printf("st, %d, ed %d \n",start,end);
                 sz_x1*=wqx[ip1];
                 sz_xv=svsel(p0,sz_x1,sz_xv);
                 sz_x2*=wqx[ip2];
                 sz_xv=svsel(p1,sz_x2,sz_xv);
                 sz_y1*=wqy[ip1];
                 sz_yv=svsel(p0,sz_y1,sz_yv);
                 sz_y2*=wqy[ip2];
                 sz_yv=svsel(p1,sz_y2,sz_yv);
                 sz_z1*=wqz[ip1];
                 sz_zv=svsel(p0,sz_z1,sz_zv);
                 sz_z2*=wqz[ip2];
                 sz_zv=svsel(p1,sz_z2,sz_zv);
                 // double vvs[8];
                 // sz_xv.Store(p,&vvs[0]);
                 // test[ip]=vvs[0];
                 // test[ip1]=vvs[2];
 
                 // test[ip]=wqx[ip];
                 // test[ip1]=wqx[ip1];
 
                 MVec vx1=MVec::Load(p0, &sx_m[ip1*2]);
                 MVec vx2=MVec::Load(p0, &sx_m[ip2*2]);
                 // double vvs[8];
                 // vx1.Store(p0,&vvs[0]);
                 // test[ip]=vvs[0];
                 // vx2.Store(p0,&vvs[0]);
                 // test[ip2]=vvs[0];
 
                 MVec vy1=MVec::Load(p0, &sy_m[ip1*2]);
                 MVec vy2=MVec::Load(p0, &sy_m[ip2*2]);
 
                 const uint64_t x_indices[8]={0,2,0,2,1,3,1,3};
                 MVec vx_broadcast=svtbl(svzip1(vx1,vx2),svld1_u64(svptrue_b64(),x_indices));
                 const uint64_t y_indices[8]={0,0,2,2,1,1,3,3};
                 MVec vy_broadcast=svtbl(svzip1(vy1,vy2),svld1_u64(svptrue_b64(),y_indices));
 
                 MVec sxsy_v=vx_broadcast*vy_broadcast;      
 
                 // svzero_za();
                 svmopa_za64_m(0, p_4, svptrue_b64(), sz_xv, sxsy_v);
                 svmopa_za64_m(1, p_4, svptrue_b64(), sz_yv, sxsy_v);
                 svmopa_za64_m(2, p_4, svptrue_b64(), sz_zv, sxsy_v);
 
                 // first_idx=-1;
             
             
         }
 
         // svzero_za();
         // if(first_idx>=0){
         if(last){
 
             int ip1 = local_index[end-1];
             // ip1-=1;
             MVec sz_x0=svdup_n_f64(0);
             MVec sz_y0=svdup_n_f64(0);
             MVec sz_z0=svdup_n_f64(0);
             MVec sz_mm = svld1(p0,&sz_m[ip1*2]);
             MVec sz_1=sz_mm*wqx[ip1];
             sz_x0=svsel(p0,sz_1,sz_x0);
 
             // MVec sz_v2=svdup_n_f64(0);
             // MVec sz_1 = svld1(p0,&sz_m[ip1*2]);
             MVec sz_2=sz_mm*wqy[ip1];
             sz_y0=svsel(p0,sz_2,sz_y0);
 
             // MVec sz_v3=svdup_n_f64(0);
             // MVec sz_3 = svld1(p0,&sz_m[ip1*2]);
             MVec sz_3=sz_mm*wqx[ip1];
             sz_z0=svsel(p0,sz_3,sz_z0);
             // svbool_t p1=svwhilelt_b64(2,4);
             MVec vx1=MVec::Load(p0, &sx_m[ip1*2]);
             MVec vy1=MVec::Load(p0, &sy_m[ip1*2]);
             MVec sxsy_v=svsplice(p0,vx1,vy1);
             // svzero_za();
             svmopa_za64_m(0, p0, p_4, sz_1, sxsy_v);
             svmopa_za64_m(1, p0, p_4, sz_2, sxsy_v);
             svmopa_za64_m(2, p0, p_4, sz_3, sxsy_v);
         }
 
         MVec wwx = MVec::Load(p,&xrhocells[8*(old_bin)]);
         MVec wwy = MVec::Load(p,&yrhocells[8*(old_bin)]);
         MVec wwz = MVec::Load(p,&zrhocells[8*(old_bin)]);
         MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,0);
         MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4,0,1);
         // svfloat64x2_t ss=svcreate2_f64(wxsxsysz0,wxsxsysz0);
         // MVec B=svext(wxsxsysz1,wxsxsysz1,4);
         // MVec s=svsel(p_4,wxsxsysz0,B);
         MVec s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
         wwx+=s;
         wxsxsysz0 = svread_hor_za64_m(vzero,p_4_8,0,2);
         wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,0,3);
         MVec B=svext(wxsxsysz1,wxsxsysz1,4);
         s=svext(wxsxsysz0,B,4);
         // B=svext(wxsxsysz1,wxsxsysz1,4);
         // s=svsel(p_4,wxsxsysz0,B);
         // s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
         wwx+=s;
         wwx.Store(p,&xrhocells[8*(old_bin)]);
 
         wxsxsysz0 = svread_hor_za64_m(vzero,p_4,1,0);
         wxsxsysz1 = svread_hor_za64_m(vzero,p_4,1,1);
         MVec sy=svsplice(p_4,wxsxsysz0,wxsxsysz1);
         wwy+=sy;
         wxsxsysz0 = svread_hor_za64_m(vzero,p_4_8,1,2);
         wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,1,3);
         MVec By=svext(wxsxsysz1,wxsxsysz1,4);
         sy=svext(wxsxsysz0,By,4);
         wwy+=sy;
         wwy.Store(p,&yrhocells[8*(old_bin)]);
 
         wxsxsysz0 = svread_hor_za64_m(vzero,p_4,2,0);
         wxsxsysz1 = svread_hor_za64_m(vzero,p_4,2,1);
         MVec sz=svsplice(p_4,wxsxsysz0,wxsxsysz1);
         wwz+=sz;
         wxsxsysz0 = svread_hor_za64_m(vzero,p_4_8,2,2);
         wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,2,3);
         MVec Bz=svext(wxsxsysz1,wxsxsysz1,4);
         sz=svext(wxsxsysz0,Bz,4);
         wwz+=sy;
         wwz.Store(p,&zrhocells[8*(old_bin)]); 
 
         // wwx.Store(p,&xrhocells[8*(old_bin)]);
         // // test[c]=xrhocells[8*c];
         // wwy.Store(p,&yrhocells[8*(old_bin)]);
         // wwz.Store(p,&zrhocells[8*(old_bin)]); 
     }
 }
 
 // one cell sme
 template <int depos_order>
 __arm_new("za") inline void sort_3d_sme_kernal_1(
     const long numcell,
     const std::vector<int>& local_index,
     const std::vector<int>& bin_length,
     const std::vector<int>& bin_offsets,
     std::vector<amrex::Real>& xrhocells,
     std::vector<amrex::Real>& yrhocells,
     std::vector<amrex::Real>& zrhocells,
     std::vector<amrex::Real>& sx_m,
     std::vector<amrex::Real>& sy_m,
     std::vector<amrex::Real>& sz_m,
     std::vector<amrex::Real>& wqx,
     std::vector<amrex::Real>& wqy,
     std::vector<amrex::Real>& wqz
 )__arm_streaming
 {
     using namespace amrex::literals;
     // svbool_t p=svwhilelt_b64(start,end);
     // intVec ip_v=intVec::Load(p,&local_index[idx]);
     // svbool_t pp = svcmpneq_n_s64(p, ip_v, INVALID_PARTICLE_ID);
 
     svbool_t p_4=svwhilelt_b64(0,4);
     svbool_t p_4_8=svbic_z(svptrue_b64(),svptrue_b64(),p_4);
     svbool_t p0=svwhilelt_b64(0,2);
     svbool_t p1=svbic_z(p_4,p_4, p0);
     svbool_t p = svptrue_b64();
     MVec vzero(0);
     for (int old_bin = 1; old_bin <= numcell; ++old_bin) {
         if (bin_length[old_bin-1] == 0) continue;
         int start = bin_offsets[old_bin-1];
         int end = bin_offsets[old_bin];
         svzero_za();
         int ipp=0;
         // while(idx1<end-last){
         // while(ipp<bin_length-last){
         int first_idx=-1;
         for(int i=start;i<end;i++){
             if (local_index[i] == INVALID_PARTICLE_ID) {
                 // idx1++;
                 continue;
             } 
             if(first_idx<0){
                 first_idx=i;
             }else{
                 int idx1 = first_idx;
                 int idx2=i;
                 int ip1 = local_index[idx1];
                 int ip2 = local_index[idx2];
                 
                 MVec sz_xv=svdup_n_f64(0);
                 MVec sz_yv=svdup_n_f64(0);
                 MVec sz_zv=svdup_n_f64(0);
                 MVec sz_x1 = svld1(p0,&sz_m[ip1*2]);
                 MVec sz_x2 = svld1(p1,&sz_m[ip1*2]);
                 MVec sz_y1 = sz_x1; 
                 MVec sz_y2 = sz_x2; 
                 MVec sz_z1 = sz_x1;
                 MVec sz_z2 = sz_x2;
                 // svbool_t p1=svwhilelt_b64(2,4);
                 // MVec sz_x1=sz_1*wqx[ip1];
                 // sz_x1=svsel(p0,sz_x1,sz_v0);
                 // MVec sz_x2=sz_2*wqx[ip2];
                 // sz_x1=svsel(p1,sz_x2,sz_v0);
 
                 // MVec sz_y1=sz_1*wqy[ip1];
                 // sz_y1=svsel(p0,sz_y1,sz_v0);
                 // MVec sz_y2=sz_2*wqy[ip2];
                 // sz_y1=svsel(p1,sz_y2,sz_v0);
 
                 // MVec sz_z1=sz_1*wqz[ip1];
                 // sz_z1=svsel(p0,sz_z1,sz_v0);
                 // MVec sz_z2=sz_2*wqz[ip2];
                 // sz_z1=svsel(p1,sz_z2,sz_v0);
 
                 
                 sz_x1*=wqx[ip1];
                 sz_xv=svsel(p0,sz_x1,sz_xv);
                 sz_x2*=wqx[ip2];
                 sz_xv=svsel(p1,sz_x2,sz_xv);
                 sz_y1*=wqy[ip1];
                 sz_yv=svsel(p0,sz_y1,sz_yv);
                 sz_y2*=wqy[ip2];
                 sz_yv=svsel(p1,sz_y2,sz_yv);
                 sz_z1*=wqz[ip1];
                 sz_zv=svsel(p0,sz_z1,sz_zv);
                 sz_z2*=wqz[ip2];
                 sz_zv=svsel(p1,sz_z2,sz_zv);
                 // double vvs[8];
                 // sz_xv.Store(p,&vvs[0]);
                 // test[ip]=vvs[0];
                 // test[ip1]=vvs[2];
 
                 // test[ip]=wqx[ip];
                 // test[ip1]=wqx[ip1];
 
                 MVec vx1=MVec::Load(p0, &sx_m[ip1*2]);
                 MVec vx2=MVec::Load(p0, &sx_m[ip2*2]);
                 // double vvs[8];
                 // vx1.Store(p0,&vvs[0]);
                 // test[ip]=vvs[0];
                 // vx2.Store(p0,&vvs[0]);
                 // test[ip2]=vvs[0];
 
                 MVec vy1=MVec::Load(p0, &sy_m[ip1*2]);
                 MVec vy2=MVec::Load(p0, &sy_m[ip2*2]);
 
                 const uint64_t x_indices[8]={0,2,0,2,1,3,1,3};
                 MVec vx_broadcast=svtbl(svzip1(vx1,vx2),svld1_u64(svptrue_b64(),x_indices));
                 const uint64_t y_indices[8]={0,0,2,2,1,1,3,3};
                 MVec vy_broadcast=svtbl(svzip1(vy1,vy2),svld1_u64(svptrue_b64(),y_indices));
 
                 MVec sxsy_v=vx_broadcast*vy_broadcast;      
 
                 // svzero_za();
                 svmopa_za64_m(0, p_4, svptrue_b64(), sz_xv, sxsy_v);
                 svmopa_za64_m(1, p_4, svptrue_b64(), sz_yv, sxsy_v);
                 svmopa_za64_m(2, p_4, svptrue_b64(), sz_zv, sxsy_v);
 
                 first_idx=-1;
             }
             
         }
 
         // svzero_za();
         if(first_idx>=0){
 
             int ip1 = local_index[first_idx];
             // ip1-=1;
             MVec sz_x0=svdup_n_f64(0);
             MVec sz_y0=svdup_n_f64(0);
             MVec sz_z0=svdup_n_f64(0);
             MVec sz_mm = svld1(p0,&sz_m[ip1*2]);
             MVec sz_1=sz_mm*wqx[ip1];
             sz_x0=svsel(p0,sz_1,sz_x0);
 
             // MVec sz_v2=svdup_n_f64(0);
             // MVec sz_1 = svld1(p0,&sz_m[ip1*2]);
             MVec sz_2=sz_mm*wqy[ip1];
             sz_y0=svsel(p0,sz_2,sz_y0);
 
             // MVec sz_v3=svdup_n_f64(0);
             // MVec sz_3 = svld1(p0,&sz_m[ip1*2]);
             MVec sz_3=sz_mm*wqx[ip1];
             sz_z0=svsel(p0,sz_3,sz_z0);
             // svbool_t p1=svwhilelt_b64(2,4);
             MVec vx1=MVec::Load(p0, &sx_m[ip1*2]);
             MVec vy1=MVec::Load(p0, &sy_m[ip1*2]);
             MVec sxsy_v=svsplice(p0,vx1,vx1)*svzip1(vy1,vy1);
 
             // MVec sxsy_v=svsplice(p0,vx1,vy1);
             // svzero_za();
             svmopa_za64_m(0, p0, p_4, sz_1, sxsy_v);
             svmopa_za64_m(1, p0, p_4, sz_2, sxsy_v);
             svmopa_za64_m(2, p0, p_4, sz_3, sxsy_v);
         }
 
         MVec wwx = MVec::Load(p,&xrhocells[8*(old_bin)]);
         MVec wwy = MVec::Load(p,&yrhocells[8*(old_bin)]);
         MVec wwz = MVec::Load(p,&zrhocells[8*(old_bin)]);
         MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,0);
         MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4,0,1);
         // svfloat64x2_t ss=svcreate2_f64(wxsxsysz0,wxsxsysz0);
         // MVec B=svext(wxsxsysz1,wxsxsysz1,4);
         // MVec s=svsel(p_4,wxsxsysz0,B);
         MVec s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
         wwx+=s;
         wxsxsysz0 = svread_hor_za64_m(vzero,p_4_8,0,2);
         wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,0,3);
         MVec B=svext(wxsxsysz1,wxsxsysz1,4);
         s=svext(wxsxsysz0,B,4);
         // B=svext(wxsxsysz1,wxsxsysz1,4);
         // s=svsel(p_4,wxsxsysz0,B);
         // s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
         wwx+=s;
         wwx.Store(p,&xrhocells[8*(old_bin)]);
 
         wxsxsysz0 = svread_hor_za64_m(vzero,p_4,1,0);
         wxsxsysz1 = svread_hor_za64_m(vzero,p_4,1,1);
         MVec sy=svsplice(p_4,wxsxsysz0,wxsxsysz1);
         wwy+=sy;
         wxsxsysz0 = svread_hor_za64_m(vzero,p_4_8,1,2);
         wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,1,3);
         MVec By=svext(wxsxsysz1,wxsxsysz1,4);
         sy=svext(wxsxsysz0,By,4);
         wwy+=sy;
         wwy.Store(p,&yrhocells[8*(old_bin)]);
 
         wxsxsysz0 = svread_hor_za64_m(vzero,p_4,2,0);
         wxsxsysz1 = svread_hor_za64_m(vzero,p_4,2,1);
         MVec sz=svsplice(p_4,wxsxsysz0,wxsxsysz1);
         wwz+=sz;
         wxsxsysz0 = svread_hor_za64_m(vzero,p_4_8,2,2);
         wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,2,3);
         MVec Bz=svext(wxsxsysz1,wxsxsysz1,4);
         sz=svext(wxsxsysz0,Bz,4);
         wwz+=sy;
         wwz.Store(p,&zrhocells[8*(old_bin)]); 
 
         // wwx.Store(p,&xrhocells[8*(old_bin)]);
         // // test[c]=xrhocells[8*c];
         // wwy.Store(p,&yrhocells[8*(old_bin)]);
         // wwz.Store(p,&zrhocells[8*(old_bin)]); 
     }
 }
 
 // one cell sme
 template <int depos_order>
 __arm_new("za") inline void sort_3d_sme_kernal_2 (
     const long numcell,
     const std::vector<int>& local_index,
     const std::vector<int>& bin_length,
     const std::vector<int>& bin_offsets,
     std::vector<amrex::Real>& xrhocells,
     std::vector<amrex::Real>& yrhocells,
     std::vector<amrex::Real>& zrhocells,
     std::vector<amrex::Real>& sx_m,
     std::vector<amrex::Real>& sy_m,
     std::vector<amrex::Real>& sz_m,
     std::vector<amrex::Real>& wqx,
     std::vector<amrex::Real>& wqy,
     std::vector<amrex::Real>& wqz,
     amrex::Dim3 len
 )__arm_streaming
 {
     using namespace amrex::literals;
     // svbool_t p=svwhilelt_b64(start,end);
     // intVec ip_v=intVec::Load(p,&local_index[idx]);
     // svbool_t pp = svcmpneq_n_s64(p, ip_v, INVALID_PARTICLE_ID);
 
     svbool_t p_4=svwhilelt_b64(0,4);
     svbool_t p_4_8=svbic_z(svptrue_b64(),svptrue_b64(),p_4);
     svbool_t p0=svwhilelt_b64(0,2);
     svbool_t p1=svbic_z(p_4,p_4, p0);
     svbool_t p = svptrue_b64();
     MVec vzero(0);
 
     long nnx = len.x;
     long nny = len.y;
     long nnxny = nnx*nny;
     // for (int old_bin = 1; old_bin <= numcell; ++old_bin) {
     for (int iz = 0; iz < len.z; ++iz) {
         for (int iy = 0; iy < len.y; ++iy) {       
             for (int ix = 0; ix < len.x; ix++) {
                 int old_bin=(ix) + (iy) * nnx + (iz) * nnxny+1;
 
                 if (bin_length[old_bin-1] == 0) continue;
                 int start = bin_offsets[old_bin-1];
                 int end = bin_offsets[old_bin];
                 svzero_za();
                 int ipp=0;
                 // while(idx1<end-last){
                 // while(ipp<bin_length-last){
                 int first_idx=-1;
                 for(int i=start;i<end;i++){
                     if (local_index[i] == INVALID_PARTICLE_ID) {
                         // idx1++;
                         continue;
                     } 
                     if(first_idx<0){
                         first_idx=i;
                     }else{
                         int idx1 = first_idx;
                         int idx2=i;
                         int ip1 = local_index[idx1];
                         int ip2 = local_index[idx2];
                         
                         MVec sz_xv=svdup_n_f64(0);
                         MVec sz_yv=svdup_n_f64(0);
                         MVec sz_zv=svdup_n_f64(0);
                         MVec sz_x1 = svld1(p0,&sz_m[ip1*2]);
                         MVec sz_x2 = svld1(p1,&sz_m[ip1*2]);
                         MVec sz_y1 = sz_x1; 
                         MVec sz_y2 = sz_x2; 
                         MVec sz_z1 = sz_x1;
                         MVec sz_z2 = sz_x2;
                         // svbool_t p1=svwhilelt_b64(2,4);
                         // MVec sz_x1=sz_1*wqx[ip1];
                         // sz_x1=svsel(p0,sz_x1,sz_v0);
                         // MVec sz_x2=sz_2*wqx[ip2];
                         // sz_x1=svsel(p1,sz_x2,sz_v0);
 
                         // MVec sz_y1=sz_1*wqy[ip1];
                         // sz_y1=svsel(p0,sz_y1,sz_v0);
                         // MVec sz_y2=sz_2*wqy[ip2];
                         // sz_y1=svsel(p1,sz_y2,sz_v0);
 
                         // MVec sz_z1=sz_1*wqz[ip1];
                         // sz_z1=svsel(p0,sz_z1,sz_v0);
                         // MVec sz_z2=sz_2*wqz[ip2];
                         // sz_z1=svsel(p1,sz_z2,sz_v0);
 
                         
                         sz_x1*=wqx[ip1];
                         sz_xv=svsel(p0,sz_x1,sz_xv);
                         sz_x2*=wqx[ip2];
                         sz_xv=svsel(p1,sz_x2,sz_xv);
                         sz_y1*=wqy[ip1];
                         sz_yv=svsel(p0,sz_y1,sz_yv);
                         sz_y2*=wqy[ip2];
                         sz_yv=svsel(p1,sz_y2,sz_yv);
                         sz_z1*=wqz[ip1];
                         sz_zv=svsel(p0,sz_z1,sz_zv);
                         sz_z2*=wqz[ip2];
                         sz_zv=svsel(p1,sz_z2,sz_zv);
                         // double vvs[8];
                         // sz_xv.Store(p,&vvs[0]);
                         // test[ip]=vvs[0];
                         // test[ip1]=vvs[2];
 
                         // test[ip]=wqx[ip];
                         // test[ip1]=wqx[ip1];
 
                         MVec vx1=MVec::Load(p0, &sx_m[ip1*2]);
                         MVec vx2=MVec::Load(p0, &sx_m[ip2*2]);
                         // double vvs[8];
                         // vx1.Store(p0,&vvs[0]);
                         // test[ip]=vvs[0];
                         // vx2.Store(p0,&vvs[0]);
                         // test[ip2]=vvs[0];
 
                         MVec vy1=MVec::Load(p0, &sy_m[ip1*2]);
                         MVec vy2=MVec::Load(p0, &sy_m[ip2*2]);
 
                         const uint64_t x_indices[8]={0,2,0,2,1,3,1,3};
                         MVec vx_broadcast=svtbl(svzip1(vx1,vx2),svld1_u64(svptrue_b64(),x_indices));
                         const uint64_t y_indices[8]={0,0,2,2,1,1,3,3};
                         MVec vy_broadcast=svtbl(svzip1(vy1,vy2),svld1_u64(svptrue_b64(),y_indices));
 
                         MVec sxsy_v=vx_broadcast*vy_broadcast;      
 
                         // svzero_za();
                         svmopa_za64_m(0, p_4, svptrue_b64(), sz_xv, sxsy_v);
                         svmopa_za64_m(1, p_4, svptrue_b64(), sz_yv, sxsy_v);
                         svmopa_za64_m(2, p_4, svptrue_b64(), sz_zv, sxsy_v);
 
                         first_idx=-1;
                     }
                     
                 }
 
                 // svzero_za();
                 if(first_idx>=0){
                     int ip1 = local_index[first_idx];
                     // ip1-=1;
                     MVec sz_x0=svdup_n_f64(0);
                     MVec sz_y0=svdup_n_f64(0);
                     MVec sz_z0=svdup_n_f64(0);
                     MVec sz_mm = svld1(p0,&sz_m[ip1*2]);
                     MVec sz_1=sz_mm*wqx[ip1];
                     sz_x0=svsel(p0,sz_1,sz_x0);
 
                     // MVec sz_v2=svdup_n_f64(0);
                     // MVec sz_1 = svld1(p0,&sz_m[ip1*2]);
                     MVec sz_2=sz_mm*wqy[ip1];
                     sz_y0=svsel(p0,sz_2,sz_y0);
 
                     // MVec sz_v3=svdup_n_f64(0);
                     // MVec sz_3 = svld1(p0,&sz_m[ip1*2]);
                     MVec sz_3=sz_mm*wqx[ip1];
                     sz_z0=svsel(p0,sz_3,sz_z0);
                     // svbool_t p1=svwhilelt_b64(2,4);
                     MVec vx1=MVec::Load(p0, &sx_m[ip1*2]);
                     MVec vy1=MVec::Load(p0, &sy_m[ip1*2]);
                     // MVec sxsy_v=svsplice(p0,vx1,vy1);
                     MVec sxsy_v=svsplice(p0,vx1,vx1)*svzip1(vy1,vy1);
                     // svzero_za();
                     svmopa_za64_m(0, p0, p_4, sz_x0, sxsy_v);
                     svmopa_za64_m(1, p0, p_4, sz_y0, sxsy_v);
                     svmopa_za64_m(2, p0, p_4, sz_z0, sxsy_v);
                 }
 
                 MVec wwx = MVec::Load(p,&xrhocells[8*(old_bin)]);
                 MVec wwy = MVec::Load(p,&yrhocells[8*(old_bin)]);
                 MVec wwz = MVec::Load(p,&zrhocells[8*(old_bin)]);
                 MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,0);
                 MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4,0,1);
                 // svfloat64x2_t ss=svcreate2_f64(wxsxsysz0,wxsxsysz0);
                 // MVec B=svext(wxsxsysz1,wxsxsysz1,4);
                 // MVec s=svsel(p_4,wxsxsysz0,B);
                 MVec s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
                 wwx+=s;
                 wxsxsysz0 = svread_hor_za64_m(vzero,p_4_8,0,2);
                 wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,0,3);
                 MVec B=svext(wxsxsysz1,wxsxsysz1,4);
                 s=svext(wxsxsysz0,B,4);
                 // B=svext(wxsxsysz1,wxsxsysz1,4);
                 // s=svsel(p_4,wxsxsysz0,B);
                 // s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
                 wwx+=s;
                 wwx.Store(p,&xrhocells[8*(old_bin)]);
 
                 wxsxsysz0 = svread_hor_za64_m(vzero,p_4,1,0);
                 wxsxsysz1 = svread_hor_za64_m(vzero,p_4,1,1);
                 MVec sy=svsplice(p_4,wxsxsysz0,wxsxsysz1);
                 wwy+=sy;
                 wxsxsysz0 = svread_hor_za64_m(vzero,p_4_8,1,2);
                 wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,1,3);
                 MVec By=svext(wxsxsysz1,wxsxsysz1,4);
                 sy=svext(wxsxsysz0,By,4);
                 wwy+=sy;
                 wwy.Store(p,&yrhocells[8*(old_bin)]);
 
                 wxsxsysz0 = svread_hor_za64_m(vzero,p_4,2,0);
                 wxsxsysz1 = svread_hor_za64_m(vzero,p_4,2,1);
                 MVec sz=svsplice(p_4,wxsxsysz0,wxsxsysz1);
                 wwz+=sz;
                 wxsxsysz0 = svread_hor_za64_m(vzero,p_4_8,2,2);
                 wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,2,3);
                 MVec Bz=svext(wxsxsysz1,wxsxsysz1,4);
                 sz=svext(wxsxsysz0,Bz,4);
                 wwz+=sy;
                 wwz.Store(p,&zrhocells[8*(old_bin)]); 
 
                 // wwx.Store(p,&xrhocells[8*(old_bin)]);
                 // // test[c]=xrhocells[8*c];
                 // wwy.Store(p,&yrhocells[8*(old_bin)]);
                 // wwz.Store(p,&zrhocells[8*(old_bin)]); 
             }
         }
     }
 }
 
 // one cell sme
 template <int depos_order>
 __arm_new("za") inline void sort_3d_sme_kernal_3 (
     const long numcell,
     const std::vector<int>& local_index,
     const std::vector<int>& bin_length,
     const std::vector<int>& bin_offsets,
     std::vector<amrex::Real>& xrhocells,
     std::vector<amrex::Real>& yrhocells,
     std::vector<amrex::Real>& zrhocells,
     std::vector<amrex::Real>& sx_m,
     std::vector<amrex::Real>& sy_m,
     std::vector<amrex::Real>& sz_m,
     std::vector<amrex::Real>& wqx,
     std::vector<amrex::Real>& wqy,
     std::vector<amrex::Real>& wqz,
     amrex::Dim3 len, 
     std::vector<amrex::Real>& testsxwq,
     std::vector<amrex::Real>& test0,
     std::vector<amrex::Real>& test1
 )__arm_streaming
 {
     using namespace amrex::literals;
     // svbool_t p=svwhilelt_b64(start,end);
     // intVec ip_v=intVec::Load(p,&local_index[idx]);
     // svbool_t pp = svcmpneq_n_s64(p, ip_v, INVALID_PARTICLE_ID);
 
     svbool_t p_4=svwhilelt_b64(0,4);
     svbool_t p_4_8=svbic_z(svptrue_b64(),svptrue_b64(),p_4);
     svbool_t p0=svwhilelt_b64(0,2);
     svbool_t p1=svbic_z(p_4,p_4, p0);
     svbool_t p = svptrue_b64();
     MVec vzero(0);

    // // 获取SVE矢量的字节数
    // uint64_t num_bytes = svcntb();

    // // 谓词的每个比特对应一个字节，因此我们创建一个同样大小的内存区域
    // std::vector<int64_t> result(num_bytes);

    // // 创建一个有效的全真谓词，用于加载和存储操作
    // svbool_t pg_all = svptrue_b64();

    // // 创建一个全为1的8位整数矢量
    // svint64_t ones = svdup_n_s64(1);
    // // 创建一个全为0的8位整数矢量
    // svint64_t zeros = svdup_n_s64(0);

    // // 根据待检查的谓词pg，在ones和zeros之间进行选择
    // // 如果pg的某个通道为true，则结果矢量的对应通道为1，否则为0
    // svint64_t selected_vector = svsel_s64(p, ones, zeros);
    // // 将结果矢量存储到内存中
    // svst1_s64(pg_all, result.data(), selected_vector);
    // // 打印结果
    // std::cout << "p (svbool_t) content:" << std::endl;
    // std::cout << "[ ";
    // uint64_t num_lanes = svcntd(); // 获取32位元素的通道数
    // for (uint64_t i = 0; i < num_lanes; ++i) {
    //     std::cout << static_cast<int>(result[i]) << " ";
    // }
    // std::cout << "]" << std::endl;
    // selected_vector = svsel_s64(p1, ones, zeros);
    // // 将结果矢量存储到内存中
    // svst1_s64(pg_all, result.data(), selected_vector);
    // // 打印结果
    // std::cout << "p1 (svbool_t) content:" << std::endl;
    // std::cout << "[ ";
    // num_lanes = svcntd(); // 获取32位元素的通道数
    // for (uint64_t i = 0; i < num_lanes; ++i) {
    //     std::cout << static_cast<int>(result[i]) << " ";
    // }
    // std::cout << "]" << std::endl;
    // selected_vector = svsel_s64(p_4_8, ones, zeros);
    // // 将结果矢量存储到内存中
    // svst1_s64(pg_all, result.data(), selected_vector);
    // // 打印结果
    // std::cout << "p4-8 (svbool_t) content:" << std::endl;
    // std::cout << "[ ";
    // num_lanes = svcntd(); // 获取32位元素的通道数
    // for (uint64_t i = 0; i < num_lanes; ++i) {
    //     std::cout << static_cast<int>(result[i]) << " ";
    // }
    // std::cout << "]" << std::endl;
    // amrex::Abort("test over");
 
     long nnx = len.x;
     long nny = len.y;
     long nnxny = nnx*nny;
     // for (int old_bin = 1; old_bin <= numcell; ++old_bin) {
     for (int iz = 0; iz < len.z; ++iz) {
         for (int iy = 0; iy < len.y; ++iy) {       
             for (int ix = 0; ix < len.x; ix++) {
                 int old_bin=(ix) + (iy) * nnx + (iz) * nnxny+1;
 
                 if (bin_length[old_bin-1] == 0) continue;
                 int start = bin_offsets[old_bin-1];
                 int end = bin_offsets[old_bin];
                 svzero_za();
                 int ipp=0;
                 // while(idx1<end-last){
                 // while(ipp<bin_length-last){
                 int first_idx=-1;
                 for(int i=start;i<end;i++){
                     if (local_index[i] == INVALID_PARTICLE_ID) {
                         // idx1++;
                         continue;
                     } 
                     if(first_idx<0){
                         first_idx=i;
                     }else{
                         int idx1 = first_idx;
                         int idx2=i;
                         int ip1 = local_index[idx1];
                         int ip2 = local_index[idx2];
                         
                         MVec sz_xv=svdup_n_f64(0);
                         MVec sz_yv=svdup_n_f64(0);
                         MVec sz_zv=svdup_n_f64(0);
                         MVec sz_x1 = svld1(p0,&sz_m[ip1*2]);
                         sz_x1.Store(p0,&test0[2*ip1]);
                         MVec sz_x2 = svld1(p1,&sz_m[(ip2-1)*2]);
                         sz_x2.Store(p1,&test0[2*(ip2-1)]);
                         MVec sz_y1 = sz_x1; 
                         MVec sz_y2 = sz_x2; 
                         MVec sz_z1 = sz_x1;
                         MVec sz_z2 = sz_x2;
                         
                         // svbool_t p1=svwhilelt_b64(2,4);
                         // MVec sz_x1=sz_1*wqx[ip1];
                         // sz_x1=svsel(p0,sz_x1,sz_v0);
                         // MVec sz_x2=sz_2*wqx[ip2];
                         // sz_x1=svsel(p1,sz_x2,sz_v0);
 
                         // MVec sz_y1=sz_1*wqy[ip1];
                         // sz_y1=svsel(p0,sz_y1,sz_v0);
                         // MVec sz_y2=sz_2*wqy[ip2];
                         // sz_y1=svsel(p1,sz_y2,sz_v0);
 
                         // MVec sz_z1=sz_1*wqz[ip1];
                         // sz_z1=svsel(p0,sz_z1,sz_v0);
                         // MVec sz_z2=sz_2*wqz[ip2];
                         // sz_z1=svsel(p1,sz_z2,sz_v0);
 
                         
                        //  MVec testsxwq_v=sz_x1*wqx[ip1];
                        //  testsxwq_v.Store(svptrue_b64(),&testsxwq[8*(ip1)]);
                        svfloat64_t testsxwq_v = svdup_f64(0.0);
                        testsxwq_v=svmul_f64_m(p0, sz_x1, svdup_f64(wqx[ip1]));
                        svst1_f64(p, &testsxwq[8*(ip1)], testsxwq_v);
                        sz_x1*=wqx[ip1];
                        sz_xv=svsel(p0,sz_x1,sz_xv);
                        //  sz_xv.Store(p0,&testsxwq[2*(ip1)]);
                        // sz_x1.Store(svptrue_b64(),&testsxwq[8*(ip1)]);
 
                        // testsxwq_v=sz_x2*wqx[ip2];
                        // testsxwq_v.Store(svptrue_b64(),&testsxwq[8*(ip2)]);
                        testsxwq_v = svdup_f64(0.0);
                        testsxwq_v=svmul_f64_m(p1, sz_x2, svdup_f64(wqx[ip2]));
                        svfloat64_t final_vector = svcompact_f64(p1, testsxwq_v);
                        svst1_f64(p, &testsxwq[8*(ip2)], final_vector);
                        sz_x2*=wqx[ip2];
                        sz_xv=svsel(p1,sz_x2,sz_xv);
                        //  sz_x2.Store(svptrue_b64(),&testsxwq[8*(ip2)]);
                        //  sz_xv.Store(p1,&testsxwq[2*(ip2)]);
 
                        sz_y1*=wqy[ip1];
                        sz_yv=svsel(p0,sz_y1,sz_yv);
                        sz_y2*=wqy[ip2];
                        sz_yv=svsel(p1,sz_y2,sz_yv);
                        sz_z1*=wqz[ip1];
                        sz_zv=svsel(p0,sz_z1,sz_zv);
                        sz_z2*=wqz[ip2];
                        sz_zv=svsel(p1,sz_z2,sz_zv);
                        // double vvs[8];
                        // sz_xv.Store(p,&vvs[0]);
                        // test[ip]=vvs[0];
                        // test[ip1]=vvs[2];

                        // test[ip]=wqx[ip];
                        // test[ip1]=wqx[ip1];

                        MVec vx1=MVec::Load(p0, &sx_m[ip1*2]);
                        MVec vx2=MVec::Load(p0, &sx_m[ip2*2]);
                        // double vvs[8];
                        // vx1.Store(p0,&vvs[0]);
                        // test[ip]=vvs[0];
                        // vx2.Store(p0,&vvs[0]);
                        // test[ip2]=vvs[0];

                        MVec vy1=MVec::Load(p0, &sy_m[ip1*2]);
                        MVec vy2=MVec::Load(p0, &sy_m[ip2*2]);

                        const uint64_t x_indices[8]={0,2,0,2,1,3,1,3};
                        MVec vx_broadcast=svtbl(svzip1(vx1,vx2),svld1_u64(svptrue_b64(),x_indices));
                        const uint64_t y_indices[8]={0,0,2,2,1,1,3,3};
                        MVec vy_broadcast=svtbl(svzip1(vy1,vy2),svld1_u64(svptrue_b64(),y_indices));

                        MVec sxsy_v=vx_broadcast*vy_broadcast;      

                        // svzero_za();
                        svmopa_za64_m(0, p_4, svptrue_b64(), sz_xv, sxsy_v);
                        svmopa_za64_m(1, p_4, svptrue_b64(), sz_yv, sxsy_v);
                        svmopa_za64_m(2, p_4, svptrue_b64(), sz_zv, sxsy_v);

                        first_idx=-1;
                    }
                     
                 }
 
                // svzero_za();
                if(first_idx>=0){
                    int ip1 = local_index[first_idx];
                    // ip1-=1;
                    MVec sz_x0=svdup_n_f64(0);
                    MVec sz_y0=svdup_n_f64(0);
                    MVec sz_z0=svdup_n_f64(0);
                    MVec sz_mm = svld1(p0,&sz_m[ip1*2]);
                    sz_mm.Store(p0,&test0[2*ip1]);
                    //  MVec testsxwq_v=sz_mm*wqx[ip1];
                    //  testsxwq_v.Store(svptrue_b64(),&testsxwq[8*(ip1)]);
                    svfloat64_t testsxwq_v = svdup_f64(0.0);
                    testsxwq_v=svmul_f64_m(p0, sz_mm, svdup_f64(wqx[ip1]));
                    svst1_f64(p, &testsxwq[8*(ip1)], testsxwq_v);
                    MVec sz_1=sz_mm*wqx[ip1];
                    sz_x0=svsel(p0,sz_1,sz_x0);
                    //  sz_1.Store(svptrue_b64(),&testsxwq[8*(ip1)]);
                    //  sz_x0.Store(p0,&testsxwq[2*(ip1)]);
 
                     // MVec sz_v2=svdup_n_f64(0);
                     // MVec sz_1 = svld1(p0,&sz_m[ip1*2]);
                     MVec sz_2=sz_mm*wqy[ip1];
                     sz_y0=svsel(p0,sz_2,sz_y0);
 
                     // MVec sz_v3=svdup_n_f64(0);
                     // MVec sz_3 = svld1(p0,&sz_m[ip1*2]);
                     MVec sz_3=sz_mm*wqx[ip1];
                     sz_z0=svsel(p0,sz_3,sz_z0);
                     // svbool_t p1=svwhilelt_b64(2,4);
                     MVec vx1=MVec::Load(p0, &sx_m[ip1*2]);
                     MVec vy1=MVec::Load(p0, &sy_m[ip1*2]);
                     // MVec sxsy_v=svsplice(p0,vx1,vy1);
                     MVec sxsy_v=svsplice(p0,vx1,vx1)*svzip1(vy1,vy1);
                     // svzero_za();
                     svmopa_za64_m(0, p0, p_4, sz_x0, sxsy_v);
                     svmopa_za64_m(1, p0, p_4, sz_y0, sxsy_v);
                     svmopa_za64_m(2, p0, p_4, sz_z0, sxsy_v);
                 }
 
                 MVec wwx = MVec::Load(p,&xrhocells[8*(old_bin)]);
                 MVec wwy = MVec::Load(p,&yrhocells[8*(old_bin)]);
                 MVec wwz = MVec::Load(p,&zrhocells[8*(old_bin)]);
                 MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,0);
                 MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4,0,1);
                 // svfloat64x2_t ss=svcreate2_f64(wxsxsysz0,wxsxsysz0);
                 // MVec B=svext(wxsxsysz1,wxsxsysz1,4);
                 // MVec s=svsel(p_4,wxsxsysz0,B);
                 MVec s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
                 wwx+=s;
                 wxsxsysz0 = svread_hor_za64_m(vzero,p_4_8,0,2);
                 wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,0,3);
                 MVec B=svext(wxsxsysz1,wxsxsysz1,4);
                 s=svext(wxsxsysz0,B,4);
                 // B=svext(wxsxsysz1,wxsxsysz1,4);
                 // s=svsel(p_4,wxsxsysz0,B);
                 // s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
                 wwx+=s;
                 wwx.Store(p,&xrhocells[8*(old_bin)]);
 
                 wxsxsysz0 = svread_hor_za64_m(vzero,p_4,1,0);
                 wxsxsysz1 = svread_hor_za64_m(vzero,p_4,1,1);
                 MVec sy=svsplice(p_4,wxsxsysz0,wxsxsysz1);
                 wwy+=sy;
                 wxsxsysz0 = svread_hor_za64_m(vzero,p_4_8,1,2);
                 wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,1,3);
                 MVec By=svext(wxsxsysz1,wxsxsysz1,4);
                 sy=svext(wxsxsysz0,By,4);
                 wwy+=sy;
                 wwy.Store(p,&yrhocells[8*(old_bin)]);
 
                 wxsxsysz0 = svread_hor_za64_m(vzero,p_4,2,0);
                 wxsxsysz1 = svread_hor_za64_m(vzero,p_4,2,1);
                 MVec sz=svsplice(p_4,wxsxsysz0,wxsxsysz1);
                 wwz+=sz;
                 wxsxsysz0 = svread_hor_za64_m(vzero,p_4_8,2,2);
                 wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,2,3);
                 MVec Bz=svext(wxsxsysz1,wxsxsysz1,4);
                 sz=svext(wxsxsysz0,Bz,4);
                 wwz+=sy;
                 wwz.Store(p,&zrhocells[8*(old_bin)]); 
 
                 // wwx.Store(p,&xrhocells[8*(old_bin)]);
                 // // test[c]=xrhocells[8*c];
                 // wwy.Store(p,&yrhocells[8*(old_bin)]);
                 // wwz.Store(p,&zrhocells[8*(old_bin)]); 
             }
         }
     }
 }
 
// 这是0709版本3阶kernal的备份，有xyz三个方向
template <int depos_order>
__arm_new("za") void sort_3d_sme_kernal_order_3 (
    const std::vector<int>& local_index,
    const std::vector<int>& bin_length,
    const std::vector<int>& bin_offsets,
    std::vector<amrex::Real>& xrhocells,
    std::vector<amrex::Real>& yrhocells,
    std::vector<amrex::Real>& zrhocells,
    std::vector<amrex::Real>& sx_m,
    std::vector<amrex::Real>& sy_m,
    std::vector<amrex::Real>& sz_m,
    std::vector<amrex::Real>& wqx,
    std::vector<amrex::Real>& wqy,
    std::vector<amrex::Real>& wqz,
    amrex::Dim3 len, int np, int numcell
)__arm_streaming {
    using namespace amrex::literals;
    int nshape = 4;
    
    svbool_t p = svptrue_b64();
    svbool_t p0=svwhilelt_b64(0,4); // 前4个的谓词
    svbool_t p1=svbic_z(p,p, p0); // 后4个的谓词
    MVec vzero(0);

    int nx = len.x;
    int ny = len.y;
    int nxny = nx*ny;
    // printf("in\n");
    // for (int iz = 0; iz < len.z; ++iz) {
    //     for (int iy = 0; iy < len.y; ++iy) {       
    //         for (int ix = 0; ix < len.x; ix++) {
    //             int old_bin=(ix) + (iy) * nx + (iz) * ny+1;
            for (int old_bin = 1; old_bin <= numcell; old_bin++) {
                // printf("old %d bin_length %d \n",old_bin,bin_length[old_bin-1]);
                std::vector<int> ip_list;
                // Jxarr = wqx*sx*sy*sz
                if (bin_length[old_bin-1] == 0) continue;
                int start = bin_offsets[old_bin-1];
                int end = bin_offsets[old_bin];
                svzero_za();

                int first_idx=-1;
                for(int i=start;i<end;i++){
                    // printf("start %d end %d local_index %d \n",start,end,local_index[i]);
                    if (local_index[i] == INVALID_PARTICLE_ID) {
                        // idx1++;
                        continue;
                    } 
                    if(first_idx<0){
                        first_idx=i;
                    }else{
                        int idx1 = first_idx;
                        int idx2=i;
                        int ip1 = local_index[idx1];
                        ip_list.push_back(ip1);
                        int ip2 = local_index[idx2];
                        ip_list.push_back(ip2);
                        // printf("ip1 %d ip2 %d\n",ip1,ip2);

                        // sx0sy x sz
                        MVec p1wqxsy = svld1(p0,&sy_m[ip1*nshape])*wqx[ip1];
                        MVec p1sx0sy = p1wqxsy*sx_m[ip1*nshape+0];// first 4 (1111 0000)
                        MVec p2wqxsy = svld1(p1,&sy_m[(ip2-1)*nshape])*wqx[ip2];
                        MVec p2sx0sy = p2wqxsy*sx_m[(ip2-1)*nshape+0]; // only last 4 (0000 1111)
                        MVec sx0sy = svsel(p0,p1sx0sy,p2sx0sy);
                        //====================
                        // double A[8]={0.};
                        // sx0sy.Store(p,&A[0]);
                        // printf("Test sxsy:");
                        // for(int ii=0;ii<8;ii++){
                        //     printf("\tsxsy[%d]: %f\n",ii,A[ii]);
                        // }
                        //======================

                        MVec p1sz = svld1(p0,&sz_m[ip1*nshape]);
                        MVec p2sz = svld1(p1,&sz_m[(ip2-1)*nshape]);
                        MVec sz = svsel(p0,p1sz,p2sz);

                        svmopa_za64_m(0, p, p, sx0sy, sz);

                        // sx1sy x sz
                        MVec p1sx1sy = p1wqxsy*sx_m[ip1*nshape+1];
                        MVec p2sx1sy = p2wqxsy*sx_m[(ip2-1)*nshape+1];
                        MVec sx1sy = svsel(p0,p1sx1sy,p2sx1sy);
                        svmopa_za64_m(1, p, p, sx1sy, sz);

                        // sx2sy x sz
                        MVec p1sx2sy = p1wqxsy*sx_m[ip1*nshape+2];
                        MVec p2sx2sy = p2wqxsy*sx_m[(ip2-1)*nshape+2];
                        MVec sx2sy = svsel(p0,p1sx2sy,p2sx2sy);
                        svmopa_za64_m(2, p, p, sx2sy, sz);

                        // sx3sy x sz
                        MVec p1sx3sy = p1wqxsy*sx_m[ip1*nshape+3];
                        MVec p2sx3sy = p2wqxsy*sx_m[(ip2-1)*nshape+3];
                        MVec sx3sy = svsel(p0,p1sx3sy,p2sx3sy);
                        svmopa_za64_m(3, p, p, sx3sy, sz);

                        first_idx=-1;
                    }  
                }
                if(first_idx>=0){
                    int ip1 = local_index[first_idx];
                    ip_list.push_back(ip1);

                    // sx0sy x sz
                    MVec wqxsy = svld1(p0,&sy_m[ip1*nshape])*wqx[ip1];
                    MVec sx0sy = wqxsy*sx_m[ip1*nshape+0];// first 4 (1111 0000)
                    MVec sz = svld1(p0,&sz_m[ip1*nshape]);
                    svmopa_za64_m(0, p, p, sx0sy, sz);

                    // sx1sy x sz
                    MVec sx1sy = wqxsy*sx_m[ip1*nshape+1];
                    svmopa_za64_m(1, p, p, sx1sy, sz);

                    // sx2sy x sz
                    MVec sx2sy = wqxsy*sx_m[ip1*nshape+2];
                    svmopa_za64_m(2, p, p, sx2sy, sz);

                    // sx3sy x sz
                    MVec sx3sy = wqxsy*sx_m[ip1*nshape+3];
                    svmopa_za64_m(3, p, p, sx3sy, sz);
                }
                // x0
                MVec p1wxsx0sysz0 = svread_hor_za64_m(vzero,p0,0,0); //第一个粒子第一层（总共4层）第一组的第1行，11110000
                MVec p1wxsx0sysz1 = svread_hor_za64_m(vzero,p0,0,1); //第一个粒子第一层（总共4层）第一组的第2行，11110000
                MVec p1s0=svsplice(p0,p1wxsx0sysz0, p1wxsx0sysz1); //粒子1第一组8个数
                MVec p2wxsx0sysz0 = svread_hor_za64_m(vzero,p1,0,4); //第2个粒子同理，但是00001111
                MVec p2wxsx0sysz1 = svread_hor_za64_m(vzero,p1,0,5);
                MVec p2s0 = svext(p2wxsx0sysz0,svext(p2wxsx0sysz1,p2wxsx0sysz1,4),4); //组织成第2个粒子的第一组8个数
                MVec xrhocells0 = MVec::Load(p,&xrhocells[8*(old_bin-nx-1)]); //对于jx的第1个rhocell，位置ic-nx-1
                xrhocells0+=(p1s0+p2s0); //两个粒子最终加总一次
                xrhocells0.Store(p,&xrhocells[8*(old_bin-nx-1)]); //写回第1组的rhocell

                MVec p1wxsx0sysz2 = svread_hor_za64_m(vzero,p0,0,2); //第一层粒子1第2组的第1行
                MVec p1wxsx0sysz3 = svread_hor_za64_m(vzero,p0,0,3);
                MVec p1s1=svsplice(p0,p1wxsx0sysz0, p1wxsx0sysz1); //粒子1第2组8个数
                MVec p2wxsx0sysz2 = svread_hor_za64_m(vzero,p1,0,6); //第一层粒子2第2组的第1行
                MVec p2wxsx0sysz3 = svread_hor_za64_m(vzero,p1,0,7);
                MVec p2s1 = svext(p2wxsx0sysz2,svext(p2wxsx0sysz3,p2wxsx0sysz3,4),4); //组织成粒子2第2组8个数
                MVec xrhocells1 = MVec::Load(p,&xrhocells[8*(old_bin+nx-1)]); //第二个rhocell
                xrhocells1+=(p1s1+p2s1);//两个粒子最终加总一次
                xrhocells1.Store(p,&xrhocells[8*(old_bin+nx-1)]);//写回第2组的rhocell
                // 上面是第一层的rhocell结束，也就是x=0这一层

                // x1
                MVec p1wxsx1sysz0 = svread_hor_za64_m(vzero,p0,1,0); //第一个粒子第2层（总共4层）第3组的第1行，11110000
                MVec p1wxsx1sysz1 = svread_hor_za64_m(vzero,p0,1,1); //第一个粒子第2层（总共4层）第3组的第2行，11110000
                MVec p1s2=svsplice(p0,p1wxsx1sysz0, p1wxsx1sysz1); 
                MVec p2wxsx1sysz0 = svread_hor_za64_m(vzero,p1,1,4); 
                MVec p2wxsx1sysz1 = svread_hor_za64_m(vzero,p1,1,5);
                MVec p2s2 = svext(p2wxsx1sysz0,svext(p2wxsx1sysz1,p2wxsx1sysz1,4),4); 
                MVec xrhocells2 = MVec::Load(p,&xrhocells[8*(old_bin-nx)]); 
                xrhocells2+=(p1s2+p2s2); //两个粒子最终加总一次
                xrhocells2.Store(p,&xrhocells[8*(old_bin-nx)]); 

                MVec p1wxsx1sysz2 = svread_hor_za64_m(vzero,p0,1,2); 
                MVec p1wxsx1sysz3 = svread_hor_za64_m(vzero,p0,1,3);
                MVec p1s3=svsplice(p0,p1wxsx1sysz0, p1wxsx1sysz1); 
                MVec p2wxsx1sysz2 = svread_hor_za64_m(vzero,p1,1,6); 
                MVec p2wxsx1sysz3 = svread_hor_za64_m(vzero,p1,1,7);
                MVec p2s3 = svext(p2wxsx1sysz2,svext(p2wxsx1sysz3,p2wxsx1sysz3,4),4); 
                MVec xrhocells3 = MVec::Load(p,&xrhocells[8*(old_bin+nx)]); 
                xrhocells3+=(p1s3+p2s3);//两个粒子最终加总一次
                xrhocells3.Store(p,&xrhocells[8*(old_bin+nx)]);
                // 上面是第2层的rhocell结束，也就是x=1这一层

                // x2
                MVec p1wxsx2sysz0 = svread_hor_za64_m(vzero,p0,2,0); 
                MVec p1wxsx2sysz1 = svread_hor_za64_m(vzero,p0,2,1); 
                MVec p1s4=svsplice(p0,p1wxsx2sysz0, p1wxsx2sysz1); 
                MVec p2wxsx2sysz0 = svread_hor_za64_m(vzero,p1,2,4); 
                MVec p2wxsx2sysz1 = svread_hor_za64_m(vzero,p1,2,5);
                MVec p2s4 = svext(p2wxsx2sysz0,svext(p2wxsx2sysz1,p2wxsx2sysz1,4),4); 
                MVec xrhocells4 = MVec::Load(p,&xrhocells[8*(old_bin-nx+1)]); 
                xrhocells4+=(p1s4+p2s4); //两个粒子最终加总一次
                xrhocells4.Store(p,&xrhocells[8*(old_bin-nx+1)]); 

                MVec p1wxsx2sysz2 = svread_hor_za64_m(vzero,p0,2,2); 
                MVec p1wxsx2sysz3 = svread_hor_za64_m(vzero,p0,2,3);
                MVec p1s5=svsplice(p0,p1wxsx2sysz0, p1wxsx2sysz1); 
                MVec p2wxsx2sysz2 = svread_hor_za64_m(vzero,p1,2,6); 
                MVec p2wxsx2sysz3 = svread_hor_za64_m(vzero,p1,2,7);
                MVec p2s5 = svext(p2wxsx2sysz2,svext(p2wxsx2sysz3,p2wxsx2sysz3,4),4); 
                MVec xrhocells5 = MVec::Load(p,&xrhocells[8*(old_bin+nx+1)]); 
                xrhocells5+=(p1s5+p2s5);//两个粒子最终加总一次
                xrhocells5.Store(p,&xrhocells[8*(old_bin+nx+1)]);
                // 上面是第3层的rhocell结束，也就是x=2这一层

                // x3
                MVec p1wxsx3sysz0 = svread_hor_za64_m(vzero,p0,3,0); 
                MVec p1wxsx3sysz1 = svread_hor_za64_m(vzero,p0,3,1); 
                MVec p1s6=svsplice(p0,p1wxsx3sysz0, p1wxsx3sysz1); 
                MVec p2wxsx3sysz0 = svread_hor_za64_m(vzero,p1,3,4); 
                MVec p2wxsx3sysz1 = svread_hor_za64_m(vzero,p1,3,5);
                MVec p2s6 = svext(p2wxsx3sysz0,svext(p2wxsx3sysz1,p2wxsx3sysz1,4),4); 
                MVec xrhocells6 = MVec::Load(p,&xrhocells[8*(old_bin-nx+2)]); 
                xrhocells6+=(p1s6+p2s6); //两个粒子最终加总一次
                xrhocells6.Store(p,&xrhocells[8*(old_bin-nx+2)]); 

                MVec p1wxsx3sysz2 = svread_hor_za64_m(vzero,p0,3,2); 
                MVec p1wxsx3sysz3 = svread_hor_za64_m(vzero,p0,3,3);
                MVec p1s7=svsplice(p0,p1wxsx3sysz0, p1wxsx3sysz1); 
                MVec p2wxsx3sysz2 = svread_hor_za64_m(vzero,p1,3,6); 
                MVec p2wxsx3sysz3 = svread_hor_za64_m(vzero,p1,3,7);
                MVec p2s7 = svext(p2wxsx3sysz2,svext(p2wxsx3sysz3,p2wxsx3sysz3,4),4); 
                MVec xrhocells7 = MVec::Load(p,&xrhocells[8*(old_bin+nx+2)]); 
                xrhocells7+=(p1s7+p2s7);//两个粒子最终加总一次
                xrhocells7.Store(p,&xrhocells[8*(old_bin+nx+2)]);
                // 上面是第4层的rhocell结束，也就是x=3这一层

                svzero_za();
                const int last = bin_length[old_bin-1]%2;
                // printf("bin_length[old_bin-1] %d last %d\n",bin_length[old_bin-1],last);
                for(int i=0;i<(bin_length[old_bin-1]-last);i+=2){
                    int ip1=ip_list[i];
                    int ip2=ip_list[i+1];
                    // printf("ip1 %d ip2 %d\n",ip1,ip2);
                    // printf("wqy %d sxm %d szm %d sym %d\n"
                    //     ,wqy.size(),sx_m.size(),sz_m.size(),sy_m.size());
                    // Jyarr=wqy*....
                    // sx0sy x sz
                    MVec syv=svld1(p0,&sy_m[ip1*nshape]);
                    MVec p1wqysy = syv*wqy[ip1];
                    MVec p1sx0sy = p1wqysy*sx_m[ip1*nshape+0];// first 4 (1111 0000)
                    MVec p2wqysy = svld1(p1,&sy_m[(ip2-1)*nshape])*wqy[ip2];
                    MVec p2sx0sy = p2wqysy*sx_m[(ip2-1)*nshape+0]; // only last 4 (0000 1111)
                    MVec sx0sy = svsel(p0,p1sx0sy,p2sx0sy);

                    MVec p1sz = svld1(p0,&sz_m[ip1*nshape]);
                    MVec p2sz = svld1(p1,&sz_m[(ip2-1)*nshape]);
                    MVec sz = svsel(p0,p1sz,p2sz);

                    svmopa_za64_m(0, p, p, sx0sy, sz);

                    // sx1sy x sz
                    MVec p1sx1sy = p1wqysy*sx_m[ip1*nshape+1];
                    MVec p2sx1sy = p2wqysy*sx_m[(ip2-1)*nshape+1];
                    MVec sx1sy = svsel(p0,p1sx1sy,p2sx1sy);
                    svmopa_za64_m(1, p, p, sx1sy, sz);

                    // sx2sy x sz
                    MVec p1sx2sy = p1wqysy*sx_m[ip1*nshape+1];
                    MVec p2sx2sy = p2wqysy*sx_m[(ip2-1)*nshape+1];
                    MVec sx2sy = svsel(p0,p1sx2sy,p2sx2sy);
                    svmopa_za64_m(2, p, p, sx2sy, sz);

                    // sx3sy x sz
                    MVec p1sx3sy = p1wqysy*sx_m[ip1*nshape+1];
                    MVec p2sx3sy = p2wqysy*sx_m[(ip2-1)*nshape+1];
                    MVec sx3sy = svsel(p0,p1sx3sy,p2sx3sy);
                    svmopa_za64_m(3, p, p, sx3sy, sz);

                    // Jzarr
                    MVec p1wqzsy = syv*wqz[ip1];
                    MVec wzp1sx0sy = p1wqzsy*sx_m[ip1*nshape+0];// first 4 (1111 0000)
                    MVec p2wqzsy = svld1(p1,&sy_m[(ip2-1)*nshape])*wqz[ip2];
                    MVec wzp2sx0sy = p2wqzsy*sx_m[(ip2-1)*nshape+0]; // only last 4 (0000 1111)
                    MVec wzsx0sy = svsel(p0,wzp1sx0sy,wzp2sx0sy);

                    svmopa_za64_m(4, p, p, wzsx0sy, sz);

                    // sx1sy x sz
                    MVec wzp1sx1sy = p1wqzsy*sx_m[ip1*nshape+1];
                    MVec wzp2sx1sy = p2wqzsy*sx_m[(ip2-1)*nshape+1];
                    MVec wzsx1sy = svsel(p0,wzp1sx1sy,wzp2sx1sy);
                    svmopa_za64_m(5, p, p, wzsx1sy, sz);

                    // sx2sy x sz
                    MVec wzp1sx2sy = p1wqzsy*sx_m[ip1*nshape+1];
                    MVec wzp2sx2sy = p2wqzsy*sx_m[(ip2-1)*nshape+1];
                    MVec wzsx2sy = svsel(p0,wzp1sx2sy,wzp2sx2sy);
                    svmopa_za64_m(6, p, p, wzsx2sy, sz);

                    // sx3sy x sz
                    MVec wzp1sx3sy = p1wqzsy*sx_m[ip1*nshape+1];
                    MVec wzp2sx3sy = p2wqzsy*sx_m[(ip2-1)*nshape+1];
                    MVec wzsx3sy = svsel(p0,wzp1sx3sy,wzp2sx3sy);
                    svmopa_za64_m(7, p, p, wzsx3sy, sz);
                }
                if(last){
                    int ip1=ip_list[bin_length[old_bin-1]-1];  
                    // Jy
                    // sx0sy x sz
                    MVec syv = svld1(p0,&sy_m[ip1*nshape]);
                    MVec wqysy = syv*wqy[ip1];
                    MVec sx0sy = wqysy*sx_m[ip1*nshape+0];// first 4 (1111 0000)
                    MVec sz = svld1(p0,&sz_m[ip1*nshape]);
                    svmopa_za64_m(0, p, p, sx0sy, sz);

                    // sx1sy x sz
                    MVec sx1sy = wqysy*sx_m[ip1*nshape+1];
                    svmopa_za64_m(1, p, p, sx1sy, sz);

                    // sx2sy x sz
                    MVec sx2sy = wqysy*sx_m[ip1*nshape+1];
                    svmopa_za64_m(2, p, p, sx2sy, sz);

                    // sx3sy x sz
                    MVec sx3sy = wqysy*sx_m[ip1*nshape+1];
                    svmopa_za64_m(3, p, p, sx3sy, sz);

                    //Jz
                    // sx0sy x sz
                    MVec wqzsy = syv*wqz[ip1];
                    MVec wzsx0sy = wqzsy*sx_m[ip1*nshape+0];// first 4 (1111 0000)
                    svmopa_za64_m(4, p, p, wzsx0sy, sz);

                    // sx1sy x sz
                    MVec wzsx1sy = wqzsy*sx_m[ip1*nshape+1];
                    svmopa_za64_m(5, p, p, wzsx1sy, sz);

                    // sx2sy x sz
                    MVec wzsx2sy = wqzsy*sx_m[ip1*nshape+1];
                    svmopa_za64_m(6, p, p, wzsx2sy, sz);

                    // sx3sy x sz
                    MVec wzsx3sy = wqzsy*sx_m[ip1*nshape+1];
                    svmopa_za64_m(7, p, p, wzsx3sy, sz);
                }
                //Jy
                // x0
                MVec p1wysx0sysz0 = svread_hor_za64_m(vzero,p0,0,0); //第一个粒子第一层（总共4层）第一组的第1行，11110000
                MVec p1wysx0sysz1 = svread_hor_za64_m(vzero,p0,0,1); //第一个粒子第一层（总共4层）第一组的第2行，11110000
                MVec p1wys0=svsplice(p0,p1wysx0sysz0, p1wysx0sysz1); //粒子1第一组8个数
                MVec p2wysx0sysz0 = svread_hor_za64_m(vzero,p1,0,4); //第2个粒子同理，但是00001111
                MVec p2wysx0sysz1 = svread_hor_za64_m(vzero,p1,0,5);
                MVec p2wys0 = svext(p2wysx0sysz0,svext(p2wysx0sysz1,p2wysx0sysz1,4),4); //组织成第2个粒子的第一组8个数
                MVec yrhocells0 = MVec::Load(p,&yrhocells[8*(old_bin-nx-1)]); //对于jx的第1个rhocell，位置ic-nx-1
                yrhocells0+=(p1wys0+p2wys0); //两个粒子最终加总一次
                yrhocells0.Store(p,&yrhocells[8*(old_bin-nx-1)]); //写回第1组的rhocell

                MVec p1wysx0sysz2 = svread_hor_za64_m(vzero,p0,0,2); //第一层粒子1第2组的第1行
                MVec p1wysx0sysz3 = svread_hor_za64_m(vzero,p0,0,3);
                MVec p1wys1=svsplice(p0,p1wysx0sysz0, p1wysx0sysz1); //粒子1第2组8个数
                MVec p2wysx0sysz2 = svread_hor_za64_m(vzero,p1,0,6); //第一层粒子2第2组的第1行
                MVec p2wysx0sysz3 = svread_hor_za64_m(vzero,p1,0,7);
                MVec p2wys1 = svext(p2wysx0sysz2,svext(p2wysx0sysz3,p2wysx0sysz3,4),4); //组织成粒子2第2组8个数
                MVec yrhocells1 = MVec::Load(p,&yrhocells[8*(old_bin+nx-1)]); //第二个rhocell
                yrhocells1+=(p1wys1+p2wys1);//两个粒子最终加总一次
                yrhocells1.Store(p,&yrhocells[8*(old_bin+nx-1)]);//写回第2组的rhocell
                // 上面是第一层的rhocell结束，也就是x=0这一层

                // x1
                MVec p1wysx1sysz0 = svread_hor_za64_m(vzero,p0,1,0); //第一个粒子第2层（总共4层）第3组的第1行，11110000
                MVec p1wysx1sysz1 = svread_hor_za64_m(vzero,p0,1,1); //第一个粒子第2层（总共4层）第3组的第2行，11110000
                MVec p1wys2=svsplice(p0,p1wysx1sysz0, p1wysx1sysz1); 
                MVec p2wysx1sysz0 = svread_hor_za64_m(vzero,p1,1,4); 
                MVec p2wysx1sysz1 = svread_hor_za64_m(vzero,p1,1,5);
                MVec p2wys2 = svext(p2wysx1sysz0,svext(p2wysx1sysz1,p2wysx1sysz1,4),4); 
                MVec yrhocells2 = MVec::Load(p,&yrhocells[8*(old_bin-nx)]); 
                yrhocells2+=(p1wys2+p2wys2); //两个粒子最终加总一次
                yrhocells2.Store(p,&yrhocells[8*(old_bin-nx)]); 

                MVec p1wysx1sysz2 = svread_hor_za64_m(vzero,p0,1,2); 
                MVec p1wysx1sysz3 = svread_hor_za64_m(vzero,p0,1,3);
                MVec p1wys3=svsplice(p0,p1wysx1sysz0, p1wysx1sysz1); 
                MVec p2wysx1sysz2 = svread_hor_za64_m(vzero,p1,1,6); 
                MVec p2wysx1sysz3 = svread_hor_za64_m(vzero,p1,1,7);
                MVec p2wys3 = svext(p2wysx1sysz2,svext(p2wysx1sysz3,p2wysx1sysz3,4),4); 
                MVec yrhocells3 = MVec::Load(p,&yrhocells[8*(old_bin+nx)]); 
                yrhocells3+=(p1wys3+p2wys3);//两个粒子最终加总一次
                yrhocells3.Store(p,&yrhocells[8*(old_bin+nx)]);
                // 上面是第2层的rhocell结束，也就是x=1这一层

                // x2
                MVec p1wysx2sysz0 = svread_hor_za64_m(vzero,p0,2,0); 
                MVec p1wysx2sysz1 = svread_hor_za64_m(vzero,p0,2,1); 
                MVec p1wys4=svsplice(p0,p1wysx2sysz0, p1wysx2sysz1); 
                MVec p2wysx2sysz0 = svread_hor_za64_m(vzero,p1,2,4); 
                MVec p2wysx2sysz1 = svread_hor_za64_m(vzero,p1,2,5);
                MVec p2wys4 = svext(p2wysx2sysz0,svext(p2wysx2sysz1,p2wysx2sysz1,4),4); 
                MVec yrhocells4 = MVec::Load(p,&yrhocells[8*(old_bin-nx+1)]); 
                yrhocells4+=(p1wys4+p2wys4); //两个粒子最终加总一次
                yrhocells4.Store(p,&yrhocells[8*(old_bin-nx+1)]); 

                MVec p1wysx2sysz2 = svread_hor_za64_m(vzero,p0,2,2); 
                MVec p1wysx2sysz3 = svread_hor_za64_m(vzero,p0,2,3);
                MVec p1wys5=svsplice(p0,p1wysx2sysz0, p1wysx2sysz1); 
                MVec p2wysx2sysz2 = svread_hor_za64_m(vzero,p1,2,6); 
                MVec p2wysx2sysz3 = svread_hor_za64_m(vzero,p1,2,7);
                MVec p2wys5 = svext(p2wysx2sysz2,svext(p2wysx2sysz3,p2wysx2sysz3,4),4); 
                MVec yrhocells5 = MVec::Load(p,&yrhocells[8*(old_bin+nx+1)]); 
                yrhocells5+=(p1wys5+p2wys5);//两个粒子最终加总一次
                yrhocells5.Store(p,&yrhocells[8*(old_bin+nx+1)]);
                // 上面是第3层的rhocell结束，也就是x=2这一层

                // x3
                MVec p1wysx3sysz0 = svread_hor_za64_m(vzero,p0,3,0); 
                MVec p1wysx3sysz1 = svread_hor_za64_m(vzero,p0,3,1); 
                MVec p1wys6=svsplice(p0,p1wysx3sysz0, p1wysx3sysz1); 
                MVec p2wysx3sysz0 = svread_hor_za64_m(vzero,p1,3,4); 
                MVec p2wysx3sysz1 = svread_hor_za64_m(vzero,p1,3,5);
                MVec p2wys6 = svext(p2wysx3sysz0,svext(p2wysx3sysz1,p2wysx3sysz1,4),4); 
                MVec yrhocells6 = MVec::Load(p,&yrhocells[8*(old_bin-nx+2)]); 
                yrhocells6+=(p1wys6+p2wys6); //两个粒子最终加总一次
                yrhocells6.Store(p,&yrhocells[8*(old_bin-nx+2)]); 

                MVec p1wysx3sysz2 = svread_hor_za64_m(vzero,p0,3,2); 
                MVec p1wysx3sysz3 = svread_hor_za64_m(vzero,p0,3,3);
                MVec p1wys7=svsplice(p0,p1wysx3sysz0, p1wysx3sysz1); 
                MVec p2wysx3sysz2 = svread_hor_za64_m(vzero,p1,3,6); 
                MVec p2wysx3sysz3 = svread_hor_za64_m(vzero,p1,3,7);
                MVec p2wys7 = svext(p2wysx3sysz2,svext(p2wysx3sysz3,p2wysx3sysz3,4),4); 
                MVec yrhocells7 = MVec::Load(p,&yrhocells[8*(old_bin+nx+2)]); 
                yrhocells7+=(p1wys7+p2wys7);//两个粒子最终加总一次
                yrhocells7.Store(p,&yrhocells[8*(old_bin+nx+2)]);
                // 上面是第4层的rhocell结束，也就是x=3这一层
                //Jz
                // x0
                MVec p1wzsx0sysz0 = svread_hor_za64_m(vzero,p0,0,0); //第一个粒子第一层（总共4层）第一组的第1行，11110000
                MVec p1wzsx0sysz1 = svread_hor_za64_m(vzero,p0,0,1); //第一个粒子第一层（总共4层）第一组的第2行，11110000
                MVec p1wzs0=svsplice(p0,p1wzsx0sysz0, p1wzsx0sysz1); //粒子1第一组8个数
                MVec p2wzsx0sysz0 = svread_hor_za64_m(vzero,p1,0,4); //第2个粒子同理，但是00001111
                MVec p2wzsx0sysz1 = svread_hor_za64_m(vzero,p1,0,5);
                MVec p2wzs0 = svext(p2wzsx0sysz0,svext(p2wzsx0sysz1,p2wzsx0sysz1,4),4); //组织成第2个粒子的第一组8个数
                MVec zrhocells0 = MVec::Load(p,&zrhocells[8*(old_bin-nx-1)]); //对于jx的第1个rhocell，位置ic-nx-1
                zrhocells0+=(p1wzs0+p2wzs0); //两个粒子最终加总一次
                zrhocells0.Store(p,&zrhocells[8*(old_bin-nx-1)]); //写回第1组的rhocell

                MVec p1wzsx0sysz2 = svread_hor_za64_m(vzero,p0,0,2); //第一层粒子1第2组的第1行
                MVec p1wzsx0sysz3 = svread_hor_za64_m(vzero,p0,0,3);
                MVec p1wzs1=svsplice(p0,p1wzsx0sysz0, p1wzsx0sysz1); //粒子1第2组8个数
                MVec p2wzsx0sysz2 = svread_hor_za64_m(vzero,p1,0,6); //第一层粒子2第2组的第1行
                MVec p2wzsx0sysz3 = svread_hor_za64_m(vzero,p1,0,7);
                MVec p2wzs1 = svext(p2wzsx0sysz2,svext(p2wzsx0sysz3,p2wzsx0sysz3,4),4); //组织成粒子2第2组8个数
                MVec zrhocells1 = MVec::Load(p,&zrhocells[8*(old_bin+nx-1)]); //第二个rhocell
                zrhocells1+=(p1wzs1+p2wzs1);//两个粒子最终加总一次
                zrhocells1.Store(p,&zrhocells[8*(old_bin+nx-1)]);//写回第2组的rhocell
                // 上面是第一层的rhocell结束，也就是x=0这一层

                // x1
                MVec p1wzsx1sysz0 = svread_hor_za64_m(vzero,p0,1,0); //第一个粒子第2层（总共4层）第3组的第1行，11110000
                MVec p1wzsx1sysz1 = svread_hor_za64_m(vzero,p0,1,1); //第一个粒子第2层（总共4层）第3组的第2行，11110000
                MVec p1wzs2=svsplice(p0,p1wzsx1sysz0, p1wzsx1sysz1); 
                MVec p2wzsx1sysz0 = svread_hor_za64_m(vzero,p1,1,4); 
                MVec p2wzsx1sysz1 = svread_hor_za64_m(vzero,p1,1,5);
                MVec p2wzs2 = svext(p2wzsx1sysz0,svext(p2wzsx1sysz1,p2wzsx1sysz1,4),4); 
                MVec zrhocells2 = MVec::Load(p,&zrhocells[8*(old_bin-nx)]); 
                zrhocells2+=(p1wzs2+p2wzs2); //两个粒子最终加总一次
                zrhocells2.Store(p,&zrhocells[8*(old_bin-nx)]); 

                MVec p1wzsx1sysz2 = svread_hor_za64_m(vzero,p0,1,2); 
                MVec p1wzsx1sysz3 = svread_hor_za64_m(vzero,p0,1,3);
                MVec p1wzs3=svsplice(p0,p1wzsx1sysz0, p1wzsx1sysz1); 
                MVec p2wzsx1sysz2 = svread_hor_za64_m(vzero,p1,1,6); 
                MVec p2wzsx1sysz3 = svread_hor_za64_m(vzero,p1,1,7);
                MVec p2wzs3 = svext(p2wzsx1sysz2,svext(p2wzsx1sysz3,p2wzsx1sysz3,4),4); 
                MVec zrhocells3 = MVec::Load(p,&zrhocells[8*(old_bin+nx)]); 
                zrhocells3+=(p1wzs3+p2wzs3);//两个粒子最终加总一次
                zrhocells3.Store(p,&zrhocells[8*(old_bin+nx)]);
                // 上面是第2层的rhocell结束，也就是x=1这一层

                // x2
                MVec p1wzsx2sysz0 = svread_hor_za64_m(vzero,p0,2,0); 
                MVec p1wzsx2sysz1 = svread_hor_za64_m(vzero,p0,2,1); 
                MVec p1wzs4=svsplice(p0,p1wzsx2sysz0, p1wzsx2sysz1); 
                MVec p2wzsx2sysz0 = svread_hor_za64_m(vzero,p1,2,4); 
                MVec p2wzsx2sysz1 = svread_hor_za64_m(vzero,p1,2,5);
                MVec p2wzs4 = svext(p2wzsx2sysz0,svext(p2wzsx2sysz1,p2wzsx2sysz1,4),4); 
                MVec zrhocells4 = MVec::Load(p,&zrhocells[8*(old_bin-nx+1)]); 
                zrhocells4+=(p1wzs4+p2wzs4); //两个粒子最终加总一次
                zrhocells4.Store(p,&zrhocells[8*(old_bin-nx+1)]); 

                MVec p1wzsx2sysz2 = svread_hor_za64_m(vzero,p0,2,2); 
                MVec p1wzsx2sysz3 = svread_hor_za64_m(vzero,p0,2,3);
                MVec p1wzs5=svsplice(p0,p1wzsx2sysz0, p1wzsx2sysz1); 
                MVec p2wzsx2sysz2 = svread_hor_za64_m(vzero,p1,2,6); 
                MVec p2wzsx2sysz3 = svread_hor_za64_m(vzero,p1,2,7);
                MVec p2wzs5 = svext(p2wzsx2sysz2,svext(p2wzsx2sysz3,p2wzsx2sysz3,4),4); 
                MVec zrhocells5 = MVec::Load(p,&zrhocells[8*(old_bin+nx+1)]); 
                zrhocells5+=(p1wzs5+p2wzs5);//两个粒子最终加总一次
                zrhocells5.Store(p,&zrhocells[8*(old_bin+nx+1)]);
                // 上面是第3层的rhocell结束，也就是x=2这一层

                // x3
                MVec p1wzsx3sysz0 = svread_hor_za64_m(vzero,p0,3,0); 
                MVec p1wzsx3sysz1 = svread_hor_za64_m(vzero,p0,3,1); 
                MVec p1wzs6=svsplice(p0,p1wzsx3sysz0, p1wzsx3sysz1); 
                MVec p2wzsx3sysz0 = svread_hor_za64_m(vzero,p1,3,4); 
                MVec p2wzsx3sysz1 = svread_hor_za64_m(vzero,p1,3,5);
                MVec p2wzs6 = svext(p2wzsx3sysz0,svext(p2wzsx3sysz1,p2wzsx3sysz1,4),4); 
                MVec zrhocells6 = MVec::Load(p,&zrhocells[8*(old_bin-nx+2)]); 
                zrhocells6+=(p1wzs6+p2wzs6); //两个粒子最终加总一次
                zrhocells6.Store(p,&zrhocells[8*(old_bin-nx+2)]); 

                MVec p1wzsx3sysz2 = svread_hor_za64_m(vzero,p0,3,2); 
                MVec p1wzsx3sysz3 = svread_hor_za64_m(vzero,p0,3,3);
                MVec p1wzs7=svsplice(p0,p1wzsx3sysz0, p1wzsx3sysz1); 
                MVec p2wzsx3sysz2 = svread_hor_za64_m(vzero,p1,3,6); 
                MVec p2wzsx3sysz3 = svread_hor_za64_m(vzero,p1,3,7);
                MVec p2wzs7 = svext(p2wzsx3sysz2,svext(p2wzsx3sysz3,p2wzsx3sysz3,4),4); 
                MVec zrhocells7 = MVec::Load(p,&zrhocells[8*(old_bin+nx+2)]); 
                zrhocells7+=(p1wzs7+p2wzs7);//两个粒子最终加总一次
                zrhocells7.Store(p,&zrhocells[8*(old_bin+nx+2)]);
                // 上面是第4层的rhocell结束，也就是x=3这一层
            }
    //     }
    // }
}

// 这个版本是每次mopa计算完然后直接读写入
// 这个版本不需要排序，修改后变成3阶的pure sme消融实验
template <int depos_order>
__arm_new("za") void sort_3d_sme_kernal_order_3_pure_sme (
    const std::vector<int>& local_index,
    const std::vector<int>& bin_length,
    const std::vector<int>& bin_offsets,
    std::vector<amrex::Real>& xrhocells,
    std::vector<amrex::Real>& yrhocells,
    std::vector<amrex::Real>& zrhocells,
    std::vector<amrex::Real>& sx_m,
    std::vector<amrex::Real>& sy_m,
    std::vector<amrex::Real>& sz_m,
    std::vector<amrex::Real>& wqx,
    std::vector<amrex::Real>& wqy,
    std::vector<amrex::Real>& wqz,
    amrex::Dim3 len, int np, int numcell,
    int xjstride,int xkstride,
    std::vector<amrex::Real>& testsxwq
)__arm_streaming {
    using namespace amrex::literals;
    int nshape = 4;
    
    svbool_t p = svptrue_b64();
    svbool_t p0=svwhilelt_b64(0,4); // 前4个的谓词
    svbool_t p1=svbic_z(p,p, p0); // 后4个的谓词
    MVec vzero(0);

    int binnx = len.x;
    int binny = len.y;
    int binnxy = binnx*binny;
    int rhonx = len.x-2;
    int rhonxy = rhonx*len.y;

    // int nx=xjstride-1;
    // int nxy=xkstride-33;
    // int moff[8] = {-nxy,0,nxy,2*nxy,nx-nxy,nx,nx+nxy,nx+2*nxy};
    // printf("old in\n");
    // for (int old_bin = 1; old_bin <= numcell; old_bin++) {
    // printf("len x %d y %d z %d xjstride %d xkstride %d\n",
    //     len.x,len.y,len.z,xjstride,xkstride);
    for (int iz = 0; iz < len.z-2; ++iz) {
        for (int iy = 0; iy < len.y-2; ++iy) {       
            for (int ix = 0; ix < len.x-2; ix++) {
                int old_bin=(ix) + (iy) * binnx + (iz) * binnxy;
                int rho_bin=ix+iy*rhonx+iz*rhonxy;
                // printf(" %d %d*%d %d*%d old %d/%d bin_length %d \n"
                //     ,ix,iy,xjstride,iz,xkstride
                //     ,old_bin,numcell,bin_length[old_bin]);
                std::vector<int> ip_list;
                // Jxarr = wqx*sx*sy*sz
                if (bin_length[old_bin] == 0) continue;
                int start = bin_offsets[old_bin];
                int end = bin_offsets[old_bin+1];
                svzero_za();

                int first_idx=-1;
                for(int i=start;i<end;i++){
                    // printf("start %d end %d local_index %d \n",start,end,local_index[i]);
                    if (local_index[i] == INVALID_PARTICLE_ID) {
                        // idx1++;
                        continue;
                    } 
                    if(first_idx<0){
                        first_idx=i;
                    }else{
                        svzero_za();
                        int idx1 = first_idx;
                        int idx2=i;
                        int ip1 = local_index[idx1];
                        ip_list.push_back(ip1);
                        int ip2 = local_index[idx2];
                        ip_list.push_back(ip2);
                        // printf("ip1 %d ip2 %d\n",ip1,ip2);

                        // sx0sy x sz
                        MVec p1wqxsy = svld1(p0,&sy_m[ip1*nshape])*wqx[ip1];
                        MVec p1sz0sy = p1wqxsy*sz_m[ip1*nshape+0];// first 4 (1111 0000)
                        MVec p2wqxsy = svld1(p1,&sy_m[(ip2-1)*nshape])*wqx[ip2];
                        MVec p2sz0sy = p2wqxsy*sz_m[(ip2)*nshape+0]; // only last 4 (0000 1111)
                        MVec sz0sy = svsel(p0,p1sz0sy,p2sz0sy);
                        //====================
                        // double A[8]={0.};
                        // sx0sy.Store(p,&A[0]);
                        // printf("Test sxsy:");
                        // for(int ii=0;ii<8;ii++){
                        //     printf("\tsxsy[%d]: %f\n",ii,A[ii]);
                        // }
                        //======================

                        MVec p1sx = svld1(p0,&sx_m[ip1*nshape]);
                        MVec p2sx = svld1(p1,&sx_m[(ip2-1)*nshape]);
                        MVec sx = svsel(p0,p1sx,p2sx);

                        svmopa_za64_m(0, p, p, sz0sy, sx);

                        // sx1sy x sz
                        MVec p1sz1sy = p1wqxsy*sz_m[ip1*nshape+1];
                        MVec p2sz1sy = p2wqxsy*sz_m[(ip2)*nshape+1];
                        MVec sz1sy = svsel(p0,p1sz1sy,p2sz1sy);
                        svmopa_za64_m(1, p, p, sz1sy, sx);

                        // sx2sy x sz
                        MVec p1sz2sy = p1wqxsy*sz_m[ip1*nshape+2];
                        MVec p2sz2sy = p2wqxsy*sz_m[(ip2)*nshape+2];
                        MVec sz2sy = svsel(p0,p1sz2sy,p2sz2sy);
                        svmopa_za64_m(2, p, p, sz2sy, sx);

                        // sx3sy x sz
                        MVec p1sz3sy = p1wqxsy*sz_m[ip1*nshape+3];
                        MVec p2sz3sy = p2wqxsy*sz_m[(ip2)*nshape+3];
                        MVec sz3sy = svsel(p0,p1sz3sy,p2sz3sy);
                        svmopa_za64_m(3, p, p, sz3sy, sx);

                        first_idx=-1;
                        // x0
                        MVec p1wxsz0sysx0 = svread_hor_za64_m(vzero,p0,0,0); //第一个粒子第一层（总共4层）第一组的第1行，11110000
                        MVec p1wxsz0sysx1 = svread_hor_za64_m(vzero,p0,0,1); //第一个粒子第一层（总共4层）第一组的第2行，11110000
                        MVec p1s0=svsplice(p0,p1wxsz0sysx0, p1wxsz0sysx1); //粒子1第一组8个数
                        MVec p2wxsz0sysx0 = svread_hor_za64_m(vzero,p1,0,4); //第2个粒子同理，但是00001111
                        MVec p2wxsz0sysx1 = svread_hor_za64_m(vzero,p1,0,5);
                        MVec p2s0 = svext(p2wxsz0sysx0,svext(p2wxsz0sysx1,p2wxsz0sysx1,4),4); //组织成第2个粒子的第一组8个数
                        MVec xrhocells0 = MVec::Load(p,&xrhocells[8*(rho_bin)]); //对于jx的第1个rhocell，位置ic-nx-1
                        xrhocells0+=(p1s0+p2s0); //两个粒子最终加总一次
                        xrhocells0.Store(p,&xrhocells[8*(rho_bin)]); //写回第1组的rhocell
                        
                        MVec p1wxsz0sysx2 = svread_hor_za64_m(vzero,p0,0,2); //第一层粒子1第2组的第1行
                        MVec p1wxsz0sysx3 = svread_hor_za64_m(vzero,p0,0,3);
                        MVec p1s1=svsplice(p0,p1wxsz0sysx2, p1wxsz0sysx3); //粒子1第2组8个数
                        MVec p2wxsz0sysx2 = svread_hor_za64_m(vzero,p1,0,6); //第一层粒子2第2组的第1行
                        MVec p2wxsz0sysx3 = svread_hor_za64_m(vzero,p1,0,7);
                        MVec p2s1 = svext(p2wxsz0sysx2,svext(p2wxsz0sysx3,p2wxsz0sysx3,4),4); //组织成粒子2第2组8个数
                        MVec xrhocells1 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonx)]); //第二个rhocell
                        xrhocells1+=(p1s1+p2s1);//两个粒子最终加总一次
                        xrhocells1.Store(p,&xrhocells[8*(rho_bin+2*rhonx)]);//写回第2组的rhocell
                        // 上面是第一层的rhocell结束，也就是x=0这一层
                        //==========================
                        p1s0.Store(p,&testsxwq[ip1*64]);
                        p2s0.Store(p,&testsxwq[ip2*64]);
                        p1s1.Store(p,&testsxwq[ip1*64+8]);
                        p2s1.Store(p,&testsxwq[ip2*64+8]);
                        // double A[8]={0.};
                        // int yy[8]={-1,-1,-1,-1, 0,0,0,0};
                        // int zz[8]={-1, 0, 1, 2,-1,0,1,2};
                        // p1s0.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip1,ix-1,iy+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        // p2s0.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip2,ix-1,iy+yy[ii],iz+zz[ii],A[ii]);
                        // }

                        // p1s1.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip1,ix-1,iy+2+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        // p2s1.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip2,ix-1,iy+2+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        //======================

                        // x1
                        MVec p1wxsz1sysx0 = svread_hor_za64_m(vzero,p0,1,0); //第一个粒子第2层（总共4层）第3组的第1行，11110000
                        MVec p1wxsz1sysx1 = svread_hor_za64_m(vzero,p0,1,1); //第一个粒子第2层（总共4层）第3组的第2行，11110000
                        MVec p1s2=svsplice(p0,p1wxsz1sysx0, p1wxsz1sysx1); 
                        MVec p2wxsz1sysx0 = svread_hor_za64_m(vzero,p1,1,4); 
                        MVec p2wxsz1sysx1 = svread_hor_za64_m(vzero,p1,1,5);
                        MVec p2s2 = svext(p2wxsz1sysx0,svext(p2wxsz1sysx1,p2wxsz1sysx1,4),4); 
                        MVec xrhocells2 = MVec::Load(p,&xrhocells[8*(rho_bin+rhonxy)]); 
                        xrhocells2+=(p1s2+p2s2); //两个粒子最终加总一次
                        xrhocells2.Store(p,&xrhocells[8*(rho_bin+rhonxy)]); 

                        MVec p1wxsz1sysx2 = svread_hor_za64_m(vzero,p0,1,2); 
                        MVec p1wxsz1sysx3 = svread_hor_za64_m(vzero,p0,1,3);
                        MVec p1s3=svsplice(p0,p1wxsz1sysx2, p1wxsz1sysx3); 
                        MVec p2wxsz1sysx2 = svread_hor_za64_m(vzero,p1,1,6); 
                        MVec p2wxsz1sysx3 = svread_hor_za64_m(vzero,p1,1,7);
                        MVec p2s3 = svext(p2wxsz1sysx2,svext(p2wxsz1sysx3,p2wxsz1sysx3,4),4); 
                        MVec xrhocells3 = MVec::Load(p,&xrhocells[8*(rho_bin+rhonxy+2*rhonx)]); 
                        xrhocells3+=(p1s3+p2s3);//两个粒子最终加总一次
                        xrhocells3.Store(p,&xrhocells[8*(rho_bin+rhonxy+2*rhonx)]);
                        // 上面是第2层的rhocell结束，也就是x=1这一层
                        //========================
                        p1s2.Store(p,&testsxwq[ip1*64+8*2]);
                        p2s2.Store(p,&testsxwq[ip2*64+8*2]);
                        p1s3.Store(p,&testsxwq[ip1*64+8*3]);
                        p2s3.Store(p,&testsxwq[ip2*64+8*3]);
                        // p1s0.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip1,ix,iy+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        // p2s0.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip2,ix,iy+yy[ii],iz+zz[ii],A[ii]);
                        // }

                        // p1s1.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip1,ix,iy+2+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        // p2s1.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip2,ix,iy+2+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        //======================

                        // x2
                        MVec p1wxsz2sysx0 = svread_hor_za64_m(vzero,p0,2,0); 
                        MVec p1wxsz2sysx1 = svread_hor_za64_m(vzero,p0,2,1); 
                        MVec p1s4=svsplice(p0,p1wxsz2sysx0, p1wxsz2sysx1); 
                        MVec p2wxsz2sysx0 = svread_hor_za64_m(vzero,p1,2,4); 
                        MVec p2wxsz2sysx1 = svread_hor_za64_m(vzero,p1,2,5);
                        MVec p2s4 = svext(p2wxsz2sysx0,svext(p2wxsz2sysx1,p2wxsz2sysx1,4),4); 
                        MVec xrhocells4 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy)]); 
                        xrhocells4+=(p1s4+p2s4); //两个粒子最终加总一次
                        xrhocells4.Store(p,&xrhocells[8*(rho_bin+2*rhonxy)]); 

                        MVec p1wxsz2sysx2 = svread_hor_za64_m(vzero,p0,2,2); 
                        MVec p1wxsz2sysx3 = svread_hor_za64_m(vzero,p0,2,3);
                        MVec p1s5=svsplice(p0,p1wxsz2sysx2, p1wxsz2sysx3); 
                        MVec p2wxsz2sysx2 = svread_hor_za64_m(vzero,p1,2,6); 
                        MVec p2wxsz2sysx3 = svread_hor_za64_m(vzero,p1,2,7);
                        MVec p2s5 = svext(p2wxsz2sysx2,svext(p2wxsz2sysx3,p2wxsz2sysx3,4),4); 
                        MVec xrhocells5 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+2*rhonx)]); 
                        xrhocells5+=(p1s5+p2s5);//两个粒子最终加总一次
                        xrhocells5.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+2*rhonx)]);
                        // 上面是第3层的rhocell结束，也就是x=2这一层
                        //========================
                        p1s4.Store(p,&testsxwq[ip1*64+8*4]);
                        p2s4.Store(p,&testsxwq[ip2*64+8*4]);
                        p1s5.Store(p,&testsxwq[ip1*64+8*5]);
                        p2s5.Store(p,&testsxwq[ip2*64+8*5]);
                        // p1s0.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip1,ix+1,iy+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        // p2s0.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip2,ix+1,iy+yy[ii],iz+zz[ii],A[ii]);
                        // }

                        // p1s1.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip1,ix+1,iy+2+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        // p2s1.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip2,ix+1,iy+2+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        //======================

                        // x3
                        MVec p1wxsz3sysx0 = svread_hor_za64_m(vzero,p0,3,0); 
                        MVec p1wxsz3sysx1 = svread_hor_za64_m(vzero,p0,3,1); 
                        MVec p1s6=svsplice(p0,p1wxsz3sysx0, p1wxsz3sysx1); 
                        MVec p2wxsz3sysx0 = svread_hor_za64_m(vzero,p1,3,4); 
                        MVec p2wxsz3sysx1 = svread_hor_za64_m(vzero,p1,3,5);
                        MVec p2s6 = svext(p2wxsz3sysx0,svext(p2wxsz3sysx1,p2wxsz3sysx1,4),4); 
                        MVec xrhocells6 = MVec::Load(p,&xrhocells[8*(rho_bin+rhonxy*3)]); 
                        xrhocells6+=(p1s6+p2s6); //两个粒子最终加总一次
                        xrhocells6.Store(p,&xrhocells[8*(rho_bin+rhonxy*3)]); 

                        MVec p1wxsz3sysx2 = svread_hor_za64_m(vzero,p0,3,2); 
                        MVec p1wxsz3sysx3 = svread_hor_za64_m(vzero,p0,3,3);
                        MVec p1s7=svsplice(p0,p1wxsz3sysx2, p1wxsz3sysx3); 
                        MVec p2wxsz3sysx2 = svread_hor_za64_m(vzero,p1,3,6); 
                        MVec p2wxsz3sysx3 = svread_hor_za64_m(vzero,p1,3,7);
                        MVec p2s7 = svext(p2wxsz3sysx2,svext(p2wxsz3sysx3,p2wxsz3sysx3,4),4); 
                        MVec xrhocells7 = MVec::Load(p,&xrhocells[8*(rho_bin+rhonxy*3+2*rhonx)]); 
                        xrhocells7+=(p1s7+p2s7);//两个粒子最终加总一次
                        xrhocells7.Store(p,&xrhocells[8*(rho_bin+rhonxy*3+2*rhonx)]);
                        //========================
                        p1s6.Store(p,&testsxwq[ip1*64+8*6]);
                        p2s6.Store(p,&testsxwq[ip2*64+8*6]);
                        p1s7.Store(p,&testsxwq[ip1*64+8*7]);
                        p2s7.Store(p,&testsxwq[ip2*64+8*7]);
                        // p1s0.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip1,ix+2,iy+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        // p2s0.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip2,ix+2,iy+yy[ii],iz+zz[ii],A[ii]);
                        // }

                        // p1s1.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip1,ix+2,iy+2+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        // p2s1.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip2,ix+2,iy+2+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        //======================
                    }  
                }
                if(first_idx>=0){
                    svzero_za();
                    int ip1 = local_index[first_idx];
                    ip_list.push_back(ip1);
                    //=================
                    // printf("single partile!\n");
                    // exit(0);
                    //=================

                    // sx0sy x sz
                    MVec wqxsy = svld1(p0,&sy_m[ip1*nshape])*wqx[ip1];
                    MVec sz0sy = wqxsy*sz_m[ip1*nshape+0];// first 4 (1111 0000)
                    MVec sx = svld1(p0,&sx_m[ip1*nshape]);
                    svmopa_za64_m(0, p0, p0, sz0sy, sx);

                    MVec wxsz0sysx0 = svread_hor_za64_m(vzero,p0,0,0); //第一个粒子第一层（总共4层）第一组的第1行，11110000
                    MVec wxsz0sysx1 = svread_hor_za64_m(vzero,p0,0,1); //第一个粒子第一层（总共4层）第一组的第2行，11110000
                    MVec s0=svsplice(p0,wxsz0sysx0, wxsz0sysx1); //粒子1第一组8个数
                    MVec xrhocells0 = MVec::Load(p,&xrhocells[8*(rho_bin)]); //对于jx的第1个rhocell，位置ic-nx-1
                    xrhocells0+=s0; //两个粒子最终加总一次
                    xrhocells0.Store(p,&xrhocells[8*(rho_bin)]); //写回第1组的rhocell
                     
                    MVec wxsz0sysx2 = svread_hor_za64_m(vzero,p0,0,2); //第一层粒子1第2组的第1行
                    MVec wxsz0sysx3 = svread_hor_za64_m(vzero,p0,0,3);
                    MVec s1=svsplice(p0,wxsz0sysx2, wxsz0sysx3); //粒子1第2组8个数
                    MVec xrhocells1 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonx)]); //第二个rhocell
                    xrhocells1+=(s1);//两个粒子最终加总一次
                    xrhocells1.Store(p,&xrhocells[8*(rho_bin+2*rhonx)]);//写回第2组的rhocell
                    //==========================
                    s0.Store(p,&testsxwq[ip1*64]);
                    s1.Store(p,&testsxwq[ip1*64+8]);
                    //============================= 

                    // sz1sy x sx
                    MVec sz1sy = wqxsy*sz_m[ip1*nshape+1];
                    svmopa_za64_m(1, p0, p0, sz1sy, sx);

                    MVec wxsz1sysx0 = svread_hor_za64_m(vzero,p0,1,0); //第一个粒子第一层（总共4层）第一组的第1行，11110000
                    MVec wxsz1sysx1 = svread_hor_za64_m(vzero,p0,1,1); //第一个粒子第一层（总共4层）第一组的第2行，11110000
                    MVec s2=svsplice(p0,wxsz1sysx0, wxsz1sysx1); //粒子1第一组8个数
                    MVec xrhocells2 = MVec::Load(p,&xrhocells[8*(rho_bin+rhonxy)]); //对于jx的第1个rhocell，位置ic-nx-1
                    xrhocells2+=s2; //两个粒子最终加总一次
                    xrhocells2.Store(p,&xrhocells[8*(rho_bin+rhonxy)]); //写回第1组的rhocell
                     
                    MVec wxsz1sysx2 = svread_hor_za64_m(vzero,p0,1,2); //第一层粒子1第2组的第1行
                    MVec wxsz1sysx3 = svread_hor_za64_m(vzero,p0,1,3);
                    MVec s3=svsplice(p0,wxsz1sysx2, wxsz1sysx3); //粒子1第2组8个数
                    MVec xrhocells3 = MVec::Load(p,&xrhocells[8*(rho_bin+rhonxy+2*rhonx)]); //第二个rhocell
                    xrhocells3+=(s3);//两个粒子最终加总一次
                    xrhocells3.Store(p,&xrhocells[8*(rho_bin+rhonxy+2*rhonx)]);//写回第2组的rhocell
                    //==========================
                    s2.Store(p,&testsxwq[ip1*64+8*2]);
                    s3.Store(p,&testsxwq[ip1*64+8*3]);
                    //============================= 

                    // sz2sy x sx
                    MVec sz2sy = wqxsy*sz_m[ip1*nshape+2];
                    svmopa_za64_m(2, p0, p0, sz2sy, sx);

                    MVec wxsz2sysx0 = svread_hor_za64_m(vzero,p0,2,0); //第一个粒子第一层（总共4层）第一组的第1行，11110000
                    MVec wxsz2sysx1 = svread_hor_za64_m(vzero,p0,2,1); //第一个粒子第一层（总共4层）第一组的第2行，11110000
                    MVec s4=svsplice(p0,wxsz2sysx0, wxsz2sysx1); //粒子1第一组8个数
                    MVec xrhocells4 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy)]); //对于jx的第1个rhocell，位置ic-nx-1
                    xrhocells4+=s4; //两个粒子最终加总一次
                    xrhocells4.Store(p,&xrhocells[8*(rho_bin+2*rhonxy)]); //写回第1组的rhocell
                     
                    MVec wxsz2sysx2 = svread_hor_za64_m(vzero,p0,2,2); //第一层粒子1第2组的第1行
                    MVec wxsz2sysx3 = svread_hor_za64_m(vzero,p0,2,3);
                    MVec s5=svsplice(p0,wxsz2sysx2, wxsz2sysx3); //粒子1第2组8个数
                    MVec xrhocells5 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+2*rhonx)]); //第二个rhocell
                    xrhocells5+=(s5);//两个粒子最终加总一次
                    xrhocells5.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+2*rhonx)]);//写回第2组的rhocell
                    //==========================
                    s4.Store(p,&testsxwq[ip1*64+8*4]);
                    s5.Store(p,&testsxwq[ip1*64+8*5]);
                    //============================= 

                    // sz3sy x sx
                    MVec sz3sy = wqxsy*sz_m[ip1*nshape+3];
                    svmopa_za64_m(3, p0, p0, sz3sy, sx);

                    MVec wxsz3sysx0 = svread_hor_za64_m(vzero,p0,3,0); //第一个粒子第一层（总共4层）第一组的第1行，11110000
                    MVec wxsz3sysx1 = svread_hor_za64_m(vzero,p0,3,1); //第一个粒子第一层（总共4层）第一组的第2行，11110000
                    MVec s6=svsplice(p0,wxsz3sysx0, wxsz3sysx1); //粒子1第一组8个数
                    MVec xrhocells6 = MVec::Load(p,&xrhocells[8*(rho_bin+3*rhonxy)]); //对于jx的第1个rhocell，位置ic-nx-1
                    xrhocells6+=s6; //两个粒子最终加总一次
                    xrhocells6.Store(p,&xrhocells[8*(rho_bin+3*rhonxy)]); //写回第1组的rhocell
                     
                    MVec wxsz3sysx2 = svread_hor_za64_m(vzero,p0,3,2); //第一层粒子1第2组的第1行
                    MVec wxsz3sysx3 = svread_hor_za64_m(vzero,p0,3,3);
                    MVec s7=svsplice(p0,wxsz3sysx2, wxsz3sysx3); //粒子1第2组8个数
                    MVec xrhocells7 = MVec::Load(p,&xrhocells[8*(rho_bin+3*rhonxy+2*rhonx)]); //第二个rhocell
                    xrhocells7+=(s7);//两个粒子最终加总一次
                    xrhocells7.Store(p,&xrhocells[8*(rho_bin+3*rhonxy+2*rhonx)]);//写回第2组的rhocell
                    //==========================
                    s6.Store(p,&testsxwq[ip1*64+8*6]);
                    s7.Store(p,&testsxwq[ip1*64+8*7]);
                    //============================= 
                }
                
                
                // x0
                // MVec p1wxsx0sysz0 = svread_hor_za64_m(vzero,p0,0,0); //第一个粒子第一层（总共4层）第一组的第1行，11110000
                // MVec p1wxsx0sysz1 = svread_hor_za64_m(vzero,p0,0,1); //第一个粒子第一层（总共4层）第一组的第2行，11110000
                // MVec p1s0=svsplice(p0,p1wxsx0sysz0, p1wxsx0sysz1); //粒子1第一组8个数
                // MVec p2wxsx0sysz0 = svread_hor_za64_m(vzero,p1,0,4); //第2个粒子同理，但是00001111
                // MVec p2wxsx0sysz1 = svread_hor_za64_m(vzero,p1,0,5);
                // MVec p2s0 = svext(p2wxsx0sysz0,svext(p2wxsx0sysz1,p2wxsx0sysz1,4),4); //组织成第2个粒子的第一组8个数
                // MVec xrhocells0 = MVec::Load(p,&xrhocells[8*(old_bin-nx-1)]); //对于jx的第1个rhocell，位置ic-nx-1
                // xrhocells0+=(p1s0+p2s0); //两个粒子最终加总一次
                // xrhocells0.Store(p,&xrhocells[8*(old_bin-nx-1)]); //写回第1组的rhocell

                // MVec p1wxsx0sysz2 = svread_hor_za64_m(vzero,p0,0,2); //第一层粒子1第2组的第1行
                // MVec p1wxsx0sysz3 = svread_hor_za64_m(vzero,p0,0,3);
                // MVec p1s1=svsplice(p0,p1wxsx0sysz0, p1wxsx0sysz1); //粒子1第2组8个数
                // MVec p2wxsx0sysz2 = svread_hor_za64_m(vzero,p1,0,6); //第一层粒子2第2组的第1行
                // MVec p2wxsx0sysz3 = svread_hor_za64_m(vzero,p1,0,7);
                // MVec p2s1 = svext(p2wxsx0sysz2,svext(p2wxsx0sysz3,p2wxsx0sysz3,4),4); //组织成粒子2第2组8个数
                // MVec xrhocells1 = MVec::Load(p,&xrhocells[8*(old_bin+nx-1)]); //第二个rhocell
                // xrhocells1+=(p1s1+p2s1);//两个粒子最终加总一次
                // xrhocells1.Store(p,&xrhocells[8*(old_bin+nx-1)]);//写回第2组的rhocell
                // // 上面是第一层的rhocell结束，也就是x=0这一层

                // // x1
                // MVec p1wxsx1sysz0 = svread_hor_za64_m(vzero,p0,1,0); //第一个粒子第2层（总共4层）第3组的第1行，11110000
                // MVec p1wxsx1sysz1 = svread_hor_za64_m(vzero,p0,1,1); //第一个粒子第2层（总共4层）第3组的第2行，11110000
                // MVec p1s2=svsplice(p0,p1wxsx1sysz0, p1wxsx1sysz1); 
                // MVec p2wxsx1sysz0 = svread_hor_za64_m(vzero,p1,1,4); 
                // MVec p2wxsx1sysz1 = svread_hor_za64_m(vzero,p1,1,5);
                // MVec p2s2 = svext(p2wxsx1sysz0,svext(p2wxsx1sysz1,p2wxsx1sysz1,4),4); 
                // MVec xrhocells2 = MVec::Load(p,&xrhocells[8*(old_bin-nx)]); 
                // xrhocells2+=(p1s2+p2s2); //两个粒子最终加总一次
                // xrhocells2.Store(p,&xrhocells[8*(old_bin-nx)]); 

                // MVec p1wxsx1sysz2 = svread_hor_za64_m(vzero,p0,1,2); 
                // MVec p1wxsx1sysz3 = svread_hor_za64_m(vzero,p0,1,3);
                // MVec p1s3=svsplice(p0,p1wxsx1sysz0, p1wxsx1sysz1); 
                // MVec p2wxsx1sysz2 = svread_hor_za64_m(vzero,p1,1,6); 
                // MVec p2wxsx1sysz3 = svread_hor_za64_m(vzero,p1,1,7);
                // MVec p2s3 = svext(p2wxsx1sysz2,svext(p2wxsx1sysz3,p2wxsx1sysz3,4),4); 
                // MVec xrhocells3 = MVec::Load(p,&xrhocells[8*(old_bin+nx)]); 
                // xrhocells3+=(p1s3+p2s3);//两个粒子最终加总一次
                // xrhocells3.Store(p,&xrhocells[8*(old_bin+nx)]);
                // // 上面是第2层的rhocell结束，也就是x=1这一层

                // // x2
                // MVec p1wxsx2sysz0 = svread_hor_za64_m(vzero,p0,2,0); 
                // MVec p1wxsx2sysz1 = svread_hor_za64_m(vzero,p0,2,1); 
                // MVec p1s4=svsplice(p0,p1wxsx2sysz0, p1wxsx2sysz1); 
                // MVec p2wxsx2sysz0 = svread_hor_za64_m(vzero,p1,2,4); 
                // MVec p2wxsx2sysz1 = svread_hor_za64_m(vzero,p1,2,5);
                // MVec p2s4 = svext(p2wxsx2sysz0,svext(p2wxsx2sysz1,p2wxsx2sysz1,4),4); 
                // MVec xrhocells4 = MVec::Load(p,&xrhocells[8*(old_bin-nx+1)]); 
                // xrhocells4+=(p1s4+p2s4); //两个粒子最终加总一次
                // xrhocells4.Store(p,&xrhocells[8*(old_bin-nx+1)]); 

                // MVec p1wxsx2sysz2 = svread_hor_za64_m(vzero,p0,2,2); 
                // MVec p1wxsx2sysz3 = svread_hor_za64_m(vzero,p0,2,3);
                // MVec p1s5=svsplice(p0,p1wxsx2sysz0, p1wxsx2sysz1); 
                // MVec p2wxsx2sysz2 = svread_hor_za64_m(vzero,p1,2,6); 
                // MVec p2wxsx2sysz3 = svread_hor_za64_m(vzero,p1,2,7);
                // MVec p2s5 = svext(p2wxsx2sysz2,svext(p2wxsx2sysz3,p2wxsx2sysz3,4),4); 
                // MVec xrhocells5 = MVec::Load(p,&xrhocells[8*(old_bin+nx+1)]); 
                // xrhocells5+=(p1s5+p2s5);//两个粒子最终加总一次
                // xrhocells5.Store(p,&xrhocells[8*(old_bin+nx+1)]);
                // // 上面是第3层的rhocell结束，也就是x=2这一层

                // // x3
                // MVec p1wxsx3sysz0 = svread_hor_za64_m(vzero,p0,3,0); 
                // MVec p1wxsx3sysz1 = svread_hor_za64_m(vzero,p0,3,1); 
                // MVec p1s6=svsplice(p0,p1wxsx3sysz0, p1wxsx3sysz1); 
                // MVec p2wxsx3sysz0 = svread_hor_za64_m(vzero,p1,3,4); 
                // MVec p2wxsx3sysz1 = svread_hor_za64_m(vzero,p1,3,5);
                // MVec p2s6 = svext(p2wxsx3sysz0,svext(p2wxsx3sysz1,p2wxsx3sysz1,4),4); 
                // MVec xrhocells6 = MVec::Load(p,&xrhocells[8*(old_bin-nx+2)]); 
                // xrhocells6+=(p1s6+p2s6); //两个粒子最终加总一次
                // xrhocells6.Store(p,&xrhocells[8*(old_bin-nx+2)]); 

                // MVec p1wxsx3sysz2 = svread_hor_za64_m(vzero,p0,3,2); 
                // MVec p1wxsx3sysz3 = svread_hor_za64_m(vzero,p0,3,3);
                // MVec p1s7=svsplice(p0,p1wxsx3sysz0, p1wxsx3sysz1); 
                // MVec p2wxsx3sysz2 = svread_hor_za64_m(vzero,p1,3,6); 
                // MVec p2wxsx3sysz3 = svread_hor_za64_m(vzero,p1,3,7);
                // MVec p2s7 = svext(p2wxsx3sysz2,svext(p2wxsx3sysz3,p2wxsx3sysz3,4),4); 
                // MVec xrhocells7 = MVec::Load(p,&xrhocells[8*(old_bin+nx+2)]); 
                // xrhocells7+=(p1s7+p2s7);//两个粒子最终加总一次
                // xrhocells7.Store(p,&xrhocells[8*(old_bin+nx+2)]);
                // 上面是第4层的rhocell结束，也就是x=3这一层
            }
        }
    }
}

// 这个是普通的一次算两个点排序的最终版本，名为v1
// 这个版本和1阶是同一个思路，目前只有x方向一个
template <int depos_order>
__arm_new("za") inline void sort_3d_sme_kernal_order_3_test (
    const std::vector<int>& local_index,
    const std::vector<int>& bin_length,
    const std::vector<int>& bin_offsets,
    std::vector<amrex::Real>& xrhocells,
    std::vector<amrex::Real>& yrhocells,
    std::vector<amrex::Real>& zrhocells,
    std::vector<amrex::Real>& sx_m,
    std::vector<amrex::Real>& sy_m,
    std::vector<amrex::Real>& sz_m,
    std::vector<amrex::Real>& wqx,
    std::vector<amrex::Real>& wqy,
    std::vector<amrex::Real>& wqz,
    amrex::Dim3 len, int np, int numcell,
    int xjstride,int xkstride,
    std::vector<amrex::Real>& testsxwq
)__arm_streaming {
    using namespace amrex::literals;
    uint64_t indexing=0;
    uint64_t dataprepare=0;
    uint64_t mopa=0;
    uint64_t reducing=0;
    uint64_t svetime[3]={0};

    svetime[0]=rdtscm();
    int nshape = 4;
    
    svbool_t p = svptrue_b64();
    svbool_t p0=svwhilelt_b64(0,4); // 前4个的谓词
    svbool_t p1=svbic_z(p,p, p0); // 后4个的谓词
    MVec vzero(0);

    int binnx = len.x;
    int binny = len.y;
    int binnxy = binnx*binny;
    int rhonx = len.x-2;
    int rhonxy = rhonx*len.y;
    svetime[1]=rdtscm();
    dataprepare+=(svetime[1]-svetime[0]);
 
    // int nx=xjstride-1;
    // int nxy=xkstride-33;
    // int moff[8] = {-nxy,0,nxy,2*nxy,nx-nxy,nx,nx+nxy,nx+2*nxy};
    // printf("old in\n");
    // for (int old_bin = 1; old_bin <= numcell; old_bin++) {
    // printf("len x %d y %d z %d xjstride %d xkstride %d\n",
    //     len.x,len.y,len.z,xjstride,xkstride);
    for (int iz = 0; iz < len.z-2; ++iz) {
        for (int iy = 0; iy < len.y-2; ++iy) {       
            for (int ix = 0; ix < len.x-2; ix++) {

                svetime[0]=rdtscm();
                int old_bin=(ix) + (iy) * binnx + (iz) * binnxy;
                int rho_bin=ix+iy*rhonx+iz*rhonxy;
                // printf(" %d %d*%d %d*%d old %d/%d bin_length %d \n"
                //     ,ix,iy,xjstride,iz,xkstride
                //     ,old_bin,numcell,bin_length[old_bin]);
                std::vector<int> ip_list;
                // Jxarr = wqx*sx*sy*sz
                if (bin_length[old_bin] == 0) continue;
                int start = bin_offsets[old_bin];
                int end = bin_offsets[old_bin+1];
                svzero_za();

                int first_idx=-1;
                svetime[1]=rdtscm();
                indexing+=(svetime[1]-svetime[0]); 
                for(int i=start;i<end;i++){
                    svetime[0]=rdtscm();

                    // printf("start %d end %d local_index %d \n",start,end,local_index[i]);
                    if (local_index[i] == INVALID_PARTICLE_ID) {
                        // idx1++;
                        continue;
                    } 
                    if(first_idx<0){
                        first_idx=i;
                    }else{
                        svzero_za();
                        int idx1 = first_idx;
                        int idx2=i;
                        int ip1 = local_index[idx1];
                        ip_list.push_back(ip1);
                        int ip2 = local_index[idx2];
                        ip_list.push_back(ip2);
                        // printf("ip1 %d ip2 %d\n",ip1,ip2);
                        svetime[1]=rdtscm();
                        indexing+=(svetime[1]-svetime[0]); 
 
                        svetime[0]=rdtscm(); 

                        // sx0sy x sz
                        MVec p1wqxsy = svld1(p0,&sy_m[ip1*nshape])*wqx[ip1];
                        MVec p1sz0sy = p1wqxsy*sz_m[ip1*nshape+0];// first 4 (1111 0000)
                        MVec p2wqxsy = svld1(p1,&sy_m[(ip2-1)*nshape])*wqx[ip2];
                        MVec p2sz0sy = p2wqxsy*sz_m[(ip2)*nshape+0]; // only last 4 (0000 1111)
                        MVec sz0sy = svsel(p0,p1sz0sy,p2sz0sy);
                        //====================
                        // double A[8]={0.};
                        // sx0sy.Store(p,&A[0]);
                        // printf("Test sxsy:");
                        // for(int ii=0;ii<8;ii++){
                        //     printf("\tsxsy[%d]: %f\n",ii,A[ii]);
                        // }
                        //======================

                        MVec p1sx = svld1(p0,&sx_m[ip1*nshape]);
                        MVec p2sx = svld1(p1,&sx_m[(ip2-1)*nshape]);
                        MVec sx = svsel(p0,p1sx,p2sx);

                        svmopa_za64_m(0, p, p, sz0sy, sx);

                        // sx1sy x sz
                        MVec p1sz1sy = p1wqxsy*sz_m[ip1*nshape+1];
                        MVec p2sz1sy = p2wqxsy*sz_m[(ip2)*nshape+1];
                        MVec sz1sy = svsel(p0,p1sz1sy,p2sz1sy);
                        svmopa_za64_m(1, p, p, sz1sy, sx);

                        // sx2sy x sz
                        MVec p1sz2sy = p1wqxsy*sz_m[ip1*nshape+2];
                        MVec p2sz2sy = p2wqxsy*sz_m[(ip2)*nshape+2];
                        MVec sz2sy = svsel(p0,p1sz2sy,p2sz2sy);
                        svmopa_za64_m(2, p, p, sz2sy, sx);

                        // sx3sy x sz
                        MVec p1sz3sy = p1wqxsy*sz_m[ip1*nshape+3];
                        MVec p2sz3sy = p2wqxsy*sz_m[(ip2)*nshape+3];
                        MVec sz3sy = svsel(p0,p1sz3sy,p2sz3sy);
                        svmopa_za64_m(3, p, p, sz3sy, sx);

                        first_idx=-1;
                        svetime[1]=rdtscm();
                        mopa+=(svetime[1]-svetime[0]); 
                    }  
                }
                if(first_idx>=0){
                    svetime[0]=rdtscm();
                    // svzero_za();
                    int ip1 = local_index[first_idx];
                    ip_list.push_back(ip1);
                    //=================
                    // printf("single partile!\n");
                    // exit(0);
                    //=================

                    // sx0sy x sz
                    MVec wqxsy = svld1(p0,&sy_m[ip1*nshape])*wqx[ip1];
                    MVec sz0sy = wqxsy*sz_m[ip1*nshape+0];// first 4 (1111 0000)
                    MVec sx = svld1(p0,&sx_m[ip1*nshape]);
                    svmopa_za64_m(0, p0, p0, sz0sy, sx);

                    // MVec wxsz0sysx0 = svread_hor_za64_m(vzero,p0,0,0); //第一个粒子第一层（总共4层）第一组的第1行，11110000
                    // MVec wxsz0sysx1 = svread_hor_za64_m(vzero,p0,0,1); //第一个粒子第一层（总共4层）第一组的第2行，11110000
                    // MVec s0=svsplice(p0,wxsz0sysx0, wxsz0sysx1); //粒子1第一组8个数
                    // MVec xrhocells0 = MVec::Load(p,&xrhocells[8*(rho_bin)]); //对于jx的第1个rhocell，位置ic-nx-1
                    // xrhocells0+=s0; //两个粒子最终加总一次
                    // xrhocells0.Store(p,&xrhocells[8*(rho_bin)]); //写回第1组的rhocell
                     
                    // MVec wxsz0sysx2 = svread_hor_za64_m(vzero,p0,0,2); //第一层粒子1第2组的第1行
                    // MVec wxsz0sysx3 = svread_hor_za64_m(vzero,p0,0,3);
                    // MVec s1=svsplice(p0,wxsz0sysx2, wxsz0sysx3); //粒子1第2组8个数
                    // MVec xrhocells1 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonx)]); //第二个rhocell
                    // xrhocells1+=(s1);//两个粒子最终加总一次
                    // xrhocells1.Store(p,&xrhocells[8*(rho_bin+2*rhonx)]);//写回第2组的rhocell
                    // //==========================
                    // s0.Store(p,&testsxwq[ip1*64]);
                    // s1.Store(p,&testsxwq[ip1*64+8]);
                    // //============================= 

                    // sz1sy x sx
                    MVec sz1sy = wqxsy*sz_m[ip1*nshape+1];
                    svmopa_za64_m(1, p0, p0, sz1sy, sx);

                    // MVec wxsz1sysx0 = svread_hor_za64_m(vzero,p0,1,0); //第一个粒子第一层（总共4层）第一组的第1行，11110000
                    // MVec wxsz1sysx1 = svread_hor_za64_m(vzero,p0,1,1); //第一个粒子第一层（总共4层）第一组的第2行，11110000
                    // MVec s2=svsplice(p0,wxsz1sysx0, wxsz1sysx1); //粒子1第一组8个数
                    // MVec xrhocells2 = MVec::Load(p,&xrhocells[8*(rho_bin+rhonxy)]); //对于jx的第1个rhocell，位置ic-nx-1
                    // xrhocells2+=s2; //两个粒子最终加总一次
                    // xrhocells2.Store(p,&xrhocells[8*(rho_bin+rhonxy)]); //写回第1组的rhocell
                     
                    // MVec wxsz1sysx2 = svread_hor_za64_m(vzero,p0,1,2); //第一层粒子1第2组的第1行
                    // MVec wxsz1sysx3 = svread_hor_za64_m(vzero,p0,1,3);
                    // MVec s3=svsplice(p0,wxsz1sysx2, wxsz1sysx3); //粒子1第2组8个数
                    // MVec xrhocells3 = MVec::Load(p,&xrhocells[8*(rho_bin+rhonxy+2*rhonx)]); //第二个rhocell
                    // xrhocells3+=(s3);//两个粒子最终加总一次
                    // xrhocells3.Store(p,&xrhocells[8*(rho_bin+rhonxy+2*rhonx)]);//写回第2组的rhocell
                    // //==========================
                    // s2.Store(p,&testsxwq[ip1*64+8*2]);
                    // s3.Store(p,&testsxwq[ip1*64+8*3]);
                    // //============================= 

                    // sz2sy x sx
                    MVec sz2sy = wqxsy*sz_m[ip1*nshape+2];
                    svmopa_za64_m(2, p0, p0, sz2sy, sx);

                    // MVec wxsz2sysx0 = svread_hor_za64_m(vzero,p0,2,0); //第一个粒子第一层（总共4层）第一组的第1行，11110000
                    // MVec wxsz2sysx1 = svread_hor_za64_m(vzero,p0,2,1); //第一个粒子第一层（总共4层）第一组的第2行，11110000
                    // MVec s4=svsplice(p0,wxsz2sysx0, wxsz2sysx1); //粒子1第一组8个数
                    // MVec xrhocells4 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy)]); //对于jx的第1个rhocell，位置ic-nx-1
                    // xrhocells4+=s4; //两个粒子最终加总一次
                    // xrhocells4.Store(p,&xrhocells[8*(rho_bin+2*rhonxy)]); //写回第1组的rhocell
                     
                    // MVec wxsz2sysx2 = svread_hor_za64_m(vzero,p0,2,2); //第一层粒子1第2组的第1行
                    // MVec wxsz2sysx3 = svread_hor_za64_m(vzero,p0,2,3);
                    // MVec s5=svsplice(p0,wxsz2sysx2, wxsz2sysx3); //粒子1第2组8个数
                    // MVec xrhocells5 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+2*rhonx)]); //第二个rhocell
                    // xrhocells5+=(s5);//两个粒子最终加总一次
                    // xrhocells5.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+2*rhonx)]);//写回第2组的rhocell
                    // //==========================
                    // s4.Store(p,&testsxwq[ip1*64+8*4]);
                    // s5.Store(p,&testsxwq[ip1*64+8*5]);
                    // //============================= 

                    // sz3sy x sx
                    MVec sz3sy = wqxsy*sz_m[ip1*nshape+3];
                    svmopa_za64_m(3, p0, p0, sz3sy, sx);

                    // MVec wxsz3sysx0 = svread_hor_za64_m(vzero,p0,3,0); //第一个粒子第一层（总共4层）第一组的第1行，11110000
                    // MVec wxsz3sysx1 = svread_hor_za64_m(vzero,p0,3,1); //第一个粒子第一层（总共4层）第一组的第2行，11110000
                    // MVec s6=svsplice(p0,wxsz3sysx0, wxsz3sysx1); //粒子1第一组8个数
                    // MVec xrhocells6 = MVec::Load(p,&xrhocells[8*(rho_bin+3*rhonxy)]); //对于jx的第1个rhocell，位置ic-nx-1
                    // xrhocells6+=s6; //两个粒子最终加总一次
                    // xrhocells6.Store(p,&xrhocells[8*(rho_bin+3*rhonxy)]); //写回第1组的rhocell
                     
                    // MVec wxsz3sysx2 = svread_hor_za64_m(vzero,p0,3,2); //第一层粒子1第2组的第1行
                    // MVec wxsz3sysx3 = svread_hor_za64_m(vzero,p0,3,3);
                    // MVec s7=svsplice(p0,wxsz3sysx2, wxsz3sysx3); //粒子1第2组8个数
                    // MVec xrhocells7 = MVec::Load(p,&xrhocells[8*(rho_bin+3*rhonxy+2*rhonx)]); //第二个rhocell
                    // xrhocells7+=(s7);//两个粒子最终加总一次
                    // xrhocells7.Store(p,&xrhocells[8*(rho_bin+3*rhonxy+2*rhonx)]);//写回第2组的rhocell
                    // //==========================
                    // s6.Store(p,&testsxwq[ip1*64+8*6]);
                    // s7.Store(p,&testsxwq[ip1*64+8*7]);
                    // //============================= 
                    svetime[1]=rdtscm();
                    mopa+=(svetime[1]-svetime[0]);
                }

                svetime[0]=rdtscm();
                // x0
                MVec p1wxsz0sysx0 = svread_hor_za64_m(vzero,p0,0,0); //第一个粒子第一层（总共4层）第一组的第1行，11110000
                MVec p1wxsz0sysx1 = svread_hor_za64_m(vzero,p0,0,1); //第一个粒子第一层（总共4层）第一组的第2行，11110000
                MVec p1s0=svsplice(p0,p1wxsz0sysx0, p1wxsz0sysx1); //粒子1第一组8个数
                MVec p2wxsz0sysx0 = svread_hor_za64_m(vzero,p1,0,4); //第2个粒子同理，但是00001111
                MVec p2wxsz0sysx1 = svread_hor_za64_m(vzero,p1,0,5);
                MVec p2s0 = svext(p2wxsz0sysx0,svext(p2wxsz0sysx1,p2wxsz0sysx1,4),4); //组织成第2个粒子的第一组8个数
                MVec xrhocells0 = MVec::Load(p,&xrhocells[8*(rho_bin)]); //对于jx的第1个rhocell，位置ic-nx-1
                xrhocells0+=(p1s0+p2s0); //两个粒子最终加总一次
                xrhocells0.Store(p,&xrhocells[8*(rho_bin)]); //写回第1组的rhocell
                
                MVec p1wxsz0sysx2 = svread_hor_za64_m(vzero,p0,0,2); //第一层粒子1第2组的第1行
                MVec p1wxsz0sysx3 = svread_hor_za64_m(vzero,p0,0,3);
                MVec p1s1=svsplice(p0,p1wxsz0sysx2, p1wxsz0sysx3); //粒子1第2组8个数
                MVec p2wxsz0sysx2 = svread_hor_za64_m(vzero,p1,0,6); //第一层粒子2第2组的第1行
                MVec p2wxsz0sysx3 = svread_hor_za64_m(vzero,p1,0,7);
                MVec p2s1 = svext(p2wxsz0sysx2,svext(p2wxsz0sysx3,p2wxsz0sysx3,4),4); //组织成粒子2第2组8个数
                MVec xrhocells1 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonx)]); //第二个rhocell
                xrhocells1+=(p1s1+p2s1);//两个粒子最终加总一次
                xrhocells1.Store(p,&xrhocells[8*(rho_bin+2*rhonx)]);//写回第2组的rhocell
                // 上面是第一层的rhocell结束，也就是x=0这一层

                // x1
                MVec p1wxsz1sysx0 = svread_hor_za64_m(vzero,p0,1,0); //第一个粒子第2层（总共4层）第3组的第1行，11110000
                MVec p1wxsz1sysx1 = svread_hor_za64_m(vzero,p0,1,1); //第一个粒子第2层（总共4层）第3组的第2行，11110000
                MVec p1s2=svsplice(p0,p1wxsz1sysx0, p1wxsz1sysx1); 
                MVec p2wxsz1sysx0 = svread_hor_za64_m(vzero,p1,1,4); 
                MVec p2wxsz1sysx1 = svread_hor_za64_m(vzero,p1,1,5);
                MVec p2s2 = svext(p2wxsz1sysx0,svext(p2wxsz1sysx1,p2wxsz1sysx1,4),4); 
                MVec xrhocells2 = MVec::Load(p,&xrhocells[8*(rho_bin+rhonxy)]); 
                xrhocells2+=(p1s2+p2s2); //两个粒子最终加总一次
                xrhocells2.Store(p,&xrhocells[8*(rho_bin+rhonxy)]); 

                MVec p1wxsz1sysx2 = svread_hor_za64_m(vzero,p0,1,2); 
                MVec p1wxsz1sysx3 = svread_hor_za64_m(vzero,p0,1,3);
                MVec p1s3=svsplice(p0,p1wxsz1sysx2, p1wxsz1sysx3); 
                MVec p2wxsz1sysx2 = svread_hor_za64_m(vzero,p1,1,6); 
                MVec p2wxsz1sysx3 = svread_hor_za64_m(vzero,p1,1,7);
                MVec p2s3 = svext(p2wxsz1sysx2,svext(p2wxsz1sysx3,p2wxsz1sysx3,4),4); 
                MVec xrhocells3 = MVec::Load(p,&xrhocells[8*(rho_bin+rhonxy+2*rhonx)]); 
                xrhocells3+=(p1s3+p2s3);//两个粒子最终加总一次
                xrhocells3.Store(p,&xrhocells[8*(rho_bin+rhonxy+2*rhonx)]);
                // 上面是第2层的rhocell结束，也就是x=1这一层

                // x2
                MVec p1wxsz2sysx0 = svread_hor_za64_m(vzero,p0,2,0); 
                MVec p1wxsz2sysx1 = svread_hor_za64_m(vzero,p0,2,1); 
                MVec p1s4=svsplice(p0,p1wxsz2sysx0, p1wxsz2sysx1); 
                MVec p2wxsz2sysx0 = svread_hor_za64_m(vzero,p1,2,4); 
                MVec p2wxsz2sysx1 = svread_hor_za64_m(vzero,p1,2,5);
                MVec p2s4 = svext(p2wxsz2sysx0,svext(p2wxsz2sysx1,p2wxsz2sysx1,4),4); 
                MVec xrhocells4 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy)]); 
                xrhocells4+=(p1s4+p2s4); //两个粒子最终加总一次
                xrhocells4.Store(p,&xrhocells[8*(rho_bin+2*rhonxy)]); 

                MVec p1wxsz2sysx2 = svread_hor_za64_m(vzero,p0,2,2); 
                MVec p1wxsz2sysx3 = svread_hor_za64_m(vzero,p0,2,3);
                MVec p1s5=svsplice(p0,p1wxsz2sysx2, p1wxsz2sysx3); 
                MVec p2wxsz2sysx2 = svread_hor_za64_m(vzero,p1,2,6); 
                MVec p2wxsz2sysx3 = svread_hor_za64_m(vzero,p1,2,7);
                MVec p2s5 = svext(p2wxsz2sysx2,svext(p2wxsz2sysx3,p2wxsz2sysx3,4),4); 
                MVec xrhocells5 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+2*rhonx)]); 
                xrhocells5+=(p1s5+p2s5);//两个粒子最终加总一次
                xrhocells5.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+2*rhonx)]);
                // 上面是第3层的rhocell结束，也就是x=2这一层

                // x3
                MVec p1wxsz3sysx0 = svread_hor_za64_m(vzero,p0,3,0); 
                MVec p1wxsz3sysx1 = svread_hor_za64_m(vzero,p0,3,1); 
                MVec p1s6=svsplice(p0,p1wxsz3sysx0, p1wxsz3sysx1); 
                MVec p2wxsz3sysx0 = svread_hor_za64_m(vzero,p1,3,4); 
                MVec p2wxsz3sysx1 = svread_hor_za64_m(vzero,p1,3,5);
                MVec p2s6 = svext(p2wxsz3sysx0,svext(p2wxsz3sysx1,p2wxsz3sysx1,4),4); 
                MVec xrhocells6 = MVec::Load(p,&xrhocells[8*(rho_bin+rhonxy*3)]); 
                xrhocells6+=(p1s6+p2s6); //两个粒子最终加总一次
                xrhocells6.Store(p,&xrhocells[8*(rho_bin+rhonxy*3)]); 

                MVec p1wxsz3sysx2 = svread_hor_za64_m(vzero,p0,3,2); 
                MVec p1wxsz3sysx3 = svread_hor_za64_m(vzero,p0,3,3);
                MVec p1s7=svsplice(p0,p1wxsz3sysx2, p1wxsz3sysx3); 
                MVec p2wxsz3sysx2 = svread_hor_za64_m(vzero,p1,3,6); 
                MVec p2wxsz3sysx3 = svread_hor_za64_m(vzero,p1,3,7);
                MVec p2s7 = svext(p2wxsz3sysx2,svext(p2wxsz3sysx3,p2wxsz3sysx3,4),4); 
                MVec xrhocells7 = MVec::Load(p,&xrhocells[8*(rho_bin+rhonxy*3+2*rhonx)]); 
                xrhocells7+=(p1s7+p2s7);//两个粒子最终加总一次
                xrhocells7.Store(p,&xrhocells[8*(rho_bin+rhonxy*3+2*rhonx)]);
                
                svetime[1]=rdtscm();
                reducing+=(svetime[1]-svetime[0]); 
            }
        }
    }
    printf("===============START SME==============\n");
    printf("\t indexing:%d \n",indexing);
    printf("\t dataprepare:%d \n",dataprepare);
    printf("\t mopa:%d \n",mopa);
    printf("\t reducing:%d \n",reducing);
    printf("===============END SME==============\n");
}


template <int depos_order>
__arm_new("za") inline void sort_3d_sme_kernal_order_3_v2 (
    const std::vector<int>& local_index,
    const std::vector<int>& bin_length,
    const std::vector<int>& bin_offsets,
    std::vector<amrex::Real>& xrhocells,
    std::vector<amrex::Real>& yrhocells,
    std::vector<amrex::Real>& zrhocells,
    std::vector<amrex::Real>& sx_m,
    std::vector<amrex::Real>& sy_m,
    std::vector<amrex::Real>& sz_m,
    std::vector<amrex::Real>& wqx,
    std::vector<amrex::Real>& wqy,
    std::vector<amrex::Real>& wqz,
    amrex::Dim3 len,int np,
    std::vector<amrex::Real>& testsxwq,
    std::vector<int>& ip_list
)__arm_streaming {
    using namespace amrex::literals;
    // uint64_t indexing=0;
    // uint64_t dataprepare=0;
    // uint64_t mopa=0;
    // uint64_t reducing=0;
    // uint64_t Total=0;
    // uint64_t svetime[3]={0};
    // uint64_t svetime1[2]={0};
    // uint64_t mopatime[2]={0};

    // svetime1[0]=rdtscm();
    // svetime[0]=rdtscm();
    int nshape = 4;
    
    svbool_t p = svptrue_b64();
    svbool_t p0=svwhilelt_b64(0,4); // 前4个的谓词
    // svbool_t p1=svbic_z(p,p, p0); // 后4个的谓词
    MVec vzero(0);

    int binnx = len.x;
    int binny = len.y;
    int binnxy = binnx*binny;

    int rhonx = len.x+1;
    int rhonxy = rhonx*(len.y-2);
    // svetime[1]=rdtscm();
    // dataprepare+=(svetime[1]-svetime[0]);
#if 0
    int numbin=len.x*len.y*len.z;
    int vl=svcntw();
    svint32_t vmax = svdup_s32(INVALID_PARTICLE_ID);
    std::vector<int> ip_list1(np,0);  
    svbool_t p_all = svptrue_b32();
    int write_ptr = 0;
    
    for (int old_bin = 0; old_bin < numbin; ++old_bin) {
        int start = bin_offsets[old_bin];
        for(int i=start;i<bin_offsets[old_bin+1];i+=vl){
            svbool_t p0 = svwhilelt_b32(i,bin_offsets[old_bin+1]);
            svint32_t ip_v = svld1_s32(p0,&local_index[i]);
            svbool_t p1 = svcmpne_s32(p0, ip_v, vmax); 
            svint32_t real_ip_v = svcompact_s32(p1, ip_v);
            int count = svcntp_b32(p_all, p1);
            svbool_t p_store = svwhilelt_b32(0, count);
            svst1_s32(p_store,&ip_list1[write_ptr],real_ip_v);
            write_ptr+=count;
            // printf("count %d\n",count);
        }
    }
    // for (int old_bin = 0; old_bin < numbin; ++old_bin) {
    //     int start = bin_offsets[old_bin];
    //     for(int i=0;i<bin_length[old_bin];i+=vl){
    //         svbool_t p0 = svwhilelt_b32(i,bin_length[old_bin]);
    //         svint32_t ip_v = svld1_s32(p0,&local_index[start+i]);
    //         svbool_t p1 = svcmpne_s32(p0, ip_v, vmax); 
    //         svint32_t real_ip_v = svcompact_s32(p1, ip_v);
    //         int count = svcntp_b32(p_all, p1);
    //         svbool_t p_store = svwhilelt_b32(0, count);
    //         svst1_s32(p_store,&ip_list1[write_ptr],real_ip_v);
    //         write_ptr+=count;
    //         // printf("count %d\n",count);
    //     }
    // }
    //====================================
    // for(int ip=0;ip<np;ip++){
    //     printf("ip_list1[%d]=%d\n",ip,ip_list1[ip]);
    // }
    std::vector<std::vector<int>> ip_test(numbin); 
    for (int iz = 0; iz < len.z-2; ++iz) {
        for (int iy = 0; iy < len.y-2; ++iy) {       
            for (int ix = 0; ix < len.x-2; ix++) {
                int old_bin=(ix) + (iy) * binnx + (iz) * binnxy;
               
                if (bin_length[old_bin] == 0) continue;
                int start = bin_offsets[old_bin];
                int end = bin_offsets[old_bin+1];
                svzero_za();
                int binlen=0;
                for(int i=start;i<end;i++){
                    if (local_index[i] == INVALID_PARTICLE_ID) {
                        // idx1++;
                        continue;
                    } 
                    int ip = local_index[i];
                    ip_test[old_bin].push_back(ip);
                    binlen++;
                }
                if(binlen!=bin_length[old_bin]){
                    printf("LEN ERR!! bin_length[%d] %d != true %d \n", 
                        old_bin,bin_length[old_bin],binlen
                    );
                }
            }
        }
    }
    int start=0;
    int errip=0;
    for (int iz = 0; iz < len.z-2; ++iz) {
        for (int iy = 0; iy < len.y-2; ++iy) {       
            for (int ix = 0; ix < len.x-2; ix++) {
                int old_bin=(ix) + (iy) * binnx + (iz) * binnxy;
                int binlength = bin_length[old_bin];
                
                for(int i=0;i<binlength;++i){
                    int ip = ip_list1[start+i];
                    int iptrue = ip_test[old_bin][i];
                    if(ip!=iptrue){
                        
                        printf("ix %d iy %d iz %d bin %d iplist[%d] %d iptrue %d \n"
                            ,ix,iy,iz
                            ,old_bin,start+i,ip,iptrue
                        );
                        errip++;
                        
                    }
                    if(errip>10) {
                
                        for(int ii1=0;ii1<50;ii1++){
                            int ii=ii1-25;
                            int off=bin_offsets[old_bin];
                            printf("local_index[%d]=%d\n"
                                ,off+ii,local_index[off+ii]
                            );
                        }
                        for(int bin1=old_bin;bin1<old_bin+20;bin1++){
                            int bin=bin1-10;
                            int off=bin_offsets[bin];
                            printf("bin_offsets[%d]=%d  bin_length[%d]=%d \n"
                                ,bin,off
                                ,bin,bin_length[bin]
                            );
                        
                        }
                        for(int ip1=0;ip1<np/10;ip1++){
                            printf("ip_list1[%d]=%d\n",ip1,ip_list1[ip1]);
                        }
                        exit(0);
                    }
                }
                start+=binlength;
            }
        }
    }
    //====================================
#endif

    // std::vector<int> ip_list1; 
    int ip_ptr=0;
    for (int iz = 0; iz < len.z-2; ++iz) {
        for (int iy = 0; iy < len.y-2; ++iy) {       
            for (int ix = 0; ix < len.x-2; ix++) {

                // svetime[0]=rdtscm();
                int old_bin=(ix) + (iy) * binnx + (iz) * binnxy;
                int rho_bin=ix+iy*rhonx+iz*rhonxy;
                // std::vector<int> ip_list;
                // svetime[1]=rdtscm();
                // indexing+=(svetime[1]-svetime[0]); 
#if 0
                // svetime[0]=rdtscm();
                if (bin_length[old_bin] == 0) continue;
                int start = bin_offsets[old_bin];
                int end = bin_offsets[old_bin+1];
                svzero_za();

                // svetime[1]=rdtscm();
                // indexing+=(svetime[1]-svetime[0]); 

                
                for(int i=start;i<end;i++){
                    // svetime[0]=rdtscm();
                    // mopatime[0]=rdtscm1();
                    if (local_index[i] == INVALID_PARTICLE_ID) {
                        // idx1++;
                        continue;
                    } 
                    int ip = local_index[i];
#endif

#if 1
                int binlength = bin_length[old_bin];
                std::vector<int> ip_list1(np,0);
                ip_list1=ip_list;
                for(int i=0;i<binlength;++i){
                    int ip = ip_list1[ip_ptr+i];
#endif
                    // ip_list1.push_back(ip);
                    // mopatime[1]=rdtscm1();
                    // indexing+=(mopatime[1]-mopatime[0]);
                    // svetime[1]=rdtscm();
                    // indexing+=(svetime[1]-svetime[0]); 
                    //==============================
                    // printf("ip %d sx_m %f \n",ip,sx_m[ip*nshape]);
                    //================================

                    // svetime[0]=rdtscm();
                    svzero_za();
                    // mopatime[0]=rdtscm1();
                    MVec wqxsy = svld1(p0,&sy_m[ip*nshape])*wqx[ip];
                    MVec sz0sy = wqxsy*sz_m[ip*nshape+0];
                    MVec sz1sy = wqxsy*sz_m[ip*nshape+1];
                    // MVec sz01sy = svsel(p0,sz0sy,sz1sy);
                    MVec sz01sy = svsplice(p0,sz0sy,sz1sy);

                    MVec sx = svld1(p0,&sx_m[ip*nshape]);
                    // svetime[1]=rdtscm();
                    // dataprepare+=(svetime[1]-svetime[0]);
                    // svetime[0]=rdtscm();
                    svmopa_za64_m(0, p0, p, sx, sz01sy);
                    // svetime[1]=rdtscm();
                    // mopa+=(svetime[1]-svetime[0]);
                    // svetime[0]=rdtscm();
                    MVec sz2sy = wqxsy*sz_m[ip*nshape+2];
                    MVec sz3sy = wqxsy*sz_m[ip*nshape+3];
                    MVec sz23sy = svsplice(p0,sz2sy,sz3sy);
                    // MVec sz23sy = svsel(p0,sz2sy,sz3sy);
                    // svetime[1]=rdtscm();
                    // dataprepare+=(svetime[1]-svetime[0]);
                    // svetime[0]=rdtscm();
                    svmopa_za64_m(1, p0, p, sx, sz23sy);
                    // mopatime[1]=rdtscm1();
                    // mopa+=(unsigned long long)(mopatime[1]-mopatime[0]);
                    // svetime[1]=rdtscm();
                    // mopa+=(svetime[1]-svetime[0]); 

                    //==========================
                    MVec s0=svread_hor_za64_m(vzero,p,0,0);
                    s0.Store(p,&testsxwq[ip*64+0]);
                    MVec s1=svread_hor_za64_m(vzero,p,0,1);
                    s1.Store(p,&testsxwq[ip*64+8]);
                    MVec s2=svread_hor_za64_m(vzero,p,0,2);
                    s2.Store(p,&testsxwq[ip*64+16]);
                    MVec s3=svread_hor_za64_m(vzero,p,0,3);
                    s3.Store(p,&testsxwq[ip*64+24]);
                    MVec s4=svread_hor_za64_m(vzero,p,1,0);
                    s4.Store(p,&testsxwq[ip*64+32]);
                    MVec s5=svread_hor_za64_m(vzero,p,1,1);
                    s5.Store(p,&testsxwq[ip*64+40]);
                    MVec s6=svread_hor_za64_m(vzero,p,1,2);
                    s6.Store(p,&testsxwq[ip*64+48]);
                    MVec s7=svread_hor_za64_m(vzero,p,1,3);
                    s7.Store(p,&testsxwq[ip*64+56]);
                    //==========================
                    //   z0y0 z0y1 z0y2 z0y3 z1y0 z1y1 z1y2 z1y3
                    // x0           wxsx0sysz01
                    // x1           wxsx1sysz01
                    // x2           wxsx2sysz01
                    // x3           wxsx3sysz01
                    MVec wxsx0sysz01 = svread_hor_za64_m(vzero,p,0,0);
                    MVec xrhocells0 = MVec::Load(p,&xrhocells[8*(rho_bin)]); 
                    xrhocells0+=wxsx0sysz01; 
                    xrhocells0.Store(p,&xrhocells[8*(rho_bin)]); 
                    
                    MVec wxsx1sysz01 = svread_hor_za64_m(vzero,p,0,1);
                    MVec xrhocells1 = MVec::Load(p,&xrhocells[8*(rho_bin+1)]); 
                    xrhocells1+=wxsx1sysz01; 
                    xrhocells1.Store(p,&xrhocells[8*(rho_bin+1)]); 

                    MVec wxsx2sysz01 = svread_hor_za64_m(vzero,p,0,2);
                    MVec xrhocells2 = MVec::Load(p,&xrhocells[8*(rho_bin+2)]); 
                    xrhocells2+=wxsx2sysz01; 
                    xrhocells2.Store(p,&xrhocells[8*(rho_bin+2)]); 

                    MVec wxsx3sysz01 = svread_hor_za64_m(vzero,p,0,3);
                    MVec xrhocells3 = MVec::Load(p,&xrhocells[8*(rho_bin+3)]); 
                    xrhocells3+=wxsx3sysz01; 
                    xrhocells3.Store(p,&xrhocells[8*(rho_bin+3)]); 

                    //   z2y0 z2y1 z2y2 z2y3 z3y0 z3y1 z3y2 z3y3
                    // x0           wxsx0sysz23
                    // x1           wxsx1sysz23
                    // x2           wxsx2sysz23
                    // x3           wxsx3sysz23
                    MVec wxsx0sysz23 = svread_hor_za64_m(vzero,p,1,0);
                    MVec xrhocells4 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy)]); 
                    xrhocells4+=wxsx0sysz23; 
                    xrhocells4.Store(p,&xrhocells[8*(rho_bin+2*rhonxy)]); 
                    
                    MVec wxsx1sysz23 = svread_hor_za64_m(vzero,p,1,1);
                    MVec xrhocells5 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+1)]); 
                    xrhocells5+=wxsx1sysz23; 
                    xrhocells5.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+1)]); 

                    MVec wxsx2sysz23 = svread_hor_za64_m(vzero,p,1,2);
                    MVec xrhocells6 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+2)]); 
                    xrhocells6+=wxsx2sysz23; 
                    xrhocells6.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+2)]); 

                    MVec wxsx3sysz23 = svread_hor_za64_m(vzero,p,1,3);
                    MVec xrhocells7 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+3)]); 
                    xrhocells7+=wxsx3sysz23; 
                    xrhocells7.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+3)]); 
                }
                ip_ptr+=binlength;
                // mopatime[1]=rdtscm1();
                // mopa+=(unsigned long long)(mopatime[1]-mopatime[0]);

                // svetime[0]=rdtscm();
                //   z0y0 z0y1 z0y2 z0y3 z1y0 z1y1 z1y2 z1y3
                // x0           wxsx0sysz01
                // x1           wxsx1sysz01
                // x2           wxsx2sysz01
                // x3           wxsx3sysz01
                // MVec wxsx0sysz01 = svread_hor_za64_m(vzero,p,0,0);
                // MVec xrhocells0 = MVec::Load(p,&xrhocells[8*(rho_bin)]); 
                // xrhocells0+=wxsx0sysz01; 
                // xrhocells0.Store(p,&xrhocells[8*(rho_bin)]); 
                
                // MVec wxsx1sysz01 = svread_hor_za64_m(vzero,p,0,1);
                // MVec xrhocells1 = MVec::Load(p,&xrhocells[8*(rho_bin+1)]); 
                // xrhocells1+=wxsx1sysz01; 
                // xrhocells1.Store(p,&xrhocells[8*(rho_bin+1)]); 

                // MVec wxsx2sysz01 = svread_hor_za64_m(vzero,p,0,2);
                // MVec xrhocells2 = MVec::Load(p,&xrhocells[8*(rho_bin+2)]); 
                // xrhocells2+=wxsx2sysz01; 
                // xrhocells2.Store(p,&xrhocells[8*(rho_bin+2)]); 

                // MVec wxsx3sysz01 = svread_hor_za64_m(vzero,p,0,3);
                // MVec xrhocells3 = MVec::Load(p,&xrhocells[8*(rho_bin+3)]); 
                // xrhocells3+=wxsx3sysz01; 
                // xrhocells3.Store(p,&xrhocells[8*(rho_bin+3)]); 

                // //   z2y0 z2y1 z2y2 z2y3 z3y0 z3y1 z3y2 z3y3
                // // x0           wxsx0sysz23
                // // x1           wxsx1sysz23
                // // x2           wxsx2sysz23
                // // x3           wxsx3sysz23
                // MVec wxsx0sysz23 = svread_hor_za64_m(vzero,p,1,0);
                // MVec xrhocells4 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy)]); 
                // xrhocells4+=wxsx0sysz23; 
                // xrhocells4.Store(p,&xrhocells[8*(rho_bin+2*rhonxy)]); 
                
                // MVec wxsx1sysz23 = svread_hor_za64_m(vzero,p,1,1);
                // MVec xrhocells5 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+1)]); 
                // xrhocells5+=wxsx1sysz23; 
                // xrhocells5.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+1)]); 

                // MVec wxsx2sysz23 = svread_hor_za64_m(vzero,p,1,2);
                // MVec xrhocells6 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+2)]); 
                // xrhocells6+=wxsx2sysz23; 
                // xrhocells6.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+2)]); 

                // MVec wxsx3sysz23 = svread_hor_za64_m(vzero,p,1,3);
                // MVec xrhocells7 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+3)]); 
                // xrhocells7+=wxsx3sysz23; 
                // xrhocells7.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+3)]); 

                
                // svetime[1]=rdtscm();
                // reducing+=(svetime[1]-svetime[0]); 
            }
        }
    }
    // if(ip_list1!=ip_list) {
    //     printf("IPERR\n");
    //     for(int i=0;i<np;i++)
    //     {
    //         printf("ip_list[%d] = %d TRUE= %d \n",i,ip_list[i],ip_list1[i]);
    //     }
    //     exit(0);
    // }
    // svetime1[1]=rdtscm();
    // Total+=(svetime1[1]-svetime1[0]);

    // printf("===============START SME==============\n");
    // printf("\t indexing:%d \n",indexing);
    // printf("\t dataprepare:%d \n",dataprepare);
    // printf("\t mopa:%llu \n",(unsigned long long)mopa);
    // printf("\t reducing:%d \n",reducing);
    // printf("\t Total:%d \n",Total);
    // printf("===============END SME==============\n");
}

// 这版本用了转置的sx
template <int depos_order>
__arm_new("za") inline void sort_3d_sme_kernal_order_3_v3 (
    const std::vector<int>& local_index,
    const std::vector<int>& bin_length,
    const std::vector<int>& bin_offsets,
    std::vector<amrex::Real>& xrhocells,
    std::vector<amrex::Real>& yrhocells,
    std::vector<amrex::Real>& zrhocells,
    std::vector<amrex::Real>& sx_mT,
    std::vector<amrex::Real>& sy_mT,
    std::vector<amrex::Real>& sz_mT,
    std::vector<amrex::Real>& wqx,
    std::vector<amrex::Real>& wqy,
    std::vector<amrex::Real>& wqz,
    amrex::Dim3 len,int np,
    std::vector<int>& ip_list
)__arm_streaming {
    using namespace amrex::literals;
    // uint64_t indexing=0;
    // uint64_t dataprepare=0;
    // uint64_t mopa=0;
    // uint64_t reducing=0;
    // uint64_t Total=0;
    // uint64_t svetime[3]={0};
    // uint64_t svetime1[2]={0};
    // uint64_t mopatime[2]={0};

    // svetime1[0]=rdtscm();
    // svetime[0]=rdtscm();
    int nshapes = 4;
    
    svbool_t p = svptrue_b64();
    svbool_t p0=svwhilelt_b64(0,4); // 前4个的谓词
    // svbool_t p1=svbic_z(p,p, p0); // 后4个的谓词
    MVec vzero(0);

    int binnx = len.x;
    int binny = len.y;
    int binnxy = binnx*binny;

    int rhonx = len.x+1;
    int rhonxy = rhonx*(len.y-2);
    // svetime[1]=rdtscm();
    // dataprepare+=(svetime[1]-svetime[0]);

    const svuint64_t sx_index = svindex_u64(0, np);
    int ip_ptr=0;
    for (int iz = 0; iz < len.z-2; ++iz) {
        for (int iy = 0; iy < len.y-2; ++iy) {       
            for (int ix = 0; ix < len.x-2; ix++) {
                svzero_za();
                // svetime[0]=rdtscm();
                int old_bin=(ix) + (iy) * binnx + (iz) * binnxy;
                int rho_bin=ix+iy*rhonx+iz*rhonxy;

                int binlength = bin_length[old_bin];
                for(int i=0;i<binlength;++i){
                    int ip = ip_list[ip_ptr+i];

                    // svetime[0]=rdtscm();
                    // svzero_za();
                    // mopatime[0]=rdtscm1();
                    MVec wqxsy = svld1_gather_index(p0,&sy_mT[ip],sx_index)*wqx[ip];
                    // MVec wqxsy = svld1(p0,&sy_m[ip*nshape])*wqx[ip];
                    MVec sz0sy = wqxsy*sz_mT[ip+0];
                    MVec sz1sy = wqxsy*sz_mT[ip+1*np];
                    // MVec sz01sy = svsel(p0,sz0sy,sz1sy);
                    MVec sz01sy = svsplice(p0,sz0sy,sz1sy);

                    MVec sx = svld1_gather_index(p0,&sx_mT[ip],sx_index);
                    // MVec sx = svld1(p0,&sx_m[ip*nshape]);
                    // svetime[1]=rdtscm();
                    // dataprepare+=(svetime[1]-svetime[0]);
                    // svetime[0]=rdtscm();
                    svmopa_za64_m(0, p0, p, sx, sz01sy);
                    // svetime[1]=rdtscm();
                    // mopa+=(svetime[1]-svetime[0]);
                    // svetime[0]=rdtscm();
                    MVec sz2sy = wqxsy*sz_mT[ip+2*np];
                    MVec sz3sy = wqxsy*sz_mT[ip+3*np];
                    MVec sz23sy = svsplice(p0,sz2sy,sz3sy);
                    // MVec sz23sy = svsel(p0,sz2sy,sz3sy);
                    // svetime[1]=rdtscm();
                    // dataprepare+=(svetime[1]-svetime[0]);
                    // svetime[0]=rdtscm();
                    svmopa_za64_m(1, p0, p, sx, sz23sy);
                    // mopatime[1]=rdtscm1();
                    // mopa+=(unsigned long long)(mopatime[1]-mopatime[0]);
                    // svetime[1]=rdtscm();
                    // mopa+=(svetime[1]-svetime[0]); 

                    //==========================
                    // MVec s0=svread_hor_za64_m(vzero,p,0,0);
                    // s0.Store(p,&testsxwq[ip*64+0]);
                    // MVec s1=svread_hor_za64_m(vzero,p,0,1);
                    // s1.Store(p,&testsxwq[ip*64+8]);
                    // MVec s2=svread_hor_za64_m(vzero,p,0,2);
                    // s2.Store(p,&testsxwq[ip*64+16]);
                    // MVec s3=svread_hor_za64_m(vzero,p,0,3);
                    // s3.Store(p,&testsxwq[ip*64+24]);
                    // MVec s4=svread_hor_za64_m(vzero,p,1,0);
                    // s4.Store(p,&testsxwq[ip*64+32]);
                    // MVec s5=svread_hor_za64_m(vzero,p,1,1);
                    // s5.Store(p,&testsxwq[ip*64+40]);
                    // MVec s6=svread_hor_za64_m(vzero,p,1,2);
                    // s6.Store(p,&testsxwq[ip*64+48]);
                    // MVec s7=svread_hor_za64_m(vzero,p,1,3);
                    // s7.Store(p,&testsxwq[ip*64+56]);
                    //==========================

                    // MVec wxsx0sysz01 = svread_hor_za64_m(vzero,p,0,0);
                    // MVec xrhocells0 = MVec::Load(p,&xrhocells[8*(rho_bin)]); 
                    // xrhocells0+=wxsx0sysz01; 
                    // xrhocells0.Store(p,&xrhocells[8*(rho_bin)]); 
                    
                    // MVec wxsx1sysz01 = svread_hor_za64_m(vzero,p,0,1);
                    // MVec xrhocells1 = MVec::Load(p,&xrhocells[8*(rho_bin+1)]); 
                    // xrhocells1+=wxsx1sysz01; 
                    // xrhocells1.Store(p,&xrhocells[8*(rho_bin+1)]); 

                    // MVec wxsx2sysz01 = svread_hor_za64_m(vzero,p,0,2);
                    // MVec xrhocells2 = MVec::Load(p,&xrhocells[8*(rho_bin+2)]); 
                    // xrhocells2+=wxsx2sysz01; 
                    // xrhocells2.Store(p,&xrhocells[8*(rho_bin+2)]); 

                    // MVec wxsx3sysz01 = svread_hor_za64_m(vzero,p,0,3);
                    // MVec xrhocells3 = MVec::Load(p,&xrhocells[8*(rho_bin+3)]); 
                    // xrhocells3+=wxsx3sysz01; 
                    // xrhocells3.Store(p,&xrhocells[8*(rho_bin+3)]); 

                    // //   z2y0 z2y1 z2y2 z2y3 z3y0 z3y1 z3y2 z3y3
                    // // x0           wxsx0sysz23
                    // // x1           wxsx1sysz23
                    // // x2           wxsx2sysz23
                    // // x3           wxsx3sysz23
                    // MVec wxsx0sysz23 = svread_hor_za64_m(vzero,p,1,0);
                    // MVec xrhocells4 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy)]); 
                    // xrhocells4+=wxsx0sysz23; 
                    // xrhocells4.Store(p,&xrhocells[8*(rho_bin+2*rhonxy)]); 
                    
                    // MVec wxsx1sysz23 = svread_hor_za64_m(vzero,p,1,1);
                    // MVec xrhocells5 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+1)]); 
                    // xrhocells5+=wxsx1sysz23; 
                    // xrhocells5.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+1)]); 

                    // MVec wxsx2sysz23 = svread_hor_za64_m(vzero,p,1,2);
                    // MVec xrhocells6 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+2)]); 
                    // xrhocells6+=wxsx2sysz23; 
                    // xrhocells6.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+2)]); 

                    // MVec wxsx3sysz23 = svread_hor_za64_m(vzero,p,1,3);
                    // MVec xrhocells7 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+3)]); 
                    // xrhocells7+=wxsx3sysz23; 
                    // xrhocells7.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+3)]); 
                }
                ip_ptr+=binlength;
                // mopatime[1]=rdtscm1();
                // mopa+=(unsigned long long)(mopatime[1]-mopatime[0]);

                // svetime[0]=rdtscm();
                //   z0y0 z0y1 z0y2 z0y3 z1y0 z1y1 z1y2 z1y3
                // x0           wxsx0sysz01
                // x1           wxsx1sysz01
                // x2           wxsx2sysz01
                // x3           wxsx3sysz01
                MVec wxsx0sysz01 = svread_hor_za64_m(vzero,p,0,0);
                MVec xrhocells0 = MVec::Load(p,&xrhocells[8*(rho_bin)]); 
                xrhocells0+=wxsx0sysz01; 
                xrhocells0.Store(p,&xrhocells[8*(rho_bin)]); 
                
                MVec wxsx1sysz01 = svread_hor_za64_m(vzero,p,0,1);
                MVec xrhocells1 = MVec::Load(p,&xrhocells[8*(rho_bin+1)]); 
                xrhocells1+=wxsx1sysz01; 
                xrhocells1.Store(p,&xrhocells[8*(rho_bin+1)]); 

                MVec wxsx2sysz01 = svread_hor_za64_m(vzero,p,0,2);
                MVec xrhocells2 = MVec::Load(p,&xrhocells[8*(rho_bin+2)]); 
                xrhocells2+=wxsx2sysz01; 
                xrhocells2.Store(p,&xrhocells[8*(rho_bin+2)]); 

                MVec wxsx3sysz01 = svread_hor_za64_m(vzero,p,0,3);
                MVec xrhocells3 = MVec::Load(p,&xrhocells[8*(rho_bin+3)]); 
                xrhocells3+=wxsx3sysz01; 
                xrhocells3.Store(p,&xrhocells[8*(rho_bin+3)]); 

                //   z2y0 z2y1 z2y2 z2y3 z3y0 z3y1 z3y2 z3y3
                // x0           wxsx0sysz23
                // x1           wxsx1sysz23
                // x2           wxsx2sysz23
                // x3           wxsx3sysz23
                MVec wxsx0sysz23 = svread_hor_za64_m(vzero,p,1,0);
                MVec xrhocells4 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy)]); 
                xrhocells4+=wxsx0sysz23; 
                xrhocells4.Store(p,&xrhocells[8*(rho_bin+2*rhonxy)]); 
                
                MVec wxsx1sysz23 = svread_hor_za64_m(vzero,p,1,1);
                MVec xrhocells5 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+1)]); 
                xrhocells5+=wxsx1sysz23; 
                xrhocells5.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+1)]); 

                MVec wxsx2sysz23 = svread_hor_za64_m(vzero,p,1,2);
                MVec xrhocells6 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+2)]); 
                xrhocells6+=wxsx2sysz23; 
                xrhocells6.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+2)]); 

                MVec wxsx3sysz23 = svread_hor_za64_m(vzero,p,1,3);
                MVec xrhocells7 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+3)]); 
                xrhocells7+=wxsx3sysz23; 
                xrhocells7.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+3)]); 

                
                // svetime[1]=rdtscm();
                // reducing+=(svetime[1]-svetime[0]); 
            }
        }
    }
    // if(ip_list1!=ip_list) {
    //     printf("IPERR\n");
    //     for(int i=0;i<np;i++)
    //     {
    //         printf("ip_list[%d] = %d TRUE= %d \n",i,ip_list[i],ip_list1[i]);
    //     }
    //     exit(0);
    // }
    // svetime1[1]=rdtscm();
    // Total+=(svetime1[1]-svetime1[0]);

    // printf("===============START SME==============\n");
    // printf("\t indexing:%d \n",indexing);
    // printf("\t dataprepare:%d \n",dataprepare);
    // printf("\t mopa:%llu \n",(unsigned long long)mopa);
    // printf("\t reducing:%d \n",reducing);
    // printf("\t Total:%d \n",Total);
    // printf("===============END SME==============\n");
}

// 这版本用了转置的sx
template <int depos_order>
__arm_new("za") inline void sort_3d_sme_kernal_order_3_compact (
    const std::vector<int>& local_index,
    const std::vector<int>& bin_length,
    const std::vector<int>& bin_offsets,
    std::vector<amrex::Real>& xrhocells,
    std::vector<amrex::Real>& yrhocells,
    std::vector<amrex::Real>& zrhocells,
    std::vector<amrex::Real>& sx_mT,
    std::vector<amrex::Real>& sy_mT,
    std::vector<amrex::Real>& sz_mT,
    std::vector<amrex::Real>& wqx,
    std::vector<amrex::Real>& wqy,
    std::vector<amrex::Real>& wqz,
    amrex::Dim3 len,int np
)__arm_streaming {
    using namespace amrex::literals;
    // uint64_t indexing=0;
    // uint64_t dataprepare=0;
    // uint64_t mopa=0;
    // uint64_t reducing=0;
    // uint64_t Total=0;
    // uint64_t svetime[3]={0};
    // uint64_t svetime1[2]={0};
    // uint64_t mopatime[2]={0};

    // svetime1[0]=rdtscm();
    // svetime[0]=rdtscm();
    int nshapes = 4;
    
    svbool_t p = svptrue_b64();
    svbool_t p0=svwhilelt_b64(0,4); // 前4个的谓词
    // svbool_t p1=svbic_z(p,p, p0); // 后4个的谓词
    MVec vzero(0);

    int binnx = len.x;
    int binny = len.y;
    int binnxy = binnx*binny;

    int rhonx = len.x+1;
    int rhonxy = rhonx*(len.y-2);
    // svetime[1]=rdtscm();
    // dataprepare+=(svetime[1]-svetime[0]);

    const svuint64_t sx_index = svindex_u64(0, np);
    // int ip_ptr=0;
    for (int iz = 0; iz < len.z-2; ++iz) {
        for (int iy = 0; iy < len.y-2; ++iy) {       
            for (int ix = 0; ix < len.x-2; ix++) {
                svzero_za();
                // svetime[0]=rdtscm();
                int old_bin=(ix) + (iy) * binnx + (iz) * binnxy;
                int rho_bin=ix+iy*rhonx+iz*rhonxy;

                int binlength = bin_length[old_bin];
                int binoffset = bin_offsets[old_bin];
                for(int i=0;i<binlength;++i){
                    int ip = local_index[binoffset+i];

                    // svetime[0]=rdtscm();
                    // svzero_za();
                    // mopatime[0]=rdtscm1();
                    MVec wqxsy = svld1_gather_index(p0,&sy_mT[ip],sx_index)*wqx[ip];
                    // MVec wqxsy = svld1(p0,&sy_m[ip*nshape])*wqx[ip];
                    MVec sz0sy = wqxsy*sz_mT[ip+0];
                    MVec sz1sy = wqxsy*sz_mT[ip+1*np];
                    // MVec sz01sy = svsel(p0,sz0sy,sz1sy);
                    MVec sz01sy = svsplice(p0,sz0sy,sz1sy);

                    MVec sx = svld1_gather_index(p0,&sx_mT[ip],sx_index);
                    // MVec sx = svld1(p0,&sx_m[ip*nshape]);
                    // svetime[1]=rdtscm();
                    // dataprepare+=(svetime[1]-svetime[0]);
                    // svetime[0]=rdtscm();
                    svmopa_za64_m(0, p0, p, sx, sz01sy);
                    // svetime[1]=rdtscm();
                    // mopa+=(svetime[1]-svetime[0]);
                    // svetime[0]=rdtscm();
                    MVec sz2sy = wqxsy*sz_mT[ip+2*np];
                    MVec sz3sy = wqxsy*sz_mT[ip+3*np];
                    MVec sz23sy = svsplice(p0,sz2sy,sz3sy);
                    // MVec sz23sy = svsel(p0,sz2sy,sz3sy);
                    // svetime[1]=rdtscm();
                    // dataprepare+=(svetime[1]-svetime[0]);
                    // svetime[0]=rdtscm();
                    svmopa_za64_m(1, p0, p, sx, sz23sy);
                    // mopatime[1]=rdtscm1();
                    // mopa+=(unsigned long long)(mopatime[1]-mopatime[0]);
                    // svetime[1]=rdtscm();
                    // mopa+=(svetime[1]-svetime[0]); 

                    //==========================
                    // MVec s0=svread_hor_za64_m(vzero,p,0,0);
                    // s0.Store(p,&testsxwq[ip*64+0]);
                    // MVec s1=svread_hor_za64_m(vzero,p,0,1);
                    // s1.Store(p,&testsxwq[ip*64+8]);
                    // MVec s2=svread_hor_za64_m(vzero,p,0,2);
                    // s2.Store(p,&testsxwq[ip*64+16]);
                    // MVec s3=svread_hor_za64_m(vzero,p,0,3);
                    // s3.Store(p,&testsxwq[ip*64+24]);
                    // MVec s4=svread_hor_za64_m(vzero,p,1,0);
                    // s4.Store(p,&testsxwq[ip*64+32]);
                    // MVec s5=svread_hor_za64_m(vzero,p,1,1);
                    // s5.Store(p,&testsxwq[ip*64+40]);
                    // MVec s6=svread_hor_za64_m(vzero,p,1,2);
                    // s6.Store(p,&testsxwq[ip*64+48]);
                    // MVec s7=svread_hor_za64_m(vzero,p,1,3);
                    // s7.Store(p,&testsxwq[ip*64+56]);
                    //==========================

                    // MVec wxsx0sysz01 = svread_hor_za64_m(vzero,p,0,0);
                    // MVec xrhocells0 = MVec::Load(p,&xrhocells[8*(rho_bin)]); 
                    // xrhocells0+=wxsx0sysz01; 
                    // xrhocells0.Store(p,&xrhocells[8*(rho_bin)]); 
                    
                    // MVec wxsx1sysz01 = svread_hor_za64_m(vzero,p,0,1);
                    // MVec xrhocells1 = MVec::Load(p,&xrhocells[8*(rho_bin+1)]); 
                    // xrhocells1+=wxsx1sysz01; 
                    // xrhocells1.Store(p,&xrhocells[8*(rho_bin+1)]); 

                    // MVec wxsx2sysz01 = svread_hor_za64_m(vzero,p,0,2);
                    // MVec xrhocells2 = MVec::Load(p,&xrhocells[8*(rho_bin+2)]); 
                    // xrhocells2+=wxsx2sysz01; 
                    // xrhocells2.Store(p,&xrhocells[8*(rho_bin+2)]); 

                    // MVec wxsx3sysz01 = svread_hor_za64_m(vzero,p,0,3);
                    // MVec xrhocells3 = MVec::Load(p,&xrhocells[8*(rho_bin+3)]); 
                    // xrhocells3+=wxsx3sysz01; 
                    // xrhocells3.Store(p,&xrhocells[8*(rho_bin+3)]); 

                    // //   z2y0 z2y1 z2y2 z2y3 z3y0 z3y1 z3y2 z3y3
                    // // x0           wxsx0sysz23
                    // // x1           wxsx1sysz23
                    // // x2           wxsx2sysz23
                    // // x3           wxsx3sysz23
                    // MVec wxsx0sysz23 = svread_hor_za64_m(vzero,p,1,0);
                    // MVec xrhocells4 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy)]); 
                    // xrhocells4+=wxsx0sysz23; 
                    // xrhocells4.Store(p,&xrhocells[8*(rho_bin+2*rhonxy)]); 
                    
                    // MVec wxsx1sysz23 = svread_hor_za64_m(vzero,p,1,1);
                    // MVec xrhocells5 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+1)]); 
                    // xrhocells5+=wxsx1sysz23; 
                    // xrhocells5.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+1)]); 

                    // MVec wxsx2sysz23 = svread_hor_za64_m(vzero,p,1,2);
                    // MVec xrhocells6 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+2)]); 
                    // xrhocells6+=wxsx2sysz23; 
                    // xrhocells6.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+2)]); 

                    // MVec wxsx3sysz23 = svread_hor_za64_m(vzero,p,1,3);
                    // MVec xrhocells7 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+3)]); 
                    // xrhocells7+=wxsx3sysz23; 
                    // xrhocells7.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+3)]); 
                }
                // ip_ptr+=binlength;
                // mopatime[1]=rdtscm1();
                // mopa+=(unsigned long long)(mopatime[1]-mopatime[0]);

                // svetime[0]=rdtscm();
                //   z0y0 z0y1 z0y2 z0y3 z1y0 z1y1 z1y2 z1y3
                // x0           wxsx0sysz01
                // x1           wxsx1sysz01
                // x2           wxsx2sysz01
                // x3           wxsx3sysz01
                MVec wxsx0sysz01 = svread_hor_za64_m(vzero,p,0,0);
                MVec xrhocells0 = MVec::Load(p,&xrhocells[8*(rho_bin)]); 
                xrhocells0+=wxsx0sysz01; 
                xrhocells0.Store(p,&xrhocells[8*(rho_bin)]); 
                
                MVec wxsx1sysz01 = svread_hor_za64_m(vzero,p,0,1);
                MVec xrhocells1 = MVec::Load(p,&xrhocells[8*(rho_bin+1)]); 
                xrhocells1+=wxsx1sysz01; 
                xrhocells1.Store(p,&xrhocells[8*(rho_bin+1)]); 

                MVec wxsx2sysz01 = svread_hor_za64_m(vzero,p,0,2);
                MVec xrhocells2 = MVec::Load(p,&xrhocells[8*(rho_bin+2)]); 
                xrhocells2+=wxsx2sysz01; 
                xrhocells2.Store(p,&xrhocells[8*(rho_bin+2)]); 

                MVec wxsx3sysz01 = svread_hor_za64_m(vzero,p,0,3);
                MVec xrhocells3 = MVec::Load(p,&xrhocells[8*(rho_bin+3)]); 
                xrhocells3+=wxsx3sysz01; 
                xrhocells3.Store(p,&xrhocells[8*(rho_bin+3)]); 

                //   z2y0 z2y1 z2y2 z2y3 z3y0 z3y1 z3y2 z3y3
                // x0           wxsx0sysz23
                // x1           wxsx1sysz23
                // x2           wxsx2sysz23
                // x3           wxsx3sysz23
                MVec wxsx0sysz23 = svread_hor_za64_m(vzero,p,1,0);
                MVec xrhocells4 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy)]); 
                xrhocells4+=wxsx0sysz23; 
                xrhocells4.Store(p,&xrhocells[8*(rho_bin+2*rhonxy)]); 
                
                MVec wxsx1sysz23 = svread_hor_za64_m(vzero,p,1,1);
                MVec xrhocells5 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+1)]); 
                xrhocells5+=wxsx1sysz23; 
                xrhocells5.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+1)]); 

                MVec wxsx2sysz23 = svread_hor_za64_m(vzero,p,1,2);
                MVec xrhocells6 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+2)]); 
                xrhocells6+=wxsx2sysz23; 
                xrhocells6.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+2)]); 

                MVec wxsx3sysz23 = svread_hor_za64_m(vzero,p,1,3);
                MVec xrhocells7 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+3)]); 
                xrhocells7+=wxsx3sysz23; 
                xrhocells7.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+3)]); 

                
                // svetime[1]=rdtscm();
                // reducing+=(svetime[1]-svetime[0]); 
            }
        }
    }
    // if(ip_list1!=ip_list) {
    //     printf("IPERR\n");
    //     for(int i=0;i<np;i++)
    //     {
    //         printf("ip_list[%d] = %d TRUE= %d \n",i,ip_list[i],ip_list1[i]);
    //     }
    //     exit(0);
    // }
    // svetime1[1]=rdtscm();
    // Total+=(svetime1[1]-svetime1[0]);

    // printf("===============START SME==============\n");
    // printf("\t indexing:%d \n",indexing);
    // printf("\t dataprepare:%d \n",dataprepare);
    // printf("\t mopa:%llu \n",(unsigned long long)mopa);
    // printf("\t reducing:%d \n",reducing);
    // printf("\t Total:%d \n",Total);
    // printf("===============END SME==============\n");
}

template <int depos_order>
__arm_new("za") inline void sort_3d_sme_kernal_order_3_compact_HBM_test (
    const HBM_Inner_Vector_Int& local_index,
    const std::vector<int>& bin_length,
    const std::vector<int>& bin_offsets,
    HBM_Inner_Vector_Real& xrhocells,
    HBM_Inner_Vector_Real& yrhocells,
    HBM_Inner_Vector_Real& zrhocells,
    HBM_Inner_Vector_Real& sx_mT,
    HBM_Inner_Vector_Real& sy_mT,
    HBM_Inner_Vector_Real& sz_mT,
    HBM_Inner_Vector_Real& wqx,
    HBM_Inner_Vector_Real& wqy,
    HBM_Inner_Vector_Real& wqz,
    amrex::Dim3 len,int np,
    std::vector<amrex::Real>& testsxwq
)__arm_streaming {
    using namespace amrex::literals;
    
    int nshapes = 4;
    
    svbool_t p = svptrue_b64();
    svbool_t p0=svwhilelt_b64(0,4); // 前4个的谓词
    // svbool_t p1=svbic_z(p,p, p0); // 后4个的谓词
    MVec vzero(0);

    int binnx = len.x;
    int binny = len.y;
    int binnxy = binnx*binny;

    int rhonx = len.x+1;
    int rhonxy = rhonx*(len.y-2);

    const svuint64_t sx_index = svindex_u64(0, np);
    // int ip_ptr=0;
    for (int iz = 0; iz < len.z-2; ++iz) {
        for (int iy = 0; iy < len.y-2; ++iy) {       
            for (int ix = 0; ix < len.x-2; ix++) {
                svzero_za();
                // svetime[0]=rdtscm();
                int old_bin=(ix) + (iy) * binnx + (iz) * binnxy;
                int rho_bin=ix+iy*rhonx+iz*rhonxy;

                int binlength = bin_length[old_bin];
                int binoffset = bin_offsets[old_bin];
                for(int i=0;i<binlength;++i){
                    int ip = local_index[binoffset+i];

                    // svetime[0]=rdtscm();
                    // svzero_za();
                    // mopatime[0]=rdtscm1();
                    MVec wqxsy = svld1_gather_index(p0,&sy_mT[ip],sx_index);
                    // MVec wqxsy = svld1(p0,&sy_m[ip*nshape])*wqx[ip];
                    MVec sz0sy = wqxsy*sz_mT[ip+0];
                    MVec sz1sy = wqxsy*sz_mT[ip+1*np];
                    // MVec sz01sy = svsel(p0,sz0sy,sz1sy);
                    MVec sz01sy = svsplice(p0,sz0sy,sz1sy);

                    MVec sx = svld1_gather_index(p0,&sx_mT[ip],sx_index)*wqx[ip];
                    // MVec sx = svld1(p0,&sx_m[ip*nshape]);
                    // svetime[1]=rdtscm();
                    // dataprepare+=(svetime[1]-svetime[0]);
                    // svetime[0]=rdtscm();
                    svmopa_za64_m(0, p0, p, sx, sz01sy);
                    // svetime[1]=rdtscm();
                    // mopa+=(svetime[1]-svetime[0]);
                    // svetime[0]=rdtscm();
                    MVec sz2sy = wqxsy*sz_mT[ip+2*np];
                    MVec sz3sy = wqxsy*sz_mT[ip+3*np];
                    MVec sz23sy = svsplice(p0,sz2sy,sz3sy);
                    // MVec sz23sy = svsel(p0,sz2sy,sz3sy);
                    // svetime[1]=rdtscm();
                    // dataprepare+=(svetime[1]-svetime[0]);
                    // svetime[0]=rdtscm();
                    svmopa_za64_m(1, p0, p, sx, sz23sy);
                    // mopatime[1]=rdtscm1();
                    // mopa+=(unsigned long long)(mopatime[1]-mopatime[0]);
                    // svetime[1]=rdtscm();
                    // mopa+=(svetime[1]-svetime[0]); 

                    //==========================
                    // MVec s0=svread_hor_za64_m(vzero,p,0,0);
                    // s0.Store(p,&testsxwq[ip*64+0]);
                    // MVec s1=svread_hor_za64_m(vzero,p,0,1);
                    // s1.Store(p,&testsxwq[ip*64+8]);
                    // MVec s2=svread_hor_za64_m(vzero,p,0,2);
                    // s2.Store(p,&testsxwq[ip*64+16]);
                    // MVec s3=svread_hor_za64_m(vzero,p,0,3);
                    // s3.Store(p,&testsxwq[ip*64+24]);
                    // MVec s4=svread_hor_za64_m(vzero,p,1,0);
                    // s4.Store(p,&testsxwq[ip*64+32]);
                    // MVec s5=svread_hor_za64_m(vzero,p,1,1);
                    // s5.Store(p,&testsxwq[ip*64+40]);
                    // MVec s6=svread_hor_za64_m(vzero,p,1,2);
                    // s6.Store(p,&testsxwq[ip*64+48]);
                    // MVec s7=svread_hor_za64_m(vzero,p,1,3);
                    // s7.Store(p,&testsxwq[ip*64+56]);
                    //==========================

                    // MVec wxsx0sysz01 = svread_hor_za64_m(vzero,p,0,0);
                    // MVec xrhocells0 = MVec::Load(p,&xrhocells[8*(rho_bin)]); 
                    // xrhocells0+=wxsx0sysz01; 
                    // xrhocells0.Store(p,&xrhocells[8*(rho_bin)]); 
                    
                    // MVec wxsx1sysz01 = svread_hor_za64_m(vzero,p,0,1);
                    // MVec xrhocells1 = MVec::Load(p,&xrhocells[8*(rho_bin+1)]); 
                    // xrhocells1+=wxsx1sysz01; 
                    // xrhocells1.Store(p,&xrhocells[8*(rho_bin+1)]); 

                    // MVec wxsx2sysz01 = svread_hor_za64_m(vzero,p,0,2);
                    // MVec xrhocells2 = MVec::Load(p,&xrhocells[8*(rho_bin+2)]); 
                    // xrhocells2+=wxsx2sysz01; 
                    // xrhocells2.Store(p,&xrhocells[8*(rho_bin+2)]); 

                    // MVec wxsx3sysz01 = svread_hor_za64_m(vzero,p,0,3);
                    // MVec xrhocells3 = MVec::Load(p,&xrhocells[8*(rho_bin+3)]); 
                    // xrhocells3+=wxsx3sysz01; 
                    // xrhocells3.Store(p,&xrhocells[8*(rho_bin+3)]); 

                    // //   z2y0 z2y1 z2y2 z2y3 z3y0 z3y1 z3y2 z3y3
                    // // x0           wxsx0sysz23
                    // // x1           wxsx1sysz23
                    // // x2           wxsx2sysz23
                    // // x3           wxsx3sysz23
                    // MVec wxsx0sysz23 = svread_hor_za64_m(vzero,p,1,0);
                    // MVec xrhocells4 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy)]); 
                    // xrhocells4+=wxsx0sysz23; 
                    // xrhocells4.Store(p,&xrhocells[8*(rho_bin+2*rhonxy)]); 
                    
                    // MVec wxsx1sysz23 = svread_hor_za64_m(vzero,p,1,1);
                    // MVec xrhocells5 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+1)]); 
                    // xrhocells5+=wxsx1sysz23; 
                    // xrhocells5.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+1)]); 

                    // MVec wxsx2sysz23 = svread_hor_za64_m(vzero,p,1,2);
                    // MVec xrhocells6 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+2)]); 
                    // xrhocells6+=wxsx2sysz23; 
                    // xrhocells6.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+2)]); 

                    // MVec wxsx3sysz23 = svread_hor_za64_m(vzero,p,1,3);
                    // MVec xrhocells7 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+3)]); 
                    // xrhocells7+=wxsx3sysz23; 
                    // xrhocells7.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+3)]); 
                }
                // ip_ptr+=binlength;
                // mopatime[1]=rdtscm1();
                // mopa+=(unsigned long long)(mopatime[1]-mopatime[0]);

                // svetime[0]=rdtscm();
                //   z0y0 z0y1 z0y2 z0y3 z1y0 z1y1 z1y2 z1y3
                // x0           wxsx0sysz01
                // x1           wxsx1sysz01
                // x2           wxsx2sysz01
                // x3           wxsx3sysz01
                MVec wxsx0sysz01 = svread_hor_za64_m(vzero,p,0,0);
                MVec xrhocells0 = MVec::Load(p,&xrhocells[8*(rho_bin)]); 
                xrhocells0+=wxsx0sysz01; 
                xrhocells0.Store(p,&xrhocells[8*(rho_bin)]); 
                
                MVec wxsx1sysz01 = svread_hor_za64_m(vzero,p,0,1);
                MVec xrhocells1 = MVec::Load(p,&xrhocells[8*(rho_bin+1)]); 
                xrhocells1+=wxsx1sysz01; 
                xrhocells1.Store(p,&xrhocells[8*(rho_bin+1)]); 

                MVec wxsx2sysz01 = svread_hor_za64_m(vzero,p,0,2);
                MVec xrhocells2 = MVec::Load(p,&xrhocells[8*(rho_bin+2)]); 
                xrhocells2+=wxsx2sysz01; 
                xrhocells2.Store(p,&xrhocells[8*(rho_bin+2)]); 

                MVec wxsx3sysz01 = svread_hor_za64_m(vzero,p,0,3);
                MVec xrhocells3 = MVec::Load(p,&xrhocells[8*(rho_bin+3)]); 
                xrhocells3+=wxsx3sysz01; 
                xrhocells3.Store(p,&xrhocells[8*(rho_bin+3)]); 

                //   z2y0 z2y1 z2y2 z2y3 z3y0 z3y1 z3y2 z3y3
                // x0           wxsx0sysz23
                // x1           wxsx1sysz23
                // x2           wxsx2sysz23
                // x3           wxsx3sysz23
                MVec wxsx0sysz23 = svread_hor_za64_m(vzero,p,1,0);
                MVec xrhocells4 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy)]); 
                xrhocells4+=wxsx0sysz23; 
                xrhocells4.Store(p,&xrhocells[8*(rho_bin+2*rhonxy)]); 
                
                MVec wxsx1sysz23 = svread_hor_za64_m(vzero,p,1,1);
                MVec xrhocells5 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+1)]); 
                xrhocells5+=wxsx1sysz23; 
                xrhocells5.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+1)]); 

                MVec wxsx2sysz23 = svread_hor_za64_m(vzero,p,1,2);
                MVec xrhocells6 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+2)]); 
                xrhocells6+=wxsx2sysz23; 
                xrhocells6.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+2)]); 

                MVec wxsx3sysz23 = svread_hor_za64_m(vzero,p,1,3);
                MVec xrhocells7 = MVec::Load(p,&xrhocells[8*(rho_bin+2*rhonxy+3)]); 
                xrhocells7+=wxsx3sysz23; 
                xrhocells7.Store(p,&xrhocells[8*(rho_bin+2*rhonxy+3)]); 

                
                // svetime[1]=rdtscm();
                // reducing+=(svetime[1]-svetime[0]); 
            }
        }
    }
    // if(ip_list1!=ip_list) {
    //     printf("IPERR\n");
    //     for(int i=0;i<np;i++)
    //     {
    //         printf("ip_list[%d] = %d TRUE= %d \n",i,ip_list[i],ip_list1[i]);
    //     }
    //     exit(0);
    // }
    // svetime1[1]=rdtscm();
    // Total+=(svetime1[1]-svetime1[0]);

    // printf("===============START SME==============\n");
    // printf("\t indexing:%d \n",indexing);
    // printf("\t dataprepare:%d \n",dataprepare);
    // printf("\t mopa:%llu \n",(unsigned long long)mopa);
    // printf("\t reducing:%d \n",reducing);
    // printf("\t Total:%d \n",Total);
    // printf("===============END SME==============\n");
}


template <int depos_order>
__arm_new("za") inline void sort_3d_sme_kernal_order_3_compact_jxjyjz_HBM (
    const HBM_Inner_Vector_Int& local_index,
    const std::vector<int>& bin_length,
    const std::vector<int>& bin_offsets,
    HBM_Inner_Vector_Real& xrhocells,
    HBM_Inner_Vector_Real& yrhocells,
    HBM_Inner_Vector_Real& zrhocells,
    HBM_Inner_Vector_Real& sx_mT,
    HBM_Inner_Vector_Real& sy_mT,
    HBM_Inner_Vector_Real& sz_mT,
    HBM_Inner_Vector_Real& wqx,
    HBM_Inner_Vector_Real& wqy,
    HBM_Inner_Vector_Real& wqz,
    amrex::Dim3 len,int np
)__arm_streaming {
    using namespace amrex::literals;

    int nshapes = 4;
    
    svbool_t p = svptrue_b64();
    svbool_t p0=svwhilelt_b64(0,4); // 前4个的谓词
    // svbool_t p1=svbic_z(p,p, p0); // 后4个的谓词
    MVec vzero(0);

    int binnx = len.x;
    int binny = len.y;
    int binnxy = binnx*binny;

    int rhonx = len.x+1;
    int rhonxy = rhonx*(len.y-2);

    const svuint64_t sx_index = svindex_u64(0, np);
    for (int iz = 0; iz < len.z-2; ++iz) {
        for (int iy = 0; iy < len.y-2; ++iy) {       
            for (int ix = 0; ix < len.x-2; ix++) {
                int old_bin=(ix) + (iy) * binnx + (iz) * binnxy;
                int rho_bin=ix+iy*rhonx+iz*rhonxy;
                
                int binlength = bin_length[old_bin];
                int binoffset = bin_offsets[old_bin];
                
                svzero_za();
                for(int i=0;i<binlength;++i){
                    int ip = local_index[binoffset+i];

                    MVec sy = svld1_gather_index(p0,&sy_mT[ip],sx_index);
                    MVec sz0sy = sy*sz_mT[ip+0];
                    MVec sz1sy = sy*sz_mT[ip+1*np];
                    MVec sz01sy = svsplice(p0,sz0sy,sz1sy);
                    MVec sx = svld1_gather_index(p0,&sx_mT[ip],sx_index);
                    // MVec wqxsx = sx*wqx[ip];
                    MVec wqxsx = svmul_n_f64_z(p0, sx, wqx[ip]); 
                    svmopa_za64_m(0, p0, p, wqxsx, sz01sy);

                    MVec sz2sy = sy*sz_mT[ip+2*np];
                    MVec sz3sy = sy*sz_mT[ip+3*np];
                    MVec sz23sy = svsplice(p0,sz2sy,sz3sy);
                    svmopa_za64_m(1, p0, p, wqxsx, sz23sy);
                    
                    MVec wqysx = sx*wqy[ip];
                    svmopa_za64_m(2, p0, p, wqysx, sz01sy);
                    svmopa_za64_m(3, p0, p, wqysx, sz23sy);

                    MVec wqzsx = sx*wqy[ip];
                    svmopa_za64_m(4, p0, p, wqzsx, sz01sy);
                    svmopa_za64_m(5, p0, p, wqzsx, sz23sy);        
                }
                
                long offset0=8*(rho_bin);
                long offset1=8*(rho_bin+1);
                long offset2=8*(rho_bin+2);
                long offset3=8*(rho_bin+3);
                // Jx_arr
                //   z0y0 z0y1 z0y2 z0y3 z1y0 z1y1 z1y2 z1y3
                // x0           wxsx0sysz01
                // x1           wxsx1sysz01
                // x2           wxsx2sysz01
                // x3           wxsx3sysz01
                MVec wxsx0sysz01 = svread_hor_za64_m(vzero,p,0,0);
                MVec xrhocells0 = MVec::Load(p,&xrhocells[offset0]); 
                xrhocells0+=wxsx0sysz01; 
                xrhocells0.Store(p,&xrhocells[offset0]); 
                
                MVec wxsx1sysz01 = svread_hor_za64_m(vzero,p,0,1);
                MVec xrhocells1 = MVec::Load(p,&xrhocells[offset1]); 
                xrhocells1+=wxsx1sysz01; 
                xrhocells1.Store(p,&xrhocells[offset1]); 

                MVec wxsx2sysz01 = svread_hor_za64_m(vzero,p,0,2);
                MVec xrhocells2 = MVec::Load(p,&xrhocells[offset2]); 
                xrhocells2+=wxsx2sysz01; 
                xrhocells2.Store(p,&xrhocells[offset2]); 

                MVec wxsx3sysz01 = svread_hor_za64_m(vzero,p,0,3);
                MVec xrhocells3 = MVec::Load(p,&xrhocells[offset3]); 
                xrhocells3+=wxsx3sysz01; 
                xrhocells3.Store(p,&xrhocells[offset3]); 

                long offset4=8*(rho_bin+2*rhonxy);
                long offset5=8*(rho_bin+2*rhonxy+1);
                long offset6=8*(rho_bin+2*rhonxy+2);
                long offset7=8*(rho_bin+2*rhonxy+3);
                //   z2y0 z2y1 z2y2 z2y3 z3y0 z3y1 z3y2 z3y3
                // x0           wxsx0sysz23
                // x1           wxsx1sysz23
                // x2           wxsx2sysz23
                // x3           wxsx3sysz23
                MVec wxsx0sysz23 = svread_hor_za64_m(vzero,p,1,0);
                MVec xrhocells4 = MVec::Load(p,&xrhocells[offset4]); 
                xrhocells4+=wxsx0sysz23; 
                xrhocells4.Store(p,&xrhocells[offset4]); 
                
                MVec wxsx1sysz23 = svread_hor_za64_m(vzero,p,1,1);
                MVec xrhocells5 = MVec::Load(p,&xrhocells[offset5]); 
                xrhocells5+=wxsx1sysz23; 
                xrhocells5.Store(p,&xrhocells[offset5]); 

                MVec wxsx2sysz23 = svread_hor_za64_m(vzero,p,1,2);
                MVec xrhocells6 = MVec::Load(p,&xrhocells[offset6]); 
                xrhocells6+=wxsx2sysz23; 
                xrhocells6.Store(p,&xrhocells[offset6]); 

                MVec wxsx3sysz23 = svread_hor_za64_m(vzero,p,1,3);
                MVec xrhocells7 = MVec::Load(p,&xrhocells[offset7]); 
                xrhocells7+=wxsx3sysz23; 
                xrhocells7.Store(p,&xrhocells[offset7]); 

                // Jy_arr
                //   z0y0 z0y1 z0y2 z0y3 z1y0 z1y1 z1y2 z1y3
                // x0           wysx0sysz01
                // x1           wysx1sysz01
                // x2           wysx2sysz01
                // x3           wysx3sysz01
                MVec wysx0sysz01 = svread_hor_za64_m(vzero,p,2,0);
                MVec yrhocells0 = MVec::Load(p,&yrhocells[offset0]); 
                yrhocells0+=wysx0sysz01; 
                yrhocells0.Store(p,&yrhocells[offset0]); 
                
                MVec wysx1sysz01 = svread_hor_za64_m(vzero,p,2,1);
                MVec yrhocells1 = MVec::Load(p,&yrhocells[offset1]); 
                yrhocells1+=wysx1sysz01; 
                yrhocells1.Store(p,&yrhocells[offset1]); 

                MVec wysx2sysz01 = svread_hor_za64_m(vzero,p,2,2);
                MVec yrhocells2 = MVec::Load(p,&yrhocells[offset2]); 
                yrhocells2+=wysx2sysz01; 
                yrhocells2.Store(p,&yrhocells[offset2]); 

                MVec wysx3sysz01 = svread_hor_za64_m(vzero,p,2,3);
                MVec yrhocells3 = MVec::Load(p,&yrhocells[offset3]); 
                yrhocells3+=wysx3sysz01; 
                yrhocells3.Store(p,&yrhocells[offset3]); 

                //   z2y0 z2y1 z2y2 z2y3 z3y0 z3y1 z3y2 z3y3
                // x0           wysx0sysz23
                // x1           wysx1sysz23
                // x2           wysx2sysz23
                // x3           wysx3sysz23
                MVec wysx0sysz23 = svread_hor_za64_m(vzero,p,3,0);
                MVec yrhocells4 = MVec::Load(p,&yrhocells[offset4]); 
                yrhocells4+=wysx0sysz23; 
                yrhocells4.Store(p,&yrhocells[offset4]); 
                
                MVec wysx1sysz23 = svread_hor_za64_m(vzero,p,3,1);
                MVec yrhocells5 = MVec::Load(p,&yrhocells[offset5]); 
                yrhocells5+=wysx1sysz23; 
                yrhocells5.Store(p,&yrhocells[offset5]); 

                MVec wysx2sysz23 = svread_hor_za64_m(vzero,p,3,2);
                MVec yrhocells6 = MVec::Load(p,&yrhocells[offset6]); 
                yrhocells6+=wysx2sysz23; 
                yrhocells6.Store(p,&yrhocells[offset6]); 

                MVec wysx3sysz23 = svread_hor_za64_m(vzero,p,3,3);
                MVec yrhocells7 = MVec::Load(p,&yrhocells[offset7]); 
                yrhocells7+=wysx3sysz23; 
                yrhocells7.Store(p,&yrhocells[offset7]); 

                // Jz_arr
                //   z0y0 z0y1 z0y2 z0y3 z1y0 z1y1 z1y2 z1y3
                // x0           wzsx0sysz01
                // x1           wzsx1sysz01
                // x2           wzsx2sysz01
                // x3           wzsx3sysz01
                MVec wzsx0sysz01 = svread_hor_za64_m(vzero,p,4,0);
                MVec zrhocells0 = MVec::Load(p,&zrhocells[offset0]); 
                zrhocells0+=wzsx0sysz01; 
                zrhocells0.Store(p,&zrhocells[offset0]); 
                
                MVec wzsx1sysz01 = svread_hor_za64_m(vzero,p,4,1);
                MVec zrhocells1 = MVec::Load(p,&zrhocells[offset1]); 
                zrhocells1+=wzsx1sysz01; 
                zrhocells1.Store(p,&zrhocells[offset1]); 

                MVec wzsx2sysz01 = svread_hor_za64_m(vzero,p,4,2);
                MVec zrhocells2 = MVec::Load(p,&zrhocells[offset2]); 
                zrhocells2+=wzsx2sysz01; 
                zrhocells2.Store(p,&zrhocells[offset2]); 

                MVec wzsx3sysz01 = svread_hor_za64_m(vzero,p,4,3);
                MVec zrhocells3 = MVec::Load(p,&zrhocells[offset3]); 
                zrhocells3+=wzsx3sysz01; 
                zrhocells3.Store(p,&zrhocells[offset3]); 

                //   z2y0 z2y1 z2y2 z2y3 z3y0 z3y1 z3y2 z3y3
                // x0           wzsx0sysz23
                // x1           wzsx1sysz23
                // x2           wzsx2sysz23
                // x3           wzsx3sysz23
                MVec wzsx0sysz23 = svread_hor_za64_m(vzero,p,5,0);
                MVec zrhocells4 = MVec::Load(p,&zrhocells[offset4]); 
                zrhocells4+=wzsx0sysz23; 
                zrhocells4.Store(p,&zrhocells[offset4]); 
                
                MVec wzsx1sysz23 = svread_hor_za64_m(vzero,p,5,1);
                MVec zrhocells5 = MVec::Load(p,&zrhocells[offset5]); 
                zrhocells5+=wzsx1sysz23; 
                zrhocells5.Store(p,&zrhocells[offset5]); 

                MVec wzsx2sysz23 = svread_hor_za64_m(vzero,p,5,2);
                MVec zrhocells6 = MVec::Load(p,&zrhocells[offset6]); 
                zrhocells6+=wzsx2sysz23; 
                zrhocells6.Store(p,&zrhocells[offset6]); 

                MVec wzsx3sysz23 = svread_hor_za64_m(vzero,p,5,3);
                MVec zrhocells7 = MVec::Load(p,&zrhocells[offset7]); 
                zrhocells7+=wzsx3sysz23; 
                zrhocells7.Store(p,&zrhocells[offset7]); 

            }
        }
    }
}


template <int depos_order>
__arm_new("za") inline void sort_3d_sme_kernal_order_3_compact_jxjyjz (
    const std::vector<int>& local_index,
    const std::vector<int>& bin_length,
    const std::vector<int>& bin_offsets,
    HBM_Inner_Vector_Real& xrhocells,
    HBM_Inner_Vector_Real& yrhocells,
    HBM_Inner_Vector_Real& zrhocells,
    HBM_Inner_Vector_Real& sx_mT,
    HBM_Inner_Vector_Real& sy_mT,
    HBM_Inner_Vector_Real& sz_mT,
    HBM_Inner_Vector_Real& wqx,
    HBM_Inner_Vector_Real& wqy,
    HBM_Inner_Vector_Real& wqz,
    amrex::Dim3 len,int np
)__arm_streaming {
    using namespace amrex::literals;

    int nshapes = 4;
    
    svbool_t p = svptrue_b64();
    svbool_t p0=svwhilelt_b64(0,4); // 前4个的谓词
    // svbool_t p1=svbic_z(p,p, p0); // 后4个的谓词
    MVec vzero(0);

    int binnx = len.x;
    int binny = len.y;
    int binnxy = binnx*binny;

    int rhonx = len.x+1;
    int rhonxy = rhonx*(len.y-2);

    const svuint64_t sx_index = svindex_u64(0, np);
    for (int iz = 0; iz < len.z-2; ++iz) {
        for (int iy = 0; iy < len.y-2; ++iy) {       
            for (int ix = 0; ix < len.x-2; ix++) {
                svzero_za();
                int old_bin=(ix) + (iy) * binnx + (iz) * binnxy;
                int rho_bin=ix+iy*rhonx+iz*rhonxy;

                int binlength = bin_length[old_bin];
                int binoffset = bin_offsets[old_bin];

                for(int i=0;i<binlength;++i){
                    int ip = local_index[binoffset+i];

                    MVec sy = svld1_gather_index(p0,&sy_mT[ip],sx_index);
                    MVec sz0sy = sy*sz_mT[ip+0];
                    MVec sz1sy = sy*sz_mT[ip+1*np];
                    MVec sz01sy = svsplice(p0,sz0sy,sz1sy);
                    MVec sx = svld1_gather_index(p0,&sx_mT[ip],sx_index);
                    // MVec wqxsx = sx*wqx[ip];
                    MVec wqxsx = svmul_n_f64_z(p0, sx, wqx[ip]); 
                    svmopa_za64_m(0, p0, p, wqxsx, sz01sy);

                    MVec sz2sy = sy*sz_mT[ip+2*np];
                    MVec sz3sy = sy*sz_mT[ip+3*np];
                    MVec sz23sy = svsplice(p0,sz2sy,sz3sy);
                    svmopa_za64_m(1, p0, p, wqxsx, sz23sy);
                    
                    MVec wqysx = sx*wqy[ip];
                    svmopa_za64_m(2, p0, p, wqysx, sz01sy);
                    svmopa_za64_m(3, p0, p, wqysx, sz23sy);

                    MVec wqzsx = sx*wqy[ip];
                    svmopa_za64_m(4, p0, p, wqzsx, sz01sy);
                    svmopa_za64_m(5, p0, p, wqzsx, sz23sy);        
                }
                
                int offset0=8*(rho_bin);
                int offset1=8*(rho_bin+1);
                int offset2=8*(rho_bin+2);
                int offset3=8*(rho_bin+3);
                // Jx_arr
                //   z0y0 z0y1 z0y2 z0y3 z1y0 z1y1 z1y2 z1y3
                // x0           wxsx0sysz01
                // x1           wxsx1sysz01
                // x2           wxsx2sysz01
                // x3           wxsx3sysz01
                MVec wxsx0sysz01 = svread_hor_za64_m(vzero,p,0,0);
                MVec xrhocells0 = MVec::Load(p,&xrhocells[offset0]); 
                xrhocells0+=wxsx0sysz01; 
                xrhocells0.Store(p,&xrhocells[offset0]); 
                
                MVec wxsx1sysz01 = svread_hor_za64_m(vzero,p,0,1);
                MVec xrhocells1 = MVec::Load(p,&xrhocells[offset1]); 
                xrhocells1+=wxsx1sysz01; 
                xrhocells1.Store(p,&xrhocells[offset1]); 

                MVec wxsx2sysz01 = svread_hor_za64_m(vzero,p,0,2);
                MVec xrhocells2 = MVec::Load(p,&xrhocells[offset2]); 
                xrhocells2+=wxsx2sysz01; 
                xrhocells2.Store(p,&xrhocells[offset2]); 

                MVec wxsx3sysz01 = svread_hor_za64_m(vzero,p,0,3);
                MVec xrhocells3 = MVec::Load(p,&xrhocells[offset3]); 
                xrhocells3+=wxsx3sysz01; 
                xrhocells3.Store(p,&xrhocells[offset3]); 

                int offset4=8*(rho_bin+2*rhonxy);
                int offset5=8*(rho_bin+2*rhonxy+1);
                int offset6=8*(rho_bin+2*rhonxy+2);
                int offset7=8*(rho_bin+2*rhonxy+3);
                //   z2y0 z2y1 z2y2 z2y3 z3y0 z3y1 z3y2 z3y3
                // x0           wxsx0sysz23
                // x1           wxsx1sysz23
                // x2           wxsx2sysz23
                // x3           wxsx3sysz23
                MVec wxsx0sysz23 = svread_hor_za64_m(vzero,p,1,0);
                MVec xrhocells4 = MVec::Load(p,&xrhocells[offset4]); 
                xrhocells4+=wxsx0sysz23; 
                xrhocells4.Store(p,&xrhocells[offset4]); 
                
                MVec wxsx1sysz23 = svread_hor_za64_m(vzero,p,1,1);
                MVec xrhocells5 = MVec::Load(p,&xrhocells[offset5]); 
                xrhocells5+=wxsx1sysz23; 
                xrhocells5.Store(p,&xrhocells[offset5]); 

                MVec wxsx2sysz23 = svread_hor_za64_m(vzero,p,1,2);
                MVec xrhocells6 = MVec::Load(p,&xrhocells[offset6]); 
                xrhocells6+=wxsx2sysz23; 
                xrhocells6.Store(p,&xrhocells[offset6]); 

                MVec wxsx3sysz23 = svread_hor_za64_m(vzero,p,1,3);
                MVec xrhocells7 = MVec::Load(p,&xrhocells[offset7]); 
                xrhocells7+=wxsx3sysz23; 
                xrhocells7.Store(p,&xrhocells[offset7]); 

                // Jy_arr
                //   z0y0 z0y1 z0y2 z0y3 z1y0 z1y1 z1y2 z1y3
                // x0           wysx0sysz01
                // x1           wysx1sysz01
                // x2           wysx2sysz01
                // x3           wysx3sysz01
                MVec wysx0sysz01 = svread_hor_za64_m(vzero,p,2,0);
                MVec yrhocells0 = MVec::Load(p,&yrhocells[offset0]); 
                yrhocells0+=wysx0sysz01; 
                yrhocells0.Store(p,&yrhocells[offset0]); 
                
                MVec wysx1sysz01 = svread_hor_za64_m(vzero,p,2,1);
                MVec yrhocells1 = MVec::Load(p,&yrhocells[offset1]); 
                yrhocells1+=wysx1sysz01; 
                yrhocells1.Store(p,&yrhocells[offset1]); 

                MVec wysx2sysz01 = svread_hor_za64_m(vzero,p,2,2);
                MVec yrhocells2 = MVec::Load(p,&yrhocells[offset2]); 
                yrhocells2+=wysx2sysz01; 
                yrhocells2.Store(p,&yrhocells[offset2]); 

                MVec wysx3sysz01 = svread_hor_za64_m(vzero,p,2,3);
                MVec yrhocells3 = MVec::Load(p,&yrhocells[offset3]); 
                yrhocells3+=wysx3sysz01; 
                yrhocells3.Store(p,&yrhocells[offset3]); 

                //   z2y0 z2y1 z2y2 z2y3 z3y0 z3y1 z3y2 z3y3
                // x0           wysx0sysz23
                // x1           wysx1sysz23
                // x2           wysx2sysz23
                // x3           wysx3sysz23
                MVec wysx0sysz23 = svread_hor_za64_m(vzero,p,3,0);
                MVec yrhocells4 = MVec::Load(p,&yrhocells[offset4]); 
                yrhocells4+=wysx0sysz23; 
                yrhocells4.Store(p,&yrhocells[offset4]); 
                
                MVec wysx1sysz23 = svread_hor_za64_m(vzero,p,3,1);
                MVec yrhocells5 = MVec::Load(p,&yrhocells[offset5]); 
                yrhocells5+=wysx1sysz23; 
                yrhocells5.Store(p,&yrhocells[offset5]); 

                MVec wysx2sysz23 = svread_hor_za64_m(vzero,p,3,2);
                MVec yrhocells6 = MVec::Load(p,&yrhocells[offset6]); 
                yrhocells6+=wysx2sysz23; 
                yrhocells6.Store(p,&yrhocells[offset6]); 

                MVec wysx3sysz23 = svread_hor_za64_m(vzero,p,3,3);
                MVec yrhocells7 = MVec::Load(p,&yrhocells[offset7]); 
                yrhocells7+=wysx3sysz23; 
                yrhocells7.Store(p,&yrhocells[offset7]); 

                // Jz_arr
                //   z0y0 z0y1 z0y2 z0y3 z1y0 z1y1 z1y2 z1y3
                // x0           wzsx0sysz01
                // x1           wzsx1sysz01
                // x2           wzsx2sysz01
                // x3           wzsx3sysz01
                MVec wzsx0sysz01 = svread_hor_za64_m(vzero,p,4,0);
                MVec zrhocells0 = MVec::Load(p,&zrhocells[offset0]); 
                zrhocells0+=wzsx0sysz01; 
                zrhocells0.Store(p,&zrhocells[offset0]); 
                
                MVec wzsx1sysz01 = svread_hor_za64_m(vzero,p,4,1);
                MVec zrhocells1 = MVec::Load(p,&zrhocells[offset1]); 
                zrhocells1+=wzsx1sysz01; 
                zrhocells1.Store(p,&zrhocells[offset1]); 

                MVec wzsx2sysz01 = svread_hor_za64_m(vzero,p,4,2);
                MVec zrhocells2 = MVec::Load(p,&zrhocells[offset2]); 
                zrhocells2+=wzsx2sysz01; 
                zrhocells2.Store(p,&zrhocells[offset2]); 

                MVec wzsx3sysz01 = svread_hor_za64_m(vzero,p,4,3);
                MVec zrhocells3 = MVec::Load(p,&zrhocells[offset3]); 
                zrhocells3+=wzsx3sysz01; 
                zrhocells3.Store(p,&zrhocells[offset3]); 

                //   z2y0 z2y1 z2y2 z2y3 z3y0 z3y1 z3y2 z3y3
                // x0           wzsx0sysz23
                // x1           wzsx1sysz23
                // x2           wzsx2sysz23
                // x3           wzsx3sysz23
                MVec wzsx0sysz23 = svread_hor_za64_m(vzero,p,5,0);
                MVec zrhocells4 = MVec::Load(p,&zrhocells[offset4]); 
                zrhocells4+=wzsx0sysz23; 
                zrhocells4.Store(p,&zrhocells[offset4]); 
                
                MVec wzsx1sysz23 = svread_hor_za64_m(vzero,p,5,1);
                MVec zrhocells5 = MVec::Load(p,&zrhocells[offset5]); 
                zrhocells5+=wzsx1sysz23; 
                zrhocells5.Store(p,&zrhocells[offset5]); 

                MVec wzsx2sysz23 = svread_hor_za64_m(vzero,p,5,2);
                MVec zrhocells6 = MVec::Load(p,&zrhocells[offset6]); 
                zrhocells6+=wzsx2sysz23; 
                zrhocells6.Store(p,&zrhocells[offset6]); 

                MVec wzsx3sysz23 = svread_hor_za64_m(vzero,p,5,3);
                MVec zrhocells7 = MVec::Load(p,&zrhocells[offset7]); 
                zrhocells7+=wzsx3sysz23; 
                zrhocells7.Store(p,&zrhocells[offset7]); 
            }
        }
    }
}

// 这是备份版本，0710最初版本备份
template <int depos_order>
__arm_new("za") void sort_3d_sme_kernal_order_3_test_bak (
    const std::vector<int>& local_index,
    const std::vector<int>& bin_length,
    const std::vector<int>& bin_offsets,
    std::vector<amrex::Real>& xrhocells,
    std::vector<amrex::Real>& yrhocells,
    std::vector<amrex::Real>& zrhocells,
    std::vector<amrex::Real>& sx_m,
    std::vector<amrex::Real>& sy_m,
    std::vector<amrex::Real>& sz_m,
    std::vector<amrex::Real>& wqx,
    std::vector<amrex::Real>& wqy,
    std::vector<amrex::Real>& wqz,
    amrex::Dim3 len, int np, int numcell,
    int xjstride,int xkstride,
    std::vector<amrex::Real>& testsxwq
)__arm_streaming {
    using namespace amrex::literals;
    int nshape = 4;
    
    svbool_t p = svptrue_b64();
    svbool_t p0=svwhilelt_b64(0,4); // 前4个的谓词
    svbool_t p1=svbic_z(p,p, p0); // 后4个的谓词
    MVec vzero(0);

    int binnx = len.x;
    int binny = len.y;
    int binnxy = binnx*binny;
    // int nx=xjstride-1;
    // int nxy=xkstride-33;
    // int moff[8] = {-nxy,0,nxy,2*nxy,nx-nxy,nx,nx+nxy,nx+2*nxy};
    // printf("old in\n");
    // for (int old_bin = 1; old_bin <= numcell; old_bin++) {
    printf("len x %d y %d z %d xjstride %d xkstride %d\n",
        len.x,len.y,len.z,xjstride,xkstride);
    for (int iz = 0; iz < len.z; ++iz) {
        for (int iy = 0; iy < len.y; ++iy) {       
            for (int ix = 0; ix < len.x; ix++) {
                int old_bin=(ix) + (iy) * binnx + (iz) * binnxy;
                // printf(" %d %d*%d %d*%d old %d/%d bin_length %d \n"
                //     ,ix,iy,xjstride,iz,xkstride
                //     ,old_bin,numcell,bin_length[old_bin-1]);
                std::vector<int> ip_list;
                // Jxarr = wqx*sx*sy*sz
                if (bin_length[old_bin] == 0) continue;
                int start = bin_offsets[old_bin];
                int end = bin_offsets[old_bin+1];
                svzero_za();

                int first_idx=-1;
                for(int i=start;i<end;i++){
                    // printf("start %d end %d local_index %d \n",start,end,local_index[i]);
                    if (local_index[i] == INVALID_PARTICLE_ID) {
                        // idx1++;
                        continue;
                    } 
                    if(first_idx<0){
                        first_idx=i;
                    }else{
                        svzero_za();
                        int idx1 = first_idx;
                        int idx2=i;
                        int ip1 = local_index[idx1];
                        ip_list.push_back(ip1);
                        int ip2 = local_index[idx2];
                        ip_list.push_back(ip2);
                        // printf("ip1 %d ip2 %d\n",ip1,ip2);

                        // sx0sy x sz
                        MVec p1wqxsy = svld1(p0,&sy_m[ip1*nshape])*wqx[ip1];
                        MVec p1sx0sy = p1wqxsy*sx_m[ip1*nshape+0];// first 4 (1111 0000)
                        MVec p2wqxsy = svld1(p1,&sy_m[(ip2-1)*nshape])*wqx[ip2];
                        MVec p2sx0sy = p2wqxsy*sx_m[(ip2-1)*nshape+0]; // only last 4 (0000 1111)
                        MVec sx0sy = svsel(p0,p1sx0sy,p2sx0sy);
                        //====================
                        // double A[8]={0.};
                        // sx0sy.Store(p,&A[0]);
                        // printf("Test sxsy:");
                        // for(int ii=0;ii<8;ii++){
                        //     printf("\tsxsy[%d]: %f\n",ii,A[ii]);
                        // }
                        //======================

                        MVec p1sz = svld1(p0,&sz_m[ip1*nshape]);
                        MVec p2sz = svld1(p1,&sz_m[(ip2-1)*nshape]);
                        MVec sz = svsel(p0,p1sz,p2sz);

                        svmopa_za64_m(0, p, p, sx0sy, sz);

                        // sx1sy x sz
                        MVec p1sx1sy = p1wqxsy*sx_m[ip1*nshape+1];
                        MVec p2sx1sy = p2wqxsy*sx_m[(ip2-1)*nshape+1];
                        MVec sx1sy = svsel(p0,p1sx1sy,p2sx1sy);
                        svmopa_za64_m(1, p, p, sx1sy, sz);

                        // sx2sy x sz
                        MVec p1sx2sy = p1wqxsy*sx_m[ip1*nshape+2];
                        MVec p2sx2sy = p2wqxsy*sx_m[(ip2-1)*nshape+2];
                        MVec sx2sy = svsel(p0,p1sx2sy,p2sx2sy);
                        svmopa_za64_m(2, p, p, sx2sy, sz);

                        // sx3sy x sz
                        MVec p1sx3sy = p1wqxsy*sx_m[ip1*nshape+3];
                        MVec p2sx3sy = p2wqxsy*sx_m[(ip2-1)*nshape+3];
                        MVec sx3sy = svsel(p0,p1sx3sy,p2sx3sy);
                        svmopa_za64_m(3, p, p, sx3sy, sz);

                        first_idx=-1;
                        // x0
                        MVec p1wxsx0sysz0 = svread_hor_za64_m(vzero,p0,0,0); //第一个粒子第一层（总共4层）第一组的第1行，11110000
                        MVec p1wxsx0sysz1 = svread_hor_za64_m(vzero,p0,0,1); //第一个粒子第一层（总共4层）第一组的第2行，11110000
                        MVec p1s0=svsplice(p0,p1wxsx0sysz0, p1wxsx0sysz1); //粒子1第一组8个数
                        MVec p2wxsx0sysz0 = svread_hor_za64_m(vzero,p1,0,4); //第2个粒子同理，但是00001111
                        MVec p2wxsx0sysz1 = svread_hor_za64_m(vzero,p1,0,5);
                        MVec p2s0 = svext(p2wxsx0sysz0,svext(p2wxsx0sysz1,p2wxsx0sysz1,4),4); //组织成第2个粒子的第一组8个数
                        MVec xrhocells0 = MVec::Load(p,&xrhocells[8*(old_bin-1)]); //对于jx的第1个rhocell，位置ic-nx-1
                        xrhocells0+=(p1s0+p2s0); //两个粒子最终加总一次
                        xrhocells0.Store(p,&xrhocells[8*(old_bin-1)]); //写回第1组的rhocell
                        
                        MVec p1wxsx0sysz2 = svread_hor_za64_m(vzero,p0,0,2); //第一层粒子1第2组的第1行
                        MVec p1wxsx0sysz3 = svread_hor_za64_m(vzero,p0,0,3);
                        MVec p1s1=svsplice(p0,p1wxsx0sysz0, p1wxsx0sysz1); //粒子1第2组8个数
                        MVec p2wxsx0sysz2 = svread_hor_za64_m(vzero,p1,0,6); //第一层粒子2第2组的第1行
                        MVec p2wxsx0sysz3 = svread_hor_za64_m(vzero,p1,0,7);
                        MVec p2s1 = svext(p2wxsx0sysz2,svext(p2wxsx0sysz3,p2wxsx0sysz3,4),4); //组织成粒子2第2组8个数
                        MVec xrhocells1 = MVec::Load(p,&xrhocells[8*(old_bin-1+2*binnx)]); //第二个rhocell
                        xrhocells1+=(p1s1+p2s1);//两个粒子最终加总一次
                        xrhocells1.Store(p,&xrhocells[8*(old_bin-1+2*binnx)]);//写回第2组的rhocell
                        // 上面是第一层的rhocell结束，也就是x=0这一层
                        //==========================
                        p1s0.Store(p,&testsxwq[ip1*64]);
                        p2s0.Store(p,&testsxwq[ip2*64]);
                        p1s1.Store(p,&testsxwq[ip1*64+8]);
                        p2s1.Store(p,&testsxwq[ip2*64+8]);
                        // double A[8]={0.};
                        // int yy[8]={-1,-1,-1,-1, 0,0,0,0};
                        // int zz[8]={-1, 0, 1, 2,-1,0,1,2};
                        // p1s0.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip1,ix-1,iy+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        // p2s0.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip2,ix-1,iy+yy[ii],iz+zz[ii],A[ii]);
                        // }

                        // p1s1.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip1,ix-1,iy+2+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        // p2s1.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip2,ix-1,iy+2+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        //======================

                        // x1
                        MVec p1wxsx1sysz0 = svread_hor_za64_m(vzero,p0,1,0); //第一个粒子第2层（总共4层）第3组的第1行，11110000
                        MVec p1wxsx1sysz1 = svread_hor_za64_m(vzero,p0,1,1); //第一个粒子第2层（总共4层）第3组的第2行，11110000
                        MVec p1s2=svsplice(p0,p1wxsx1sysz0, p1wxsx1sysz1); 
                        MVec p2wxsx1sysz0 = svread_hor_za64_m(vzero,p1,1,4); 
                        MVec p2wxsx1sysz1 = svread_hor_za64_m(vzero,p1,1,5);
                        MVec p2s2 = svext(p2wxsx1sysz0,svext(p2wxsx1sysz1,p2wxsx1sysz1,4),4); 
                        MVec xrhocells2 = MVec::Load(p,&xrhocells[8*(old_bin)]); 
                        xrhocells2+=(p1s2+p2s2); //两个粒子最终加总一次
                        xrhocells2.Store(p,&xrhocells[8*(old_bin)]); 

                        MVec p1wxsx1sysz2 = svread_hor_za64_m(vzero,p0,1,2); 
                        MVec p1wxsx1sysz3 = svread_hor_za64_m(vzero,p0,1,3);
                        MVec p1s3=svsplice(p0,p1wxsx1sysz0, p1wxsx1sysz1); 
                        MVec p2wxsx1sysz2 = svread_hor_za64_m(vzero,p1,1,6); 
                        MVec p2wxsx1sysz3 = svread_hor_za64_m(vzero,p1,1,7);
                        MVec p2s3 = svext(p2wxsx1sysz2,svext(p2wxsx1sysz3,p2wxsx1sysz3,4),4); 
                        MVec xrhocells3 = MVec::Load(p,&xrhocells[8*(old_bin+2*binnx)]); 
                        xrhocells3+=(p1s3+p2s3);//两个粒子最终加总一次
                        xrhocells3.Store(p,&xrhocells[8*(old_bin+2*binnx)]);
                        // 上面是第2层的rhocell结束，也就是x=1这一层
                        //========================
                        p1s2.Store(p,&testsxwq[ip1*64+8*2]);
                        p2s2.Store(p,&testsxwq[ip2*64+8*2]);
                        p1s3.Store(p,&testsxwq[ip1*64+8*3]);
                        p2s3.Store(p,&testsxwq[ip2*64+8*3]);
                        // p1s0.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip1,ix,iy+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        // p2s0.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip2,ix,iy+yy[ii],iz+zz[ii],A[ii]);
                        // }

                        // p1s1.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip1,ix,iy+2+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        // p2s1.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip2,ix,iy+2+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        //======================

                        // x2
                        MVec p1wxsx2sysz0 = svread_hor_za64_m(vzero,p0,2,0); 
                        MVec p1wxsx2sysz1 = svread_hor_za64_m(vzero,p0,2,1); 
                        MVec p1s4=svsplice(p0,p1wxsx2sysz0, p1wxsx2sysz1); 
                        MVec p2wxsx2sysz0 = svread_hor_za64_m(vzero,p1,2,4); 
                        MVec p2wxsx2sysz1 = svread_hor_za64_m(vzero,p1,2,5);
                        MVec p2s4 = svext(p2wxsx2sysz0,svext(p2wxsx2sysz1,p2wxsx2sysz1,4),4); 
                        MVec xrhocells4 = MVec::Load(p,&xrhocells[8*(old_bin+1)]); 
                        xrhocells4+=(p1s4+p2s4); //两个粒子最终加总一次
                        xrhocells4.Store(p,&xrhocells[8*(old_bin+1)]); 

                        MVec p1wxsx2sysz2 = svread_hor_za64_m(vzero,p0,2,2); 
                        MVec p1wxsx2sysz3 = svread_hor_za64_m(vzero,p0,2,3);
                        MVec p1s5=svsplice(p0,p1wxsx2sysz0, p1wxsx2sysz1); 
                        MVec p2wxsx2sysz2 = svread_hor_za64_m(vzero,p1,2,6); 
                        MVec p2wxsx2sysz3 = svread_hor_za64_m(vzero,p1,2,7);
                        MVec p2s5 = svext(p2wxsx2sysz2,svext(p2wxsx2sysz3,p2wxsx2sysz3,4),4); 
                        MVec xrhocells5 = MVec::Load(p,&xrhocells[8*(old_bin+1+2*binnx)]); 
                        xrhocells5+=(p1s5+p2s5);//两个粒子最终加总一次
                        xrhocells5.Store(p,&xrhocells[8*(old_bin+1+2*binnx)]);
                        // 上面是第3层的rhocell结束，也就是x=2这一层
                        //========================
                        p1s4.Store(p,&testsxwq[ip1*64+8*4]);
                        p2s4.Store(p,&testsxwq[ip2*64+8*4]);
                        p1s5.Store(p,&testsxwq[ip1*64+8*5]);
                        p2s5.Store(p,&testsxwq[ip2*64+8*5]);
                        // p1s0.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip1,ix+1,iy+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        // p2s0.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip2,ix+1,iy+yy[ii],iz+zz[ii],A[ii]);
                        // }

                        // p1s1.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip1,ix+1,iy+2+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        // p2s1.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip2,ix+1,iy+2+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        //======================

                        // x3
                        MVec p1wxsx3sysz0 = svread_hor_za64_m(vzero,p0,3,0); 
                        MVec p1wxsx3sysz1 = svread_hor_za64_m(vzero,p0,3,1); 
                        MVec p1s6=svsplice(p0,p1wxsx3sysz0, p1wxsx3sysz1); 
                        MVec p2wxsx3sysz0 = svread_hor_za64_m(vzero,p1,3,4); 
                        MVec p2wxsx3sysz1 = svread_hor_za64_m(vzero,p1,3,5);
                        MVec p2s6 = svext(p2wxsx3sysz0,svext(p2wxsx3sysz1,p2wxsx3sysz1,4),4); 
                        MVec xrhocells6 = MVec::Load(p,&xrhocells[8*(old_bin+2)]); 
                        xrhocells6+=(p1s6+p2s6); //两个粒子最终加总一次
                        xrhocells6.Store(p,&xrhocells[8*(old_bin+2)]); 

                        MVec p1wxsx3sysz2 = svread_hor_za64_m(vzero,p0,3,2); 
                        MVec p1wxsx3sysz3 = svread_hor_za64_m(vzero,p0,3,3);
                        MVec p1s7=svsplice(p0,p1wxsx3sysz0, p1wxsx3sysz1); 
                        MVec p2wxsx3sysz2 = svread_hor_za64_m(vzero,p1,3,6); 
                        MVec p2wxsx3sysz3 = svread_hor_za64_m(vzero,p1,3,7);
                        MVec p2s7 = svext(p2wxsx3sysz2,svext(p2wxsx3sysz3,p2wxsx3sysz3,4),4); 
                        MVec xrhocells7 = MVec::Load(p,&xrhocells[8*(old_bin+2+2*binnx)]); 
                        xrhocells7+=(p1s7+p2s7);//两个粒子最终加总一次
                        xrhocells7.Store(p,&xrhocells[8*(old_bin+2+2*binnx)]);
                        //========================
                        p1s6.Store(p,&testsxwq[ip1*64+8*6]);
                        p2s6.Store(p,&testsxwq[ip2*64+8*6]);
                        p1s7.Store(p,&testsxwq[ip1*64+8*7]);
                        p2s7.Store(p,&testsxwq[ip2*64+8*7]);
                        // p1s0.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip1,ix+2,iy+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        // p2s0.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip2,ix+2,iy+yy[ii],iz+zz[ii],A[ii]);
                        // }

                        // p1s1.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip1,ix+2,iy+2+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        // p2s1.Store(p,&A[0]);
                        // for(int ii=0;ii<8;ii++){
                        //     printf("SVE ip %d cellIdx x %d y %d z %d: %f\n"
                        //         ,ip2,ix+2,iy+2+yy[ii],iz+zz[ii],A[ii]);
                        // }
                        //======================
                    }  
                }
                if(first_idx>=0){
                    int ip1 = local_index[first_idx];
                    ip_list.push_back(ip1);
                    //=================
                    printf("single partile!");
                    exit(0);
                    //=================

                    // sx0sy x sz
                    MVec wqxsy = svld1(p0,&sy_m[ip1*nshape])*wqx[ip1];
                    MVec sx0sy = wqxsy*sx_m[ip1*nshape+0];// first 4 (1111 0000)
                    MVec sz = svld1(p0,&sz_m[ip1*nshape]);
                    svmopa_za64_m(0, p, p, sx0sy, sz);

                    // sx1sy x sz
                    MVec sx1sy = wqxsy*sx_m[ip1*nshape+1];
                    svmopa_za64_m(1, p, p, sx1sy, sz);

                    // sx2sy x sz
                    MVec sx2sy = wqxsy*sx_m[ip1*nshape+2];
                    svmopa_za64_m(2, p, p, sx2sy, sz);

                    // sx3sy x sz
                    MVec sx3sy = wqxsy*sx_m[ip1*nshape+3];
                    svmopa_za64_m(3, p, p, sx3sy, sz);
                }
                
                svzero_za();
                // x0
                // MVec p1wxsx0sysz0 = svread_hor_za64_m(vzero,p0,0,0); //第一个粒子第一层（总共4层）第一组的第1行，11110000
                // MVec p1wxsx0sysz1 = svread_hor_za64_m(vzero,p0,0,1); //第一个粒子第一层（总共4层）第一组的第2行，11110000
                // MVec p1s0=svsplice(p0,p1wxsx0sysz0, p1wxsx0sysz1); //粒子1第一组8个数
                // MVec p2wxsx0sysz0 = svread_hor_za64_m(vzero,p1,0,4); //第2个粒子同理，但是00001111
                // MVec p2wxsx0sysz1 = svread_hor_za64_m(vzero,p1,0,5);
                // MVec p2s0 = svext(p2wxsx0sysz0,svext(p2wxsx0sysz1,p2wxsx0sysz1,4),4); //组织成第2个粒子的第一组8个数
                // MVec xrhocells0 = MVec::Load(p,&xrhocells[8*(old_bin-nx-1)]); //对于jx的第1个rhocell，位置ic-nx-1
                // xrhocells0+=(p1s0+p2s0); //两个粒子最终加总一次
                // xrhocells0.Store(p,&xrhocells[8*(old_bin-nx-1)]); //写回第1组的rhocell

                // MVec p1wxsx0sysz2 = svread_hor_za64_m(vzero,p0,0,2); //第一层粒子1第2组的第1行
                // MVec p1wxsx0sysz3 = svread_hor_za64_m(vzero,p0,0,3);
                // MVec p1s1=svsplice(p0,p1wxsx0sysz0, p1wxsx0sysz1); //粒子1第2组8个数
                // MVec p2wxsx0sysz2 = svread_hor_za64_m(vzero,p1,0,6); //第一层粒子2第2组的第1行
                // MVec p2wxsx0sysz3 = svread_hor_za64_m(vzero,p1,0,7);
                // MVec p2s1 = svext(p2wxsx0sysz2,svext(p2wxsx0sysz3,p2wxsx0sysz3,4),4); //组织成粒子2第2组8个数
                // MVec xrhocells1 = MVec::Load(p,&xrhocells[8*(old_bin+nx-1)]); //第二个rhocell
                // xrhocells1+=(p1s1+p2s1);//两个粒子最终加总一次
                // xrhocells1.Store(p,&xrhocells[8*(old_bin+nx-1)]);//写回第2组的rhocell
                // // 上面是第一层的rhocell结束，也就是x=0这一层

                // // x1
                // MVec p1wxsx1sysz0 = svread_hor_za64_m(vzero,p0,1,0); //第一个粒子第2层（总共4层）第3组的第1行，11110000
                // MVec p1wxsx1sysz1 = svread_hor_za64_m(vzero,p0,1,1); //第一个粒子第2层（总共4层）第3组的第2行，11110000
                // MVec p1s2=svsplice(p0,p1wxsx1sysz0, p1wxsx1sysz1); 
                // MVec p2wxsx1sysz0 = svread_hor_za64_m(vzero,p1,1,4); 
                // MVec p2wxsx1sysz1 = svread_hor_za64_m(vzero,p1,1,5);
                // MVec p2s2 = svext(p2wxsx1sysz0,svext(p2wxsx1sysz1,p2wxsx1sysz1,4),4); 
                // MVec xrhocells2 = MVec::Load(p,&xrhocells[8*(old_bin-nx)]); 
                // xrhocells2+=(p1s2+p2s2); //两个粒子最终加总一次
                // xrhocells2.Store(p,&xrhocells[8*(old_bin-nx)]); 

                // MVec p1wxsx1sysz2 = svread_hor_za64_m(vzero,p0,1,2); 
                // MVec p1wxsx1sysz3 = svread_hor_za64_m(vzero,p0,1,3);
                // MVec p1s3=svsplice(p0,p1wxsx1sysz0, p1wxsx1sysz1); 
                // MVec p2wxsx1sysz2 = svread_hor_za64_m(vzero,p1,1,6); 
                // MVec p2wxsx1sysz3 = svread_hor_za64_m(vzero,p1,1,7);
                // MVec p2s3 = svext(p2wxsx1sysz2,svext(p2wxsx1sysz3,p2wxsx1sysz3,4),4); 
                // MVec xrhocells3 = MVec::Load(p,&xrhocells[8*(old_bin+nx)]); 
                // xrhocells3+=(p1s3+p2s3);//两个粒子最终加总一次
                // xrhocells3.Store(p,&xrhocells[8*(old_bin+nx)]);
                // // 上面是第2层的rhocell结束，也就是x=1这一层

                // // x2
                // MVec p1wxsx2sysz0 = svread_hor_za64_m(vzero,p0,2,0); 
                // MVec p1wxsx2sysz1 = svread_hor_za64_m(vzero,p0,2,1); 
                // MVec p1s4=svsplice(p0,p1wxsx2sysz0, p1wxsx2sysz1); 
                // MVec p2wxsx2sysz0 = svread_hor_za64_m(vzero,p1,2,4); 
                // MVec p2wxsx2sysz1 = svread_hor_za64_m(vzero,p1,2,5);
                // MVec p2s4 = svext(p2wxsx2sysz0,svext(p2wxsx2sysz1,p2wxsx2sysz1,4),4); 
                // MVec xrhocells4 = MVec::Load(p,&xrhocells[8*(old_bin-nx+1)]); 
                // xrhocells4+=(p1s4+p2s4); //两个粒子最终加总一次
                // xrhocells4.Store(p,&xrhocells[8*(old_bin-nx+1)]); 

                // MVec p1wxsx2sysz2 = svread_hor_za64_m(vzero,p0,2,2); 
                // MVec p1wxsx2sysz3 = svread_hor_za64_m(vzero,p0,2,3);
                // MVec p1s5=svsplice(p0,p1wxsx2sysz0, p1wxsx2sysz1); 
                // MVec p2wxsx2sysz2 = svread_hor_za64_m(vzero,p1,2,6); 
                // MVec p2wxsx2sysz3 = svread_hor_za64_m(vzero,p1,2,7);
                // MVec p2s5 = svext(p2wxsx2sysz2,svext(p2wxsx2sysz3,p2wxsx2sysz3,4),4); 
                // MVec xrhocells5 = MVec::Load(p,&xrhocells[8*(old_bin+nx+1)]); 
                // xrhocells5+=(p1s5+p2s5);//两个粒子最终加总一次
                // xrhocells5.Store(p,&xrhocells[8*(old_bin+nx+1)]);
                // // 上面是第3层的rhocell结束，也就是x=2这一层

                // // x3
                // MVec p1wxsx3sysz0 = svread_hor_za64_m(vzero,p0,3,0); 
                // MVec p1wxsx3sysz1 = svread_hor_za64_m(vzero,p0,3,1); 
                // MVec p1s6=svsplice(p0,p1wxsx3sysz0, p1wxsx3sysz1); 
                // MVec p2wxsx3sysz0 = svread_hor_za64_m(vzero,p1,3,4); 
                // MVec p2wxsx3sysz1 = svread_hor_za64_m(vzero,p1,3,5);
                // MVec p2s6 = svext(p2wxsx3sysz0,svext(p2wxsx3sysz1,p2wxsx3sysz1,4),4); 
                // MVec xrhocells6 = MVec::Load(p,&xrhocells[8*(old_bin-nx+2)]); 
                // xrhocells6+=(p1s6+p2s6); //两个粒子最终加总一次
                // xrhocells6.Store(p,&xrhocells[8*(old_bin-nx+2)]); 

                // MVec p1wxsx3sysz2 = svread_hor_za64_m(vzero,p0,3,2); 
                // MVec p1wxsx3sysz3 = svread_hor_za64_m(vzero,p0,3,3);
                // MVec p1s7=svsplice(p0,p1wxsx3sysz0, p1wxsx3sysz1); 
                // MVec p2wxsx3sysz2 = svread_hor_za64_m(vzero,p1,3,6); 
                // MVec p2wxsx3sysz3 = svread_hor_za64_m(vzero,p1,3,7);
                // MVec p2s7 = svext(p2wxsx3sysz2,svext(p2wxsx3sysz3,p2wxsx3sysz3,4),4); 
                // MVec xrhocells7 = MVec::Load(p,&xrhocells[8*(old_bin+nx+2)]); 
                // xrhocells7+=(p1s7+p2s7);//两个粒子最终加总一次
                // xrhocells7.Store(p,&xrhocells[8*(old_bin+nx+2)]);
                // 上面是第4层的rhocell结束，也就是x=3这一层
            }
        }
    }
}
 
 template <int depos_order>
 __arm_new("za") inline void sort_3d_sme_kernal_special(
     const long numcell,
     const std::vector<int>& local_index,
     const std::vector<int>& bin_length,
     const std::vector<int>& bin_offsets,
     std::vector<amrex::Real>& xrhocells,
     std::vector<amrex::Real>& yrhocells,
     std::vector<amrex::Real>& zrhocells,
     std::vector<amrex::Real>& sx_m,
     std::vector<amrex::Real>& sy_m,
     std::vector<amrex::Real>& sz_m,
     std::vector<amrex::Real>& wqx,
     std::vector<amrex::Real>& wqy,
     std::vector<amrex::Real>& wqz
 )__arm_streaming
 {
     using namespace amrex::literals;
     // svbool_t p=svwhilelt_b64(start,end);
     // intVec ip_v=intVec::Load(p,&local_index[idx]);
     // svbool_t pp = svcmpneq_n_s64(p, ip_v, INVALID_PARTICLE_ID);
 
     svbool_t p_4=svwhilelt_b64(0,4);
     svbool_t p_4_8=svbic_z(svptrue_b64(),svptrue_b64(),p_4);
     svbool_t p0=svwhilelt_b64(0,2);
     svbool_t p1=svbic_z(p_4,p_4, p0);
     svbool_t p = svptrue_b64();
     MVec vzero(0);
     for (int old_bin = 1; old_bin <= numcell; ++old_bin) {
         if (bin_length[old_bin-1] == 0) continue;
         int start = bin_offsets[old_bin-1];
         int end = bin_offsets[old_bin];
         svzero_za();
         int ipp=0;
         // while(idx1<end-last){
         // while(ipp<bin_length-last){
         int first_idx=-1;
         for(int i=start;i<end;i++){
             if (local_index[i] == INVALID_PARTICLE_ID) {
                 // idx1++;
                 continue;
             } 
             if(first_idx<0){
                 first_idx=i;
             }else{
                 int idx1 = first_idx;
                 int idx2=i;
                 int ip1 = local_index[idx1];
                 int ip2 = local_index[idx2];
                 
                 MVec sz_xv=svdup_n_f64(0);
                 MVec sz_yv=svdup_n_f64(0);
                 MVec sz_zv=svdup_n_f64(0);
                 MVec sz_x1 = svld1(p0,&sz_m[ip1*2]);
                 MVec sz_x2 = svld1(p1,&sz_m[ip1*2]);
                 MVec sz_y1 = sz_x1; 
                 MVec sz_y2 = sz_x2; 
                 MVec sz_z1 = sz_x1;
                 MVec sz_z2 = sz_x2;
                 // svbool_t p1=svwhilelt_b64(2,4);
                 // MVec sz_x1=sz_1*wqx[ip1];
                 // sz_x1=svsel(p0,sz_x1,sz_v0);
                 // MVec sz_x2=sz_2*wqx[ip2];
                 // sz_x1=svsel(p1,sz_x2,sz_v0);
 
                 // MVec sz_y1=sz_1*wqy[ip1];
                 // sz_y1=svsel(p0,sz_y1,sz_v0);
                 // MVec sz_y2=sz_2*wqy[ip2];
                 // sz_y1=svsel(p1,sz_y2,sz_v0);
 
                 // MVec sz_z1=sz_1*wqz[ip1];
                 // sz_z1=svsel(p0,sz_z1,sz_v0);
                 // MVec sz_z2=sz_2*wqz[ip2];
                 // sz_z1=svsel(p1,sz_z2,sz_v0);
 
                 
                 sz_x1*=wqx[ip1];
                 sz_xv=svsel(p0,sz_x1,sz_xv);
                 sz_x2*=wqx[ip2];
                 sz_xv=svsel(p1,sz_x2,sz_xv);
                 sz_y1*=wqy[ip1];
                 sz_yv=svsel(p0,sz_y1,sz_yv);
                 sz_y2*=wqy[ip2];
                 sz_yv=svsel(p1,sz_y2,sz_yv);
                 sz_z1*=wqz[ip1];
                 sz_zv=svsel(p0,sz_z1,sz_zv);
                 sz_z2*=wqz[ip2];
                 sz_zv=svsel(p1,sz_z2,sz_zv);
                 // double vvs[8];
                 // sz_xv.Store(p,&vvs[0]);
                 // test[ip]=vvs[0];
                 // test[ip1]=vvs[2];
 
                 // test[ip]=wqx[ip];
                 // test[ip1]=wqx[ip1];
 
                 MVec vx1=MVec::Load(p0, &sx_m[ip1*2]);
                 MVec vx2=MVec::Load(p0, &sx_m[ip2*2]);
                 // double vvs[8];
                 // vx1.Store(p0,&vvs[0]);
                 // test[ip]=vvs[0];
                 // vx2.Store(p0,&vvs[0]);
                 // test[ip2]=vvs[0];
 
                 MVec vy1=MVec::Load(p0, &sy_m[ip1*2]);
                 MVec vy2=MVec::Load(p0, &sy_m[ip2*2]);
 
                 const uint64_t x_indices[8]={0,2,0,2,1,3,1,3};
                 MVec vx_broadcast=svtbl(svzip1(vx1,vx2),svld1_u64(svptrue_b64(),x_indices));
                 const uint64_t y_indices[8]={0,0,2,2,1,1,3,3};
                 MVec vy_broadcast=svtbl(svzip1(vy1,vy2),svld1_u64(svptrue_b64(),y_indices));
 
                 MVec sxsy_v=vx_broadcast*vy_broadcast;      
 
                 // svzero_za();
                 svmopa_za64_m(0, p_4, svptrue_b64(), sz_xv, sxsy_v);
                 svmopa_za64_m(1, p_4, svptrue_b64(), sz_yv, sxsy_v);
                 svmopa_za64_m(2, p_4, svptrue_b64(), sz_zv, sxsy_v);
 
                 first_idx=-1;
             }
             
         }
 
         // svzero_za();
         if(first_idx>=0){
 
             int ip1 = local_index[first_idx];
             // ip1-=1;
             MVec sz_x0=svdup_n_f64(0);
             MVec sz_y0=svdup_n_f64(0);
             MVec sz_z0=svdup_n_f64(0);
             MVec sz_mm = svld1(p0,&sz_m[ip1*2]);
             MVec sz_1=sz_mm*wqx[ip1];
             sz_x0=svsel(p0,sz_1,sz_x0);
 
             // MVec sz_v2=svdup_n_f64(0);
             // MVec sz_1 = svld1(p0,&sz_m[ip1*2]);
             MVec sz_2=sz_mm*wqy[ip1];
             sz_y0=svsel(p0,sz_2,sz_y0);
 
             // MVec sz_v3=svdup_n_f64(0);
             // MVec sz_3 = svld1(p0,&sz_m[ip1*2]);
             MVec sz_3=sz_mm*wqx[ip1];
             sz_z0=svsel(p0,sz_3,sz_z0);
             // svbool_t p1=svwhilelt_b64(2,4);
             MVec vx1=MVec::Load(p0, &sx_m[ip1*2]);
             MVec vy1=MVec::Load(p0, &sy_m[ip1*2]);
             MVec sxsy_v=svsplice(p0,vx1,vy1);
             // svzero_za();
             svmopa_za64_m(0, p0, p_4, sz_1, sxsy_v);
             svmopa_za64_m(1, p0, p_4, sz_2, sxsy_v);
             svmopa_za64_m(2, p0, p_4, sz_3, sxsy_v);
         }
 
         MVec wwx = MVec::Load(p,&xrhocells[8*(old_bin)]);
         MVec wwy = MVec::Load(p,&yrhocells[8*(old_bin)]);
         MVec wwz = MVec::Load(p,&zrhocells[8*(old_bin)]);
         MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,0);
         MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4,0,1);
         // svfloat64x2_t ss=svcreate2_f64(wxsxsysz0,wxsxsysz0);
         // MVec B=svext(wxsxsysz1,wxsxsysz1,4);
         // MVec s=svsel(p_4,wxsxsysz0,B);
         MVec s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
         wwx+=s;
         wxsxsysz0 = svread_hor_za64_m(vzero,p_4_8,0,2);
         wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,0,3);
         MVec B=svext(wxsxsysz1,wxsxsysz1,4);
         s=svext(wxsxsysz0,B,4);
         // B=svext(wxsxsysz1,wxsxsysz1,4);
         // s=svsel(p_4,wxsxsysz0,B);
         // s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
         wwx+=s;
         wwx.Store(p,&xrhocells[8*(old_bin)]);
 
         wxsxsysz0 = svread_hor_za64_m(vzero,p_4,1,0);
         wxsxsysz1 = svread_hor_za64_m(vzero,p_4,1,1);
         MVec sy=svsplice(p_4,wxsxsysz0,wxsxsysz1);
         wwy+=sy;
         wxsxsysz0 = svread_hor_za64_m(vzero,p_4_8,1,2);
         wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,1,3);
         MVec By=svext(wxsxsysz1,wxsxsysz1,4);
         sy=svext(wxsxsysz0,By,4);
         wwy+=sy;
         wwy.Store(p,&yrhocells[8*(old_bin)]);
 
         wxsxsysz0 = svread_hor_za64_m(vzero,p_4,2,0);
         wxsxsysz1 = svread_hor_za64_m(vzero,p_4,2,1);
         MVec sz=svsplice(p_4,wxsxsysz0,wxsxsysz1);
         wwz+=sz;
         wxsxsysz0 = svread_hor_za64_m(vzero,p_4_8,2,2);
         wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,2,3);
         MVec Bz=svext(wxsxsysz1,wxsxsysz1,4);
         sz=svext(wxsxsysz0,Bz,4);
         wwz+=sy;
         wwz.Store(p,&zrhocells[8*(old_bin)]); 
 
         // wwx.Store(p,&xrhocells[8*(old_bin)]);
         // // test[c]=xrhocells[8*c];
         // wwy.Store(p,&yrhocells[8*(old_bin)]);
         // wwz.Store(p,&zrhocells[8*(old_bin)]); 
     }
 }
 
 template <int depos_order>
 __arm_new("za") inline void sort_3d_sme_kernal_hybrid_nosort(
     const long np_to_deposit, const std::vector<long>& newbin,
     std::vector<amrex::Real>& xrhocells,
     std::vector<amrex::Real>& yrhocells,
     std::vector<amrex::Real>& zrhocells,
     std::vector<amrex::Real>& sx_m,
     std::vector<amrex::Real>& sy_m,
     std::vector<amrex::Real>& sz_m,
     std::vector<amrex::Real>& wqx,
     std::vector<amrex::Real>& wqy,
     std::vector<amrex::Real>& wqz
 )__arm_streaming
 {
     using namespace amrex::literals;
 
     svbool_t p_4=svwhilelt_b64(0,4);
     svbool_t p_4_8=svbic_z(svptrue_b64(),svptrue_b64(),p_4);
     svbool_t p0=svwhilelt_b64(0,2);
     svbool_t p1=svbic_z(p_4,p_4, p0);
     svbool_t p = svptrue_b64();
     MVec vzero(0);
     int last=np_to_deposit%2;
     for(long ip=0;ip<np_to_deposit-last;ip+=2){
         svzero_za();
         int ip1 = ip;
         int ip2 = ip+1;
         
         MVec sz_xv=svdup_n_f64(0);
         MVec sz_yv=svdup_n_f64(0);
         MVec sz_zv=svdup_n_f64(0);
         MVec sz_x1 = svld1(p0,&sz_m[ip1*2]);
         MVec sz_x2 = svld1(p1,&sz_m[ip1*2]);
         // MVec sz_y1 = sz_x1; 
         // MVec sz_y2 = sz_x2; 
         // MVec sz_z1 = sz_x1;
         // MVec sz_z2 = sz_x2;
         // svbool_t p1=svwhilelt_b64(2,4);
         // sz_x1*=wqx[ip1];
         sz_xv=svsel(p0,sz_x1,sz_xv);
         // sz_x2*=wqx[ip2];
         sz_xv=svsel(p1,sz_x2,sz_xv);
         // sz_y1*=wqy[ip1];
         // sz_yv=svsel(p0,sz_y1,sz_yv);
         // sz_y2*=wqy[ip2];
         // sz_yv=svsel(p1,sz_y2,sz_yv);
         // sz_z1*=wqz[ip1];
         // sz_zv=svsel(p0,sz_z1,sz_zv);
         // sz_z2*=wqz[ip2];
         // sz_zv=svsel(p1,sz_z2,sz_zv);
 
 
         MVec vx1=MVec::Load(p0, &sx_m[ip1*2]);
         MVec vx2=MVec::Load(p0, &sx_m[ip2*2]);
 
         MVec vy1=MVec::Load(p0, &sy_m[ip1*2]);
         MVec vy2=MVec::Load(p0, &sy_m[ip2*2]);
 
         const uint64_t x_indices[8]={0,2,0,2,1,3,1,3};
         MVec vx_broadcast=svtbl(svzip1(vx1,vx2),svld1_u64(svptrue_b64(),x_indices));
         const uint64_t y_indices[8]={0,0,2,2,1,1,3,3};
         MVec vy_broadcast=svtbl(svzip1(vy1,vy2),svld1_u64(svptrue_b64(),y_indices));
 
         MVec sxsy_v=vx_broadcast*vy_broadcast;      
 
         // svzero_za();
         svmopa_za64_m(0, p_4, svptrue_b64(), sz_xv, sxsy_v);
         // svmopa_za64_m(1, p_4, svptrue_b64(), sz_yv, sxsy_v);
         // svmopa_za64_m(2, p_4, svptrue_b64(), sz_zv, sxsy_v);
 
         int idx1=newbin[ip1];
         MVec wwx = MVec::Load(p,&xrhocells[8*(idx1)]);
         MVec wwy = MVec::Load(p,&yrhocells[8*(idx1)]);
         MVec wwz = MVec::Load(p,&zrhocells[8*(idx1)]);
         MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,0);
         MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4,0,1);
         MVec s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
         wwx+=(s*wqx[ip1]);
         wwy+=(s*wqy[ip1]);
         wwz+=(s*wqz[ip1]);
         wwx.Store(p,&xrhocells[8*(idx1)]);
         wwy.Store(p,&yrhocells[8*(idx1)]);
         wwz.Store(p,&zrhocells[8*(idx1)]);
 
         int idx2=newbin[ip2];
         wwx = MVec::Load(p,&xrhocells[8*(idx2)]);
         wwy = MVec::Load(p,&yrhocells[8*(idx2)]);
         wwz = MVec::Load(p,&zrhocells[8*(idx2)]);
         wxsxsysz0 = svread_hor_za64_m(vzero,p_4_8,0,2);
         wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,0,3);
         MVec B=svext(wxsxsysz1,wxsxsysz1,4);
         MVec s2=svext(wxsxsysz0,B,4);
         wwx+=(s2*wqx[ip2]);
         wwy+=(s2*wqy[ip2]);
         wwz+=(s2*wqz[ip2]);
         wwx.Store(p,&xrhocells[8*(idx2)]);
         wwy.Store(p,&yrhocells[8*(idx2)]);
         wwz.Store(p,&zrhocells[8*(idx2)]); 
             
     }
 
     if(np_to_deposit%2){
         svzero_za();
 
         int ip1 = np_to_deposit-1;
         MVec sz_v=svdup_n_f64(0);
         MVec sz_1 = svld1(p0,&sz_m[ip1*2]);
         // sz_1*=wqx[ip1];
         sz_v=svsel(p0,sz_1,sz_v);
         // svbool_t p1=svwhilelt_b64(2,4);
         MVec vx1=MVec::Load(p0, &sx_m[ip1*2]);
         MVec vy1=MVec::Load(p0, &sy_m[ip1*2]);
         MVec sxsy_v=svsplice(p0,vx1,vy1);
         svmopa_za64_m(0, p0, p_4, sz_v, sxsy_v);
         int idx1=newbin[ip1];
         MVec wwx = MVec::Load(p,&xrhocells[8*(idx1)]);
         MVec wwy = MVec::Load(p,&yrhocells[8*(idx1)]);
         MVec wwz = MVec::Load(p,&zrhocells[8*(idx1)]);
         MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,0);
         MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4,0,1);
         MVec s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
         wwx+=(s*wqx[ip1]);
         wwy+=(s*wqy[ip1]);
         wwz+=(s*wqz[ip1]);
         wwx.Store(p,&xrhocells[8*(idx1)]);
         wwy.Store(p,&yrhocells[8*(idx1)]);
         wwz.Store(p,&zrhocells[8*(idx1)]);
 
     }
 }
 
 template <int depos_order>
 __arm_new("za") inline void sort_3d_sme_kernal_bak(
     const long numcell,
     const std::vector<int>& local_index,
     const int bin_length,
     const int start,
     const int end,
     const int old_bin,
     std::vector<amrex::Real>& xrhocells,
     std::vector<amrex::Real>& yrhocells,
     std::vector<amrex::Real>& zrhocells,
     std::vector<amrex::Real>& sx_m,
     std::vector<amrex::Real>& sy_m,
     std::vector<amrex::Real>& sz_m,
     std::vector<amrex::Real>& wqx,
     std::vector<amrex::Real>& wqy,
     std::vector<amrex::Real>& wqz
 )__arm_streaming
 {
     using namespace amrex::literals;
     // svbool_t p=svwhilelt_b64(start,end);
     // intVec ip_v=intVec::Load(p,&local_index[idx]);
     // svbool_t pp = svcmpneq_n_s64(p, ip_v, INVALID_PARTICLE_ID);
 
     svbool_t p_4=svwhilelt_b64(0,4);
     svbool_t p_4_8=svbic_z(svptrue_b64(),svptrue_b64(),p_4);
     svbool_t p0=svwhilelt_b64(0,2);
     svbool_t p1=svbic_z(p_4,p_4, p0);
     svbool_t p = svptrue_b64();
     MVec vzero(0);
 
     svzero_za();
     const int last = bin_length%2;
     int idx1=start;
     // for(int idx=start;idx<end1;idx+=2){
     int ipp=0;
     while(ipp<bin_length-last){
         while (local_index[idx1] == INVALID_PARTICLE_ID) {
             idx1++;
             continue;
         }
         int ip1 = local_index[idx1];
         int idx2=idx1+1;
         while (local_index[idx2] == INVALID_PARTICLE_ID) {
             idx2++;
             continue;
         }
         int ip2 = local_index[idx2];
         // sx={x[0],x[1],x2[0],x2[1]}
         // sysz={y1[0]z1[0],y1[1]z1[0],y1[0]z1[1],y1[1]z1[1],y2[0]z2[0],y2[1]z2[0],y2[0]z2[1],y2[1]z2[1]}
         // int ip=xbinList[idx];
         // int ip1=xbinList[idx+1];
         // int ipp1=ipp+1;
         
         MVec sz_xv=svdup_n_f64(0);
         MVec sz_yv=svdup_n_f64(0);
         MVec sz_zv=svdup_n_f64(0);
         MVec sz_x1 = svld1(p0,&sz_m[ip1*2]);
         MVec sz_x2 = svld1(p1,&sz_m[ip2*2]);
         MVec sz_y1 = sz_x1; 
         MVec sz_y2 = sz_x2; 
         MVec sz_z1 = sz_x1;
         MVec sz_z2 = sz_x2;
         // svbool_t p1=svwhilelt_b64(2,4);
         sz_x1*=wqx[ip1];
         sz_xv=svsel(p0,sz_x1,sz_xv);
         sz_x2*=wqx[ip2];
         sz_xv=svsel(p1,sz_x2,sz_xv);
         sz_y1*=wqy[ip1];
         sz_yv=svsel(p0,sz_y1,sz_yv);
         sz_y2*=wqy[ip2];
         sz_yv=svsel(p1,sz_y2,sz_yv);
         sz_z1*=wqz[ip1];
         sz_zv=svsel(p0,sz_z1,sz_zv);
         sz_z2*=wqz[ip2];
         sz_zv=svsel(p1,sz_z2,sz_zv);
         // double vvs[8];
         // sz_xv.Store(p,&vvs[0]);
         // test[ip]=vvs[0];
         // test[ip1]=vvs[2];
 
         // test[ip]=wqx[ip];
         // test[ip1]=wqx[ip1];
 
         MVec vx1=MVec::Load(p0, &sx_m[ip1*2]);
         MVec vx2=MVec::Load(p0, &sx_m[ip2*2]);
         // double vvs[8];
         // vx1.Store(p0,&vvs[0]);
         // test[ip]=vvs[0];
         // vx2.Store(p0,&vvs[0]);
         // test[ip2]=vvs[0];
 
         MVec vy1=MVec::Load(p0, &sy_m[ip1*2]);
         MVec vy2=MVec::Load(p0, &sy_m[ip2*2]);
 
         const uint64_t x_indices[8]={0,2,0,2,1,3,1,3};
         MVec vx_broadcast=svtbl(svzip1(vx1,vx2),svld1_u64(svptrue_b64(),x_indices));
         const uint64_t y_indices[8]={0,0,2,2,1,1,3,3};
         MVec vy_broadcast=svtbl(svzip1(vy1,vy2),svld1_u64(svptrue_b64(),y_indices));
 
         MVec sxsy_v=vx_broadcast*vy_broadcast;      
 
         // svzero_za();
         svmopa_za64_m(0, p_4, svptrue_b64(), sz_xv, sxsy_v);
         svmopa_za64_m(1, p_4, svptrue_b64(), sz_yv, sxsy_v);
         svmopa_za64_m(2, p_4, svptrue_b64(), sz_zv, sxsy_v);
 
         idx1=idx2+1;
         ipp+=2;
     }
 
     // svzero_za();
     if(last){
         // int ip=xbinList[end1+1];   
         // printf("ip %d len %d \n",ip,end-start);
         while (local_index[idx1] == INVALID_PARTICLE_ID) {
             idx1++;
             continue;
         }
         int ip1 = local_index[idx1];
         // ip1-=1;
         MVec sz_v=svdup_n_f64(0);
         MVec sz_1 = svld1(p0,&sz_m[ip1*2]);
         sz_1*=wqx[ip1];
         sz_v=svsel(p0,sz_1,sz_v);
         // svbool_t p1=svwhilelt_b64(2,4);
         MVec vx1=MVec::Load(p0, &sx_m[ip1*2]);
         MVec vy1=MVec::Load(p0, &sy_m[ip1*2]);
         MVec sxsy_v=svsplice(p0,vx1,vy1);
         // svzero_za();
         svmopa_za64_m(0, p0, p_4, sz_v, sxsy_v);
     }
 
     MVec wwx = MVec::Load(p,&xrhocells[8*(old_bin-1)]);
     MVec wwy = MVec::Load(p,&yrhocells[8*(old_bin-1)]);
     MVec wwz = MVec::Load(p,&zrhocells[8*(old_bin-1)]);
     MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,0);
     MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4,0,1);
     // svfloat64x2_t ss=svcreate2_f64(wxsxsysz0,wxsxsysz0);
     // MVec B=svext(wxsxsysz1,wxsxsysz1,4);
     // MVec s=svsel(p_4,wxsxsysz0,B);
     MVec s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
     wwx+=s;
     wxsxsysz0 = svread_hor_za64_m(vzero,p_4_8,0,2);
     wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,0,3);
     MVec B=svext(wxsxsysz1,wxsxsysz1,4);
     s=svext(wxsxsysz0,B,4);
     // B=svext(wxsxsysz1,wxsxsysz1,4);
     // s=svsel(p_4,wxsxsysz0,B);
     // s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
     wwx+=s;
     wwx.Store(p,&xrhocells[8*(old_bin-1)]);
     // test[c]=xrhocells[8*c];
     wwy.Store(p,&yrhocells[8*(old_bin-1)]);
     wwz.Store(p,&zrhocells[8*(old_bin-1)]); 
 }
 
 
 template <int depos_order>
 void doDepositionShapeN_3d_sme_hybrid_nosort (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Dim3 hi,
                          amrex::Dim3 len,
                          amrex::Real q,
                          std::vector<int>& test,
                          std::vector<int>& test0,
                          ParticleTileType& ptile, const amrex::Box& box,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     WARPX_PROFILE("doDepositionShapeN_3d_sme_hybrid_nosort()");
     // uint64_t total_time[3]={0};
     using namespace std::chrono;
     using namespace amrex::literals;
     double total_time=0;
     // auto total_start=high_resolution_clock::now();
     uint64_t precompute=0;
     uint64_t cale_time=0;
     uint64_t sort_time=0;
         uint64_t count_time=0;
         uint64_t presum_time=0;
         uint64_t binlist_time=0;
     uint64_t reduce_time=0;
     uint64_t svetime[3]={0};
     uint64_t branch_time=0;
     
     // total_time[0]=rdtscv();
     
 
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z; 
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
 
     constexpr int nshapes = depos_order + 1;
     // constexpr int nshapes = 2;
     int vl=svcntd();
 
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
 
     auto compute_shape_factor_v2 = [](std::vector<double>* sx, Vec xmid, svbool_t p) {
         const svuint64_t sx_index = svindex_u64(0ULL, 2ULL);
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         svst1_scatter_index(p,&sx[0][0],sx_index,sx0);
         svst1_scatter_index(p,&sx[0][1],sx_index,sx1);
         // sx0.Store(p, sx[0]);
         // sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
     auto compute_shape_factor_v1 = [](double* sx, Vec xmid, svbool_t p) {
         const svuint64_t sx_index = svindex_u64(0, 2);
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // double test[8];
         // xint.Store(p,&test[0]);
         // for(int ii=0;ii<8;ii++){
         //     // printf("ii %d xind %f \n",ii,test[ii]);
         //     sx[ii][0]=1.0-test[ii];
         //     sx[ii][1]=test[ii];
         // }
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         // double sx00[8];
         // double sx01[8];
         // sx0.Store(p,&sx00[0]);
         // sx1.Store(p,&sx01[0]);
         // for(int ii=0;ii<8;ii++){
         //     // printf("ii %d xind %f \n",ii,test[ii]);
         //     sx[ii][0]=sx00[ii];
         //     sx[ii][1]=sx01[ii];
         // }
         svst1_scatter_index(p,&sx[0],sx_index,sx0);
         svst1_scatter_index(p,&sx[1],sx_index,sx1);
         // sx0.Store(p, sx[0]);
         // sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
     const long numcell = jx_fab.box().numPts();
     // const long numcell = ptile.m_bin_offsets.size()-1;
 
     std::vector<amrex::Real> xrhocells(8*numcell, 0.0);
     std::vector<amrex::Real> yrhocells(8*numcell, 0.0);
     std::vector<amrex::Real> zrhocells(8*numcell, 0.0);
     // one roll x
     uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
     uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
     uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
     long nx=xjstride;
     long nxy=xkstride;
     long moff[8] = {0, 1, nx, nx+1, nxy, nxy+1, nx+nxy, nx+nxy+1};
     svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
     svbool_t px = svcmpeq_n_u64(svptrue_b64(), rmx_v, 0);
     svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
     svbool_t py = svcmpeq_n_u64(svptrue_b64(), rmy_v, 0);
     svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
     svbool_t pz = svcmpeq_n_u64(svptrue_b64(), rmz_v, 0);
 
     std::vector<amrex::Real> wqx(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqy(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqz(np_to_deposit, 0.0);
 
     std::vector<amrex::Real> sx_m(np_to_deposit*nshapes, 0.);
     std::vector<amrex::Real> sy_m(np_to_deposit*nshapes, 0.);
     std::vector<amrex::Real> sz_m(np_to_deposit*nshapes, 0.);
     // alignas(64) long xoffsets[np_to_deposit]; 
     alignas(64) std::vector<long> xoffsets(np_to_deposit); 
     // alignas(64) long yoffsets[np_to_deposit];
     // alignas(64) long zoffsets[np_to_deposit];
     long bx = 2, by = 2, bz = 2;
     amrex::IntVect box_shape = box.length();
     // amrex::Print() << "Box shape: " << box_shape << std::endl;
     long nnx = box_shape[0];
     long nny = box_shape[1];
     long nnxny = nnx*nny;
     // alignas(64) long newbin[np_to_deposit];
     alignas(64) std::vector<long> newbin(np_to_deposit,-1);
     
 
     for(long ip=0;ip<np_to_deposit;ip+=vl){
         // svetime[0]=rdtscv();
 
         // 计算基本物理量
         svbool_t p=svwhilele_b64(ip,np_to_deposit);
         // Inverse of Lorentz factor gamma
         Vec uxp_v=Vec::Load(p,&uxp[ip]);
         Vec uyp_v=Vec::Load(p,&uyp[ip]);
         Vec uzp_v=Vec::Load(p,&uzp[ip]);
         Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                     + uyp_v * uyp_v * clightsq
                                     + uzp_v * uzp_v * clightsq).Sqrt();
         // Product of particle charges and weights
         Vec wp_v=Vec::Load(p,&wp[ip]);
         Vec wq_v = q * wp_v;
 
         // Current particle positions (in physical units)
         Vec xp = Vec::Load(p, &mx[ip]);
         Vec yp = Vec::Load(p, &my[ip]);
         Vec zp = Vec::Load(p, &mz[ip]);
 
         // Particle velocities
         Vec vx_v = uxp_v * gaminv;
         Vec vy_v = uyp_v * gaminv;
         Vec vz_v = uzp_v * gaminv;
 
         // if (do_ionization) wq *= ion_lev[ip];
         Vec wqx_v = wq_v * invvol * vx_v;
         Vec wqy_v = wq_v * invvol * vy_v;
         Vec wqz_v = wq_v * invvol * vz_v;
 
         wqx_v.Store(p, &wqx[ip]);
         wqy_v.Store(p, &wqy[ip]);
         wqz_v.Store(p, &wqz[ip]);
 
         Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x;
         Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y;
         Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z;
         // xmid.Store(p, &test0[ip]);
         // double* sx_temp[nshapes] = {&sx_m[0][ip], &sx_m[1][ip]};
         intVec j_cellv = compute_shape_factor_v1( &sx_m[ip*2], xmid, p);
         // j_cellv.Store(p, &test[ip]);
         intVec k_cellv = compute_shape_factor_v1( &sy_m[ip*2], ymid, p);
         intVec l_cellv = compute_shape_factor_v1( &sz_m[ip*2], zmid, p); 
 
         intVec xoffsets_v = j_cellv + k_cellv * xjstride + l_cellv * xkstride;
         // intVec yoffsets_v = j_cellv + k_cellv * yjstride + l_cellv * ykstride;
         // intVec zoffsets_v = j_cellv + k_cellv * zjstride + l_cellv * zkstride;
 
         xoffsets_v.Store(p,&xoffsets[ip]);
         // intVec new_bin_v = (j_cellv-bx) + 
         //                     (k_cellv-by)* nnx + 
         //                     (l_cellv-bz) * nnxny;
         // new_bin_v.Store(p,&newbin[ip]);
 
     }
      
     //////////////////////////
     
     sort_3d_sme_kernal_hybrid_nosort<1>(
         np_to_deposit,xoffsets,
         xrhocells,yrhocells,zrhocells,
         sx_m,sy_m,sz_m,
         wqx,wqy,wqz);
         // }
     // }
 
     // one roll x
     // uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
     // uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
     // uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
     // // long nx=xjstride;
     // // long nxy=xkstride;
     // int moff[8] = {0, 1, nx, nx+1, nxny, nxny+1, nx+nxny, nx+nxny+1};
     // svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
     // svbool_t px = svcmpeq_n_u64(svptrue_b64(), rmx_v, 0);
     // svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
     // svbool_t py = svcmpeq_n_u64(svptrue_b64(), rmy_v, 0);
     // svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
     // svbool_t pz = svcmpeq_n_u64(svptrue_b64(), rmz_v, 0);
     for (int iz = bx; iz < len.z-bx; ++iz) {
         for (int iy = bx; iy < len.y-bx; ++iy) {       
             for (int ix = bx; ix < len.x-bx; ix+=vl) {
     // for (int iz = 0; iz <= len.z; ++iz) {
     //     for (int iy = 0; iy <= len.y; ++iy) {       
     //         for (int ix = 0; ix <= len.x; ix+=vl) {
                 // svetime[0]=rdtscv();
 
                 // vector
                 svbool_t p=svwhilelt_b64(ix,(len.x-2));
                 // long j = lo.x + ix;
                 // long k = lo.y + iy;
                 // long l = lo.z + iz;
                 // x
                 // uint64_t irhox = 8*(ix + iy * xjstride + iz * xkstride);
                 // svuint64_t rhox_index = svindex_u64(0, 8ULL);
                 // long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                 svuint64_t rho_index = svindex_u64(0ULL, 8ULL);
                 long xoffset=ix + iy * xjstride + iz * xkstride;
                 // long xoffset=(ix-bx) + (iy-by) * nnx + (iz-bz) * nnxny;
                 // long cell_idx=(ix-bx) + (iy-by) * nnx + (iz-bz) * nnxny;
                 long jxoffset=xoffset;
                 // long irhox=8*xoffset;
                 long irhox=8*xoffset;
                 Vec jx0=Vec::Load(p,&jx_arr.p[jxoffset+moff[0]]);
                 svfloat64_t rhox0=svld1_gather_u64index_f64(p,&xrhocells[0+irhox],rho_index);
                 jx0+=rhox0;
                 jx0.Store(p,&jx_arr.p[jxoffset+moff[0]]);
 
                 Vec jx1=Vec::Load(p,&jx_arr.p[jxoffset+moff[1]]);
                 svfloat64_t rhox1=svld1_gather_u64index_f64(p,&xrhocells[1+irhox],rho_index);
                 jx1+=rhox1;
                 jx1.Store(p,&jx_arr.p[jxoffset+moff[1]]);
 
                 Vec jx2=Vec::Load(p,&jx_arr.p[jxoffset+moff[2]]);
                 svfloat64_t rhox2=svld1_gather_u64index_f64(p,&xrhocells[2+irhox],rho_index);
                 jx2+=rhox2;
                 jx2.Store(p,&jx_arr.p[jxoffset+moff[2]]);
 
                 Vec jx3=Vec::Load(p,&jx_arr.p[jxoffset+moff[3]]);
                 svfloat64_t rhox3=svld1_gather_u64index_f64(p,&xrhocells[3+irhox],rho_index);
                 jx3+=rhox3;
                 jx3.Store(p,&jx_arr.p[jxoffset+moff[3]]);
 
                 Vec jx4=Vec::Load(p,&jx_arr.p[jxoffset+moff[4]]);
                 svfloat64_t rhox4=svld1_gather_u64index_f64(p,&xrhocells[4+irhox],rho_index);
                 jx4+=rhox4;
                 jx4.Store(p,&jx_arr.p[jxoffset+moff[4]]);
 
                 Vec jx5=Vec::Load(p,&jx_arr.p[jxoffset+moff[5]]);
                 svfloat64_t rhox5=svld1_gather_u64index_f64(p,&xrhocells[5+irhox],rho_index);
                 jx5+=rhox5;
                 jx5.Store(p,&jx_arr.p[jxoffset+moff[5]]);
 
                 Vec jx6=Vec::Load(p,&jx_arr.p[jxoffset+moff[6]]);
                 svfloat64_t rhox6=svld1_gather_u64index_f64(p,&xrhocells[6+irhox],rho_index);
                 jx6+=rhox6;
                 jx6.Store(p,&jx_arr.p[jxoffset+moff[6]]);
 
                 Vec jx7=Vec::Load(p,&jx_arr.p[jxoffset+moff[7]]);
                 svfloat64_t rhox7=svld1_gather_u64index_f64(p,&xrhocells[7+irhox],rho_index);
                 jx7+=rhox7;
                 jx7.Store(p,&jx_arr.p[jxoffset+moff[7]]);
                 
                 // y
                 // uint64_t irhoy = ix + iy * yjstride + iz * ykstride;
                 // svuint64_t rhoy_index = svindex_u64(irhoy, 8ULL);
                 // long jyoffset = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
                 // long yoffset = ix + iy * yjstride + iz * ykstride;
                 long jyoffset=xoffset;
                 long irhoy=irhox;
 
                 Vec jy0=Vec::Load(p,&jy_arr.p[jyoffset+moff[0]]);
                 svfloat64_t rhoy0=svld1_gather_u64index_f64(p,&yrhocells[0+irhoy],rho_index);
                 jy0+=rhoy0;
                 jy0.Store(p,&jy_arr.p[jyoffset+moff[0]]);
 
                 Vec jy1=Vec::Load(p,&jy_arr.p[jyoffset+moff[1]]);
                 svfloat64_t rhoy1=svld1_gather_u64index_f64(p,&yrhocells[1+irhoy],rho_index);
                 jy1+=rhoy1;
                 jy1.Store(p,&jy_arr.p[jyoffset+moff[1]]);
 
                 Vec jy2=Vec::Load(p,&jy_arr.p[jyoffset+moff[2]]);
                 svfloat64_t rhoy2=svld1_gather_u64index_f64(p,&yrhocells[2+irhoy],rho_index);
                 jy2+=rhoy2;
                 jy2.Store(p,&jy_arr.p[jyoffset+moff[2]]);
 
                 Vec jy3=Vec::Load(p,&jy_arr.p[jyoffset+moff[3]]);
                 svfloat64_t rhoy3=svld1_gather_u64index_f64(p,&yrhocells[3+irhoy],rho_index);
                 jy3+=rhoy3;
                 jy3.Store(p,&jy_arr.p[jyoffset+moff[3]]);
 
                 Vec jy4=Vec::Load(p,&jy_arr.p[jyoffset+moff[4]]);
                 svfloat64_t rhoy4=svld1_gather_u64index_f64(p,&yrhocells[4+irhoy],rho_index);
                 jy4+=rhoy4;
                 jy4.Store(p,&jy_arr.p[jyoffset+moff[4]]);
 
                 Vec jy5=Vec::Load(p,&jy_arr.p[jyoffset+moff[5]]);
                 svfloat64_t rhoy5=svld1_gather_u64index_f64(p,&yrhocells[5+irhoy],rho_index);
                 jy5+=rhoy5;
                 jy5.Store(p,&jy_arr.p[jyoffset+moff[5]]);
 
                 Vec jy6=Vec::Load(p,&jy_arr.p[jyoffset+moff[6]]);
                 svfloat64_t rhoy6=svld1_gather_u64index_f64(p,&yrhocells[6+irhoy],rho_index);
                 jy6+=rhoy6;
                 jy6.Store(p,&jy_arr.p[jyoffset+moff[6]]);
 
                 Vec jy7=Vec::Load(p,&jy_arr.p[jyoffset+moff[7]]);
                 svfloat64_t rhoy7=svld1_gather_u64index_f64(p,&yrhocells[7+irhoy],rho_index);
                 jy7+=rhoy7;
                 jy7.Store(p,&jy_arr.p[jyoffset+moff[7]]);
 
                 // z
                 // uint64_t irhoz = ix + iy * zjstride + iz * zkstride;
                 // svuint64_t rhoz_index = svindex_u64(irhoz, 8ULL);
                 // long jzoffset = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
                 // long zoffset = ix + iy * zjstride + iz * zkstride;
                 long jzoffset=xoffset;
                 long irhoz=irhox;
                 Vec jz0=Vec::Load(p,&jz_arr.p[jzoffset+moff[0]]);
                 svfloat64_t rhoz0=svld1_gather_u64index_f64(p,&zrhocells[0+irhoz],rho_index);
                 jz0+=rhoz0;
                 jz0.Store(p,&jz_arr.p[jzoffset+moff[0]]);
 
                 Vec jz1=Vec::Load(p,&jz_arr.p[jzoffset+moff[1]]);
                 svfloat64_t rhoz1=svld1_gather_u64index_f64(p,&zrhocells[1+irhoz],rho_index);
                 jz1+=rhoz1;
                 jz1.Store(p,&jz_arr.p[jzoffset+moff[1]]);
 
                 Vec jz2=Vec::Load(p,&jz_arr.p[jzoffset+moff[2]]);
                 svfloat64_t rhoz2=svld1_gather_u64index_f64(p,&zrhocells[2+irhoz],rho_index);
                 jz2+=rhoz2;
                 jz2.Store(p,&jz_arr.p[jzoffset+moff[2]]);
 
                 Vec jz3=Vec::Load(p,&jz_arr.p[jzoffset+moff[3]]);
                 svfloat64_t rhoz3=svld1_gather_u64index_f64(p,&zrhocells[3+irhoz],rho_index);
                 jz3+=rhoz3;
                 jz3.Store(p,&jz_arr.p[jzoffset+moff[3]]);
 
                 Vec jz4=Vec::Load(p,&jz_arr.p[jzoffset+moff[4]]);
                 svfloat64_t rhoz4=svld1_gather_u64index_f64(p,&zrhocells[4+irhoz],rho_index);
                 jz4+=rhoz4;
                 jz4.Store(p,&jz_arr.p[jzoffset+moff[4]]);
 
                 Vec jz5=Vec::Load(p,&jz_arr.p[jzoffset+moff[5]]);
                 svfloat64_t rhoz5=svld1_gather_u64index_f64(p,&zrhocells[5+irhoz],rho_index);
                 jz5+=rhoz5;
                 jz5.Store(p,&jz_arr.p[jzoffset+moff[5]]);
 
                 Vec jz6=Vec::Load(p,&jz_arr.p[jzoffset+moff[6]]);
                 svfloat64_t rhoz6=svld1_gather_u64index_f64(p,&zrhocells[6+irhoz],rho_index);
                 jz6+=rhoz6;
                 jz6.Store(p,&jz_arr.p[jzoffset+moff[6]]);
 
                 Vec jz7=Vec::Load(p,&jz_arr.p[jzoffset+moff[7]]);
                 svfloat64_t rhoz7=svld1_gather_u64index_f64(p,&zrhocells[7+irhoz],rho_index);
                 jz7+=rhoz7;
                 jz7.Store(p,&jz_arr.p[jzoffset+moff[7]]);
 
                 // svetime[1]=rdtscv();
                 // reduce_time+=(svetime[1]-svetime[0]);
             }
         }
     }
     
 }


template <int depos_order>
void doDepositionShapeN_3d_sme_order3 (const GetParticlePosition<PIdx>& GetPosition,
                        const amrex::ParticleReal * const wp,
                        const amrex::ParticleReal * const uxp,
                        const amrex::ParticleReal * const uyp,
                        const amrex::ParticleReal * const uzp,
                        const int* ion_lev,
                        amrex::FArrayBox& jx_fab,
                        amrex::FArrayBox& jy_fab,
                        amrex::FArrayBox& jz_fab,
                        long np_to_deposit,
                        amrex::Real relative_time,
                        const amrex::XDim3 & dinv,
                        const amrex::XDim3 & xyzmin,
                        amrex::Dim3 lo,
                        amrex::Dim3 hi,
                        amrex::Dim3 len,
                        amrex::Real q,
                        std::vector<int>& test,
                        std::vector<double>& test0,
                        std::vector<int>& testbin,
                        std::vector<double>& test_sxm,
                        ParticleTileType& ptile, const amrex::Box& box,
                        std::vector<amrex::Real>& test_rhocells,
                        std::vector<amrex::Real>& test_sxwq,
                        [[maybe_unused]]int n_rz_azimuthal_modes)
{
    // WARPX_PROFILE("doDepositionShapeN_3d_sme_order3()");
    uint64_t total_time[3]={0};
    using namespace std::chrono;
    using namespace amrex::literals;
    uint64_t precompute=0;
    uint64_t cale_time=0;
    uint64_t sort_time=0;
        uint64_t update[2]={0};
        uint64_t update1[7]={0};
        uint64_t presort=0;
        uint64_t insert=0;
        uint64_t borrow=0;
        uint64_t rebuildtime=0;
        uint64_t rebuild1[7]={0};
    uint64_t reduce_time=0;
    uint64_t svetime[3]={0};
    uint64_t svetime1[3]={0};
    // uint64_t branch_time=0;
    
    total_time[0]=rdtscv();

    const bool do_ionization = ion_lev;
    const amrex::Real invvol = dinv.x*dinv.y*dinv.z; 
    const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;

    amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
    amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
    amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();

    constexpr int nshapes = depos_order + 1;
    int vl=svcntd();

    const amrex::ParticleReal* mx = GetPosition.m_x;
    const amrex::ParticleReal* my = GetPosition.m_y;
    const amrex::ParticleReal* mz = GetPosition.m_z;

    auto compute_shape_factor_order3 = [](double* sx, Vec xmid, svbool_t p) {
        const svuint64_t sx_index = svindex_u64(0, 4);
        intVec i_newv = svcvt_s64_f64_z(p, xmid);

        Vec j = svcvt_f64_s64_z(p, i_newv);
        Vec xint = xmid - j;

        Vec temp = 1.0 - xint;
        Vec sx0 = (1.0 / 6.0) * temp * temp * temp;
        Vec sx1 = (2.0 / 3.0) - xint * xint * (1.0 - xint * 0.5);
        Vec sx2 = (2.0 / 3.0) - temp * temp * (1.0 - 0.5 *temp);
        Vec sx3 = (1.0 / 6.0) * xint * xint * xint;
        svst1_scatter_index(p,&sx[0],sx_index,sx0);
        svst1_scatter_index(p,&sx[1],sx_index,sx1);
        svst1_scatter_index(p,&sx[2],sx_index,sx2);
        svst1_scatter_index(p,&sx[3],sx_index,sx3);

        return i_newv-1;
    };

    // 预计算网格步长
    const int xjstride = jx_arr.jstride;
    const int xkstride = jx_arr.kstride;
    const int yjstride = jy_arr.jstride;
    const int ykstride = jy_arr.kstride;
    const int zjstride = jz_arr.jstride;
    const int zkstride = jz_arr.kstride;

    std::vector<amrex::Real> wqx(np_to_deposit, 0.0);
    std::vector<amrex::Real> wqy(np_to_deposit, 0.0);
    std::vector<amrex::Real> wqz(np_to_deposit, 0.0);

    std::vector<amrex::Real> sx_m(np_to_deposit*nshapes, 0.);
    std::vector<amrex::Real> sy_m(np_to_deposit*nshapes, 0.);
    std::vector<amrex::Real> sz_m(np_to_deposit*nshapes, 0.);
    alignas(64) long xoffsets[np_to_deposit]; 
    long bx = 2, by = 2, bz = 2;
    amrex::IntVect box_shape = box.length();
    long nnx = len.x;
    long nny = len.y;
    long nnxny = nnx*nny;
    // alignas(64) std::vector<long> newbin(np_to_deposit);
    alignas(64) std::vector<int> newbin(np_to_deposit);
    
    svetime[0]=rdtscv();
    #pragma omp unroll
    for(long ip=0;ip<np_to_deposit;ip+=vl){
        // svetime[0]=rdtscv();

        // 计算基本物理量
        svbool_t p=svwhilelt_b64(ip,np_to_deposit);
        // Inverse of Lorentz factor gamma
        Vec uxp_v=Vec::Load(p,&uxp[ip]);
        Vec uyp_v=Vec::Load(p,&uyp[ip]);
        Vec uzp_v=Vec::Load(p,&uzp[ip]);
        Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                    + uyp_v * uyp_v * clightsq
                                    + uzp_v * uzp_v * clightsq).Sqrt();
        // Product of particle charges and weights
        Vec wp_v=Vec::Load(p,&wp[ip]);
        Vec wq_v = q * wp_v;

        // Current particle positions (in physical units)
        Vec xp = Vec::Load(p, &mx[ip]);
        Vec yp = Vec::Load(p, &my[ip]);
        Vec zp = Vec::Load(p, &mz[ip]);

        // Particle velocities
        Vec vx_v = uxp_v * gaminv;
        Vec vy_v = uyp_v * gaminv;
        Vec vz_v = uzp_v * gaminv;

        // if (do_ionization) wq *= ion_lev[ip];
        Vec wqx_v = wq_v * invvol * vx_v;
        Vec wqy_v = wq_v * invvol * vy_v;
        Vec wqz_v = wq_v * invvol * vz_v;

        wqx_v.Store(p, &wqx[ip]);
        wqy_v.Store(p, &wqy[ip]);
        wqz_v.Store(p, &wqz[ip]);

        Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x;
        Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y;
        Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z;
        // xmid.Store(p, &test0[ip]);
        // double* sx_temp[nshapes] = {&sx_m[0][ip], &sx_m[1][ip]};
        intVec j_cellv = compute_shape_factor_order3( &sx_m[ip*4], xmid, p);
        // j_cellv.Store(p, &test[ip]);
        intVec k_cellv = compute_shape_factor_order3( &sy_m[ip*4], ymid, p);
        intVec l_cellv = compute_shape_factor_order3( &sz_m[ip*4], zmid, p); 

        // intVec xoffsets_v = j_cellv + k_cellv * xjstride + l_cellv * xkstride;
        // intVec yoffsets_v = j_cellv + k_cellv * yjstride + l_cellv * ykstride;
        // intVec zoffsets_v = j_cellv + k_cellv * zjstride + l_cellv * zkstride;

        // xoffsets_v.Store(p,&xoffsets[ip]);
        intVec new_bin_v = (j_cellv) + 
                            (k_cellv)* nnx + 
                            (l_cellv) * nnxny;
        svst1w_s64(p, &newbin[ip], new_bin_v);
        // new_bin_v.Store(p,&newbin[ip]);
    }
    svetime[1]=rdtscv();
    precompute+=(svetime[1]-svetime[0]); 
    //==================
    test_sxm=sx_m;
    testbin=newbin;
    // test0.assign(nshapes*np_to_deposit,0);
    // test1=wqx;
    // for(int ip=0;ip<np_to_deposit;ip++){
    //     printf("newbin[%d]=%d/size %d\n",ip,newbin[ip],newbin.size());
    // }
    std::vector<amrex::Real> testsxwq(64*np_to_deposit, 0.0);
    //===================
    const int numcell=ptile.m_num_bins;
    
    // 只允许找左右两边借的方案，更快更稳定，但是不能扩展
    ///////////判断、增量处理（删除、更新索引）、或重组过程////////////
    auto& local_index = ptile.m_local_index;
    auto& bin_offsets = ptile.m_bin_offsets;
    auto& bin_length = ptile.m_bin_lengths;
    auto& num_particles = ptile.m_num_particles;
    auto& pid_to_bin_map = ptile.m_pid_to_bin_map;
    auto& pid_to_index_map = ptile.m_pid_to_index_map; 
    auto& free_slot = ptile.m_free_slots;
    std::unordered_map<int, std::vector<int>> m_pending_moves;
    bool rebuild=false;
    // rebuild=true;
    
    // L1：粒子总数超过最大容量直接重组
    if(np_to_deposit<ptile.m_capacity){
        svetime[0]=rdtscv();
        // 先统一操作，搜索一遍所有待增量更新的粒子
        // 新增粒子添加
        int loop_np=np_to_deposit;
        // 新增粒子添加
        for(int ip=num_particles;ip<np_to_deposit;ip++){
            int new_bin=newbin[ip];
            m_pending_moves[new_bin].push_back(ip);
            loop_np=num_particles;
        }
        // 减少的粒子删除
        for(int ip=np_to_deposit;ip<num_particles;ip++){
            int old_bin=pid_to_bin_map[ip];
            int idx=pid_to_index_map[ip]; 
            //打洞、长度缩减、压栈
            ptile.m_local_index[idx] = INVALID_PARTICLE_ID;
            bin_length[old_bin]--;
            free_slot[old_bin].push_back(idx);
        }
        svetime[1]=rdtscv();
        update[0]+=(svetime[1]-svetime[0]);

        // 对变化的粒子先做了删除操作
        svetime[0]=rdtscv();
        int block_size=128;
        int MOVED_PARTICLES_MAX=loop_np/4+block_size;
        int moved_ips[MOVED_PARTICLES_MAX];
        int moved_idxs[MOVED_PARTICLES_MAX];
        int moved_old_bins[MOVED_PARTICLES_MAX];
        int moved_new_bins[MOVED_PARTICLES_MAX];
        int moved_count = 0;

        for (int i = 0; i < loop_np; i += block_size) {
            svetime1[0]=rdtscv();
            int current_block_size = std::min(block_size, loop_np - i);
            // 计算需要比较的字节数
            size_t bytes_to_compare = current_block_size * sizeof(int);

            svetime1[1]=rdtscv();
            update1[0]+=(svetime1[1]-svetime1[0]);
            // --- 快速路径：使用 memcmp 比较整个块 ---
            // memcmp 比较的是内存内容。如果返回0，表示两块内存完全相同。
            if (memcmp(&newbin[i], &pid_to_bin_map[i], bytes_to_compare) == 0) {
                // 块内所有粒子都没有移动，直接跳过，这是性能提升的关键
                // ii++;
                // printf("JUMP %d\n",ii);
                continue; 
            } 
            else {
                const int num_lanes = svcntw(); // 获取向量宽度 (32位元素)
                svetime1[0]=rdtscv();
                for (int j = 0; j < current_block_size; j += num_lanes) {
                    int ip=i+j;
                    // 创建覆盖当前块的谓词 (同时为64位和32位元素创建)
                    svbool_t pg32 = svwhilelt_b32(j, current_block_size);
                    svint32_t vec_newbin = svld1_s32(pg32, &newbin[ip]);
                    svint32_t vec_oldbin  = svld1_s32(pg32, &pid_to_bin_map[ip]);
                    svbool_t moved_mask = svcmpne(pg32, vec_newbin, vec_oldbin);
                    if (!svptest_any(pg32, moved_mask)) {
                        continue;
                    }
                    // --- 开始处理移动的粒子 ---

                    // 3. GATHER 操作：获取移动粒子的 idx
                    // a. 创建当前块所有粒子的 ip 索引向量
                    svint32_t all_ips_in_block = svindex_s32(ip, 1);
                    // b. 根据 moved_mask，从 pid_to_index_map 中收集对应的 idx
                    //    svld1_gather 只会加载 moved_mask 为 true 的通道的 idx
                    svint32_t moved_idxs_vec = svld1_gather_s32index_s32(moved_mask, &pid_to_index_map[0], all_ips_in_block);

                    // 4. SCATTER 操作：将 local_index 中对应位置设为无效
                    // a. 创建一个填满无效ID的向量
                    svint32_t vec_invalid_id = svdup_s32(INVALID_PARTICLE_ID);
                    // b. 根据 moved_idxs_vec 中的索引，将无效ID分散地写入 local_index
                    //    注意：这里的谓词是 moved_mask，因为它对应于 moved_idxs_vec 的源数据
                    svst1_scatter_s32index_s32(moved_mask, &local_index[0], moved_idxs_vec, vec_invalid_id);
                    
                    // 5. PACK 操作：将所有需要的信息打包
                    int32_t count_in_this_block = svcntp_b32(pg32, moved_mask);
                    svbool_t pg_compact = svwhilelt_b32(0, count_in_this_block);

                    // a. 紧凑化 ip, new_bin, old_bin
                    svint32_t moved_ips_vec      = svcompact(moved_mask, all_ips_in_block);
                    svint32_t moved_new_bins_vec = svcompact(moved_mask, vec_newbin);
                    svint32_t moved_old_bins_vec = svcompact(moved_mask, vec_oldbin);
                    svint32_t moved_idxs_vec1 = svcompact(moved_mask, moved_idxs_vec);

                    // b. 将紧凑后的向量存入输出数组
                    svst1_s32(pg_compact, &moved_ips[moved_count], moved_ips_vec);
                    svst1_s32(pg_compact, &moved_new_bins[moved_count], moved_new_bins_vec);
                    svst1_s32(pg_compact, &moved_old_bins[moved_count], moved_old_bins_vec);
                    svst1_s32(pg_compact, &moved_idxs[moved_count], moved_idxs_vec1);

                    // 6. 更新总计数
                    moved_count += count_in_this_block;
                }
                if (moved_count > loop_np/8) {
                    rebuild=true;
                    break;
                }
                svetime1[1]=rdtscv();
                update1[1]+=(svetime1[1]-svetime1[0]);
            }
        }
        
        if (moved_count > loop_np/8) {
            rebuild=true;
        }else{
            // 为了高效更新 bin_length，先用一个临时map统计
            std::map<int, int> bin_decrement_counts;
            svetime1[0]=rdtscv();
            for (int k = 0; k < moved_count; ++k) {
                int ip = moved_ips[k];
                int new_bin = moved_new_bins[k];
                int old_bin = moved_old_bins[k];
                int idx = moved_idxs[k];

                // 执行 push_back 操作
                m_pending_moves[new_bin].push_back(ip);
                free_slot[old_bin].push_back(idx);

                // 统计每个 old_bin 离开的粒子数
                bin_decrement_counts[old_bin]++;
            }
            svetime1[1]=rdtscv();
            update1[2]+=(svetime1[1]-svetime1[0]);
            // printf("moved particels %d/%d\n",moved_count,loop_np);

            svetime1[0]=rdtscv();
            // 一次性更新 bin_length
            for (auto const& [bin, count] : bin_decrement_counts) {
                bin_length[bin] -= count;
            }
            svetime1[1]=rdtscv();
            update1[3]+=(svetime1[1]-svetime1[0]);
            
            svetime[1]=rdtscv();
            update[1]+=(svetime[1]-svetime[0]);

            svetime[0]=rdtscv();
            float rebuild_weight=WarpX::GetInstance().m_rebuild_weight;
            // float rebuild_cost=1.2; // 重组开销权重，实验测定暂定1.2吧
            // 重组开销，增量开销未达到重组开销时就不用重组
            // 重组一个粒子需要扫描一遍粒子，扫描一边网格，扫描一遍带空槽的粒子,最后扫描一遍粒子
            // 这里+估计为1，*估计为3，默认数据IO都能在在寄存器里为1
            float Cost_Global = rebuild_weight *(np_to_deposit + numcell*5
                                                +(np_to_deposit * WarpX::GetInstance().m_gap_ratio)
                                                + np_to_deposit); 

            // 预计算局部重组开销（只向右边查找）：
            // 累加（用freeslot栈移出空位开销+需要借用第n个块的开销）
            // 廉价的移动方案开销极低，复杂的方案就直接重组了
            float slot_cost=1.; // 借用空槽的cost
                                // 借空槽只需要一次交换，一次填充，所以是1
            float move_cost=6.+np_to_deposit/(4*numcell); // 移动数据块的cost,交换操作一次3*2
                                // 采用交换法（不用压实然后memmove）的话开销和大概就是一次访存估计为3-5
            float total_move_cost=0; //总开销
            // float rebuild_weight=WarpX::GetInstance().m_rebuild_weight; //达到重组开销的90%（可修改）就直接跳出直接重组了
            
            std::vector<int> borrow_size(numcell,0);

            // 先处理首尾两个块
            int old_bin = numcell-1; //尾块
            // 添加使用空槽的开销
            if (m_pending_moves.find(old_bin)!=m_pending_moves.end()) {//有需要插空的才计算
                int needed_count = m_pending_moves.at(old_bin).size();
                if (needed_count > free_slot[old_bin].size()) {
                    // 添加移动块数据的开销
                    // 因为重组计算了遍历粒子的开销，所以这里把插空开销也直接算进来了
                    int needed_borrow = needed_count - free_slot[old_bin].size();
                    int can_borrow = 0;
                    total_move_cost+=(needed_count-needed_borrow)*slot_cost; //粒子插空的
                    //最多允许借左邻居隔壁1个块
                    int next_pending_moves=0;
                    int borrow_bin=old_bin-1;
                    if (m_pending_moves.find(borrow_bin)!=m_pending_moves.end()) {
                        //如果邻居有需要插空的就记录一下，否则就不需要
                        next_pending_moves=m_pending_moves.at(borrow_bin).size();
                    }
                    can_borrow=(free_slot[borrow_bin].size()
                                -next_pending_moves
                                -borrow_size[borrow_bin]);
                    //在左边借到了
                    if (needed_borrow > can_borrow) {
                        rebuild=true;
                        // 基本上不会在一开始就超，所以不要判断成本
                        // if(total_move_cost>Cost_Global){ 
                        //     rebuild=true;
                        //     break;
                        // }
                    }
                    borrow_size[borrow_bin]+=needed_borrow; //借到了跳出，空槽被借用
                    total_move_cost+=move_cost*needed_borrow;//needed_borrow个粒子交换了
                }
            }
            old_bin = 0; //首块
            // 添加使用空槽的开销
            if (m_pending_moves.find(old_bin)!=m_pending_moves.end() && !rebuild) {//有需要插空的才计算
                int needed_count = m_pending_moves.at(old_bin).size();
                if (needed_count > free_slot[old_bin].size()) {
                    // 添加移动块数据的开销
                    // 因为重组计算了遍历粒子的开销，所以这里把插空开销也直接算进来了
                    int needed_borrow = needed_count - free_slot[old_bin].size();
                    int can_borrow = 0;
                    total_move_cost+=(needed_count-needed_borrow)*slot_cost; //粒子插空的
                    int next_pending_moves=0;
                    int borrow_bin=old_bin+1;
                    if (m_pending_moves.find(borrow_bin)!=m_pending_moves.end()) {
                        //如果邻居有需要插空的就记录一下，否则就不需要
                        next_pending_moves=m_pending_moves.at(borrow_bin).size();
                    }
                    can_borrow=(free_slot[borrow_bin].size()
                                -next_pending_moves
                                -borrow_size[borrow_bin]);
                    //在左边借到了
                    if (needed_borrow > can_borrow) {
                        rebuild=true;
                    }
                    borrow_size[borrow_bin]+=needed_borrow; //借到了跳出，空槽被借用
                    total_move_cost+=move_cost*needed_borrow;//needed_borrow个粒子交换了
                }
            }
            // 处理右左借用，先借右边再借左边
            if(!rebuild && total_move_cost<=Cost_Global){
                // 首尾特殊单独处理了
                // for (int old_bin = 1; old_bin < numcell-1; ++old_bin) { 
                //     if (m_pending_moves.find(old_bin)==m_pending_moves.end()) continue;//有需要插空的才计算
                // #pragma omp simd
                for (const auto& pair : m_pending_moves) {
                    int old_bin=pair.first;
                    if (old_bin==0 || old_bin==numcell-1) continue;//有需要插空的才计算
                    // 添加使用空槽的开销
                    int needed_count = m_pending_moves.at(old_bin).size();

                    // printf("%d \n ",old_bin);
                    // amrex::Print() << free_slot.at(old_bin).size() << std::endl;

                    if (needed_count <= free_slot.at(old_bin).size()) {
                        continue;
                    }
                    // 添加移动块数据的开销
                    // 因为重组计算了遍历粒子的开销，所以这里把插空开销也直接算进来了
                    int needed_borrow = needed_count - free_slot[old_bin].size();
                    int can_borrow = 0;
                    total_move_cost+=(needed_count-needed_borrow)*slot_cost; //粒子插空的
                    //最多允许借左右邻居隔壁2个块
                    int next_pending_moves=0;
                    int borrow_bin=old_bin+1;
                    if (m_pending_moves.find(borrow_bin)!=m_pending_moves.end()) {
                        //如果邻居有需要插空的就记录一下，否则就不需要
                        next_pending_moves=m_pending_moves.at(borrow_bin).size();
                    }
                    can_borrow=(free_slot[borrow_bin].size()
                                -next_pending_moves
                                -borrow_size[borrow_bin]);
                    //在左边就借到了
                    if (needed_borrow <= can_borrow) {
                        borrow_size[borrow_bin]+=needed_borrow; //借到了跳出，空槽被借用
                        total_move_cost+=move_cost*needed_borrow;//needed_borrow个粒子交换了
                        if(total_move_cost>Cost_Global){ 
                            rebuild=true;
                            break;
                        }
                        continue;
                    }
                    //左边没借到就找右边
                    //如果左边没空槽就会跳出了
                    borrow_size[borrow_bin]=free_slot[borrow_bin].size()-next_pending_moves;
                    int borrow_bin2=borrow_bin-2; 
                    next_pending_moves=0;
                    if (m_pending_moves.find(borrow_bin2)!=m_pending_moves.end()) {
                        next_pending_moves=m_pending_moves.at(borrow_bin2).size();
                    }
                    int can_borrow2=(free_slot[borrow_bin2].size()
                                -next_pending_moves
                                -borrow_size[borrow_bin2]);
                    needed_borrow-=can_borrow;//不够，先更新needed_borrow，再更新borrow_size占满这个块
                    if(can_borrow2<needed_borrow){ 
                        // 不够借就直接跳出，否则就够借
                        rebuild=true;
                        break;
                    }
                    //先处理上一个块的借用情况
                    total_move_cost+=move_cost*can_borrow;
                    //接下来更新这个块的借用情况
                    borrow_size[borrow_bin2]+=needed_borrow; //被借用了多少
                    total_move_cost+=move_cost*needed_borrow;//左右借用都一样
                    if(total_move_cost>Cost_Global){ 
                        rebuild=true;
                        break;
                    }
                }
            }
            svetime[1]=rdtscv();
            presort+=(svetime[1]-svetime[0]); 
        }
    }
    else{
        rebuild=true;
    }
    ptile.m_pid_to_bin_map.reserve(np_to_deposit+1);
    ptile.m_pid_to_index_map.reserve(np_to_deposit+1);
    ptile.m_pid_to_index_map.resize(np_to_deposit, -1);
    ptile.m_pid_to_bin_map.assign(newbin.begin(),
                              newbin.begin() + np_to_deposit);
    ptile.m_num_particles=np_to_deposit;
    ptile.m_was_rebuilt_this_step= false ;
    assert(newbin.size() >= np_to_deposit);
    assert(ptile.m_pid_to_bin_map.size() == np_to_deposit);

    if(!rebuild){ // 代价可以接受
        // printf("%d DO INCREMENT ADD!!\n",rebuild);
        //如果代价可以接受，就得顺便把一些参数增量更新了
        svetime[0]=rdtscv();
        ptile.m_num_empty_slots=ptile.m_capacity-np_to_deposit;
        // #pragma omp simd
        for (const auto& pair : m_pending_moves) {
            int new_bin=pair.first;
            std::vector<int>& particles_ip = m_pending_moves[new_bin];
            // printf("ADD: bin %d binlength change from %d ",new_bin,ptile.m_bin_lengths[new_bin]);
            ptile.m_bin_lengths[new_bin]+=particles_ip.size();
            // printf("to %d (+%d)\n",ptile.m_bin_lengths[new_bin],particles_ip.size());
            // for (const auto& pid : particles_ip) {
            // #pragma omp simd
            for (int i=particles_ip.size()-1; i>=0;i--) {
                int pid=particles_ip.back();
                int insert_idx = ptile.findEmptySlotInBin(new_bin);
                if (insert_idx != -1) {
                    // 直接填坑、退槽、长度增加（map已经完成更新）
                    ptile.m_local_index[insert_idx] = pid;
                    ptile.m_free_slots[new_bin].pop_back();
                    // ptile.m_bin_lengths[new_bin]++;
                    ptile.m_pid_to_index_map[pid]=insert_idx;
                    particles_ip.pop_back(); //一边填空一边更新pending_moves待插入的元素
                    // printf("[1] SLOT: inserted pid %d to bin %d at %d\n", pid, new_bin,insert_idx);
                } else {
                    break;
                }
            }
        }
        svetime[1]=rdtscv();
        insert+=(svetime[1]-svetime[0]);
    
        svetime[0]=rdtscv();
        //还有没更新完的就需要借用了
        int new_bin = numcell-1;
        //判断这块有没有数据，有就操作，不然跳过
        if (m_pending_moves.find(new_bin)!=m_pending_moves.end()) {
            int needed_borrow = m_pending_moves.at(new_bin).size();
            std::vector<int>& particles_ip = m_pending_moves[new_bin];
            int borrow_bin = new_bin-1;
            int idx=ptile.m_bin_offsets[new_bin]-1; //指向第一个块的尾巴指针
            // #pragma omp simd
            while(needed_borrow>0){
                //idx一直指向需要插入的尾巴
                int insert_idx = ptile.findEmptySlotInBin(borrow_bin);//这是借用空槽的位置
                int pid=particles_ip.back();
                // printf("[2] Borrowing index %d from bin %d\n",idx,borrow_bin);
                if(insert_idx != -1) {
                    // 把借用位置的尾巴腾出空位
                    // ptile.m_free_slots[borrow_bin].pop_back();
                    // printf("\t1) Exchange ip %d at index %d with  ip %d at index %d \n",
                    //     insert_idx,ptile.m_local_index[idx],idx,
                    //     ptile.m_local_index[insert_idx]);
                    // ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                    // if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID)
                    //     ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                    if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID){
                        // printf("\t1) Right Exchange ip %d at index %d with  ip %d at index %d \n",
                        //     ptile.m_local_index[idx],idx,
                        //     ptile.m_local_index[insert_idx],insert_idx);    
                        ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                        ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                        ptile.m_free_slots[borrow_bin].pop_back();
                    } else {
                        // printf("\t1) Right Remove slot ip %d at index %d \n",
                        //     ptile.m_local_index[idx],idx);
                        auto it = std::find(ptile.m_free_slots[borrow_bin].begin(), 
                                            ptile.m_free_slots[borrow_bin].end(), 
                                            idx);
                        if (it != ptile.m_free_slots[borrow_bin].end()) {
                            *it = ptile.m_free_slots[borrow_bin].back();    // 用末尾那个元素覆盖它
                            ptile.m_free_slots[borrow_bin].pop_back();      // 弹出末尾
                        }
                    }
                    // 向借的位置填入粒子
                    // printf("\t2) Orgin borrow ip is %d \n",ptile.m_local_index[idx]);
                    // printf("\t3)Put ip %d in bin %d at index %d \n",
                    //     pid, new_bin, idx );
                    ptile.m_local_index[idx] = pid;
                    // ptile.m_bin_offsets[new_bin] 这两个参数统一更新了
                    // ptile.m_bin_lengths[new_bin]++;
                    ptile.m_pid_to_index_map[pid]=idx;
                    particles_ip.pop_back(); //一边填空一边更新pending_moves待插入的元素
                    needed_borrow--;
                    // num_borrow++;
                    idx--;
                } else {
                    amrex::Abort("ERROR: no more slot can borrow!!!");
                }
            }
            ptile.m_bin_offsets[new_bin]=idx+1;
            m_pending_moves.erase(numcell-1);
        }
        new_bin = 0;
        //判断这块有没有数据，有就操作，不然跳过
        if (m_pending_moves.find(new_bin)!=m_pending_moves.end()) {
            int needed_borrow = m_pending_moves.at(new_bin).size();
            std::vector<int>& particles_ip = m_pending_moves[new_bin];
            int borrow_bin = new_bin+1;
            int idx=ptile.m_bin_offsets[new_bin+1]; //指向第一个块的头指针
            // #pragma omp simd
            while(needed_borrow>0){
                //idx一直指向需要插入的尾巴
                int insert_idx = ptile.findEmptySlotInBin(borrow_bin);//这是借用空槽的位置
                int pid=particles_ip.back();
                // printf("[2] Borrowing index %d from bin %d\n",idx,borrow_bin);
                if(insert_idx != -1) {
                    // 把借用位置的尾巴腾出空位
                    // ptile.m_free_slots[borrow_bin].pop_back();
                    // printf("\t1) Exchange ip %d at index %d with  ip %d at index %d \n",
                    //     ptile.m_local_index[idx],idx,ptile.m_local_index[insert_idx],insert_idx);
                    // ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                    // if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID)
                    //     ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                    if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID){
                        // printf("\t1) Right Exchange ip %d at index %d with  ip %d at index %d \n",
                        //     ptile.m_local_index[idx],idx,
                        //     ptile.m_local_index[insert_idx],insert_idx);    
                        ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                        ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                        ptile.m_free_slots[borrow_bin].pop_back();
                    } else {
                        // printf("\t1) Right Remove slot ip %d at index %d \n",
                        //     ptile.m_local_index[idx],idx);
                        auto it = std::find(ptile.m_free_slots[borrow_bin].begin(), 
                                            ptile.m_free_slots[borrow_bin].end(), 
                                            idx);
                        if (it != ptile.m_free_slots[borrow_bin].end()) {
                            *it = ptile.m_free_slots[borrow_bin].back();    // 用末尾那个元素覆盖它
                            ptile.m_free_slots[borrow_bin].pop_back();      // 弹出末尾
                        }
                    }
                    // 向借的位置填入粒子
                    // printf("\t2) Orgin borrow ip is %d \n",ptile.m_local_index[idx]);
                    // printf("\t3)Put ip %d in bin %d at index %d \n",
                    //     pid, new_bin, idx );
                    ptile.m_local_index[idx] = pid;
                    // ptile.m_bin_offsets[new_bin] 这两个参数统一更新了
                    // ptile.m_bin_lengths[new_bin]++;
                    ptile.m_pid_to_index_map[pid]=idx;
                    particles_ip.pop_back(); //一边填空一边更新pending_moves待插入的元素
                    needed_borrow--;
                    // num_borrow++;
                    idx++;
                } else {
                    amrex::Abort("ERROR: no more slot can borrow!!!");
                }
            }
            ptile.m_bin_offsets[new_bin+1]=idx;
            m_pending_moves.erase(0);
        }

        //现在按顺序处理向右边两个允许借用
        // #pragma omp simd
        for (const auto& pair : m_pending_moves) {
            int new_bin=pair.first;
            std::vector<int>& particles_ip = m_pending_moves[new_bin];
            
            int needed_borrow = m_pending_moves.at(new_bin).size();
            int borrow_bin = new_bin+1;
            int idx=ptile.m_bin_offsets[new_bin+1]; //指向第一个块的头指针
            int borrow_flag=0; //指示
            // 先右后左，因为是向右顺序处理的
            // #pragma omp simd
            while(needed_borrow>0){
                borrow_flag=1;
                //idx一直指向需要插入的尾巴
                //先找右边
                int insert_idx = ptile.findEmptySlotInBin(borrow_bin);//这是借用空槽的位置
                if(insert_idx == -1 && borrow_bin==new_bin-1) amrex::Abort("ERROR borrow!");
                int pid=particles_ip.back();
                if(insert_idx != -1){
                    // printf("[2] Borrowing index %d from bin %d\n",idx,borrow_bin);
                    if (borrow_bin==new_bin+1) {
                        // 把借用位置的尾巴腾出空位
                        if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID){
                            // printf("\t1) Right Exchange ip %d at index %d with  ip %d at index %d \n",
                            //     ptile.m_local_index[idx],idx,
                            //     ptile.m_local_index[insert_idx],insert_idx);    
                            ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                            ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                            ptile.m_free_slots[borrow_bin].pop_back();
                        } else {
                            // printf("\t1) Right Remove slot ip %d at index %d \n",
                            //     ptile.m_local_index[idx],idx);
                            auto it = std::find(ptile.m_free_slots[borrow_bin].begin(), 
                                                ptile.m_free_slots[borrow_bin].end(), 
                                                idx);
                            if (it != ptile.m_free_slots[borrow_bin].end()) {
                                *it = ptile.m_free_slots[borrow_bin].back();    // 用末尾那个元素覆盖它
                                ptile.m_free_slots[borrow_bin].pop_back();      // 弹出末尾
                            }
                        }
                        // 向借的位置填入粒子
                        // printf("\t2) Orgin borrow ip is %d \n",ptile.m_local_index[idx]);
                        // printf("\t3)Put ip %d in bin %d at index %d \n",
                        //     pid, new_bin, idx );    
                        ptile.m_local_index[idx] = pid;
                        ptile.m_pid_to_index_map[pid]=idx;
                        particles_ip.pop_back(); //一边填空一边更新pending_moves待插入的元素
                        needed_borrow--;
                        idx++;
                        continue;
                    } 
                    if (borrow_bin==new_bin-1) {
                        // ptile.m_free_slots[borrow_bin].pop_back();
                        // printf("\t1) Left Exchange ip %d at index %d with  ip %d at index %d \n",
                        //     ptile.m_local_index[idx],idx,
                        //     ptile.m_local_index[insert_idx],insert_idx);    
                        // ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                        // if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID)
                        //     ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                        if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID){
                            // printf("\t1) Left Exchange ip %d at index %d with  ip %d at index %d \n",
                            //     ptile.m_local_index[idx],idx,
                            //     ptile.m_local_index[insert_idx],insert_idx);    
                            ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                            ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                            ptile.m_free_slots[borrow_bin].pop_back();
                        } else {
                            // printf("\t1) Left Remove slot ip %d at index %d \n",
                            //     ptile.m_local_index[idx],idx);
                            auto it = std::find(ptile.m_free_slots[borrow_bin].begin(), 
                                                ptile.m_free_slots[borrow_bin].end(), 
                                                idx);
                            if (it != ptile.m_free_slots[borrow_bin].end()) {
                                *it = ptile.m_free_slots[borrow_bin].back();    // 用末尾那个元素覆盖它
                                ptile.m_free_slots[borrow_bin].pop_back();      // 弹出末尾
                            }
                        }
                        // 向借的位置填入粒子
                        // printf("\t2) Orgin borrow ip is %d \n",ptile.m_local_index[idx]);
                        // printf("\t3)Put ip %d in bin %d at index %d \n",
                        //     pid, new_bin, idx );    
                        ptile.m_local_index[idx] = pid;
                        ptile.m_pid_to_index_map[pid]=idx;
                        particles_ip.pop_back(); //一边填空一边更新pending_moves待插入的元素
                        needed_borrow--;
                        idx--;
                        continue;
                    } 
                }else {
                    // printf("\t Right not enough!\n");
                    // printf("\tUpdate Right binoffsets from %d to %d \n",
                    //     ptile.m_bin_offsets[new_bin+1],idx);
                    ptile.m_bin_offsets[new_bin+1]=idx;
                    //右边找完还不够，就继续
                    borrow_bin = new_bin-1;
                    idx=ptile.m_bin_offsets[new_bin]-1; //指向第一个块的头指针
                }
            }
            if(borrow_flag){
                if (borrow_bin==new_bin+1) {
                    // printf("\tUpdate Right binoffsets from %d to %d \n",
                        // ptile.m_bin_offsets[new_bin+1],idx);
                    ptile.m_bin_offsets[new_bin+1]=idx;
                } else if((borrow_bin==new_bin-1)){
                    // printf("\tUpdate Left binoffsets from %d to %d \n",
                    //     ptile.m_bin_offsets[new_bin],idx+1);
                    ptile.m_bin_offsets[new_bin]=idx+1;
                }
            }
        }
        svetime[1]=rdtscv();
        borrow+=(svetime[1]-svetime[0]);

    }else{ //代价太高直接重组
        //重组就不需要增量修改那些，只需要pid_to_map正确即可
        // printf("DO REBUILD!\n");
        svetime[0]=rdtscv();
        const int vlf=svcntw();

        svetime1[0]=rdtscv();
        ptile.m_was_rebuilt_this_step = true;
        std::vector<int> final_bin_counts(numcell, 0);
        // std::vector<int> final_bin_counts1(numcell, 0);
        float gap_ratio=WarpX::GetInstance().m_gap_ratio;
        const std::vector<int>& pid_to_bin_map = ptile.m_pid_to_bin_map;
        int np = ptile.m_num_particles;
        // #pragma omp simd
        // int* pointer_count=final_bin_counts.data();
        // #pragma omp simd reduction(+:pointer_count[:numcell])
        for(int ip=0;ip<np;ip++){
            // pointer_count[pid_to_bin_map[ip]]++;
            final_bin_counts[pid_to_bin_map[ip]]++;
        }  
        svetime1[1]=rdtscv();
        rebuild1[0]+=(svetime1[1]-svetime1[0]);
        //=========================
        // for(int i=0;i<numcell;i++){
        //     printf("final_bin_counts[%d]=%d\n",i,final_bin_counts[i]);
        // }
        // for(int i=0;i<np;i++){
        //     printf("pid_to_bin_map[%d]=%d size %d\n",i,pid_to_bin_map[i],pid_to_bin_map.size());
        // } 
        //==========================

        svetime1[0]=rdtscv();
        ptile.m_bin_lengths = final_bin_counts;
        // ptile.m_capacity = np*(1+gap_ratio)+numcell*1.5;
        ptile.m_capacity = static_cast<int>(std::ceil(static_cast<double>(np) * (1.0 + gap_ratio)) + 2*numcell);
        svetime1[1]=rdtscv();
        rebuild1[1]+=(svetime1[1]-svetime1[0]);

        int current_offset = 0;
        ptile.m_bin_offsets[0] = 0;
        ptile.m_free_slots.assign(numcell,std::vector<int>());
        std::vector<int> gap(numcell,0);
        //===========================
        // int current_offset1 = 0;
        // std::vector<int> testoff=ptile.m_bin_offsets;
        // std::vector<std::vector<int>> testslot=ptile.m_free_slots;
        // std::vector<int> gap1(numcell,0);
        //===========================
        
        #pragma omp unroll
        for (int binID = 0; binID < numcell; binID+=vlf) {
            svetime1[0]=rdtscv();
            svbool_t p_bin = svwhilelt_b32(binID,numcell);
            svint32_t np_in_bin=svld1_s32(p_bin,&final_bin_counts[binID]);
            // svst1_s32(p_bin,&ptile.m_bin_lengths[binID],np_in_bin);
            svint32_t gap_v=svadd_n_s32_x(p_bin,
                            svcvt_s32_f32_x(p_bin,svmul_n_f32_x(p_bin,
                            svcvt_f32_s32_x(p_bin,np_in_bin),gap_ratio)),
                            1);
            svst1_s32(p_bin,&gap[binID],gap_v);
            svint32_t block_size_v=svadd_s32_x(p_bin,gap_v,np_in_bin);
            //==========================
            // std::vector<int> gap1(vlf,0);
            // svst1_s32(p_bin,&gap1[0],gap_v);
            // std::vector<int> block_size(vlf,0);
            // svst1_s32(p_bin,&block_size[0],block_size_v);
            // const int vlf_len = std::min(vlf, static_cast<int>(numcell - binID));
            //==========================
            svetime1[1]=rdtscv();
            rebuild1[2]+=(svetime1[1]-svetime1[0]);

            svetime1[0]=rdtscv();
            // 3. 向量化局部累加 (Intra-Vector Exclusive Scan)
            //    这是将串行依赖转换为并行计算的核心
            svint32_t local_scan_v = block_size_v;
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-1));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-2));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-4));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-8));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-16));
            
            local_scan_v  = svadd_n_s32_x(p_bin, local_scan_v, current_offset);

            // 5. 存储最终计算出的偏移量结果
            //    注意，我们从 m_bin_offsets 的第 binID + 1 个位置开始存
            svst1_s32(p_bin, &ptile.m_bin_offsets[binID + 1], local_scan_v);
            // svst1_s32(p_bin, &testoff[binID + 1], final_offsets_v);

            // 6. 更新下一个块的全局偏移
            //    使用svaddv高效地计算当前块所有block_size的总和
            current_offset += svaddv_s32(p_bin, block_size_v);
            svetime1[1]=rdtscv();
            rebuild1[3]+=(svetime1[1]-svetime1[0]);

            //======================================
            // // #pragma omp simd
            // for(int ii=0;ii<vlf_len;ii++){
            //     current_offset1 += block_size[ii];
            //     // svetime1[0]=rdtscv();
            //     for(int i = current_offset1-1; i >= current_offset1-gap1[ii]; --i){
            //         testslot[binID+ii].push_back(i);
            //         printf("org push gap %d/%d into bin %d\n",
            //             i,
            //             gap1.size(),ii);
            //     }
            //     // svetime1[1]=rdtscv();
            //     // rebuild1[4]+=(svetime1[1]-svetime1[0]);
            //     // if(current_offset>ptile.m_capacity){
            //     //     amrex::Abort("ERROR: current_offset > m_capacity!!!");
            //     // }
            //     testoff[binID + 1+ii] = current_offset1;
            //     printf("block_size %d\n",block_size[ii]);
            // }
            //==================================
        }
        // svetime1[0]=rdtscv();
        if(ptile.m_bin_offsets[numcell]>=ptile.m_capacity){
            printf("ptile.m_bin_offsets[numcell] %d m_capacity %d \n"
                ,ptile.m_bin_offsets[numcell],ptile.m_capacity);
            amrex::Abort("ERROR: m_bin_offsets[numcell] >= m_capacity!!!");
        }
        // std::vector<int> target_vec;
        //下面对空slot的pushback操作也是一样的，由于vector<vector>在内存中散乱分布，
        //所以load的时候产生cachemiss导致额外开销，最好修改freeslot的数据结构以改善问题
        svetime1[0]=rdtscv();
        std::vector<int>& binoff=ptile.m_bin_offsets;
        std::vector<std::vector<int>>& freeslot=ptile.m_free_slots;
        for (int binID = 0; binID < numcell; binID++) {
            int gap_size = gap[binID];
            int start_offset = binoff[binID + 1];
            auto& target_vec = freeslot[binID];
            target_vec.resize(gap_size);
            //=========================
            // for (int k = 0; k < gap_size; ++k) {
            //     target_vec[k] = start_offset - 1 - k;
            //     printf("sve push gap %d/%d into bin %d\n",
            //         target_vec[k],
            //         gap_size,binID);
            // }
            //=========================
            for (int k = 0; k < gap_size; k += vlf) {
                // 創建謂詞，安全處理最後一個不滿的向量塊
                svbool_t pg = svwhilelt_b32(k, gap_size);
            
                // a. 生成要寫入的數值向量
                //    首先，建立一個索引向量 [k, k+1, k+2, ...]
                svint32_t vec_k_indices = svindex_s32(k, 1);
                //    然後，建立一個填滿 start_offset-1 的向量
                svint32_t vec_base = svdup_n_s32(start_offset - 1);
                //    計算出最終要寫入的值：(start_offset-1) - k
                svint32_t values_to_store = svsub_s32_z(pg, vec_base, vec_k_indices);
            
                // b. 連續寫入 (Store)
                //    將產生的向量一次性寫入目標記憶體
                svst1_s32(pg, &target_vec[k], values_to_store);
            }
            //=========================
            // for (int k = 0; k < gap_size; ++k) {
            //     // target_vec[k] = start_offset - 1 - k;
            //     printf("sve push gap %d/%d into bin %d\n",
            //         target_vec[k],
            //         gap_size,binID);
            // }
            //=========================
        }
        svetime1[1]=rdtscv();
        rebuild1[4]+=(svetime1[1]-svetime1[0]);
        //====================================
        // int err=0;
        // for(int i=0;i<testoff.size();i++){
        //     printf("offset i %d sve %d org %d \n",i,testoff[i],ptile.m_bin_offsets[i]);
        //     if(testoff[i]!=ptile.m_bin_offsets[i]){
        //         err++;
        //     }
        // }
        // if(err>100) amrex::Abort("offset err!");
        // int err1=0;
        // for (int binID = 0; binID < numcell; binID++) {
        //     for(int i=0;i<testslot[binID].size();i++){
        //         printf("bin %d slot i %d sve %d org %d \n",binID,i
        //             ,testslot[binID][i]
        //             ,ptile.m_free_slots[binID][i]);
        //         if(testslot[binID][i]!=ptile.m_free_slots[binID][i]){
        //             err1++;
        //         }
        //     }
        // }
        // if(err1>100) amrex::Abort("slot err1!");
        //=======================================

        svetime1[0]=rdtscv();
        ptile.m_capacity=ptile.m_bin_offsets[numcell];
        // ptile.m_num_particles=np;
        ptile.m_num_empty_slots = ptile.m_capacity - ptile.m_num_particles;
        ptile.m_local_index.assign(ptile.m_capacity, INVALID_PARTICLE_ID);
        // 初始化为每个 bin 的起始位置
        std::vector<int> next_write_slot = ptile.m_bin_offsets; 

        for(int ip=0;ip<np;ip++){
            int bin_id =pid_to_bin_map[ip];
            int insert_idx = next_write_slot[bin_id];
            // assert(insert_idx >= 0 && insert_idx < ptile.m_local_index.size());
            // assert(ip >= 0 && ip < ptile.m_pid_to_index_map.size());
            ptile.m_local_index[insert_idx] = ip;
            ptile.m_pid_to_index_map[ip]=insert_idx;
            next_write_slot[bin_id]++;
        }
        svetime1[1]=rdtscv();
        rebuild1[5]+=(svetime1[1]-svetime1[0]);

        ptile.m_was_rebuilt_this_step = true;
        // printf("%d DO FULL REBUILD!!!!!!!!!\n",rebuild);
        svetime[1]=rdtscv();
        rebuildtime+=(svetime[1]-svetime[0]);

    }
    m_pending_moves.clear();

    svetime1[1]=rdtscv();
    sort_time+=(svetime1[1]-svetime1[0]); 
//////////////////////////////////////////////////////

    //====================      
    // for (int old_bin = 0; old_bin < numcell; old_bin++) {
    //     printf("bin length %d\n",bin_length[old_bin]);
    // }

    //     std::vector<int> ip_list;
    //     // Jxarr = wqx*sx*sy*sz
    //     if (bin_length[old_bin] == 0) continue;
    //     int start = bin_offsets[old_bin];
    //     int end = bin_offsets[old_bin+1];

    //     int first_idx=-1;
    //     for(int i=start;i<end;i++){
    //         if (local_index[i] == INVALID_PARTICLE_ID) {
    //             // idx1++;
    //             continue;
    //         } 
    //         if(first_idx<0){
    //             first_idx=i;
    //         }else{
    //             int idx1 = first_idx;
    //             int idx2=i;
    //             int ip1 = local_index[idx1];
    //             ip_list.push_back(ip1);
    //             int ip2 = local_index[idx2];
    //             ip_list.push_back(ip2);
    //             printf("ip1 %d ip2 %d\n",ip1,ip2);
    //         }
    //     }
    // }
    //=====================

    // int n=10*12*13;
    // 三阶下面的rhocell是一个长方形，目前设计是z0，y01，x0123，这样的
    // 所以rhocell的尺寸就是x-2，y，z+1
    int nrho=(len.x-2)*len.y*(len.z+1);

    std::vector<amrex::Real> xrhocells(8*nrho, 0.0);
    std::vector<amrex::Real> yrhocells(8*nrho, 0.0);
    std::vector<amrex::Real> zrhocells(8*nrho, 0.0);
    // std::vector<amrex::Real> xrhocells(8*numcell, 0.0);
    // std::vector<amrex::Real> yrhocells(8*numcell, 0.0);
    // std::vector<amrex::Real> zrhocells(8*numcell, 0.0);
    svetime[0]=rdtscv();
    sort_3d_sme_kernal_order_3_test<3>(
        local_index,bin_length,bin_offsets,
        xrhocells,yrhocells,zrhocells,
        sx_m,sy_m,sz_m,
        wqx,wqy,wqz,len,np_to_deposit,numcell,
        xjstride,xkstride,testsxwq);
    svetime[1]=rdtscv();
    cale_time+=(svetime[1]-svetime[0]);
    //================
    // for(int i=0;i<numcell;i++){
    //     for(int j=0;j<8;j++){
    //         printf("xrhocells[%d*%d]=%f\n",i,j,xrhocells[i*j]);
    //     }
    // }
    // for(int i=0;i<np_to_deposit;i++){
    //     for(int j=0;j<4;j++){
    //         printf("sx_m[%d*%d]=%f\n",i,j,sx_m[i*j]);
    //     }
    // }
    test_sxwq=testsxwq;
    //  test1=newbin;
    //  test=ptile.m_local_index;
    //  test0=ptile.m_bin_offsets;
    test_rhocells=xrhocells;
    //==================

    long nx=xjstride;
    long nxy=xjstride*xkstride;
    long moff[8] = {0,1,2,3,nx,nx+1,nx+2,nx+3};
    // long moff[8] = {0, 1, nx, nx+1, nxy, nxy+1, nx+nxy, nx+nxy+1};
    // long moff[8] = {-1,0,1,2,2*nx-1,2*nx,2*nx+1,2*nx+2};
    // long moff[8] = {-nxy,0,nxy,2*nxy,nx-nxy,nx,nx+nxy,nx+2*nxy};
    // printf("xjstride %d xkstride %d\n",xjstride,xkstride);
    // printf("nnx %d nnxny %d\n",nnx,nnxny);
    long lnx=len.x-2;
    long lnxy=lnx*len.y;

    #pragma omp simd
    for (int iz = 0; iz <= len.z; ++iz) {
        #pragma omp simd
        for (int iy = 0; iy < len.y; ++iy) { 
            #if 0
            for (int ix = 0; ix < len.x-2; ix++) {
                // scalar mode
                // long j = lo.x + ix;
                // long k = lo.y + iy;
                // long l = lo.z + iz;
                // long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                long jxoffset = ix + iy * xjstride + iz * xkstride;
                long cell_idx=ix + iy * lnx + iz * lnxy;
                long xoffset=8*cell_idx;
                //===================
                // printf("ix %d iy %d iz %d\n",ix,iy,iz);
                // for(int ii=0;ii<8;ii++){
                //     printf("----jxoffset %d xoffset %d\n",jxoffset+moff[ii],xoffset+ii);
                //     printf("----jx_arr[%d+%d] %f += xrhocells[%d+%d] %f\n\n"
                //         ,jxoffset,moff[ii],jx_arr.p[jxoffset+moff[ii]],cell_idx,ii,xrhocells[ii+xoffset]);
                // }
                //===================
                jx_arr.p[jxoffset+moff[0]]+=xrhocells[0+xoffset];
                jx_arr.p[jxoffset+moff[1]]+=xrhocells[1+xoffset];
                jx_arr.p[jxoffset+moff[2]]+=xrhocells[2+xoffset];
                jx_arr.p[jxoffset+moff[3]]+=xrhocells[3+xoffset];
                jx_arr.p[jxoffset+moff[4]]+=xrhocells[4+xoffset];
                jx_arr.p[jxoffset+moff[5]]+=xrhocells[5+xoffset];
                jx_arr.p[jxoffset+moff[6]]+=xrhocells[6+xoffset];
                jx_arr.p[jxoffset+moff[7]]+=xrhocells[7+xoffset];
            }
            #endif

            #if 1
            #pragma unroll      
            for (int ix = 0; ix < len.x-2; ix+=vl) {
                svetime[0]=rdtscv();

                // vector
                svbool_t p=svwhilelt_b64(ix,(len.x-2));
                svuint64_t rho_index = svindex_u64(0ULL, 8ULL);
                long jxoffset=ix + iy * xjstride + iz * xkstride;
                long cell_idx=ix + iy * lnx + iz * lnxy;
                // long jxoffset=xoffset;
                long irhox=8*cell_idx;
                Vec jx0=Vec::Load(p,&jx_arr.p[jxoffset+moff[0]]);
                svfloat64_t rhox0=svld1_gather_u64index_f64(p,&xrhocells[0+irhox],rho_index);
                jx0+=rhox0;
                jx0.Store(p,&jx_arr.p[jxoffset+moff[0]]);

                Vec jx1=Vec::Load(p,&jx_arr.p[jxoffset+moff[1]]);
                svfloat64_t rhox1=svld1_gather_u64index_f64(p,&xrhocells[1+irhox],rho_index);
                jx1+=rhox1;
                jx1.Store(p,&jx_arr.p[jxoffset+moff[1]]);

                Vec jx2=Vec::Load(p,&jx_arr.p[jxoffset+moff[2]]);
                svfloat64_t rhox2=svld1_gather_u64index_f64(p,&xrhocells[2+irhox],rho_index);
                jx2+=rhox2;
                jx2.Store(p,&jx_arr.p[jxoffset+moff[2]]);

                Vec jx3=Vec::Load(p,&jx_arr.p[jxoffset+moff[3]]);
                svfloat64_t rhox3=svld1_gather_u64index_f64(p,&xrhocells[3+irhox],rho_index);
                jx3+=rhox3;
                jx3.Store(p,&jx_arr.p[jxoffset+moff[3]]);

                Vec jx4=Vec::Load(p,&jx_arr.p[jxoffset+moff[4]]);
                svfloat64_t rhox4=svld1_gather_u64index_f64(p,&xrhocells[4+irhox],rho_index);
                jx4+=rhox4;
                jx4.Store(p,&jx_arr.p[jxoffset+moff[4]]);

                Vec jx5=Vec::Load(p,&jx_arr.p[jxoffset+moff[5]]);
                svfloat64_t rhox5=svld1_gather_u64index_f64(p,&xrhocells[5+irhox],rho_index);
                jx5+=rhox5;
                jx5.Store(p,&jx_arr.p[jxoffset+moff[5]]);

                Vec jx6=Vec::Load(p,&jx_arr.p[jxoffset+moff[6]]);
                svfloat64_t rhox6=svld1_gather_u64index_f64(p,&xrhocells[6+irhox],rho_index);
                jx6+=rhox6;
                jx6.Store(p,&jx_arr.p[jxoffset+moff[6]]);

                Vec jx7=Vec::Load(p,&jx_arr.p[jxoffset+moff[7]]);
                svfloat64_t rhox7=svld1_gather_u64index_f64(p,&xrhocells[7+irhox],rho_index);
                jx7+=rhox7;
                jx7.Store(p,&jx_arr.p[jxoffset+moff[7]]);
                
        //         // y
        //         // uint64_t irhoy = ix + iy * yjstride + iz * ykstride;
        //         // svuint64_t rhoy_index = svindex_u64(irhoy, 8ULL);
        //         // long jyoffset = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
        //         // long yoffset = ix + iy * yjstride + iz * ykstride;
        //         long jyoffset=xoffset;
        //         long irhoy=irhox;
        //         Vec jy0=Vec::Load(p,&jy_arr.p[jyoffset+moff[0]]);
        //         svfloat64_t rhoy0=svld1_gather_u64index_f64(p,&yrhocells[0+irhoy],rho_index);
        //         jy0+=rhoy0;
        //         jy0.Store(p,&jy_arr.p[jyoffset+moff[0]]);

        //         Vec jy1=Vec::Load(p,&jy_arr.p[jyoffset+moff[1]]);
        //         svfloat64_t rhoy1=svld1_gather_u64index_f64(p,&yrhocells[1+irhoy],rho_index);
        //         jy1+=rhoy1;
        //         jy1.Store(p,&jy_arr.p[jyoffset+moff[1]]);

        //         Vec jy2=Vec::Load(p,&jy_arr.p[jyoffset+moff[2]]);
        //         svfloat64_t rhoy2=svld1_gather_u64index_f64(p,&yrhocells[2+irhoy],rho_index);
        //         jy2+=rhoy2;
        //         jy2.Store(p,&jy_arr.p[jyoffset+moff[2]]);

        //         Vec jy3=Vec::Load(p,&jy_arr.p[jyoffset+moff[3]]);
        //         svfloat64_t rhoy3=svld1_gather_u64index_f64(p,&yrhocells[3+irhoy],rho_index);
        //         jy3+=rhoy3;
        //         jy3.Store(p,&jy_arr.p[jyoffset+moff[3]]);

        //         Vec jy4=Vec::Load(p,&jy_arr.p[jyoffset+moff[4]]);
        //         svfloat64_t rhoy4=svld1_gather_u64index_f64(p,&yrhocells[4+irhoy],rho_index);
        //         jy4+=rhoy4;
        //         jy4.Store(p,&jy_arr.p[jyoffset+moff[4]]);

        //         Vec jy5=Vec::Load(p,&jy_arr.p[jyoffset+moff[5]]);
        //         svfloat64_t rhoy5=svld1_gather_u64index_f64(p,&yrhocells[5+irhoy],rho_index);
        //         jy5+=rhoy5;
        //         jy5.Store(p,&jy_arr.p[jyoffset+moff[5]]);

        //         Vec jy6=Vec::Load(p,&jy_arr.p[jyoffset+moff[6]]);
        //         svfloat64_t rhoy6=svld1_gather_u64index_f64(p,&yrhocells[6+irhoy],rho_index);
        //         jy6+=rhoy6;
        //         jy6.Store(p,&jy_arr.p[jyoffset+moff[6]]);

        //         Vec jy7=Vec::Load(p,&jy_arr.p[jyoffset+moff[7]]);
        //         svfloat64_t rhoy7=svld1_gather_u64index_f64(p,&yrhocells[7+irhoy],rho_index);
        //         jy7+=rhoy7;
        //         jy7.Store(p,&jy_arr.p[jyoffset+moff[7]]);

        //         // z
        //         // uint64_t irhoz = ix + iy * zjstride + iz * zkstride;
        //         // svuint64_t rhoz_index = svindex_u64(irhoz, 8ULL);
        //         // long jzoffset = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
        //         long zoffset = ix + iy * zjstride + iz * zkstride;
        //         long jzoffset=xoffset;
        //         long irhoz=irhox;
        //         Vec jz0=Vec::Load(p,&jz_arr.p[jzoffset+moff[0]]);
        //         svfloat64_t rhoz0=svld1_gather_u64index_f64(p,&zrhocells[0+irhoz],rho_index);
        //         jz0+=rhoz0;
        //         jz0.Store(p,&jz_arr.p[jzoffset+moff[0]]);

        //         Vec jz1=Vec::Load(p,&jz_arr.p[jzoffset+moff[1]]);
        //         svfloat64_t rhoz1=svld1_gather_u64index_f64(p,&zrhocells[1+irhoz],rho_index);
        //         jz1+=rhoz1;
        //         jz1.Store(p,&jz_arr.p[jzoffset+moff[1]]);

        //         Vec jz2=Vec::Load(p,&jz_arr.p[jzoffset+moff[2]]);
        //         svfloat64_t rhoz2=svld1_gather_u64index_f64(p,&zrhocells[2+irhoz],rho_index);
        //         jz2+=rhoz2;
        //         jz2.Store(p,&jz_arr.p[jzoffset+moff[2]]);

        //         Vec jz3=Vec::Load(p,&jz_arr.p[jzoffset+moff[3]]);
        //         svfloat64_t rhoz3=svld1_gather_u64index_f64(p,&zrhocells[3+irhoz],rho_index);
        //         jz3+=rhoz3;
        //         jz3.Store(p,&jz_arr.p[jzoffset+moff[3]]);

        //         Vec jz4=Vec::Load(p,&jz_arr.p[jzoffset+moff[4]]);
        //         svfloat64_t rhoz4=svld1_gather_u64index_f64(p,&zrhocells[4+irhoz],rho_index);
        //         jz4+=rhoz4;
        //         jz4.Store(p,&jz_arr.p[jzoffset+moff[4]]);

        //         Vec jz5=Vec::Load(p,&jz_arr.p[jzoffset+moff[5]]);
        //         svfloat64_t rhoz5=svld1_gather_u64index_f64(p,&zrhocells[5+irhoz],rho_index);
        //         jz5+=rhoz5;
        //         jz5.Store(p,&jz_arr.p[jzoffset+moff[5]]);

        //         Vec jz6=Vec::Load(p,&jz_arr.p[jzoffset+moff[6]]);
        //         svfloat64_t rhoz6=svld1_gather_u64index_f64(p,&zrhocells[6+irhoz],rho_index);
        //         jz6+=rhoz6;
        //         jz6.Store(p,&jz_arr.p[jzoffset+moff[6]]);

        //         Vec jz7=Vec::Load(p,&jz_arr.p[jzoffset+moff[7]]);
        //         svfloat64_t rhoz7=svld1_gather_u64index_f64(p,&zrhocells[7+irhoz],rho_index);
        //         jz7+=rhoz7;
        //         jz7.Store(p,&jz_arr.p[jzoffset+moff[7]]);

                svetime[1]=rdtscv();
                reduce_time+=(svetime[1]-svetime[0]);
            }
            #endif
        }
    }
    
    total_time[1]=rdtscv();
    total_time[2]=total_time[1]-total_time[0];
    printf("SME Total:%d \n",total_time[2]);
    printf("\t precompute:%d \n",precompute);
    printf("\t cale_time:%d \n",cale_time);
    printf("\t sort_time:%d \n",sort_time);
    printf("\t\t update1:%d ",update[0]);
    printf(" update2:%d \n",update[1]);
    printf("\t\t --Dupdate0:%d \n",update1[0]);
    printf("\t\t --Dupdate1:%d \n",update1[1]);
    printf("\t\t --Dupdate2:%d \n",update1[2]);
    printf("\t\t --Dupdate3:%d \n",update1[3]);
    printf("\t\t --Dupdate4:%d \n",update1[4]);
    printf("\t\t --Dupdate5:%d \n",update1[5]);
    printf("\t\t presort:%d \n",presort);
    printf("\t\t insert:%d \n",insert);
    printf("\t\t borrow:%d \n",borrow);
    printf("\t\t rebuildtime:%d \n",rebuildtime);
    printf("\t\t --Drebuild0:%d \n",rebuild1[0]);
    printf("\t\t --Drebuild1:%d \n",rebuild1[1]);
    printf("\t\t --Drebuild2:%d \n",rebuild1[2]);
    printf("\t\t --Drebuild3:%d \n",rebuild1[3]);
    printf("\t\t --Drebuild4:%d \n",rebuild1[4]);
    printf("\t\t --Drebuild5:%d \n",rebuild1[5]);
    printf("\t reduce_time:%d \n",reduce_time);
}


static inline void increment_sort_particles (
    int np_to_deposit, ParticleTileType& ptile,
    std::vector<int>& newbin, int numcell
)
{
    auto& local_index = ptile.m_local_index;
    auto& bin_offsets = ptile.m_bin_offsets;
    auto& bin_length = ptile.m_bin_lengths;
    auto& num_particles = ptile.m_num_particles;
    auto& pid_to_bin_map = ptile.m_pid_to_bin_map;
    auto& pid_to_index_map = ptile.m_pid_to_index_map; 
    auto& free_slot = ptile.m_free_slots;
    std::unordered_map<int, std::vector<int>> m_pending_moves;
    bool rebuild=false;
    // rebuild=true;
    //==================================
    // for(int ip=0;ip<np_to_deposit;ip++){
    //     printf("newbin[%d] = %d\n",ip,newbin[ip]);
    // }
    //=================================
    if(np_to_deposit<ptile.m_capacity){

        int loop_np=np_to_deposit;
        // 新增粒子添加
        for(int ip=num_particles;ip<np_to_deposit;ip++){
            int new_bin=newbin[ip];
            m_pending_moves[new_bin].push_back(ip);
            loop_np=num_particles;
        }
        // 减少的粒子删除
        for(int ip=np_to_deposit;ip<num_particles;ip++){
            int old_bin=pid_to_bin_map[ip];
            int idx=pid_to_index_map[ip]; 
            //打洞、长度缩减、压栈
            ptile.m_local_index[idx] = INVALID_PARTICLE_ID;
            bin_length[old_bin]--;
            free_slot[old_bin].push_back(idx);
        }

        // 对变化的粒子先做了删除操作
        int block_size=WarpX::GetInstance().m_fast_cmp_block_size;; // 256
        float max_np_rate=WarpX::GetInstance().m_max_moved_np_rate; // 0.15
        int MOVED_PARTICLES_MAX=loop_np/4+block_size;
        int moved_ips[MOVED_PARTICLES_MAX];
        int moved_idxs[MOVED_PARTICLES_MAX];
        int moved_old_bins[MOVED_PARTICLES_MAX];
        int moved_new_bins[MOVED_PARTICLES_MAX];
        int moved_count = 0;

        for (int i = 0; i < loop_np; i += block_size) {
            // svetime1[0]=rdtscv();
            int current_block_size = std::min(block_size, loop_np - i);
            // 计算需要比较的字节数
            size_t bytes_to_compare = current_block_size * sizeof(int);

            // --- 快速路径：使用 memcmp 比较整个块 ---
            // memcmp 比较的是内存内容。如果返回0，表示两块内存完全相同。
            if (memcmp(&newbin[i], &pid_to_bin_map[i], bytes_to_compare) == 0) {
                // 块内所有粒子都没有移动，直接跳过，这是性能提升的关键
                continue; 
            } 
            else {
                const int num_lanes = svcntw(); // 获取向量宽度 (32位元素)
                // svetime1[0]=rdtscv();
                for (int j = 0; j < current_block_size; j += num_lanes) {
                    int ip=i+j;
                    // 创建覆盖当前块的谓词 (同时为64位和32位元素创建)
                    svbool_t pg32 = svwhilelt_b32(j, current_block_size);
                    svint32_t vec_newbin = svld1_s32(pg32, &newbin[ip]);
                    svint32_t vec_oldbin  = svld1_s32(pg32, &pid_to_bin_map[ip]);
                    svbool_t moved_mask = svcmpne(pg32, vec_newbin, vec_oldbin);
                    if (!svptest_any(pg32, moved_mask)) {
                        continue;
                    }
                    // --- 开始处理移动的粒子 ---

                    // 3. GATHER 操作：获取移动粒子的 idx
                    // a. 创建当前块所有粒子的 ip 索引向量
                    svint32_t all_ips_in_block = svindex_s32(ip, 1);
                    // b. 根据 moved_mask，从 pid_to_index_map 中收集对应的 idx
                    //    svld1_gather 只会加载 moved_mask 为 true 的通道的 idx
                    svint32_t moved_idxs_vec = svld1_gather_s32index_s32(moved_mask, &pid_to_index_map[0], all_ips_in_block);

                    // 4. SCATTER 操作：将 local_index 中对应位置设为无效
                    // a. 创建一个填满无效ID的向量
                    svint32_t vec_invalid_id = svdup_s32(INVALID_PARTICLE_ID);
                    // b. 根据 moved_idxs_vec 中的索引，将无效ID分散地写入 local_index
                    //    注意：这里的谓词是 moved_mask，因为它对应于 moved_idxs_vec 的源数据
                    svst1_scatter_s32index_s32(moved_mask, &local_index[0], moved_idxs_vec, vec_invalid_id);
                    
                    // 5. PACK 操作：将所有需要的信息打包
                    int32_t count_in_this_block = svcntp_b32(pg32, moved_mask);
                    svbool_t pg_compact = svwhilelt_b32(0, count_in_this_block);

                    // a. 紧凑化 ip, new_bin, old_bin
                    svint32_t moved_ips_vec      = svcompact(moved_mask, all_ips_in_block);
                    svint32_t moved_new_bins_vec = svcompact(moved_mask, vec_newbin);
                    svint32_t moved_old_bins_vec = svcompact(moved_mask, vec_oldbin);
                    svint32_t moved_idxs_vec1 = svcompact(moved_mask, moved_idxs_vec);

                    // b. 将紧凑后的向量存入输出数组
                    svst1_s32(pg_compact, &moved_ips[moved_count], moved_ips_vec);
                    svst1_s32(pg_compact, &moved_new_bins[moved_count], moved_new_bins_vec);
                    svst1_s32(pg_compact, &moved_old_bins[moved_count], moved_old_bins_vec);
                    svst1_s32(pg_compact, &moved_idxs[moved_count], moved_idxs_vec1);

                    // 6. 更新总计数
                    moved_count += count_in_this_block;
                }
                if (moved_count > loop_np*max_np_rate) {
                    rebuild=true;
                    break;
                }
            }
        }

        if (rebuild==false) {
            // 为了高效更新 bin_length，先用一个临时map统计
            std::map<int, int> bin_decrement_counts;
            // svetime1[0]=rdtscv();
            for (int k = 0; k < moved_count; ++k) {
                int ip = moved_ips[k];
                int new_bin = moved_new_bins[k];
                int old_bin = moved_old_bins[k];
                int idx = moved_idxs[k];

                // 执行 push_back 操作
                m_pending_moves[new_bin].push_back(ip);
                free_slot[old_bin].push_back(idx);

                // 统计每个 old_bin 离开的粒子数
                bin_decrement_counts[old_bin]++;
            }

            // 一次性更新 bin_length
            for (auto const& [bin, count] : bin_decrement_counts) {
                bin_length[bin] -= count;
            }
        }
    } else {
        rebuild=true;
    }

    // rebuild=false;

    ptile.m_pid_to_bin_map.reserve(np_to_deposit+1);
    ptile.m_pid_to_index_map.reserve(np_to_deposit+1);
    ptile.m_pid_to_index_map.resize(np_to_deposit, -1);
    ptile.m_pid_to_bin_map.assign(newbin.begin(),
                              newbin.begin() + np_to_deposit);
    ptile.m_num_particles=np_to_deposit;
    ptile.m_was_rebuilt_this_step= false ;
    // assert(newbin.size() >= np_to_deposit);
    // assert(ptile.m_pid_to_bin_map.size() == np_to_deposit);

    if(!rebuild){ 

        ptile.m_num_empty_slots=ptile.m_capacity-np_to_deposit;

        for (const auto& pair : m_pending_moves) {
            int new_bin=pair.first;
            std::vector<int>& particles_ip = m_pending_moves[new_bin];
            ptile.m_bin_lengths[new_bin]+=particles_ip.size();
            for (int i=particles_ip.size()-1; i>=0;i--) {
                int pid=particles_ip.back();
                int insert_idx = ptile.findEmptySlotInBin(new_bin);
                if (insert_idx != -1) {
                    // 直接填坑、退槽、长度增加（map已经完成更新）
                    ptile.m_local_index[insert_idx] = pid;
                    ptile.m_free_slots[new_bin].pop_back();
                    // ptile.m_bin_lengths[new_bin]++;
                    ptile.m_pid_to_index_map[pid]=insert_idx;
                    particles_ip.pop_back(); //一边填空一边更新pending_moves待插入的元素
                } else {
                    break;
                }
            }
        }
        //还有没更新完的就需要借用了
        int new_bin = numcell-1;
        //判断这块有没有数据，有就操作，不然跳过
        if (m_pending_moves.find(new_bin)!=m_pending_moves.end()) {
            int needed_borrow = m_pending_moves.at(new_bin).size();
            std::vector<int>& particles_ip = m_pending_moves[new_bin];
            int borrow_bin = new_bin-1;
            int idx=ptile.m_bin_offsets[new_bin]-1; //指向第一个块的尾巴指针
            // #pragma omp simd
            while(needed_borrow>0){
                //idx一直指向需要插入的尾巴
                int insert_idx = ptile.findEmptySlotInBin(borrow_bin);//这是借用空槽的位置
                int pid=particles_ip.back();
                if(insert_idx != -1) {
                    // 把借用位置的尾巴腾出空位
                    if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID){
                        ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                        ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                        ptile.m_free_slots[borrow_bin].pop_back();
                    } else {
                        auto it = std::find(ptile.m_free_slots[borrow_bin].begin(), 
                                            ptile.m_free_slots[borrow_bin].end(), 
                                            idx);
                        if (it != ptile.m_free_slots[borrow_bin].end()) {
                            *it = ptile.m_free_slots[borrow_bin].back();    // 用末尾那个元素覆盖它
                            ptile.m_free_slots[borrow_bin].pop_back();      // 弹出末尾
                        }
                    }
                    // 向借的位置填入粒子
                    ptile.m_local_index[idx] = pid;
                    ptile.m_pid_to_index_map[pid]=idx;
                    particles_ip.pop_back(); //一边填空一边更新pending_moves待插入的元素
                    needed_borrow--;
                    idx--;
                } else {
                    rebuild=true;
                    break;
                    // amrex::Abort("ERROR: no more slot can borrow!!!");
                }
            }
            // if(!rebuild){
                ptile.m_bin_offsets[new_bin]=idx+1;
                m_pending_moves.erase(numcell-1);
            // } else {
            //     break;
            // }
        }
        new_bin = 0;
        //判断这块有没有数据，有就操作，不然跳过
        if (!rebuild && m_pending_moves.find(new_bin)!=m_pending_moves.end()) {
            int needed_borrow = m_pending_moves.at(new_bin).size();
            std::vector<int>& particles_ip = m_pending_moves[new_bin];
            int borrow_bin = new_bin+1;
            int idx=ptile.m_bin_offsets[new_bin+1]; //指向第一个块的头指针
            // #pragma omp simd
            while(needed_borrow>0){
                //idx一直指向需要插入的尾巴
                int insert_idx = ptile.findEmptySlotInBin(borrow_bin);//这是借用空槽的位置
                int pid=particles_ip.back();
                if(insert_idx != -1) {
                    // 把借用位置的尾巴腾出空位
                    if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID){
                        ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                        ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                        ptile.m_free_slots[borrow_bin].pop_back();
                    } else {
                        auto it = std::find(ptile.m_free_slots[borrow_bin].begin(), 
                                            ptile.m_free_slots[borrow_bin].end(), 
                                            idx);
                        if (it != ptile.m_free_slots[borrow_bin].end()) {
                            *it = ptile.m_free_slots[borrow_bin].back();    // 用末尾那个元素覆盖它
                            ptile.m_free_slots[borrow_bin].pop_back();      // 弹出末尾
                        }
                    }
                    // 向借的位置填入粒子
                    ptile.m_local_index[idx] = pid;
                    ptile.m_pid_to_index_map[pid]=idx;
                    particles_ip.pop_back(); //一边填空一边更新pending_moves待插入的元素
                    needed_borrow--;
                    idx++;
                } else {
                    rebuild=true;
                    break;
                    // amrex::Abort("ERROR: no more slot can borrow!!!");
                }
            }
            // if(!rebuild){
                ptile.m_bin_offsets[new_bin+1]=idx;
                m_pending_moves.erase(0);
            // } else {
            //     break;
            // }
        }

        //现在按顺序处理向右边两个允许借用
        if(!rebuild){
            for (const auto& pair : m_pending_moves) {
                int new_bin=pair.first;
                std::vector<int>& particles_ip = m_pending_moves[new_bin];
                
                int needed_borrow = m_pending_moves.at(new_bin).size();
                int borrow_bin = new_bin+1;
                int idx=ptile.m_bin_offsets[new_bin+1]; //指向第一个块的头指针
                int borrow_flag=0; //指示
                // 先右后左，因为是向右顺序处理的
                // #pragma omp simd
                while(needed_borrow>0){
                    borrow_flag=1;
                    //idx一直指向需要插入的尾巴
                    //先找右边
                    int insert_idx = ptile.findEmptySlotInBin(borrow_bin);//这是借用空槽的位置
                    if(insert_idx == -1 && borrow_bin==new_bin-1) {
                        rebuild=true;
                        break;
                        // amrex::Abort("ERROR borrow!");
                    }
                    int pid=particles_ip.back();
                    if(insert_idx != -1){
                        if (borrow_bin==new_bin+1) {
                            // 把借用位置的尾巴腾出空位
                            if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID){
                                ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                                ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                                ptile.m_free_slots[borrow_bin].pop_back();
                            } else {
                                auto it = std::find(ptile.m_free_slots[borrow_bin].begin(), 
                                                    ptile.m_free_slots[borrow_bin].end(), 
                                                    idx);
                                if (it != ptile.m_free_slots[borrow_bin].end()) {
                                    *it = ptile.m_free_slots[borrow_bin].back();    // 用末尾那个元素覆盖它
                                    ptile.m_free_slots[borrow_bin].pop_back();      // 弹出末尾
                                }
                            }
                            // 向借的位置填入粒子
                            ptile.m_local_index[idx] = pid;
                            ptile.m_pid_to_index_map[pid]=idx;
                            particles_ip.pop_back(); //一边填空一边更新pending_moves待插入的元素
                            needed_borrow--;
                            idx++;
                            continue;
                        } 
                        if (borrow_bin==new_bin-1) {
                            if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID){
                                ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                                ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                                ptile.m_free_slots[borrow_bin].pop_back();
                            } else {
                                auto it = std::find(ptile.m_free_slots[borrow_bin].begin(), 
                                                    ptile.m_free_slots[borrow_bin].end(), 
                                                    idx);
                                if (it != ptile.m_free_slots[borrow_bin].end()) {
                                    *it = ptile.m_free_slots[borrow_bin].back();    // 用末尾那个元素覆盖它
                                    ptile.m_free_slots[borrow_bin].pop_back();      // 弹出末尾
                                }
                            }
                            // 向借的位置填入粒子
                            ptile.m_local_index[idx] = pid;
                            ptile.m_pid_to_index_map[pid]=idx;
                            particles_ip.pop_back(); //一边填空一边更新pending_moves待插入的元素
                            needed_borrow--;
                            idx--;
                            continue;
                        } 
                    }else {
                        ptile.m_bin_offsets[new_bin+1]=idx;
                        //右边找完还不够，就继续
                        borrow_bin = new_bin-1;
                        idx=ptile.m_bin_offsets[new_bin]-1; //指向第一个块的头指针
                    }
                }
                if(!rebuild){
                    if(borrow_flag){
                        if (borrow_bin==new_bin+1) {
                            ptile.m_bin_offsets[new_bin+1]=idx;
                        } else if((borrow_bin==new_bin-1)){
                            ptile.m_bin_offsets[new_bin]=idx+1;
                        }
                    }
                } else {
                    break;
                }
            }
        }
    }

    if(rebuild)
    { 
        const int vlf=svcntw();

        ptile.m_was_rebuilt_this_step = true;
        std::vector<int> final_bin_counts(numcell, 0);
        float gap_ratio=WarpX::GetInstance().m_gap_ratio;
        const std::vector<int>& pid_to_bin_map = ptile.m_pid_to_bin_map;
        int np = ptile.m_num_particles;
        // #pragma omp simd
        for(int ip=0;ip<np_to_deposit;ip++){
            final_bin_counts[pid_to_bin_map[ip]]++;
        }  
        ptile.m_bin_lengths = final_bin_counts;
        ptile.m_capacity = static_cast<int>(std::ceil(static_cast<double>(np) * (1.0 + gap_ratio)) + 2*numcell);
        //==================================
        // for(int bin=0;bin<numcell;bin++){
        //     printf("final_bin_counts[%d] = %d\n",bin,final_bin_counts[bin]);
        // }
        //=================================
        int current_offset = 0;
        ptile.m_bin_offsets[0] = 0;
        ptile.m_free_slots.assign(numcell,std::vector<int>());
        std::vector<int> gap(numcell,0);
        
        #pragma omp unroll
        for (int binID = 0; binID < numcell; binID+=vlf) {
            svbool_t p_bin = svwhilelt_b32(binID,numcell);
            svint32_t np_in_bin=svld1_s32(p_bin,&final_bin_counts[binID]);
            svint32_t gap_v=svadd_n_s32_x(p_bin,
                            svcvt_s32_f32_x(p_bin,svmul_n_f32_x(p_bin,
                            svcvt_f32_s32_x(p_bin,np_in_bin),gap_ratio)),
                            1);
            svst1_s32(p_bin,&gap[binID],gap_v);
            svint32_t block_size_v=svadd_s32_x(p_bin,gap_v,np_in_bin);
            // 3. 向量化局部累加 (Intra-Vector Exclusive Scan)
            //    这是将串行依赖转换为并行计算的核心
            svint32_t local_scan_v = block_size_v;
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-1));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-2));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-4));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-8));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-16));
            
            local_scan_v  = svadd_n_s32_x(p_bin, local_scan_v, current_offset);

            // 5. 存储最终计算出的偏移量结果
            //    注意，我们从 m_bin_offsets 的第 binID + 1 个位置开始存
            svst1_s32(p_bin, &ptile.m_bin_offsets[binID + 1], local_scan_v);
            // svst1_s32(p_bin, &testoff[binID + 1], final_offsets_v);

            // 6. 更新下一个块的全局偏移
            //    使用svaddv高效地计算当前块所有block_size的总和
            current_offset += svaddv_s32(p_bin, block_size_v);
        }
        // if(ptile.m_bin_offsets[numcell]>=ptile.m_capacity){
        //     printf("ptile.m_bin_offsets[numcell] %d m_capacity %d \n"
        //         ,ptile.m_bin_offsets[numcell],ptile.m_capacity);
        //     amrex::Abort("ERROR: m_bin_offsets[numcell] >= m_capacity!!!");
        // }

        //下面对空slot的pushback操作也是一样的，由于vector<vector>在内存中散乱分布，
        //所以load的时候产生cachemiss导致额外开销，最好修改freeslot的数据结构以改善问题
        std::vector<int>& binoff=ptile.m_bin_offsets;
        std::vector<std::vector<int>>& freeslot=ptile.m_free_slots;
        for (int binID = 0; binID < numcell; binID++) {
            int gap_size = gap[binID];
            int start_offset = binoff[binID + 1];
            auto& target_vec = freeslot[binID];
            target_vec.resize(gap_size);
            for (int k = 0; k < gap_size; k += vlf) {
                // 創建謂詞，安全處理最後一個不滿的向量塊
                svbool_t pg = svwhilelt_b32(k, gap_size);
            
                // a. 生成要寫入的數值向量
                //    首先，建立一個索引向量 [k, k+1, k+2, ...]
                svint32_t vec_k_indices = svindex_s32(k, 1);
                //    然後，建立一個填滿 start_offset-1 的向量
                svint32_t vec_base = svdup_n_s32(start_offset - 1);
                //    計算出最終要寫入的值：(start_offset-1) - k
                svint32_t values_to_store = svsub_s32_z(pg, vec_base, vec_k_indices);
            
                // b. 連續寫入 (Store)
                //    將產生的向量一次性寫入目標記憶體
                svst1_s32(pg, &target_vec[k], values_to_store);
            }
        }
        ptile.m_capacity=ptile.m_bin_offsets[numcell];
        ptile.m_num_empty_slots = ptile.m_capacity - ptile.m_num_particles;
        ptile.m_local_index.assign(ptile.m_capacity, INVALID_PARTICLE_ID);
        // 初始化为每个 bin 的起始位置
        std::vector<int> next_write_slot = ptile.m_bin_offsets; 

        for(int ip=0;ip<np;ip++){
            int bin_id =pid_to_bin_map[ip];
            int insert_idx = next_write_slot[bin_id];
            // assert(insert_idx >= 0 && insert_idx < ptile.m_local_index.size());
            // assert(ip >= 0 && ip < ptile.m_pid_to_index_map.size());
            ptile.m_local_index[insert_idx] = ip;
            ptile.m_pid_to_index_map[ip]=insert_idx;
            next_write_slot[bin_id]++;
        }
        ptile.m_was_rebuilt_this_step = true;
    }
    m_pending_moves.clear();
}

inline void test_iplist (
    int np, ParticleTileType& ptile,
    std::vector<int>& newbin, int numcell
)
{
    std::vector<int> local_index; 
    std::vector<int> bin_offsets(numcell+1);  
    std::vector<int> bin_lengths(numcell);   
    int capacity;                           
    std::vector<int> slot_offsets(numcell+1); 
    std::vector<int> bin_max_ip(numcell); 

    std::vector<int> pid_to_bin_map(np); 
    std::vector<int> pid_to_index_map(np);

    const int vlf=svcntw();
    float gap_ratio=WarpX::GetInstance().m_gap_ratio;
    pid_to_bin_map=newbin;

    for(int ip=0;ip<np;ip++){
        bin_lengths[pid_to_bin_map[ip]]++;
    }  
    capacity = static_cast<int>(std::ceil(static_cast<double>(np) * (1.0 + gap_ratio)) + 2*numcell);
    local_index.resize(capacity);

    int current_offset = 0;
    bin_offsets[0] = 0;
    slot_offsets[0] = 0;
    
    for (int binID = 0; binID < numcell; binID+=vlf) {
        svbool_t p_bin = svwhilelt_b32(binID,numcell);
        svint32_t np_in_bin=svld1_s32(p_bin,&bin_lengths[binID]);
        svint32_t gap_v=svadd_n_s32_x(p_bin,
                        svcvt_s32_f32_x(p_bin,svmul_n_f32_x(p_bin,
                        svcvt_f32_s32_x(p_bin,np_in_bin),gap_ratio)),
                        1);
        svint32_t block_size_v=svadd_s32_x(p_bin,gap_v,np_in_bin);

        svint32_t local_scan_v = block_size_v;
        local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-1));
        local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-2));
        local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-4));
        local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-8));
        local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-16));
        
        local_scan_v  = svadd_n_s32_x(p_bin, local_scan_v, current_offset);

        svst1_s32(p_bin, &bin_offsets[binID + 1], local_scan_v);
        current_offset += svaddv_s32(p_bin, block_size_v);
    }
    for (int binID = 1; binID < numcell+1; binID++) {
        slot_offsets[binID]=bin_offsets[binID-1]+bin_lengths[binID-1];
    }

    capacity=bin_offsets[numcell];
    local_index.assign(capacity, INVALID_PARTICLE_ID);
    // 初始化为每个 bin 的起始位置
    std::vector<int> next_write_slot = bin_offsets; 

    for(int ip=0;ip<np;ip++){
        int bin_id =pid_to_bin_map[ip];
        int insert_idx = next_write_slot[bin_id];
        local_index[insert_idx] = ip;
        pid_to_index_map[ip]=insert_idx;
        next_write_slot[bin_id]++;
    }
    for (int binID = 0; binID < numcell; binID++) {
        bin_max_ip[binID]=0;
        if(bin_lengths[binID]>0)
            bin_max_ip[binID]=local_index[bin_offsets[binID]+bin_lengths[binID]-1];
    }
 
    printf("rebuild? : %d \n",ptile.m_was_rebuilt_this_step);
    bool rebuild=ptile.m_was_rebuilt_this_step;
    // rebuild=1;
    // bool flag=0;

    printf("==========Test capacity===========\n");
    if(ptile.m_capacity!=capacity) printf("capacity %d True %d\n",ptile.m_capacity,capacity);
    printf("\n==========Test m_bin_lengths+m_bin_max_ip===========\n");
    for(int i=0;i<numcell;i++){
        if(ptile.m_bin_lengths[i]!=bin_lengths[i]){
            printf("bin_lengths[%d] %d True %d \n"
                ,i,ptile.m_bin_lengths[i],bin_lengths[i]);
        }
        // if(ptile.m_bin_max_ip[i]!=bin_max_ip[i]){
        //     printf("bin_max_ip[%d] %d True %d \n"
        //         ,i,ptile.m_bin_max_ip[i],bin_max_ip[i]);
        // }
    }

    std::unordered_map<int, int> seen_indices;
    bool duplicate_found = false;
    std::vector<int>& nums=ptile.m_local_index;
    // 使用带索引的 for 循环来遍历 vector，因为我们需要位置信息
    for (int i = 0; i < nums.size(); ++i) {
        int num = nums[i];

        // 规则：-1 可以重复，我们直接跳过
        if (num == -1) {
            continue;
        }

        //在哈希表中查找当前数字
        auto it = seen_indices.find(num);

        // 如果找到了 (it != seen_indices.end())，说明这个数字重复出现了
        if (it != seen_indices.end()) {
            // 首次发现重复项时，打印一个标题头
            if (!duplicate_found) {
                std::cout << "xxx1 发现以下重复数值：" << std::endl;
                duplicate_found = true;
            }
            // 打印重复的数值、当前位置，以及它首次出现的位置
            // it->second 存储的是首次出现的索引
            std::cout << "  - 数值: " << num 
                      << ", 重复位置: " << i 
                      << " (首次出现在位置: " << it->second << ")" << std::endl;
        } else {
            // 如果没找到，说明是第一次遇到这个数，将其和它的索引存入哈希表
            seen_indices[num] = i;
        }
    }

    if(rebuild){
        printf("\n==========Test m_bin_offsets+m_slot_offsets===========\n");
        for(int i=0;i<numcell+1;i++){
            if(ptile.m_bin_offsets[i]!=bin_offsets[i]){
                printf("bin_offsets[%d] %d True %d \n"
                    ,i,ptile.m_bin_offsets[i],bin_offsets[i]);
            }
            if(ptile.m_slot_offsets[i]!=slot_offsets[i]){
                printf("slot_offsets[%d] %d True %d \n"
                    ,i,ptile.m_slot_offsets[i],slot_offsets[i]);
            }
        }
    }
    if(rebuild){
        printf("\n==========Test pid_to_bin_map+pid_to_index_map===========\n");
        for(int i=0;i<np;i++){
            if(ptile.m_pid_to_bin_map[i]!=pid_to_bin_map[i]){
                printf("pid_to_bin_map[%d] %d True %d \n"
                    ,i,ptile.m_pid_to_bin_map[i],pid_to_bin_map[i]);
            }
            if(ptile.m_pid_to_index_map[i]!=pid_to_index_map[i]){
                printf("pid_to_index_map[%d] %d True %d \n"
                    ,i,ptile.m_pid_to_index_map[i],pid_to_index_map[i]);
            }
        }
    }
    if(rebuild){
        printf("\n==========Test local_index===========\n");
        for(int i=0;i<ptile.m_local_index.size();i++){
            if(ptile.m_local_index[i]!=local_index[i]){
                printf("local_index[%d] %d True %d \n"
                    ,i,ptile.m_local_index[i],local_index[i]);
            }
        }
    }
    printf("\n==========Test ips===========\n");
    for(int i=0;i<numcell;i++){
        int trueoffset = bin_offsets[i];
        int binoffset = ptile.m_bin_offsets[i];
        std::vector<int> ip1,iptrue;
        for(int j=0;j<bin_lengths[i];++j){
            ip1.push_back(ptile.m_local_index[binoffset+j]);
            iptrue.push_back(local_index[trueoffset+j]);

            // if(ptile.m_local_index[binoffset+j]!=local_index[trueoffset+j]){
            //     printf("=========\n");
            //     for(int k=0;k<bin_lengths[i]+2;++k){
            //         printf("bin %d k %d local_index(ip)[%d] %d True[%d] %d \n"
            //             ,i,k,binoffset+k,ptile.m_local_index[binoffset+k],
            //             trueoffset+k,local_index[trueoffset+k]);
            //     }
            // }
        }
        std::sort(ip1.begin(),ip1.end());
        std::sort(iptrue.begin(),iptrue.end());
        if(std::equal(ip1.begin(),ip1.end(),iptrue.begin())){
        }
        else{
            printf(" BIN %d m_bin_offsets[%d]=%d %d,m_slot_offsets[%d]=%d %d, m_bin_lengths=%d\n",i,
                i,ptile.m_bin_offsets[i],ptile.m_bin_offsets[i+1],
                i+1,ptile.m_slot_offsets[i+1],ptile.m_slot_offsets[i+2],
                ptile.m_bin_lengths[i]);
            printf("TRUE BIN %d  bin_offsets[%d]=%d %d,m_slot_offsets[%d]=%d %d, bin_lengths=%d\n",i,
                i,bin_offsets[i],bin_offsets[i+1],
                i+1,slot_offsets[i+1],slot_offsets[i+2],
                bin_lengths[i]);
            for(int ii=ptile.m_bin_offsets[i];ii<ptile.m_bin_offsets[i+1];ii++){
                printf("BIN %d m_local_index[%d]=%d\n",i,ii,ptile.m_local_index[ii]);
            }
            for(int ii=bin_offsets[i];ii<bin_offsets[i+1];ii++){
                printf("TRUE BIN %d local_index[%d]=%d\n",i,ii,local_index[ii]);
            }
            for(int ip =0;ip<ip1.size();ip++){
                printf("BIN %d ip1 %d \n",i,ip1[ip]);
            }
            for(int ip =0;ip<iptrue.size();ip++){
                printf("BIN %d iptrue %d \n",i,iptrue[ip]);
            }
            amrex::Abort("END test");
        }
    }
    printf("\n==========End Test===========\n");
 
    // amrex::Abort("end test");
}

inline void sorted_index_pma_compact (
    std::unordered_map<int, int>& bin_decrement_counts,
    std::vector<int>& local_index,
    std::vector<int>& slot_offsets,
    const std::vector<int>& bin_offsets,
    std::vector<int>& pid_to_index_map
) {
    using namespace amrex::literals;

    int vl=svcntw();
    svint32_t vmax = svdup_s32(INVALID_PARTICLE_ID);
    svbool_t p_all = svptrue_b32();
    //===============
    std::vector<int> tmp_idx_map=pid_to_index_map;
    //===============

    int write_ptr = 0;
    for (auto const& [old_bin, count1]  : bin_decrement_counts) {
        // int old_bin = pair.first;
        int start = bin_offsets[old_bin];
        // printf("compact bin %d\n",old_bin);
        //==================
        // for(int i=bin_offsets[old_bin];i<bin_offsets[old_bin+1];i++){
        //     int ip=local_index[i];
        //     printf("1 bin %d index %d before ip: %d\n",old_bin,i,ip);
        // }
        // printf("1.3 before bin_offsets %d %d, slot_offsets %d %d\n",
        //     bin_offsets[old_bin],bin_offsets[old_bin+1],slot_offsets[old_bin],slot_offsets[old_bin+1]);
        //===============
        for(int i=start;i<slot_offsets[old_bin+1];i+=vl){

            svbool_t p0 = svwhilelt_b32(i,slot_offsets[old_bin+1]);
            svint32_t ip_v = svld1_s32(p0,&local_index[i]);
            svbool_t p1 = svcmpne_s32(p0, ip_v, vmax);
            svint32_t real_ip_v = svcompact_s32(p1, ip_v);
            int count = svcntp_b32(p0, p1);
            // int count = svcntp_b32(p_all, p1);
            svbool_t p_store = svwhilelt_b32(0, count);
            svst1_s32(p_store,&local_index[start],real_ip_v);
            // update pid_to_index_map
            svint32_t pid_to_index_map_v = svindex_s32(start,1);
            svst1_scatter_s32index_s32(p_store,&pid_to_index_map[0],real_ip_v,pid_to_index_map_v);
            start+=count;
            //==============

            //============
        }
        //==================
        // for(int i=bin_offsets[old_bin];i<slot_offsets[old_bin+1];i++){
        //     int ip=local_index[i];
        //     // 可选的优化，让日志更干净
        //     // if (tmp_idx_map[ip] != pid_to_index_map[ip]) {
        //     //     printf("compact %d tail Bin %d idx %d pid_to_index_map[%d] changed from %d to %d\n",
        //     //             start-bin_offsets[old_bin],old_bin,i,ip,tmp_idx_map[ip],pid_to_index_map[ip]);
        //     // }   
        //     if(ip!=-1)        
        //         printf("1.5 compact  Bin %d idx %d pid_to_index_map[%d] changed from %d to %d\n",
        //             old_bin,i,ip,tmp_idx_map[ip],pid_to_index_map[ip]);
        // }
        //===============
        for (int i=start;i<slot_offsets[old_bin+1];i+=vl) {
            svbool_t p0 = svwhilelt_b32(i,slot_offsets[old_bin+1]);
            svst1_s32(p0,&local_index[start],vmax);
        }
        slot_offsets[old_bin+1]=start;
        //==================
        // printf("BIN %d after bin_offsets %d %d, slot_offsets %d %d\n",
        //     old_bin,bin_offsets[old_bin],bin_offsets[old_bin+1],slot_offsets[old_bin+1],slot_offsets[old_bin+2]);
        // for(int i=bin_offsets[old_bin];i<bin_offsets[old_bin+1];i++){
        //     int ip=local_index[i];
        //     printf("2 bin %d index %d after ip: %d\n",old_bin,i,ip);
        // }
        //===============
    }
}

inline void sorted_index_pma_compact_hbm (
    std::unordered_map<int, int>& bin_decrement_counts,
    HBM_Inner_Vector_Int& local_index,
    std::vector<int>& slot_offsets,
    const std::vector<int>& bin_offsets,
    std::vector<int>& pid_to_index_map
) {
    using namespace amrex::literals;

    int vl=svcntw();
    svint32_t vmax = svdup_s32(INVALID_PARTICLE_ID);
    svbool_t p_all = svptrue_b32();

    int write_ptr = 0;
    for (auto const& [old_bin, count1]  : bin_decrement_counts) {
        // int old_bin = pair.first;
        int start = bin_offsets[old_bin];
        // printf("compact bin %d\n",old_bin);
        //==================
        // for(int i=bin_offsets[old_bin];i<bin_offsets[old_bin+1];i++){
        //     int ip=local_index[i];
        //     printf("1 bin %d index %d before ip: %d\n",old_bin,i,ip);
        // }
        // printf("1.3 before bin_offsets %d %d, slot_offsets %d %d\n",
        //     bin_offsets[old_bin],bin_offsets[old_bin+1],slot_offsets[old_bin],slot_offsets[old_bin+1]);
        //===============
        for(int i=start;i<slot_offsets[old_bin+1];i+=vl){

            svbool_t p0 = svwhilelt_b32(i,slot_offsets[old_bin+1]);
            svint32_t ip_v = svld1_s32(p0,&local_index[i]);
            svbool_t p1 = svcmpne_s32(p0, ip_v, vmax);
            svint32_t real_ip_v = svcompact_s32(p1, ip_v);
            int count = svcntp_b32(p0, p1);
            // int count = svcntp_b32(p_all, p1);
            svbool_t p_store = svwhilelt_b32(0, count);
            svst1_s32(p_store,&local_index[start],real_ip_v);
            // update pid_to_index_map
            svint32_t pid_to_index_map_v = svindex_s32(start,1);
            svst1_scatter_s32index_s32(p_store,&pid_to_index_map[0],real_ip_v,pid_to_index_map_v);
            start+=count;
            //==============

            //============
        }
        //==================
        // for(int i=bin_offsets[old_bin];i<slot_offsets[old_bin+1];i++){
        //     int ip=local_index[i];
        //     // 可选的优化，让日志更干净
        //     // if (tmp_idx_map[ip] != pid_to_index_map[ip]) {
        //     //     printf("compact %d tail Bin %d idx %d pid_to_index_map[%d] changed from %d to %d\n",
        //     //             start-bin_offsets[old_bin],old_bin,i,ip,tmp_idx_map[ip],pid_to_index_map[ip]);
        //     // }   
        //     if(ip!=-1)        
        //         printf("1.5 compact  Bin %d idx %d pid_to_index_map[%d] changed from %d to %d\n",
        //             old_bin,i,ip,tmp_idx_map[ip],pid_to_index_map[ip]);
        // }
        //===============
        for (int i=start;i<slot_offsets[old_bin+1];i+=vl) {
            svbool_t p0 = svwhilelt_b32(i,slot_offsets[old_bin+1]);
            svst1_s32(p0,&local_index[start],vmax);
        }
        slot_offsets[old_bin+1]=start;
        //==================
        // printf("BIN %d after bin_offsets %d %d, slot_offsets %d %d\n",
        //     old_bin,bin_offsets[old_bin],bin_offsets[old_bin+1],slot_offsets[old_bin+1],slot_offsets[old_bin+2]);
        // for(int i=bin_offsets[old_bin];i<bin_offsets[old_bin+1];i++){
        //     int ip=local_index[i];
        //     printf("2 bin %d index %d after ip: %d\n",old_bin,i,ip);
        // }
        //===============
    }
}

inline void increment_sort_particles2 (
    int np_to_deposit, ParticleTileType& ptile,
    std::vector<int>& newbin, int numcell
)
{
    auto& local_index = ptile.m_local_index;
    auto& slot_offsets = ptile.m_slot_offsets; //和binoffset对齐，长度ncell+1，[0]指向0号位置
    auto& bin_length = ptile.m_bin_lengths;
    
    auto& num_particles = ptile.m_num_particles;
    auto& bin_offsets = ptile.m_bin_offsets;
    auto& pid_to_bin_map = ptile.m_pid_to_bin_map;
    auto& pid_to_index_map = ptile.m_pid_to_index_map; 
    auto& bin_max_ip = ptile.m_bin_max_ip;
    auto& was_rebuilt_this_step =  ptile.m_was_rebuilt_this_step;

    // TODO: move ouside
    std::unordered_map<int, std::vector<int>> m_tail_pending_moves;
    std::unordered_map<int, std::vector<int>> m_front_pending_moves;
    m_tail_pending_moves.clear();
    m_front_pending_moves.clear();

    bool rebuild=false;
    // rebuild=true;
    int vlf = svcntw();
    printf("np %d numpart %d\n",np_to_deposit,num_particles);
    std::unordered_map<int, int> bin_decrement_counts;



    // Stage 1：准备增量更新的数据
    // 更新粒子的预处理，组织成从小到大的块
    if(np_to_deposit<ptile.m_capacity && !rebuild){
        // int loop_np=num_particles;
        
        // 1. 减少的粒子删除
        for(int ip=np_to_deposit;ip<num_particles;ip++){
            int old_bin=pid_to_bin_map[ip];
            int idx=pid_to_index_map[ip]; 
            //打洞、长度缩减、压栈
            ptile.m_local_index[idx] = INVALID_PARTICLE_ID;
            bin_length[old_bin]--;
            // printf("1 ip %d leave bin %d \n",ip,old_bin);
        }

        // 2. 对变化的粒子先做了删除操作
        //必须是小的一个才需要loop，因为如果新增粒子和减少的粒子都不在这里更新
        int loop_np=std::min(num_particles,np_to_deposit); 
        int block_size=WarpX::GetInstance().m_fast_cmp_block_size;; // 256
        float max_np_rate=WarpX::GetInstance().m_max_moved_np_rate; // 0.15
        int MOVED_PARTICLES_MAX=loop_np/4+block_size;
        // std::vector<int> moved_tail_ips(MOVED_PARTICLES_MAX);
        // std::vector<int> moved_front_ips(MOVED_PARTICLES_MAX);
        // std::vector<int> moved_tail_bins(MOVED_PARTICLES_MAX);
        // std::vector<int> moved_front_bins(MOVED_PARTICLES_MAX);
        // std::vector<int> moved_old_bins(MOVED_PARTICLES_MAX);
        int moved_tail_ips[MOVED_PARTICLES_MAX];
        int moved_front_ips[MOVED_PARTICLES_MAX];
        int moved_tail_bins[MOVED_PARTICLES_MAX];
        int moved_front_bins[MOVED_PARTICLES_MAX];
        int moved_old_bins[MOVED_PARTICLES_MAX];
        int tail_count = 0;
        int front_count = 0;
        int moved_count = 0;
        svint32_t vec_invalid_id = svdup_n_s32(INVALID_PARTICLE_ID);

        for (int i = 0; i < loop_np; i += block_size) {
            // svetime1[0]=rdtscv();
            int current_block_size = std::min(block_size, loop_np - i);
            // 计算需要比较的字节数
            size_t bytes_to_compare = current_block_size * sizeof(int);

            // --- 快速路径：使用 memcmp 比较整个块 ---
            // memcmp 比较的是内存内容。如果返回0，表示两块内存完全相同。
            if (memcmp(&newbin[i], &pid_to_bin_map[i], bytes_to_compare) == 0) {
                // 块内所有粒子都没有移动，直接跳过，这是性能提升的关键
                continue; 
            } 
            else {
                // svetime1[0]=rdtscv();

                for (int j = 0; j < current_block_size; j += vlf) {
                    int ip=i+j;
                    // 创建覆盖当前块的谓词 (同时为64位和32位元素创建)
                    svbool_t pg32 = svwhilelt_b32(j, current_block_size);
                    svint32_t vec_newbin = svld1_s32(pg32, &newbin[ip]);
                    svint32_t vec_oldbin  = svld1_s32(pg32, &pid_to_bin_map[ip]);
                    svbool_t moved_mask = svcmpne(pg32, vec_newbin, vec_oldbin);
                    if (!svptest_any(pg32, moved_mask)) {
                        continue;
                    }
                    // --- 开始处理移动的粒子 ---
                    // 0） 创建当前块所有粒子的 ip 索引向量
                    svint32_t all_ips_in_block = svindex_s32(ip, 1);

                    // 1) 获取移动粒子的 idx
                    svint32_t moved_idxs_vec = svld1_s32(moved_mask, &pid_to_index_map[ip]);

                    // 2) 获取这些粒子对应要分去bin的最大值对比
                    svint32_t newbin_max_ip_vec = svld1_gather_s32index_s32(moved_mask,&bin_max_ip[0],vec_newbin);

                    // 3）对比粒子和最大值，粒子大的插入后面，粒子小的插入前面
                    svbool_t moved_tail_mask = svcmpge(moved_mask, all_ips_in_block, newbin_max_ip_vec);
                    svbool_t moved_front_mask = svcmplt(moved_mask, all_ips_in_block, newbin_max_ip_vec);
                    // 4) SCATTER 操作：将 local_index 中对应位置设为无效
                    // svst1_scatter_s32index_s32(svptrue_b32(), &local_index[0], moved_idxs_vec, vec_invalid_id);
                    svst1_scatter_s32index_s32(moved_mask, &local_index[0], moved_idxs_vec, vec_invalid_id);

                    
                    // 5) PACK 操作：将所有需要的信息打包
                    int32_t count_in_this_block = svcntp_b32(pg32, moved_mask);
                    svbool_t pg_compact = svwhilelt_b32(0, count_in_this_block);
                    int32_t count_tail = svcntp_b32(pg32, moved_tail_mask);
                    svbool_t pg_tail = svwhilelt_b32(0, count_tail);
                    int32_t count_front = svcntp_b32(pg32, moved_front_mask);
                    svbool_t pg_front = svwhilelt_b32(0, count_front);
                    // a. 紧凑化 ip, new_bin, old_bin
                    svint32_t moved_tail_ips_vec      = svcompact(moved_tail_mask, all_ips_in_block);
                    svint32_t moved_front_ips_vec      = svcompact(moved_front_mask, all_ips_in_block);
                    svint32_t moved_tail_bins_vec = svcompact(moved_tail_mask, vec_newbin);
                    svint32_t moved_front_bins_vec = svcompact(moved_front_mask, vec_newbin);
                    svint32_t moved_old_bins_vec = svcompact(moved_mask, vec_oldbin);
                    // b. 将紧凑后的向量存入输出数组
                    svst1_s32(pg_tail, &moved_tail_ips[tail_count], moved_tail_ips_vec);
                    svst1_s32(pg_front, &moved_front_ips[front_count], moved_front_ips_vec);
                    svst1_s32(pg_tail, &moved_tail_bins[tail_count], moved_tail_bins_vec);
                    svst1_s32(pg_front, &moved_front_bins[front_count], moved_front_bins_vec);
                    svst1_s32(pg_compact, &moved_old_bins[moved_count], moved_old_bins_vec);

                    // 6) 更新总计数
                    tail_count += count_tail;
                    front_count += count_front;
                    moved_count += count_in_this_block;
                }
                
                if (moved_count > loop_np*max_np_rate) {
                    rebuild=true;
                    break;
                }
            }
        }
        


        // 为了高效更新 bin_length，先用一个临时map统计
        // std::unordered_map<int, int> bin_decrement_counts;
        if (!rebuild) {
            // svetime1[0]=rdtscv();
            for (int k = 0; k < moved_count; ++k) {
                // 统计每个 old_bin 离开的粒子数
                int old_bin = moved_old_bins[k];
                bin_decrement_counts[old_bin]++;
                // printf("2 ip leaveing bin %d\n",old_bin);
            }
            // 一次性更新 bin_length
            for (auto const& [bin, count] : bin_decrement_counts) {
                bin_length[bin] -= count;
            }
            // front
            for (int k = 0; k < front_count; ++k) {
                int ip = moved_front_ips[k];
                int new_bin = moved_front_bins[k];
                // 执行 push_back 操作
                m_front_pending_moves[new_bin].push_back(ip);
                // printf("3 ip %d add bin %d front\n",ip,new_bin);
                // printf("\t index %d org set to %d\n",pid_to_index_map[ip],local_index[pid_to_index_map[ip]]);
            }
            // printf("moved_tail_ipssize %d, moved_tail_binssize %d\n",
            //     moved_tail_ips.size(),moved_tail_bins.size());
            // tail
            for (int k = 0; k < tail_count; ++k) {
                int ip = moved_tail_ips[k];
                int new_bin = moved_tail_bins[k];
                // 执行 push_back 操作
                m_tail_pending_moves[new_bin].push_back(ip);
                // printf("4 k %d ip %d add bin %d tail\n",k,ip,new_bin);
            }
   
            // 3.压实local index
            sorted_index_pma_compact(bin_decrement_counts,
                local_index,slot_offsets,bin_offsets,pid_to_index_map);
            
            // 4. 新增粒子添加。因为新增粒子肯定都是大ip所以最后插入
            for(int ip=num_particles;ip<np_to_deposit;ip++){
                int new_bin=newbin[ip];
                m_tail_pending_moves[new_bin].push_back(ip);
                // printf("5 ip %d add bin %d tail\n",ip,new_bin);
            }
            // num_particles=np_to_deposit;
        }
    } else {
        rebuild=true;
    }
    // 上面减少了bin_length, slot_offset, bin_max_ip
    // m_local_index压实了,pid_to_index_map也相应变化了
    

    // Stage 2：执行增量更新
    // 下面继续更新m_pid_to_bin_map,pid_to_index_map, bin_max_ip, num_particles
    // 随着粒子的插入slot_offset,bin_offsets也需要增加（改变）了
    // 还要继续插入块更新m_local_index压实了
    pid_to_index_map.reserve(np_to_deposit+1);  
    // pid_to_index_map.clear();
    pid_to_index_map.resize(np_to_deposit);

    pid_to_bin_map.reserve(np_to_deposit+1);
    pid_to_bin_map.resize(np_to_deposit);
    std::memcpy(pid_to_bin_map.data(),
                newbin.data(),
                np_to_deposit * sizeof(int));
    // pid_to_bin_map.assign(newbin.begin(),
    //                           newbin.begin() + np_to_deposit);
    num_particles=np_to_deposit;
    was_rebuilt_this_step = false ;
    // assert(newbin.size() >= np_to_deposit);
    // assert(pid_to_bin_map.size() == np_to_deposit);
    //===================
    std::vector<int> tmp_idx_map=pid_to_index_map;
    //=====================

    // Stage 2.1：先执行尾巴插入
    // 先插tail，因为空槽在tail
    // 尾巴不够就借前面，前面不够就i跳出
    if(!rebuild){ 
        for (const auto& pair : m_tail_pending_moves) {
            int new_bin=pair.first;
            const std::vector<int>& moved_ips = pair.second;
            int ip_size = moved_ips.size();
            printf("3 update bin_max_ip[%d] from %d to %d\n"
                ,new_bin, bin_max_ip[new_bin],moved_ips[ip_size-1]);
            bin_max_ip[new_bin]=moved_ips[ip_size-1]; // 只需要在尾巴更新就对了，因为只有尾巴比较大
            
            int bin_end = bin_offsets[new_bin+1];
            int tail_bin_slot = slot_offsets[new_bin+1];
            int bin_start = bin_offsets[new_bin];
            int front_bin_slot = slot_offsets[new_bin];
            //=======================
            // printf("m_tail_pending_moves!\n");
            // printf("----moving %d ips to bin %d\n",ip_size,new_bin);
            // for(int i=0;i<ip_size;i++){
            //     printf("----moving %d to bin %d\n",moved_ips[i],new_bin);
            // }
            //====================
            if(bin_end-tail_bin_slot>=ip_size){
                std::memcpy(local_index.data()+tail_bin_slot,
                            moved_ips.data(),
                            ip_size * sizeof(int)); 
                // update pid_to_index_map_v & slot_offsets
                //===================
                // for(int i=0;i<ip_size;i++){
                //     printf("1 tail %d bin %d update %d ip from %d index to %d index \n ",
                //         new_bin,i,moved_ips[i],pid_to_index_map[moved_ips[i]],slot_offsets[new_bin+1]+i
                //     );
                // }
                // for(int i=slot_offsets[new_bin+1];i<slot_offsets[new_bin+1]+5;i++){
                //     printf("\n2 bin %d idx %d ip %d map %d  \n ",
                //         new_bin,i,local_index[i],pid_to_index_map[local_index[i]]
                //     );
                // }
                //=================
                for(int i=0;i<ip_size;i+=vlf){
                    svbool_t p=svwhilelt_b32(i,ip_size);
                    svint32_t ip_v = svld1_s32(p,&moved_ips[i]);
                    svint32_t pid_to_index_map_v = svindex_s32(slot_offsets[new_bin+1]+i,1);
                    svst1_scatter_s32index_s32(p,&pid_to_index_map[0],ip_v,pid_to_index_map_v);
                } 
                //==========================
                for(int i=0;i<ip_size;i++){
                    int ip=moved_ips[i];
                    printf("1 tail Bin %d i %d pid_to_index_map[%d] changed from %d to %d\n",
                        new_bin,i,ip,tmp_idx_map[ip],pid_to_index_map[ip]);
                }
                //==========================
                slot_offsets[new_bin+1]+=ip_size;
            }else if((bin_end-tail_bin_slot)+(bin_start-front_bin_slot)>=ip_size){
                int borrow_front=ip_size-(bin_end-tail_bin_slot);
                // bin整体向前移动front距离
                std::memmove(local_index.data()+bin_start-borrow_front,
                            local_index.data()+bin_start,
                            bin_length[new_bin] * sizeof(int));
                bin_offsets[new_bin]-=borrow_front;
                slot_offsets[new_bin+1]-=borrow_front;
                // 把数填进去
                std::memcpy(local_index.data()+slot_offsets[new_bin+1],
                            moved_ips.data(),
                            ip_size * sizeof(int));
                // update pid_to_index_map_v & slot_offsets
                //===================
                for(int i=0;i<ip_size+bin_length[new_bin];i++){
                    printf("2 tail+borrow %d bin %d update %d ip from %d index to %d index \n ",
                        new_bin,i,local_index[bin_offsets[new_bin]+i],
                        pid_to_index_map[local_index[bin_offsets[new_bin]+i]],
                        bin_offsets[new_bin]+i
                    );
                }
                //====================
                for(int i=0;i<ip_size+bin_length[new_bin];i+=vlf){
                    svbool_t p=svwhilelt_b32(i,ip_size+bin_length[new_bin]);
                    svint32_t ip_v = svld1_s32(p,&local_index[bin_offsets[new_bin]+i]);
                    svint32_t pid_to_index_map_v = svindex_s32(bin_offsets[new_bin]+i,1);
                    svst1_scatter_s32index_s32(p,&pid_to_index_map[0],ip_v,pid_to_index_map_v);
                }
                //==========================
                // for(int i=0;i<ip_size+bin_length[new_bin];i++){
                //     int ip=local_index[bin_offsets[new_bin]+i];
                //     printf("2 tail+borrow Bin %d pid_to_index_map[%d] changed from %d to %d\n",
                //         new_bin,ip,tmp_idx_map[ip],pid_to_index_map[ip]);
                // }
                //==========================
                slot_offsets[new_bin+1]+=ip_size;
            }else{
                rebuild=true;
                break;
            }
            bin_length[new_bin]+=ip_size;
        }
    }
    
    // Stage 2.2：再执行头插入
    // 再插front
    // 前面不够就借尾巴，尾巴不够就跳出
    if(!rebuild){ 
        for (const auto& pair : m_front_pending_moves) {
            int new_bin=pair.first;
            const std::vector<int>& moved_ips = pair.second;
            int bin_start = bin_offsets[new_bin];
            int front_bin_slot = slot_offsets[new_bin]; //左边的slot位置
            int bin_end = bin_offsets[new_bin+1];
            int tail_bin_slot = slot_offsets[new_bin+1]; //右边的slot位置
            int ip_size = moved_ips.size();
            //=======================
            // printf("m_front_pending_moves!\n");
            // printf("----moving %d ips to bin %d\n",ip_size,new_bin);
            // for(int i=0;i<ip_size;i++){
            //     printf("----moving %d to bin %d\n",moved_ips[i],new_bin);
            // }
            //====================
            //先找左边，再借右边
            //===================
            // for(int i=0;i<ip_size;i++){
            //     printf("3 front %d bin %d update %d ip from %d index to %d index \n ",
            //         new_bin,i,moved_ips[i],pid_to_index_map[moved_ips[i]],
            //         bin_offsets[new_bin]+i
            //     );
            // }
            //=================
            if(bin_start-front_bin_slot>=ip_size){
                std::memcpy(local_index.data()+bin_start-ip_size,
                            moved_ips.data(),
                            ip_size * sizeof(int));
                // update pid_to_index_map_v & slot_offsets
                bin_offsets[new_bin]-=ip_size;
                for(int i=0;i<ip_size;i+=vlf){
                    svbool_t p=svwhilelt_b32(i,ip_size);
                    svint32_t ip_v = svld1_s32(p,&moved_ips[i]);
                    svint32_t pid_to_index_map_v = svindex_s32(bin_offsets[new_bin]+i,1);
                    svst1_scatter_s32index_s32(p,&pid_to_index_map[0],ip_v,pid_to_index_map_v);
                } 
                //==========================
                for(int i=0;i<ip_size;i++){
                    int ip=moved_ips[i];
                    printf("3 front Bin %d pid_to_index_map[%d] changed from %d to %d\n",
                        new_bin,ip,tmp_idx_map[ip],pid_to_index_map[ip]);
                }
                //==========================
            }else if((bin_start-front_bin_slot)+(bin_end-tail_bin_slot)>=ip_size){
                int borrow_tail=ip_size-(bin_start-front_bin_slot);
                // bin整体向后移动距离
                std::memmove(local_index.data()+bin_start+borrow_tail,
                            local_index.data()+bin_start,
                            bin_length[new_bin] * sizeof(int));
                bin_offsets[new_bin]+=borrow_tail;
                slot_offsets[new_bin+1]+=borrow_tail;
                // 把数填进去
                std::memcpy(local_index.data()+bin_offsets[new_bin]-ip_size,
                            moved_ips.data(),
                            ip_size * sizeof(int));
                bin_offsets[new_bin]-=ip_size;
                // update pid_to_index_map_v & slot_offsets
                //===================
                // for(int i=0;i<ip_size+bin_length[new_bin];i++){
                //     printf("4 front+borrow %d bin %d update %d ip from %d index to %d index \n ",
                //         new_bin,i,local_index[bin_offsets[new_bin]+i],
                //         pid_to_index_map[local_index[bin_offsets[new_bin]+i]],
                //         bin_offsets[new_bin]+i
                //     );
                // }
                //====================
                for(int i=0;i<ip_size+bin_length[new_bin];i+=vlf){
                    svbool_t p=svwhilelt_b32(i,ip_size+bin_length[new_bin]);
                    svint32_t ip_v = svld1_s32(p,&local_index[bin_offsets[new_bin]+i]);
                    svint32_t pid_to_index_map_v = svindex_s32(bin_offsets[new_bin]+i,1);
                    svst1_scatter_s32index_s32(p,&pid_to_index_map[0],ip_v,pid_to_index_map_v);
                }
                //==========================
                for(int i=0;i<ip_size+bin_length[new_bin];i++){
                    int ip=local_index[bin_offsets[new_bin]+i];
                    printf("4 front+borrow Bin %d pid_to_index_map[%d] changed from %d to %d\n",
                        new_bin,ip,tmp_idx_map[ip],pid_to_index_map[ip]);
                }
                //==========================
            }
            else{
                rebuild=true;
                break;
            }
            bin_length[new_bin]+=ip_size;
        }
    }
    
    if(!rebuild)
    { 
        //===============================
        std::vector<int> next_write_slot = ptile.m_bin_offsets; 
        std::vector<int> tm_pid_to_index_map(np_to_deposit);
        for(int ip=0;ip<np_to_deposit;ip++){
            int bin_id =ptile.m_pid_to_bin_map[ip];
            int insert_idx = next_write_slot[bin_id];
            tm_pid_to_index_map[ip]=insert_idx;
            next_write_slot[bin_id]++;
        }
        for(int ip=0;ip<np_to_deposit;ip++){
            if(tm_pid_to_index_map[ip]!=pid_to_index_map[ip]){
                printf("ERRIDX pid_to_index_map[%d]=%d TRUE %d\n",
                    ip,pid_to_index_map[ip],tm_pid_to_index_map[ip]
                );
            }
        }
        //================================
        // 一次性更新 bin_max_ip
        for (auto const& [bin, count] : bin_decrement_counts) {
            printf("4 bin_max_ip[%d] changed from %d to 0 \n",bin,bin_max_ip[bin]);
            bin_max_ip[bin]=0;
            if(bin_length[bin]>0){
                bin_max_ip[bin]=local_index[slot_offsets[bin+1]-1];
                printf("\t------ or %d\n",bin_max_ip[bin]);
            }
        }
    }
    m_tail_pending_moves.clear();
    m_front_pending_moves.clear();

    // Stage 3：全部都不行，还是执行重构
    if(rebuild)
    { 
        ptile.m_was_rebuilt_this_step = true;

        // TODO:move outside
        // std::vector<int> ptile.m_bin_lengths(numcell);
        // std::vector<int> gap(numcell,0);

        float gap_ratio=WarpX::GetInstance().m_gap_ratio;
        // const std::vector<int>& pid_to_bin_map = ptile.m_pid_to_bin_map;
        // int np_to_deposit = ptile.m_num_particles;
        ptile.m_bin_lengths.clear();
        ptile.m_bin_lengths.resize(numcell);

        // Stage 1：更新m_bin_lengths
        for(int ip=0;ip<np_to_deposit;ip++){
            ptile.m_bin_lengths[ptile.m_pid_to_bin_map[ip]]++;
        }  
        // 预估容量大小
        ptile.m_capacity = static_cast<int>(
                std::ceil(static_cast<double>(
                np_to_deposit) * (1.0 + gap_ratio)) + 2*numcell);
        // 初始化偏移量
        int current_offset = 0;
        ptile.m_bin_offsets.clear();
        ptile.m_bin_offsets.resize(numcell+1);
        ptile.m_slot_offsets.clear();
        ptile.m_slot_offsets.resize(numcell+1);
        ptile.m_bin_offsets[0] = 0;
        ptile.m_slot_offsets[0] = 0;
        // ptile.m_free_slots.assign(numcell,std::vector<int>());
        
        // Stage 2: sve计算偏移量m_bin_offsets，同时更新m_slot_offsets位置
        #pragma unroll
        for (int binID = 0; binID < numcell; binID+=vlf) {
            svbool_t p_bin = svwhilelt_b32(binID,numcell);
            svint32_t np_in_bin=svld1_s32(p_bin,&ptile.m_bin_lengths[binID]);
            svint32_t gap_v=svadd_n_s32_x(p_bin,
                            svcvt_s32_f32_x(p_bin,svmul_n_f32_x(p_bin,
                            svcvt_f32_s32_x(p_bin,np_in_bin),gap_ratio)),
                            1);
            // svst1_s32(p_bin,&gap[binID],gap_v);
            svint32_t block_size_v=svadd_s32_x(p_bin,gap_v,np_in_bin);
            // 1. 向量化局部累加 (Intra-Vector Exclusive Scan)
            //    这是将串行依赖转换为并行计算的核心
            svint32_t local_scan_v = block_size_v;
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-1));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-2));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-4));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-8));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-16));
            
            local_scan_v  = svadd_n_s32_x(p_bin, local_scan_v, current_offset);

            // 2. 存储最终计算出的偏移量结果
            //    注意，我们从 m_bin_offsets 的第 binID + 1 个位置开始存
            svst1_s32(p_bin, &ptile.m_bin_offsets[binID + 1], local_scan_v);
            // 2.2 存储最终m_slot_offsets偏移量结果
            svst1_s32(p_bin, &ptile.m_slot_offsets[binID + 1], local_scan_v-gap_v);
            
            // 3. 更新下一个块的全局偏移
            //    使用svaddv高效地计算当前块所有block_size的总和
            current_offset += svaddv_s32(p_bin, block_size_v);
        }

        // Stage 3.1: 更新m_capacity，初始化m_local_index
        ptile.m_capacity=ptile.m_bin_offsets[numcell];
        ptile.m_local_index.clear();
        ptile.m_local_index.reserve(ptile.m_capacity+1);
        ptile.m_local_index.resize(ptile.m_capacity);
        std::fill_n(ptile.m_local_index.data(), ptile.m_capacity, INVALID_PARTICLE_ID);
        // ptile.m_local_index.assign(ptile.m_capacity, INVALID_PARTICLE_ID);
        // 初始化为每个 bin 的起始位置
        std::vector<int> next_write_slot = ptile.m_bin_offsets; 

        // Stage 3.2: 往m_local_index和m_pid_to_index_map填入数据
        for(int ip=0;ip<np_to_deposit;ip++){
            int bin_id =ptile.m_pid_to_bin_map[ip];
            int insert_idx = next_write_slot[bin_id];
            ptile.m_local_index[insert_idx] = ip;
            ptile.m_pid_to_index_map[ip]=insert_idx;
            next_write_slot[bin_id]++;
        }
        
        // Stage 4:更新m_bin_max_ip为每个bin中最后一个数据的值
        ptile.m_bin_max_ip.clear();
        ptile.m_bin_max_ip.resize(numcell);
        #pragma unroll
        for (int binID = 0; binID < numcell; binID+=vlf) {
            svbool_t p_bin = svwhilelt_b32(binID,numcell);
            svint32_t bin_length_v = svld1_s32(p_bin,&ptile.m_bin_lengths[binID]);
            svbool_t p0 = svcmpne_n_s32(p_bin,bin_length_v,0);
            if(svptest_any(p_bin,p0)){
                svint32_t bin_max_ip_index=svld1_s32(p0,&ptile.m_slot_offsets[binID+1]);
                bin_max_ip_index=svsub_n_s32_x(p0,bin_max_ip_index,1);
                svint32_t bin_max_ip_v=svld1_gather_s32index_s32(p0,
                    &ptile.m_local_index[0],bin_max_ip_index);
                svst1_s32(p0,&ptile.m_bin_max_ip[binID],bin_max_ip_v);
            }
        }
    }
}

// 块内有序性保证不了，反而增加排序耗时，所以不要bin_max_ip了
inline void increment_sort_particles3 (
    int np_to_deposit, ParticleTileType& ptile,
    HBM_Inner_Vector_Int& newbin, int numcell
)
{
    auto& local_index = ptile.m_local_index;
    auto& slot_offsets = ptile.m_slot_offsets; //和binoffset对齐，长度ncell+1，[0]指向0号位置
    auto& bin_length = ptile.m_bin_lengths;
    
    auto& num_particles = ptile.m_num_particles;
    auto& bin_offsets = ptile.m_bin_offsets;
    auto& pid_to_bin_map = ptile.m_pid_to_bin_map;
    auto& pid_to_index_map = ptile.m_pid_to_index_map; 
    // auto& bin_max_ip = ptile.m_bin_max_ip;
    auto& was_rebuilt_this_step =  ptile.m_was_rebuilt_this_step;
    // printf("rebuild: %d\n",was_rebuilt_this_step);
    was_rebuilt_this_step = false ;
    
    // TODO: move ouside
    std::unordered_map<int, std::vector<int>> m_pending_moves;
    m_pending_moves.clear();

    bool rebuild=false;
    // rebuild=true;
    int vlf = svcntw();
    // printf("new np %d old np %d\n",np_to_deposit,num_particles);

    // Stage 1：准备增量更新的数据
    // 更新粒子的预处理，组织成从小到大的块
    if(np_to_deposit<ptile.m_capacity && !rebuild){
        // int loop_np=num_particles;
        
        // 1. 减少的粒子删除
        // move outside
        std::unordered_map<int, int> bin_decrement_counts;
        for(int ip=np_to_deposit;ip<num_particles;ip++){
            int old_bin=pid_to_bin_map[ip];
            int idx=pid_to_index_map[ip]; 
            //打洞、长度缩减、压栈
            ptile.m_local_index[idx] = INVALID_PARTICLE_ID;
            // bin_length[old_bin]--; //在下面统一操作了
            bin_decrement_counts[old_bin]++; //必须保证记录，才能被compact
            // printf("1 ip %d delete bin %d \n",ip,old_bin);
        }

        // 2. 对变化的粒子先做了删除操作
        //必须是小的一个才需要loop，因为如果新增粒子和减少的粒子都不在这里更新
        int loop_np=std::min(num_particles,np_to_deposit); 
        int block_size=WarpX::GetInstance().m_fast_cmp_block_size;; // 256
        float max_np_rate=WarpX::GetInstance().m_max_moved_np_rate; // 0.15
        int MOVED_PARTICLES_MAX=loop_np/4+block_size;

        int moved_ips[MOVED_PARTICLES_MAX];
        int moved_old_bins[MOVED_PARTICLES_MAX];
        int moved_new_bins[MOVED_PARTICLES_MAX];
        int moved_count = 0;

        svint32_t vec_invalid_id = svdup_n_s32(INVALID_PARTICLE_ID);

        for (int i = 0; i < loop_np; i += block_size) {
            // svetime1[0]=rdtscv();
            int current_block_size = std::min(block_size, loop_np - i);
            // 计算需要比较的字节数
            size_t bytes_to_compare = current_block_size * sizeof(int);

            // --- 快速路径：使用 memcmp 比较整个块 ---
            // memcmp 比较的是内存内容。如果返回0，表示两块内存完全相同。
            if (memcmp(&newbin[i], &pid_to_bin_map[i], bytes_to_compare) == 0) {
                // 块内所有粒子都没有移动，直接跳过，这是性能提升的关键
                continue; 
            } 
            else {
                // svetime1[0]=rdtscv();

                for (int j = 0; j < current_block_size; j += vlf) {
                    int ip=i+j;
                    // 创建覆盖当前块的谓词 (同时为64位和32位元素创建)
                    svbool_t pg32 = svwhilelt_b32(j, current_block_size);
                    svint32_t vec_newbin = svld1_s32(pg32, &newbin[ip]);
                    svint32_t vec_oldbin  = svld1_s32(pg32, &pid_to_bin_map[ip]);
                    svbool_t moved_mask = svcmpne(pg32, vec_newbin, vec_oldbin);
                    if (!svptest_any(pg32, moved_mask)) {
                        continue;
                    }
                    // --- 开始处理移动的粒子 ---
                    // 0） 创建当前块所有粒子的 ip 索引向量
                    svint32_t all_ips_in_block = svindex_s32(ip, 1);

                    // 1) 获取移动粒子的 idx
                    svint32_t moved_idxs_vec = svld1_s32(moved_mask, &pid_to_index_map[ip]);

                    // 4) SCATTER 操作：将 local_index 中对应位置设为无效
                    svst1_scatter_s32index_s32(moved_mask, &local_index[0], moved_idxs_vec, vec_invalid_id);

                    
                    // 5) PACK 操作：将所有需要的信息打包
                    int32_t count_in_this_block = svcntp_b32(pg32, moved_mask);
                    svbool_t pg_compact = svwhilelt_b32(0, count_in_this_block);

                    // a. 紧凑化 ip, new_bin, old_bin
                    svint32_t moved_ips_vec      = svcompact(moved_mask, all_ips_in_block);
                    svint32_t moved_new_bins_vec = svcompact(moved_mask, vec_newbin);
                    svint32_t moved_old_bins_vec = svcompact(moved_mask, vec_oldbin);

                    // b. 将紧凑后的向量存入输出数组
                    svst1_s32(pg_compact, &moved_ips[moved_count], moved_ips_vec);
                    svst1_s32(pg_compact, &moved_new_bins[moved_count], moved_new_bins_vec);
                    svst1_s32(pg_compact, &moved_old_bins[moved_count], moved_old_bins_vec);

                    // 6) 更新总计数
                    moved_count += count_in_this_block;
                }
                
                if (moved_count > loop_np*max_np_rate) {
                    rebuild=true;
                    break;
                }
            }
        }
        


        // 为了高效更新 bin_length，先用一个临时map统计
        // std::unordered_map<int, int> bin_decrement_counts;
        if (!rebuild) {
            // svetime1[0]=rdtscv();
            // std::unordered_map<int, int> bin_decrement_counts;

            for (int k = 0; k < moved_count; ++k) {
                // 统计每个 old_bin 离开的粒子数
                int ip = moved_ips[k];
                int new_bin = moved_new_bins[k];
                int old_bin = moved_old_bins[k];

                // 执行 push_back 操作
                m_pending_moves[new_bin].push_back(ip);

                // 统计每个 old_bin 离开的粒子数
                bin_decrement_counts[old_bin]++;
                // printf("2 ip leaveing bin %d\n",old_bin);
            }
            // 一次性更新 bin_length
            for (auto const& [bin, count] : bin_decrement_counts) {
                bin_length[bin] -= count;
            }
           
            // 3.压实local index
            sorted_index_pma_compact(bin_decrement_counts,
                local_index,slot_offsets,bin_offsets,pid_to_index_map);

            // 4. 新增粒子添加。因为新增粒子肯定都是大ip所以最后插入
            for(int ip=num_particles;ip<np_to_deposit;ip++){
                int new_bin=newbin[ip];
                m_pending_moves[new_bin].push_back(ip);
                // printf("5 ip %d add bin %d tail\n",ip,new_bin);
            }
            // num_particles=np_to_deposit;
        }
    } else {
        rebuild=true;
    }
    
    // 上面减少了bin_length, slot_offset
    // m_local_index压实了,pid_to_index_map也相应变化了
    

    // Stage 2：执行增量更新
    // 下面继续更新m_pid_to_bin_map,pid_to_index_map, num_particles
    // 随着粒子的插入slot_offset,bin_offsets也需要增加（改变）了
    // 还要继续插入块更新m_local_index压实了
    pid_to_index_map.reserve(np_to_deposit+1);  
    // pid_to_index_map.clear();
    pid_to_index_map.resize(np_to_deposit);

    pid_to_bin_map.reserve(np_to_deposit+1);
    pid_to_bin_map.resize(np_to_deposit);
    std::memcpy(pid_to_bin_map.data(),
                newbin.data(),
                np_to_deposit * sizeof(int));
    num_particles=np_to_deposit;
    // was_rebuilt_this_step = false ;

    // Stage 2：执行尾巴插入
    // 先插tail，因为空槽在tail
    // 尾巴不够就借前面，前面不够就i跳出
    if(!rebuild){ 
        for (const auto& pair : m_pending_moves) {
            int new_bin=pair.first;
            const std::vector<int>& moved_ips = pair.second;
            int ip_size = moved_ips.size();
            
            int bin_end = bin_offsets[new_bin+1];
            int tail_bin_slot = slot_offsets[new_bin+1];
            int bin_start = bin_offsets[new_bin];
            int front_bin_slot = slot_offsets[new_bin];
            //=======================
            // printf("m_tail_pending_moves!\n");
            // printf("----moving %d ips to bin %d\n",ip_size,new_bin);
            // for(int i=0;i<ip_size;i++){
            //     printf("----moving %d to bin %d\n",moved_ips[i],new_bin);
            // }
            //====================
            if(bin_end-tail_bin_slot>=ip_size){
                std::memcpy(local_index.data()+tail_bin_slot,
                            moved_ips.data(),
                            ip_size * sizeof(int)); 
                
                for(int i=0;i<ip_size;i+=vlf){
                    svbool_t p=svwhilelt_b32(i,ip_size);
                    svint32_t ip_v = svld1_s32(p,&moved_ips[i]);
                    svint32_t pid_to_index_map_v = svindex_s32(slot_offsets[new_bin+1]+i,1);
                    svst1_scatter_s32index_s32(p,&pid_to_index_map[0],ip_v,pid_to_index_map_v);
                } 
                // printf("bin %d slot changed from %d to %d\n",
                //     new_bin,slot_offsets[new_bin+1],slot_offsets[new_bin+1]+ip_size
                // );
                slot_offsets[new_bin+1]+=ip_size;
            }else if((bin_end-tail_bin_slot)+(bin_start-front_bin_slot)>=ip_size){
                int borrow_front=ip_size-(bin_end-tail_bin_slot);
                // bin整体向前移动front距离
                //=======================
                // for(int ii=bin_offsets[new_bin];ii<bin_offsets[new_bin+1];ii++){
                //     printf("TEST bin %d m_local_index[%d]=%d\n",
                //         new_bin,ii,ptile.m_local_index[ii]);
                // }
                //======================
                std::memmove(local_index.data()+bin_start-borrow_front,
                            local_index.data()+bin_start,
                            bin_length[new_bin] * sizeof(int));
                //================
                // printf("borrow bin %d slot changed from %d to %d\n",
                //     new_bin,slot_offsets[new_bin+1],slot_offsets[new_bin+1]-borrow_front
                // );
                // printf("borrow bin %d binoff changed %d to %d\n",
                //     new_bin,bin_offsets[new_bin],bin_offsets[new_bin]-borrow_front
                // );
                //===============
                bin_offsets[new_bin]-=borrow_front;
                slot_offsets[new_bin+1]-=borrow_front;
                // 把数填进去
                std::memcpy(local_index.data()+slot_offsets[new_bin+1],
                            moved_ips.data(),
                            ip_size * sizeof(int));
                // update pid_to_index_map_v & slot_offsets
                for(int i=0;i<ip_size+bin_length[new_bin];i+=vlf){
                    svbool_t p=svwhilelt_b32(i,ip_size+bin_length[new_bin]);
                    svint32_t ip_v = svld1_s32(p,&local_index[bin_offsets[new_bin]+i]);
                    svint32_t pid_to_index_map_v = svindex_s32(bin_offsets[new_bin]+i,1);
                    svst1_scatter_s32index_s32(p,&pid_to_index_map[0],ip_v,pid_to_index_map_v);
                }
                //===================
                // printf("after borrow bin %d slot changed from %d to %d\n",
                //     new_bin,slot_offsets[new_bin+1],slot_offsets[new_bin+1]+ip_size
                // );
                // printf("after borrow bin %d binoff changed %d  %d\n",
                //     new_bin,bin_offsets[new_bin],bin_offsets[new_bin+1]
                // );
                //===================
                slot_offsets[new_bin+1]+=ip_size;
                //===================
                // for(int ii=bin_offsets[new_bin];ii<bin_offsets[new_bin+1];ii++){
                //     printf("TEST2 bin %d m_local_index[%d]=%d\n",
                //         new_bin,ii,ptile.m_local_index[ii]);
                // }
                //===================
            }else{
                rebuild=true;
                break;
            }
            bin_length[new_bin]+=ip_size;
        }
    }
    m_pending_moves.clear();

    // Stage 3：全部都不行，还是执行重构
    if(rebuild)
    { 
        ptile.m_was_rebuilt_this_step = true;

        // TODO:move outside
        // std::vector<int> ptile.m_bin_lengths(numcell);
        // std::vector<int> gap(numcell,0);

        float gap_ratio=WarpX::GetInstance().m_gap_ratio;
        // const std::vector<int>& pid_to_bin_map = ptile.m_pid_to_bin_map;
        // int np_to_deposit = ptile.m_num_particles;
        ptile.m_bin_lengths.clear();
        ptile.m_bin_lengths.resize(numcell);

        // Stage 1：更新m_bin_lengths
        for(int ip=0;ip<np_to_deposit;ip++){
            ptile.m_bin_lengths[ptile.m_pid_to_bin_map[ip]]++;
        }  
        // 预估容量大小
        ptile.m_capacity = static_cast<int>(
                std::ceil(static_cast<double>(
                np_to_deposit) * (1.0 + gap_ratio)) + 2*numcell);
        // 初始化偏移量
        int current_offset = 0;
        ptile.m_bin_offsets.clear();
        ptile.m_bin_offsets.resize(numcell+1);
        ptile.m_slot_offsets.clear();
        ptile.m_slot_offsets.resize(numcell+1);
        ptile.m_bin_offsets[0] = 0;
        ptile.m_slot_offsets[0] = 0;
        // ptile.m_free_slots.assign(numcell,std::vector<int>());
        
        // Stage 2: sve计算偏移量m_bin_offsets，同时更新m_slot_offsets位置
        #pragma unroll
        for (int binID = 0; binID < numcell; binID+=vlf) {
            svbool_t p_bin = svwhilelt_b32(binID,numcell);
            svint32_t np_in_bin=svld1_s32(p_bin,&ptile.m_bin_lengths[binID]);
            svint32_t gap_v=svadd_n_s32_x(p_bin,
                            svcvt_s32_f32_x(p_bin,svmul_n_f32_x(p_bin,
                            svcvt_f32_s32_x(p_bin,np_in_bin),gap_ratio)),
                            1);
            // svst1_s32(p_bin,&gap[binID],gap_v);
            svint32_t block_size_v=svadd_s32_x(p_bin,gap_v,np_in_bin);
            // 1. 向量化局部累加 (Intra-Vector Exclusive Scan)
            //    这是将串行依赖转换为并行计算的核心
            svint32_t local_scan_v = block_size_v;
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-1));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-2));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-4));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-8));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-16));
            
            local_scan_v  = svadd_n_s32_x(p_bin, local_scan_v, current_offset);

            // 2. 存储最终计算出的偏移量结果
            //    注意，我们从 m_bin_offsets 的第 binID + 1 个位置开始存
            svst1_s32(p_bin, &ptile.m_bin_offsets[binID + 1], local_scan_v);
            // 2.2 存储最终m_slot_offsets偏移量结果
            svst1_s32(p_bin, &ptile.m_slot_offsets[binID + 1], local_scan_v-gap_v);
            
            // 3. 更新下一个块的全局偏移
            //    使用svaddv高效地计算当前块所有block_size的总和
            current_offset += svaddv_s32(p_bin, block_size_v);
        }

        // Stage 3.1: 更新m_capacity，初始化m_local_index
        ptile.m_capacity=ptile.m_bin_offsets[numcell];
        ptile.m_local_index.clear();
        ptile.m_local_index.reserve(ptile.m_capacity+1);
        ptile.m_local_index.resize(ptile.m_capacity);
        std::fill_n(ptile.m_local_index.data(), ptile.m_capacity, INVALID_PARTICLE_ID);
        // ptile.m_local_index.assign(ptile.m_capacity, INVALID_PARTICLE_ID);
        // 初始化为每个 bin 的起始位置
        std::vector<int> next_write_slot = ptile.m_bin_offsets; 

        // Stage 3.2: 往m_local_index和m_pid_to_index_map填入数据
        for(int ip=0;ip<np_to_deposit;ip++){
            int bin_id =ptile.m_pid_to_bin_map[ip];
            int insert_idx = next_write_slot[bin_id];
            ptile.m_local_index[insert_idx] = ip;
            ptile.m_pid_to_index_map[ip]=insert_idx;
            next_write_slot[bin_id]++;
        }
    }
}

// 块内有序性保证不了，反而增加排序耗时，所以不要bin_max_ip了
inline void increment_sort_particles3_HBM (
    int np_to_deposit, ParticleTileType& ptile,
    HBM_Inner_Vector_Int& newbin, int numcell
)
{
    auto& local_index = ptile.m_local_index_hbm;
    auto& slot_offsets = ptile.m_slot_offsets; //和binoffset对齐，长度ncell+1，[0]指向0号位置
    auto& bin_length = ptile.m_bin_lengths;
    
    auto& num_particles = ptile.m_num_particles;
    auto& bin_offsets = ptile.m_bin_offsets;
    auto& pid_to_bin_map = ptile.m_pid_to_bin_map_hbm;
    auto& pid_to_index_map = ptile.m_pid_to_index_map; 
    // auto& bin_max_ip = ptile.m_bin_max_ip;
    auto& was_rebuilt_this_step =  ptile.m_was_rebuilt_this_step;
    // printf("rebuild: %d\n",was_rebuilt_this_step);
    was_rebuilt_this_step = false ;
    
    // TODO: move ouside
    std::unordered_map<int, HBM_Inner_Vector_Int> m_pending_moves;
    m_pending_moves.clear();

    bool rebuild=false;
    // rebuild=true;
    int vlf = svcntw();
    // printf("new np %d old np %d\n",np_to_deposit,num_particles);

    // Stage 1：准备增量更新的数据
    // 更新粒子的预处理，组织成从小到大的块
    if(np_to_deposit<ptile.m_capacity && !rebuild){
        // int loop_np=num_particles;
        
        // 1. 减少的粒子删除
        // move outside
        std::unordered_map<int, int> bin_decrement_counts;
        for(int ip=np_to_deposit;ip<num_particles;ip++){
            int old_bin=pid_to_bin_map[ip];
            int idx=pid_to_index_map[ip]; 
            //打洞、长度缩减、压栈
            ptile.m_local_index_hbm[idx] = INVALID_PARTICLE_ID;
            // bin_length[old_bin]--; //在下面统一操作了
            bin_decrement_counts[old_bin]++; //必须保证记录，才能被compact
            // printf("1 ip %d delete bin %d \n",ip,old_bin);
        }

        // 2. 对变化的粒子先做了删除操作
        //必须是小的一个才需要loop，因为如果新增粒子和减少的粒子都不在这里更新
        int loop_np=std::min(num_particles,np_to_deposit); 
        int block_size=WarpX::GetInstance().m_fast_cmp_block_size;; // 256
        float max_np_rate=WarpX::GetInstance().m_max_moved_np_rate; // 0.15
        int MOVED_PARTICLES_MAX=loop_np/4+block_size;

        int moved_ips[MOVED_PARTICLES_MAX];
        int moved_old_bins[MOVED_PARTICLES_MAX];
        int moved_new_bins[MOVED_PARTICLES_MAX];
        int moved_count = 0;

        svint32_t vec_invalid_id = svdup_n_s32(INVALID_PARTICLE_ID);

        for (int i = 0; i < loop_np; i += block_size) {
            // svetime1[0]=rdtscv();
            int current_block_size = std::min(block_size, loop_np - i);
            // 计算需要比较的字节数
            size_t bytes_to_compare = current_block_size * sizeof(int);

            // --- 快速路径：使用 memcmp 比较整个块 ---
            // memcmp 比较的是内存内容。如果返回0，表示两块内存完全相同。
            if (memcmp(&newbin[i], &pid_to_bin_map[i], bytes_to_compare) == 0) {
                // 块内所有粒子都没有移动，直接跳过，这是性能提升的关键
                continue; 
            } 
            else {
                // svetime1[0]=rdtscv();

                for (int j = 0; j < current_block_size; j += vlf) {
                    int ip=i+j;
                    // 创建覆盖当前块的谓词 (同时为64位和32位元素创建)
                    svbool_t pg32 = svwhilelt_b32(j, current_block_size);
                    svint32_t vec_newbin = svld1_s32(pg32, &newbin[ip]);
                    svint32_t vec_oldbin  = svld1_s32(pg32, &pid_to_bin_map[ip]);
                    svbool_t moved_mask = svcmpne(pg32, vec_newbin, vec_oldbin);
                    if (!svptest_any(pg32, moved_mask)) {
                        continue;
                    }
                    // --- 开始处理移动的粒子 ---
                    // 0） 创建当前块所有粒子的 ip 索引向量
                    svint32_t all_ips_in_block = svindex_s32(ip, 1);

                    // 1) 获取移动粒子的 idx
                    svint32_t moved_idxs_vec = svld1_s32(moved_mask, &pid_to_index_map[ip]);

                    // 4) SCATTER 操作：将 local_index 中对应位置设为无效
                    svst1_scatter_s32index_s32(moved_mask, &local_index[0], moved_idxs_vec, vec_invalid_id);

                    
                    // 5) PACK 操作：将所有需要的信息打包
                    int32_t count_in_this_block = svcntp_b32(pg32, moved_mask);
                    svbool_t pg_compact = svwhilelt_b32(0, count_in_this_block);

                    // a. 紧凑化 ip, new_bin, old_bin
                    svint32_t moved_ips_vec      = svcompact(moved_mask, all_ips_in_block);
                    svint32_t moved_new_bins_vec = svcompact(moved_mask, vec_newbin);
                    svint32_t moved_old_bins_vec = svcompact(moved_mask, vec_oldbin);

                    // b. 将紧凑后的向量存入输出数组
                    svst1_s32(pg_compact, &moved_ips[moved_count], moved_ips_vec);
                    svst1_s32(pg_compact, &moved_new_bins[moved_count], moved_new_bins_vec);
                    svst1_s32(pg_compact, &moved_old_bins[moved_count], moved_old_bins_vec);

                    // 6) 更新总计数
                    moved_count += count_in_this_block;
                }
                
                if (moved_count > loop_np*max_np_rate) {
                    rebuild=true;
                    break;
                }
            }
        }
        


        // 为了高效更新 bin_length，先用一个临时map统计
        // std::unordered_map<int, int> bin_decrement_counts;
        if (!rebuild) {
            // svetime1[0]=rdtscv();
            // std::unordered_map<int, int> bin_decrement_counts;

            for (int k = 0; k < moved_count; ++k) {
                // 统计每个 old_bin 离开的粒子数
                int ip = moved_ips[k];
                int new_bin = moved_new_bins[k];
                int old_bin = moved_old_bins[k];

                // 执行 push_back 操作
                m_pending_moves[new_bin].push_back(ip);

                // 统计每个 old_bin 离开的粒子数
                bin_decrement_counts[old_bin]++;
                // printf("2 ip leaveing bin %d\n",old_bin);
            }
            // 一次性更新 bin_length
            for (auto const& [bin, count] : bin_decrement_counts) {
                bin_length[bin] -= count;
            }
           
            // 3.压实local index
            sorted_index_pma_compact_hbm(bin_decrement_counts,
                local_index,slot_offsets,bin_offsets,pid_to_index_map);

            // 4. 新增粒子添加。因为新增粒子肯定都是大ip所以最后插入
            for(int ip=num_particles;ip<np_to_deposit;ip++){
                int new_bin=newbin[ip];
                m_pending_moves[new_bin].push_back(ip);
                // printf("5 ip %d add bin %d tail\n",ip,new_bin);
            }
            // num_particles=np_to_deposit;
        }
    } else {
        rebuild=true;
    }
    
    // 上面减少了bin_length, slot_offset
    // m_local_index压实了,pid_to_index_map也相应变化了
    

    // Stage 2：执行增量更新
    // 下面继续更新m_pid_to_bin_map,pid_to_index_map, num_particles
    // 随着粒子的插入slot_offset,bin_offsets也需要增加（改变）了
    // 还要继续插入块更新m_local_index压实了
    pid_to_index_map.reserve(np_to_deposit+1);  
    // pid_to_index_map.clear();
    pid_to_index_map.resize(np_to_deposit);

    pid_to_bin_map.reserve(np_to_deposit+1);
    pid_to_bin_map.resize(np_to_deposit);
    std::memcpy(pid_to_bin_map.data(),
                newbin.data(),
                np_to_deposit * sizeof(int));
    // pid_to_bin_map=std::move(newbin);
    num_particles=np_to_deposit;
    // was_rebuilt_this_step = false ;

    // Stage 2：执行尾巴插入
    // 先插tail，因为空槽在tail
    // 尾巴不够就借前面，前面不够就i跳出
    if(!rebuild){ 
        for (const auto& pair : m_pending_moves) {
            int new_bin=pair.first;
            const HBM_Inner_Vector_Int& moved_ips = pair.second;
            int ip_size = moved_ips.size();
            
            int bin_end = bin_offsets[new_bin+1];
            int tail_bin_slot = slot_offsets[new_bin+1];
            int bin_start = bin_offsets[new_bin];
            int front_bin_slot = slot_offsets[new_bin];
            //=======================
            // printf("m_tail_pending_moves!\n");
            // printf("----moving %d ips to bin %d\n",ip_size,new_bin);
            // for(int i=0;i<ip_size;i++){
            //     printf("----moving %d to bin %d\n",moved_ips[i],new_bin);
            // }
            //====================
            if(bin_end-tail_bin_slot>=ip_size){
                std::memcpy(local_index.data()+tail_bin_slot,
                            moved_ips.data(),
                            ip_size * sizeof(int)); 
                
                for(int i=0;i<ip_size;i+=vlf){
                    svbool_t p=svwhilelt_b32(i,ip_size);
                    svint32_t ip_v = svld1_s32(p,&moved_ips[i]);
                    svint32_t pid_to_index_map_v = svindex_s32(slot_offsets[new_bin+1]+i,1);
                    svst1_scatter_s32index_s32(p,&pid_to_index_map[0],ip_v,pid_to_index_map_v);
                } 
                // printf("bin %d slot changed from %d to %d\n",
                //     new_bin,slot_offsets[new_bin+1],slot_offsets[new_bin+1]+ip_size
                // );
                slot_offsets[new_bin+1]+=ip_size;
            }else if((bin_end-tail_bin_slot)+(bin_start-front_bin_slot)>=ip_size){
                int borrow_front=ip_size-(bin_end-tail_bin_slot);
                // bin整体向前移动front距离
                //=======================
                // for(int ii=bin_offsets[new_bin];ii<bin_offsets[new_bin+1];ii++){
                //     printf("TEST bin %d m_local_index[%d]=%d\n",
                //         new_bin,ii,ptile.m_local_index_hbm[ii]);
                // }
                //======================
                std::memmove(local_index.data()+bin_start-borrow_front,
                            local_index.data()+bin_start,
                            bin_length[new_bin] * sizeof(int));
                //================
                // printf("borrow bin %d slot changed from %d to %d\n",
                //     new_bin,slot_offsets[new_bin+1],slot_offsets[new_bin+1]-borrow_front
                // );
                // printf("borrow bin %d binoff changed %d to %d\n",
                //     new_bin,bin_offsets[new_bin],bin_offsets[new_bin]-borrow_front
                // );
                //===============
                bin_offsets[new_bin]-=borrow_front;
                slot_offsets[new_bin+1]-=borrow_front;
                // 把数填进去
                std::memcpy(local_index.data()+slot_offsets[new_bin+1],
                            moved_ips.data(),
                            ip_size * sizeof(int));
                // update pid_to_index_map_v & slot_offsets
                for(int i=0;i<ip_size+bin_length[new_bin];i+=vlf){
                    svbool_t p=svwhilelt_b32(i,ip_size+bin_length[new_bin]);
                    svint32_t ip_v = svld1_s32(p,&local_index[bin_offsets[new_bin]+i]);
                    svint32_t pid_to_index_map_v = svindex_s32(bin_offsets[new_bin]+i,1);
                    svst1_scatter_s32index_s32(p,&pid_to_index_map[0],ip_v,pid_to_index_map_v);
                }
                //===================
                // printf("after borrow bin %d slot changed from %d to %d\n",
                //     new_bin,slot_offsets[new_bin+1],slot_offsets[new_bin+1]+ip_size
                // );
                // printf("after borrow bin %d binoff changed %d  %d\n",
                //     new_bin,bin_offsets[new_bin],bin_offsets[new_bin+1]
                // );
                //===================
                slot_offsets[new_bin+1]+=ip_size;
                //===================
                // for(int ii=bin_offsets[new_bin];ii<bin_offsets[new_bin+1];ii++){
                //     printf("TEST2 bin %d m_local_index[%d]=%d\n",
                //         new_bin,ii,ptile.m_local_index_hbm[ii]);
                // }
                //===================
            }else{
                rebuild=true;
                break;
            }
            bin_length[new_bin]+=ip_size;
        }
    }
    m_pending_moves.clear();

    // printf("Rebuild: %d \n",rebuild);
    // Stage 3：全部都不行，还是执行重构
    if(rebuild)
    { 
        ptile.m_was_rebuilt_this_step = true;

        // TODO:move outside
        // std::vector<int> ptile.m_bin_lengths(numcell);
        // std::vector<int> gap(numcell,0);

        float gap_ratio=WarpX::GetInstance().m_gap_ratio;
        // const std::vector<int>& pid_to_bin_map = ptile.m_pid_to_bin_map_hbm;
        // int np_to_deposit = ptile.m_num_particles;
        ptile.m_bin_lengths.clear();
        ptile.m_bin_lengths.resize(numcell);

        // Stage 1：更新m_bin_lengths
        for(int ip=0;ip<np_to_deposit;ip++){
            ptile.m_bin_lengths[ptile.m_pid_to_bin_map_hbm[ip]]++;
        }  
        // 预估容量大小
        ptile.m_capacity = static_cast<int>(
                std::ceil(static_cast<double>(
                np_to_deposit) * (1.0 + gap_ratio)) + 2*numcell);
        // 初始化偏移量
        int current_offset = 0;
        ptile.m_bin_offsets.clear();
        ptile.m_bin_offsets.resize(numcell+1);
        ptile.m_slot_offsets.clear();
        ptile.m_slot_offsets.resize(numcell+1);
        ptile.m_bin_offsets[0] = 0;
        ptile.m_slot_offsets[0] = 0;
        // ptile.m_free_slots.assign(numcell,std::vector<int>());
        
        // Stage 2: sve计算偏移量m_bin_offsets，同时更新m_slot_offsets位置
        #pragma unroll
        for (int binID = 0; binID < numcell; binID+=vlf) {
            svbool_t p_bin = svwhilelt_b32(binID,numcell);
            svint32_t np_in_bin=svld1_s32(p_bin,&ptile.m_bin_lengths[binID]);
            svint32_t gap_v=svadd_n_s32_x(p_bin,
                            svcvt_s32_f32_x(p_bin,svmul_n_f32_x(p_bin,
                            svcvt_f32_s32_x(p_bin,np_in_bin),gap_ratio)),
                            1);
            // svst1_s32(p_bin,&gap[binID],gap_v);
            svint32_t block_size_v=svadd_s32_x(p_bin,gap_v,np_in_bin);
            // 1. 向量化局部累加 (Intra-Vector Exclusive Scan)
            //    这是将串行依赖转换为并行计算的核心
            svint32_t local_scan_v = block_size_v;
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-1));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-2));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-4));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-8));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-16));
            
            local_scan_v  = svadd_n_s32_x(p_bin, local_scan_v, current_offset);

            // 2. 存储最终计算出的偏移量结果
            //    注意，我们从 m_bin_offsets 的第 binID + 1 个位置开始存
            svst1_s32(p_bin, &ptile.m_bin_offsets[binID + 1], local_scan_v);
            // 2.2 存储最终m_slot_offsets偏移量结果
            svst1_s32(p_bin, &ptile.m_slot_offsets[binID + 1], local_scan_v-gap_v);
            
            // 3. 更新下一个块的全局偏移
            //    使用svaddv高效地计算当前块所有block_size的总和
            current_offset += svaddv_s32(p_bin, block_size_v);
        }

        // Stage 3.1: 更新m_capacity，初始化m_local_index
        ptile.m_capacity=ptile.m_bin_offsets[numcell];
        ptile.m_local_index_hbm.clear();
        // ptile.m_local_index_hbm.reserve(ptile.m_capacity+1);
        // ptile.m_local_index_hbm.resize(ptile.m_capacity);
        ptile.m_local_index_hbm.assign(ptile.m_capacity, INVALID_PARTICLE_ID);
        // ptile.m_local_index_hbm.shrink_to_fit();
        // std::fill_n(ptile.m_local_index_hbm.data(), ptile.m_capacity, INVALID_PARTICLE_ID);
        // ptile.m_local_index_hbm.assign(ptile.m_capacity, INVALID_PARTICLE_ID);
        // 初始化为每个 bin 的起始位置
        std::vector<int> next_write_slot = ptile.m_bin_offsets; 

        // Stage 3.2: 往m_local_index和m_pid_to_index_map填入数据
        for(int ip=0;ip<np_to_deposit;ip++){
            int bin_id =ptile.m_pid_to_bin_map_hbm[ip];
            int insert_idx = next_write_slot[bin_id];
            ptile.m_local_index_hbm[insert_idx] = ip;
            ptile.m_pid_to_index_map[ip]=insert_idx;
            next_write_slot[bin_id]++;
        }
    }
}

inline void increment_sort_particles3_HBM2 (
    int np_to_deposit, ParticleTileType& ptile,
    HBM_Inner_Vector_Int& newbin, int numcell, amrex::Dim3 len
)
{
    auto& local_index = ptile.m_local_index_hbm;
    auto& slot_offsets = ptile.m_slot_offsets; //和binoffset对齐，长度ncell+1，[0]指向0号位置
    auto& bin_length = ptile.m_bin_lengths;
    std::vector<int> before_bin_lengths;
    before_bin_lengths.assign(bin_length.begin(),bin_length.end());
    
    auto& num_particles = ptile.m_num_particles;
    auto& bin_offsets = ptile.m_bin_offsets;
    auto& pid_to_bin_map = ptile.m_pid_to_bin_map_hbm;
    auto& pid_to_index_map = ptile.m_pid_to_index_map; 
    // auto& bin_max_ip = ptile.m_bin_max_ip;
    auto& was_rebuilt_this_step =  ptile.m_was_rebuilt_this_step;
    // printf("rebuild: %d\n",was_rebuilt_this_step);
    was_rebuilt_this_step = false ;
    
    // TODO: move ouside
    std::unordered_map<int, HBM_Inner_Vector_Int> m_pending_moves;
    m_pending_moves.clear();

    bool rebuild=false;
    // rebuild=true;
    int vlf = svcntw();
    // printf("new np %d old np %d\n",np_to_deposit,num_particles);

    // Stage 1：准备增量更新的数据
    // 更新粒子的预处理，组织成从小到大的块
    if(np_to_deposit<ptile.m_capacity && !rebuild){
        // int loop_np=num_particles;
        
        // 1. 减少的粒子删除
        // move outside
        std::unordered_map<int, int> bin_decrement_counts;
        for(int ip=np_to_deposit;ip<num_particles;ip++){
            int old_bin=pid_to_bin_map[ip];
            int idx=pid_to_index_map[ip]; 
            //打洞、长度缩减、压栈
            ptile.m_local_index_hbm[idx] = INVALID_PARTICLE_ID;
            // bin_length[old_bin]--; //在下面统一操作了
            bin_decrement_counts[old_bin]++; //必须保证记录，才能被compact
            // printf("1 ip %d delete bin %d \n",ip,old_bin);
        }

        // 2. 对变化的粒子先做了删除操作
        //必须是小的一个才需要loop，因为如果新增粒子和减少的粒子都不在这里更新
        int loop_np=std::min(num_particles,np_to_deposit); 
        int block_size=WarpX::GetInstance().m_fast_cmp_block_size;; // 256
        float max_np_rate=WarpX::GetInstance().m_max_moved_np_rate; // 0.15
        int MOVED_PARTICLES_MAX=loop_np/4+block_size;

        int moved_ips[MOVED_PARTICLES_MAX];
        int moved_old_bins[MOVED_PARTICLES_MAX];
        int moved_new_bins[MOVED_PARTICLES_MAX];
        int moved_count = 0;

        svint32_t vec_invalid_id = svdup_n_s32(INVALID_PARTICLE_ID);

        for (int i = 0; i < loop_np; i += block_size) {
            // svetime1[0]=rdtscv();
            int current_block_size = std::min(block_size, loop_np - i);
            // 计算需要比较的字节数
            size_t bytes_to_compare = current_block_size * sizeof(int);

            // --- 快速路径：使用 memcmp 比较整个块 ---
            // memcmp 比较的是内存内容。如果返回0，表示两块内存完全相同。
            if (memcmp(&newbin[i], &pid_to_bin_map[i], bytes_to_compare) == 0) {
                // 块内所有粒子都没有移动，直接跳过，这是性能提升的关键
                continue; 
            } 
            else {
                // svetime1[0]=rdtscv();

                for (int j = 0; j < current_block_size; j += vlf) {
                    int ip=i+j;
                    // 创建覆盖当前块的谓词 (同时为64位和32位元素创建)
                    svbool_t pg32 = svwhilelt_b32(j, current_block_size);
                    svint32_t vec_newbin = svld1_s32(pg32, &newbin[ip]);
                    svint32_t vec_oldbin  = svld1_s32(pg32, &pid_to_bin_map[ip]);
                    svbool_t moved_mask = svcmpne(pg32, vec_newbin, vec_oldbin);
                    if (!svptest_any(pg32, moved_mask)) {
                        continue;
                    }
                    // --- 开始处理移动的粒子 ---
                    // 0） 创建当前块所有粒子的 ip 索引向量
                    svint32_t all_ips_in_block = svindex_s32(ip, 1);

                    // 1) 获取移动粒子的 idx
                    svint32_t moved_idxs_vec = svld1_s32(moved_mask, &pid_to_index_map[ip]);

                    // 4) SCATTER 操作：将 local_index 中对应位置设为无效
                    svst1_scatter_s32index_s32(moved_mask, &local_index[0], moved_idxs_vec, vec_invalid_id);

                    
                    // 5) PACK 操作：将所有需要的信息打包
                    int32_t count_in_this_block = svcntp_b32(pg32, moved_mask);
                    svbool_t pg_compact = svwhilelt_b32(0, count_in_this_block);

                    // a. 紧凑化 ip, new_bin, old_bin
                    svint32_t moved_ips_vec      = svcompact(moved_mask, all_ips_in_block);
                    svint32_t moved_new_bins_vec = svcompact(moved_mask, vec_newbin);
                    svint32_t moved_old_bins_vec = svcompact(moved_mask, vec_oldbin);

                    // b. 将紧凑后的向量存入输出数组
                    svst1_s32(pg_compact, &moved_ips[moved_count], moved_ips_vec);
                    svst1_s32(pg_compact, &moved_new_bins[moved_count], moved_new_bins_vec);
                    svst1_s32(pg_compact, &moved_old_bins[moved_count], moved_old_bins_vec);

                    // 6) 更新总计数
                    moved_count += count_in_this_block;
                }
                
                if (moved_count > loop_np*max_np_rate) {
                    rebuild=true;
                    break;
                }
            }
        }
        


        // 为了高效更新 bin_length，先用一个临时map统计
        // std::unordered_map<int, int> bin_decrement_counts;
        if (!rebuild) {
            // svetime1[0]=rdtscv();
            // std::unordered_map<int, int> bin_decrement_counts;

            for (int k = 0; k < moved_count; ++k) {
                // 统计每个 old_bin 离开的粒子数
                int ip = moved_ips[k];
                int new_bin = moved_new_bins[k];
                int old_bin = moved_old_bins[k];

                // 执行 push_back 操作
                m_pending_moves[new_bin].push_back(ip);

                // 统计每个 old_bin 离开的粒子数
                bin_decrement_counts[old_bin]++;
                // printf("2 ip leaveing bin %d\n",old_bin);
            }
            // 一次性更新 bin_length
            for (auto const& [bin, count] : bin_decrement_counts) {
                bin_length[bin] -= count;
            }
           
            // 3.压实local index
            sorted_index_pma_compact_hbm(bin_decrement_counts,
                local_index,slot_offsets,bin_offsets,pid_to_index_map);

            // 4. 新增粒子添加。因为新增粒子肯定都是大ip所以最后插入
            for(int ip=num_particles;ip<np_to_deposit;ip++){
                int new_bin=newbin[ip];
                m_pending_moves[new_bin].push_back(ip);
                // printf("5 ip %d add bin %d tail\n",ip,new_bin);
            }
            // num_particles=np_to_deposit;
        }
    } else {
        rebuild=true;
    }
    
    // 上面减少了bin_length, slot_offset
    // m_local_index压实了,pid_to_index_map也相应变化了
    

    // Stage 2：执行增量更新
    // 下面继续更新m_pid_to_bin_map,pid_to_index_map, num_particles
    // 随着粒子的插入slot_offset,bin_offsets也需要增加（改变）了
    // 还要继续插入块更新m_local_index压实了
    pid_to_index_map.reserve(np_to_deposit+1);  
    // pid_to_index_map.clear();
    pid_to_index_map.resize(np_to_deposit);

    pid_to_bin_map.reserve(np_to_deposit+1);
    pid_to_bin_map.resize(np_to_deposit);
    std::memcpy(pid_to_bin_map.data(),
                newbin.data(),
                np_to_deposit * sizeof(int));
    // pid_to_bin_map=std::move(newbin);
    num_particles=np_to_deposit;
    // was_rebuilt_this_step = false ;

    // Stage 2：执行尾巴插入
    // 先插tail，因为空槽在tail
    // 尾巴不够就借前面，前面不够就i跳出
    if(!rebuild){ 
        for (const auto& pair : m_pending_moves) {
            int new_bin=pair.first;
            const HBM_Inner_Vector_Int& moved_ips = pair.second;
            int ip_size = moved_ips.size();
            
            int bin_end = bin_offsets[new_bin+1];
            int tail_bin_slot = slot_offsets[new_bin+1];
            int bin_start = bin_offsets[new_bin];
            int front_bin_slot = slot_offsets[new_bin];
            //=======================
            // printf("m_tail_pending_moves!\n");
            // printf("----moving %d ips to bin %d\n",ip_size,new_bin);
            // for(int i=0;i<ip_size;i++){
            //     printf("----moving %d to bin %d\n",moved_ips[i],new_bin);
            // }
            //====================
            if(bin_end-tail_bin_slot>=ip_size){
                std::memcpy(local_index.data()+tail_bin_slot,
                            moved_ips.data(),
                            ip_size * sizeof(int)); 
                
                for(int i=0;i<ip_size;i+=vlf){
                    svbool_t p=svwhilelt_b32(i,ip_size);
                    svint32_t ip_v = svld1_s32(p,&moved_ips[i]);
                    svint32_t pid_to_index_map_v = svindex_s32(slot_offsets[new_bin+1]+i,1);
                    svst1_scatter_s32index_s32(p,&pid_to_index_map[0],ip_v,pid_to_index_map_v);
                } 
                // printf("bin %d slot changed from %d to %d\n",
                //     new_bin,slot_offsets[new_bin+1],slot_offsets[new_bin+1]+ip_size
                // );
                slot_offsets[new_bin+1]+=ip_size;
            }else if((bin_end-tail_bin_slot)+(bin_start-front_bin_slot)>=ip_size){
                int borrow_front=ip_size-(bin_end-tail_bin_slot);
                // bin整体向前移动front距离
                //=======================
                // for(int ii=bin_offsets[new_bin];ii<bin_offsets[new_bin+1];ii++){
                //     printf("TEST bin %d m_local_index[%d]=%d\n",
                //         new_bin,ii,ptile.m_local_index_hbm[ii]);
                // }
                //======================
                std::memmove(local_index.data()+bin_start-borrow_front,
                            local_index.data()+bin_start,
                            bin_length[new_bin] * sizeof(int));
                //================
                // printf("borrow bin %d slot changed from %d to %d\n",
                //     new_bin,slot_offsets[new_bin+1],slot_offsets[new_bin+1]-borrow_front
                // );
                // printf("borrow bin %d binoff changed %d to %d\n",
                //     new_bin,bin_offsets[new_bin],bin_offsets[new_bin]-borrow_front
                // );
                //===============
                bin_offsets[new_bin]-=borrow_front;
                slot_offsets[new_bin+1]-=borrow_front;
                // 把数填进去
                std::memcpy(local_index.data()+slot_offsets[new_bin+1],
                            moved_ips.data(),
                            ip_size * sizeof(int));
                // update pid_to_index_map_v & slot_offsets
                for(int i=0;i<ip_size+bin_length[new_bin];i+=vlf){
                    svbool_t p=svwhilelt_b32(i,ip_size+bin_length[new_bin]);
                    svint32_t ip_v = svld1_s32(p,&local_index[bin_offsets[new_bin]+i]);
                    svint32_t pid_to_index_map_v = svindex_s32(bin_offsets[new_bin]+i,1);
                    svst1_scatter_s32index_s32(p,&pid_to_index_map[0],ip_v,pid_to_index_map_v);
                }
                //===================
                // printf("after borrow bin %d slot changed from %d to %d\n",
                //     new_bin,slot_offsets[new_bin+1],slot_offsets[new_bin+1]+ip_size
                // );
                // printf("after borrow bin %d binoff changed %d  %d\n",
                //     new_bin,bin_offsets[new_bin],bin_offsets[new_bin+1]
                // );
                //===================
                slot_offsets[new_bin+1]+=ip_size;
                //===================
                // for(int ii=bin_offsets[new_bin];ii<bin_offsets[new_bin+1];ii++){
                //     printf("TEST2 bin %d m_local_index[%d]=%d\n",
                //         new_bin,ii,ptile.m_local_index_hbm[ii]);
                // }
                //===================
            }else{
                rebuild=true;
                break;
            }
            bin_length[new_bin]+=ip_size;
        }
    }
    m_pending_moves.clear();

    printf("Rebuild: %d \n",rebuild);
    // for (int binID = 0; binID < numcell; binID++) {
    //     std::cout << "Before bin: " << binID << ", length: " <<
    //         bin_length[binID] << std::endl;
    // }

    // Stage 3：全部都不行，还是执行重构
    if(rebuild)
    { 
        ptile.m_was_rebuilt_this_step = true;

        // TODO:move outside
        // std::vector<int> ptile.m_bin_lengths(numcell);
        // std::vector<int> gap(numcell,0);

        float gap_ratio=WarpX::GetInstance().m_gap_ratio;
        // const std::vector<int>& pid_to_bin_map = ptile.m_pid_to_bin_map_hbm;
        // int np_to_deposit = ptile.m_num_particles;
        ptile.m_bin_lengths.clear();
        ptile.m_bin_lengths.resize(numcell);

        // Stage 1：更新m_bin_lengths
        for(int ip=0;ip<np_to_deposit;ip++){
            ptile.m_bin_lengths[ptile.m_pid_to_bin_map_hbm[ip]]++;
        }  
        // 预估容量大小
        ptile.m_capacity = static_cast<int>(
                std::ceil(static_cast<double>(
                np_to_deposit) * (1.0 + gap_ratio)) + 2*numcell);
        // 初始化偏移量
        int current_offset = 0;
        ptile.m_bin_offsets.clear();
        ptile.m_bin_offsets.resize(numcell+1);
        ptile.m_slot_offsets.clear();
        ptile.m_slot_offsets.resize(numcell+1);
        ptile.m_bin_offsets[0] = 0;
        ptile.m_slot_offsets[0] = 0;
        // ptile.m_free_slots.assign(numcell,std::vector<int>());
        
        // Stage 2: sve计算偏移量m_bin_offsets，同时更新m_slot_offsets位置
        #pragma unroll
        for (int binID = 0; binID < numcell; binID+=vlf) {
            svbool_t p_bin = svwhilelt_b32(binID,numcell);
            svint32_t np_in_bin=svld1_s32(p_bin,&ptile.m_bin_lengths[binID]);
            svint32_t gap_v=svadd_n_s32_x(p_bin,
                            svcvt_s32_f32_x(p_bin,svmul_n_f32_x(p_bin,
                            svcvt_f32_s32_x(p_bin,np_in_bin),gap_ratio)),
                            1);
            // svst1_s32(p_bin,&gap[binID],gap_v);
            svint32_t block_size_v=svadd_s32_x(p_bin,gap_v,np_in_bin);
            // 1. 向量化局部累加 (Intra-Vector Exclusive Scan)
            //    这是将串行依赖转换为并行计算的核心
            svint32_t local_scan_v = block_size_v;
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-1));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-2));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-4));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-8));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-16));
            
            local_scan_v  = svadd_n_s32_x(p_bin, local_scan_v, current_offset);

            // 2. 存储最终计算出的偏移量结果
            //    注意，我们从 m_bin_offsets 的第 binID + 1 个位置开始存
            svst1_s32(p_bin, &ptile.m_bin_offsets[binID + 1], local_scan_v);
            // 2.2 存储最终m_slot_offsets偏移量结果
            svst1_s32(p_bin, &ptile.m_slot_offsets[binID + 1], local_scan_v-gap_v);
            
            // 3. 更新下一个块的全局偏移
            //    使用svaddv高效地计算当前块所有block_size的总和
            current_offset += svaddv_s32(p_bin, block_size_v);
        }

        // Stage 3.1: 更新m_capacity，初始化m_local_index
        ptile.m_capacity=ptile.m_bin_offsets[numcell];
        ptile.m_local_index_hbm.clear();
        // ptile.m_local_index_hbm.reserve(ptile.m_capacity+1);
        // ptile.m_local_index_hbm.resize(ptile.m_capacity);
        ptile.m_local_index_hbm.assign(ptile.m_capacity, INVALID_PARTICLE_ID);
        // ptile.m_local_index_hbm.shrink_to_fit();
        // std::fill_n(ptile.m_local_index_hbm.data(), ptile.m_capacity, INVALID_PARTICLE_ID);
        // ptile.m_local_index_hbm.assign(ptile.m_capacity, INVALID_PARTICLE_ID);
        // 初始化为每个 bin 的起始位置
        std::vector<int> next_write_slot = ptile.m_bin_offsets; 

        // Stage 3.2: 往m_local_index和m_pid_to_index_map填入数据
        for(int ip=0;ip<np_to_deposit;ip++){
            int bin_id =ptile.m_pid_to_bin_map_hbm[ip];
            int insert_idx = next_write_slot[bin_id];
            ptile.m_local_index_hbm[insert_idx] = ip;
            ptile.m_pid_to_index_map[ip]=insert_idx;
            next_write_slot[bin_id]++;
        }
    }
    for (int iz = 0; iz < len.z; ++iz) {
        for (int iy = 0; iy < len.y; ++iy) {       
            for (int ix = 0; ix < len.x; ix++) {
                int binID=(ix) + (iy) * len.x + (iz) * len.x*len.y;
                if(before_bin_lengths[binID]!=bin_length[binID]){
                    printf("x %d y %d z %d\n",ix,iy,iz);
                    std::cout << "\tBefore binlength[" << binID << "]:  " <<
                        before_bin_lengths[binID];
                    std::cout << ", After binlength[" << binID << "]:  " <<
                        bin_length[binID] << std::endl;
                }
            }
        }
    }
    
}

inline void sorted_pma_compact (
    const std::vector<int>& local_index,
    const std::vector<int>& bin_length,
    const std::vector<int>& bin_offsets,
    int np,int numbin,
    std::vector<int>& ip_list
) {
    using namespace amrex::literals;

    int vl=svcntw();
    svint32_t vmax = svdup_s32(INVALID_PARTICLE_ID);
    // std::vector<int> ip_list(np,0);  
    svbool_t p_all = svptrue_b32();
    int write_ptr = 0;
    
    for (int old_bin = 0; old_bin < numbin; ++old_bin) {
        int start = bin_offsets[old_bin];
        for(int i=start;i<bin_offsets[old_bin+1];i+=vl){
            svbool_t p0 = svwhilelt_b32(i,bin_offsets[old_bin+1]);
            svint32_t ip_v = svld1_s32(p0,&local_index[i]);
            svbool_t p1 = svcmpne_s32(p0, ip_v, vmax); 
            svint32_t real_ip_v = svcompact_s32(p1, ip_v);
            int count = svcntp_b32(p_all, p1);
            svbool_t p_store = svwhilelt_b32(0, count);
            svst1_s32(p_store,&ip_list[write_ptr],real_ip_v);
            write_ptr+=count;
        }
    }
}

inline void sorted_pma_compact2 (
    const std::vector<int>& local_index,
    std::vector<int>& ip_list
) {
    using namespace amrex::literals;

    int vl=svcntw();
    svint32_t vmax = svdup_s32(INVALID_PARTICLE_ID);
    // std::vector<int> ip_list(np,0);  
    svbool_t p_all = svptrue_b32();
    int N=local_index.size();
    int write_ptr = 0;
    for(int i=0;i<N;i+=vl){
        svbool_t p0 = svwhilelt_b32(i,N);
        svint32_t ip_v = svld1_s32(p0,&local_index[i]);
        svbool_t p1 = svcmpne_s32(p0, ip_v, vmax); 
        if(svptest_any(p0,p1)){
            svint32_t real_ip_v = svcompact_s32(p1, ip_v);
            int count = svcntp_b32(p_all, p1);
            svbool_t p_store = svwhilelt_b32(0, count);
            svst1_s32(p_store,&ip_list[write_ptr],real_ip_v);
            write_ptr+=count;
            // printf("ADD%d %d - %d to llist %d \n",i,local_index[i],local_index[i+vl],write_ptr);
        }
    }
}

__arm_new("za") inline void sme_trans_order3(
    std::vector<amrex::Real>& sx_mt,
    std::vector<amrex::Real>& sx_m,
    int np
)__arm_streaming
{
    int vl=svcntd();
    svbool_t p = svptrue_b64();
    svbool_t p4 = svwhilelt_b64(0,4);
    Vec vzero(0);
    // wxsxsysz0 = svread_hor_za64_m(vzero,p_4_8,0,2);
    #pragma unroll
    for(int ip=0;ip<np;ip+=vl){
        svbool_t p0 = svwhilelt_b64(ip,np);
        Vec v0t = Vec::Load(p0,&sx_mt[ip]);
        svwrite_ver_za64_m(0, 0, p0, v0t);
        Vec v1t = Vec::Load(p0,&sx_mt[ip+np]);
        svwrite_ver_za64_m(0, 1, p0, v1t);
        Vec v2t = Vec::Load(p0,&sx_mt[ip+2*np]);
        svwrite_ver_za64_m(0, 2, p0, v2t);
        Vec v3t = Vec::Load(p0,&sx_mt[ip+3*np]);
        svwrite_ver_za64_m(0, 3, p0, v3t);

        Vec v0 =svread_hor_za64_m(vzero, p4, 0, 0);
        v0.Store(p4,&sx_m[ip+0*4]);
        Vec v1 =svread_hor_za64_m(vzero, p4, 0, 1);
        v1.Store(p4,&sx_m[ip+1*4]);
        Vec v2 =svread_hor_za64_m(vzero, p4, 0, 2);
        v2.Store(p4,&sx_m[ip+2*4]);
        Vec v3 =svread_hor_za64_m(vzero, p4, 0, 3);
        v3.Store(p4,&sx_m[ip+3*4]);
        Vec v4 =svread_hor_za64_m(vzero, p4, 0, 4);
        v4.Store(p4,&sx_m[ip+4*4]);
        Vec v5 =svread_hor_za64_m(vzero, p4, 0, 5);
        v5.Store(p4,&sx_m[ip+5*4]);
        Vec v6 =svread_hor_za64_m(vzero, p4, 0, 6);
        v6.Store(p4,&sx_m[ip+6*4]);
        Vec v7 =svread_hor_za64_m(vzero, p4, 0, 7);
        v7.Store(p4,&sx_m[ip+7*4]);
    }
}

template <int depos_order>
void doDepositionShapeN_3d_sme_order3_v2 (const GetParticlePosition<PIdx>& GetPosition,
                        const amrex::ParticleReal * const wp,
                        const amrex::ParticleReal * const uxp,
                        const amrex::ParticleReal * const uyp,
                        const amrex::ParticleReal * const uzp,
                        const int* ion_lev,
                        std::vector<amrex::Real>& wqx,
                        std::vector<amrex::Real>& wqy,
                        std::vector<amrex::Real>& wqz,
                        std::vector<amrex::Real>& sx_mT,
                        std::vector<amrex::Real>& sy_mT,
                        std::vector<amrex::Real>& sz_mT,
                        std::vector<int>& newbin,
                        amrex::FArrayBox& jx_fab,
                        amrex::FArrayBox& jy_fab,
                        amrex::FArrayBox& jz_fab,
                        long np_to_deposit,
                        amrex::Real relative_time,
                        const amrex::XDim3 & dinv,
                        const amrex::XDim3 & xyzmin,
                        amrex::Dim3 lo,
                        amrex::Dim3 hi,
                        amrex::Dim3 len,
                        amrex::Real q,
                        std::vector<int>& test,
                        std::vector<double>& test0,
                        std::vector<int>& testbin,
                        std::vector<double>& test_sxm,
                        ParticleTileType& ptile, const amrex::Box& box,
                        std::vector<amrex::Real>& test_rhocells,
                        std::vector<amrex::Real>& test_sxwq,
                        [[maybe_unused]]int n_rz_azimuthal_modes)
{
    // WARPX_PROFILE("doDepositionShapeN_3d_sme_order3()");
    uint64_t total_time[3]={0};
    using namespace std::chrono;
    using namespace amrex::literals;
    uint64_t precompute=0;
    uint64_t precompute1[4]={0};
    uint64_t cale_time=0;
    uint64_t sort_time[2]={0};
    uint64_t total_sort_time={0};
        uint64_t update[2]={0};
        uint64_t update1[7]={0};
        uint64_t presort=0;
        uint64_t insert=0;
        uint64_t borrow=0;
        uint64_t rebuildtime=0;
        uint64_t rebuild1[7]={0};
    uint64_t reduce_time=0;
    uint64_t svetime[3]={0};
    uint64_t svetime1[3]={0};
    // uint64_t branch_time=0;
    
    total_time[0]=rdtscv();
    constexpr int nshapes = depos_order + 1;

    
    // std::vector<amrex::Real> wqx(np_to_deposit);
    // std::vector<amrex::Real> wqy(np_to_deposit);
    // std::vector<amrex::Real> wqz(np_to_deposit);
    // std::vector<amrex::Real> sx_mT(np_to_deposit*nshapes);
    // std::vector<amrex::Real> sy_mT(np_to_deposit*nshapes);
    // std::vector<amrex::Real> sz_mT(np_to_deposit*nshapes);
    // std::vector<int> newbin(np_to_deposit);

    svetime[0]=rdtscv();
    const bool do_ionization = ion_lev;
    const amrex::Real invvol = dinv.x*dinv.y*dinv.z; 
    const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;

    amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
    amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
    amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();

    
    int vl=svcntd();

    const amrex::ParticleReal* mx = GetPosition.m_x;
    const amrex::ParticleReal* my = GetPosition.m_y;
    const amrex::ParticleReal* mz = GetPosition.m_z;
#if 0
    auto compute_shape_factor_order3 = [](double* sx, Vec xmid, svbool_t p) {
        const svuint64_t sx_index = svindex_u64(0, 4);
        intVec i_newv = svcvt_s64_f64_z(p, xmid);

        Vec j = svcvt_f64_s64_z(p, i_newv);
        Vec xint = xmid - j;

        Vec temp = 1.0 - xint;
        Vec sx0 = (1.0 / 6.0) * temp * temp * temp;
        svst1_scatter_index(p,&sx[0],sx_index,sx0);
        Vec sx1 = (2.0 / 3.0) - xint * xint * (1.0 - xint * 0.5);
        svst1_scatter_index(p,&sx[1],sx_index,sx1);
        Vec sx2 = (2.0 / 3.0) - temp * temp * (1.0 - 0.5 *temp);
        svst1_scatter_index(p,&sx[2],sx_index,sx2);
        Vec sx3 = (1.0 / 6.0) * xint * xint * xint;
        svst1_scatter_index(p,&sx[3],sx_index,sx3);

        return i_newv-1;
    };
#endif
    //=======================================
    
    auto compute_shape_factor_order3_v2 = [](double* sx, Vec xmid, svbool_t p, int np) {
        intVec i_newv = svcvt_s64_f64_z(p, xmid);

        Vec j = svrintz_x(p, xmid);
        Vec xint = xmid - j;
        Vec temp = 1.0 - xint;

        Vec sx0 = (1.0 / 6.0) * temp * temp * temp;
        sx0.Store(p, &sx[0*np]);
        Vec sx1 = (2.0 / 3.0) - xint * xint * (1.0 - xint * 0.5);
        sx1.Store(p, &sx[1*np]);
        Vec sx2 = (2.0 / 3.0) - temp * temp * (1.0 - 0.5 *temp);
        sx2.Store(p, &sx[2*np]);
        Vec sx3 = (1.0 / 6.0) * xint * xint * xint;
        sx3.Store(p, &sx[3*np]);

        return i_newv-1;
    };
    //=========================================

    // 预计算网格步长
    const int xjstride = jx_arr.jstride;
    const int xkstride = jx_arr.kstride;
    const int yjstride = jy_arr.jstride;
    const int ykstride = jy_arr.kstride;
    const int zjstride = jz_arr.jstride;
    const int zkstride = jz_arr.kstride;


    // std::vector<amrex::Real> sx_m(np_to_deposit*nshapes, 0.);
    // std::vector<amrex::Real> sy_m(np_to_deposit*nshapes, 0.);
    // std::vector<amrex::Real> sz_m(np_to_deposit*nshapes, 0.);
    // alignas(64) long xoffsets[np_to_deposit]; 
    // long bx = 2, by = 2, bz = 2;
    // amrex::IntVect box_shape = box.length();
    long nnx = len.x;
    long nny = len.y;
    long nnxny = nnx*nny;
    // alignas(64) std::vector<long> newbin(np_to_deposit);
    
    // alignas(64) std::vector<int> newbin1(np_to_deposit);
    svetime[1]=rdtscv();
    precompute1[0]+=(svetime[1]-svetime[0]); 

    
    svetime[0]=rdtscv();
    #pragma unroll
    for(long ip=0;ip<np_to_deposit;ip+=vl){
        // svetime[0]=rdtscv();
        // 计算基本物理量
        svbool_t p=svwhilelt_b64(ip,np_to_deposit);

        // Inverse of Lorentz factor gamma
        Vec uxp_v=Vec::Load(p,&uxp[ip]);
        Vec uyp_v=Vec::Load(p,&uyp[ip]);
        Vec uzp_v=Vec::Load(p,&uzp[ip]);
        Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                    + uyp_v * uyp_v * clightsq
                                    + uzp_v * uzp_v * clightsq).Sqrt();
        // Product of particle charges and weights
        Vec wp_v=Vec::Load(p,&wp[ip]);
        Vec wq_v = q * wp_v;

        // Current particle positions (in physical units)
        Vec xp = Vec::Load(p, &mx[ip]);
        Vec yp = Vec::Load(p, &my[ip]);
        Vec zp = Vec::Load(p, &mz[ip]);

        // Particle velocities
        Vec vx_v = uxp_v * gaminv;
        Vec wqx_v = wq_v * invvol * vx_v;
        wqx_v.Store(p, &wqx[ip]);
        Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x;

        Vec vy_v = uyp_v * gaminv;
        Vec wqy_v = wq_v * invvol * vy_v;
        wqy_v.Store(p, &wqy[ip]);
        Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y;

        Vec vz_v = uzp_v * gaminv;
        Vec wqz_v = wq_v * invvol * vz_v;
        wqz_v.Store(p, &wqz[ip]);
        Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z;
        // svetime[1]=rdtscv();
        // precompute1[0]+=(svetime[1]-svetime[0]); 
        
        
#if 0
        svetime[0]=rdtscv();
        // xmid.Store(p, &test0[ip]);
        // double* sx_temp[nshapes] = {&sx_m[0][ip], &sx_m[1][ip]};
        intVec j_cellv = compute_shape_factor_order3( &sx_m[ip*nshapes], xmid, p);
        // j_cellv.Store(p, &test[ip]);
        intVec k_cellv = compute_shape_factor_order3( &sy_m[ip*nshapes], ymid, p);
        intVec l_cellv = compute_shape_factor_order3( &sz_m[ip*nshapes], zmid, p); 

        // intVec xoffsets_v = j_cellv + k_cellv * xjstride + l_cellv * xkstride;
        // intVec yoffsets_v = j_cellv + k_cellv * yjstride + l_cellv * ykstride;
        // intVec zoffsets_v = j_cellv + k_cellv * zjstride + l_cellv * zkstride;

        // xoffsets_v.Store(p,&xoffsets[ip]);
        intVec new_bin_v1 = (j_cellv) + 
                            (k_cellv)* nnx + 
                            (l_cellv) * nnxny;
        svst1w_s64(p, &newbin1[ip], new_bin_v1);
        // svetime[1]=rdtscv();
        // precompute1[1]+=(svetime[1]-svetime[0]); 
#endif
        // new_bin_v.Store(p,&newbin[ip]);

        // svetime[0]=rdtscv();
        intVec j_cellv2 = compute_shape_factor_order3_v2( &sx_mT[ip], xmid, p,np_to_deposit);
        intVec k_cellv2 = compute_shape_factor_order3_v2( &sy_mT[ip], ymid, p,np_to_deposit);
        intVec l_cellv2 = compute_shape_factor_order3_v2( &sz_mT[ip], zmid, p,np_to_deposit); 
        intVec new_bin_v = (j_cellv2) + 
                (k_cellv2)* nnx + 
                (l_cellv2) * nnxny;
        svst1w_s64(p, &newbin[ip], new_bin_v);
        // svetime[1]=rdtscv();
        // precompute1[2]+=(svetime[1]-svetime[0]); 

    }
    svetime[1]=rdtscv();
    precompute1[1]+=(svetime[1]-svetime[0]);
    precompute=precompute1[0]+precompute1[1]; 
    //=============================
    // test_sxm=sx_m;
    // testbin=newbin;
    // test0.assign(nshapes*np_to_deposit,0);
    // test1=wqx;
    // for(int ip=0;ip<np_to_deposit;ip++){
    //     printf("newbin[%d]=%d/size %d\n",ip,newbin[ip],newbin.size());
    // }
    // std::vector<amrex::Real> testsxwq(64*np_to_deposit, 0.0);
    //=============================

    // precompute=(precompute1[1]+precompute1[0]); 

    //===================================
    // svetime[0]=rdtscv();
    // std::vector<amrex::Real> sx_m1(np_to_deposit*nshapes, 0.);
    // std::vector<amrex::Real> sy_m1(np_to_deposit*nshapes, 0.);
    // std::vector<amrex::Real> sz_m1(np_to_deposit*nshapes, 0.);
    // sme_trans_order3(sx_mT,sx_m1,np_to_deposit);
    // svetime[1]=rdtscv();
    // precompute1[3]+=(svetime[1]-svetime[0]); 
    //===========================

    //===========================
    // svetime[0]=rdtscv();
    // const svuint64_t sx_index = svindex_u64(0, np_to_deposit);
    // std::vector<amrex::Real> errev(4*np_to_deposit, 0.);
    // svbool_t p0=svwhilelt_b64(0,4);
    // for(long i=0;i<np_to_deposit;i++){
    //     // svbool_t p=svwhilelt_b64(i,np_to_deposit);
    //     Vec wqxsx = svld1_gather_index(p0,&sx_mT[i],sx_index);
    //     Vec sx1 = svld1(p0,&sx_m[i*nshapes]);
    //     // Vec wqxsy = svld1_gather_index(p,&sy_mT[i*nshapes],sx_index);
    //     // Vec wqxsz = svld1_gather_index(p,&sz_mT[i*nshapes],sx_index);
    //     Vec errr=wqxsx-sx1;
    //     if(newbin[i]!=newbin1[i]) {
    //         printf("binerr %d trans %d true %d\n",
    //             i,newbin[i],newbin1[i]
    //         );
    //     }
    //     errr.Store(p0,&errev[i*4]);
    //     for(int j =0;j<4;j++){
    //         if(std::abs(errev[i*4+j])>1e-3) {
    //             printf("sxt %f sx %f err[%d] %f\n"
    //                 ,sx_mT[i+j*np_to_deposit]
    //                 ,sx_m[i*nshapes+j]
    //                 ,i+j,errev[i*4+j]
    //             );
    //         }
    //     }
    //     asm volatile("" ::: "memory");
    // }
    // svetime[1]=rdtscv();
    // precompute1[3]+=(svetime[1]-svetime[0]); 
    //=================================


    const int numcell=ptile.m_num_bins;
    
    // 只允许找左右两边借的方案，更快更稳定，但是不能扩展
    ///////////判断、增量处理（删除、更新索引）、或重组过程////////////
    svetime[0]=rdtscv();
    increment_sort_particles(np_to_deposit,ptile,newbin,numcell);
    svetime[1]=rdtscv();
    sort_time[0]+=(svetime[1]-svetime[0]);
    
    auto& local_index = ptile.m_local_index;
    auto& bin_offsets = ptile.m_bin_offsets;
    auto& bin_length = ptile.m_bin_lengths;
    std::vector<int> ip_list(np_to_deposit); 
    svetime[0]=rdtscv();
    //=========================
    // for(int ip=0;ip<np_to_deposit;ip++){
    //     printf("m_pid_to_index_map[%d]=%d\n",ip,ptile.m_pid_to_index_map[ip]);

    // }
    // for(int i=0;i<local_index.size();i++){
    //     printf("index[%d]=%d\n",i,local_index[i]);
    // }
    //========================

    // sorted_pma_compact2(local_index,ip_list);
    //==========================================
    // std::vector<int> ip_list1(np_to_deposit);
    // sorted_pma_compact(local_index,bin_length,bin_offsets,
    //     np_to_deposit,numcell,ip_list1
    // );
    // int N=local_index.size();
    // for(int i=0;i<N;i++){
    //     printf("local_index[%d]=%d \n",i,local_index[i]);
    // }
    // for(int i=0;i<np_to_deposit;i++){
    //     printf("iplist[%d] %d, true %d\n",i,ip_list[i],ip_list1[i]);
    // }
    // exit(0);
    //==========================================
    svetime[1]=rdtscv();
    sort_time[1]+=(svetime[1]-svetime[0]);

    total_sort_time=(sort_time[0]+sort_time[1]);

# if 0
    // svetime[0]=rdtscv();
    auto& num_particles = ptile.m_num_particles;
    auto& pid_to_bin_map = ptile.m_pid_to_bin_map;
    auto& pid_to_index_map = ptile.m_pid_to_index_map; 
    auto& free_slot = ptile.m_free_slots;
    std::unordered_map<int, std::vector<int>> m_pending_moves;
    bool rebuild=false;
    // rebuild=true;

    svetime[1]=rdtscv();
    // L1：粒子总数超过最大容量直接重组
    if(np_to_deposit<ptile.m_capacity){
        // svetime[0]=rdtscv();
        // 先统一操作，搜索一遍所有待增量更新的粒子
        // 新增粒子添加
        int loop_np=np_to_deposit;
        // 新增粒子添加
        for(int ip=num_particles;ip<np_to_deposit;ip++){
            int new_bin=newbin[ip];
            m_pending_moves[new_bin].push_back(ip);
            loop_np=num_particles;
        }
        // 减少的粒子删除
        for(int ip=np_to_deposit;ip<num_particles;ip++){
            int old_bin=pid_to_bin_map[ip];
            int idx=pid_to_index_map[ip]; 
            //打洞、长度缩减、压栈
            ptile.m_local_index[idx] = INVALID_PARTICLE_ID;
            bin_length[old_bin]--;
            free_slot[old_bin].push_back(idx);
        }
        // svetime[1]=rdtscv();
        // update[0]+=(svetime[1]-svetime[0]);

        // 对变化的粒子先做了删除操作
        // svetime[0]=rdtscv();
        int block_size=128;
        int MOVED_PARTICLES_MAX=loop_np/4+block_size;
        int moved_ips[MOVED_PARTICLES_MAX];
        int moved_idxs[MOVED_PARTICLES_MAX];
        int moved_old_bins[MOVED_PARTICLES_MAX];
        int moved_new_bins[MOVED_PARTICLES_MAX];
        int moved_count = 0;

        for (int i = 0; i < loop_np; i += block_size) {
            // svetime1[0]=rdtscv();
            int current_block_size = std::min(block_size, loop_np - i);
            // 计算需要比较的字节数
            size_t bytes_to_compare = current_block_size * sizeof(int);

            // svetime1[1]=rdtscv();
            // update1[0]+=(svetime1[1]-svetime1[0]);
            // --- 快速路径：使用 memcmp 比较整个块 ---
            // memcmp 比较的是内存内容。如果返回0，表示两块内存完全相同。
            if (memcmp(&newbin[i], &pid_to_bin_map[i], bytes_to_compare) == 0) {
                // 块内所有粒子都没有移动，直接跳过，这是性能提升的关键
                // ii++;
                // printf("JUMP %d\n",i);
                continue; 
            } 
            else {
                const int num_lanes = svcntw(); // 获取向量宽度 (32位元素)
                // svetime1[0]=rdtscv();
                for (int j = 0; j < current_block_size; j += num_lanes) {
                    int ip=i+j;
                    // 创建覆盖当前块的谓词 (同时为64位和32位元素创建)
                    svbool_t pg32 = svwhilelt_b32(j, current_block_size);
                    svint32_t vec_newbin = svld1_s32(pg32, &newbin[ip]);
                    svint32_t vec_oldbin  = svld1_s32(pg32, &pid_to_bin_map[ip]);
                    svbool_t moved_mask = svcmpne(pg32, vec_newbin, vec_oldbin);
                    if (!svptest_any(pg32, moved_mask)) {
                        continue;
                    }
                    // --- 开始处理移动的粒子 ---

                    // 3. GATHER 操作：获取移动粒子的 idx
                    // a. 创建当前块所有粒子的 ip 索引向量
                    svint32_t all_ips_in_block = svindex_s32(ip, 1);
                    // b. 根据 moved_mask，从 pid_to_index_map 中收集对应的 idx
                    //    svld1_gather 只会加载 moved_mask 为 true 的通道的 idx
                    svint32_t moved_idxs_vec = svld1_gather_s32index_s32(moved_mask, &pid_to_index_map[0], all_ips_in_block);

                    // 4. SCATTER 操作：将 local_index 中对应位置设为无效
                    // a. 创建一个填满无效ID的向量
                    svint32_t vec_invalid_id = svdup_s32(INVALID_PARTICLE_ID);
                    // b. 根据 moved_idxs_vec 中的索引，将无效ID分散地写入 local_index
                    //    注意：这里的谓词是 moved_mask，因为它对应于 moved_idxs_vec 的源数据
                    svst1_scatter_s32index_s32(moved_mask, &local_index[0], moved_idxs_vec, vec_invalid_id);
                    
                    // 5. PACK 操作：将所有需要的信息打包
                    int32_t count_in_this_block = svcntp_b32(pg32, moved_mask);
                    svbool_t pg_compact = svwhilelt_b32(0, count_in_this_block);

                    // a. 紧凑化 ip, new_bin, old_bin
                    svint32_t moved_ips_vec      = svcompact(moved_mask, all_ips_in_block);
                    svint32_t moved_new_bins_vec = svcompact(moved_mask, vec_newbin);
                    svint32_t moved_old_bins_vec = svcompact(moved_mask, vec_oldbin);
                    svint32_t moved_idxs_vec1 = svcompact(moved_mask, moved_idxs_vec);

                    // b. 将紧凑后的向量存入输出数组
                    svst1_s32(pg_compact, &moved_ips[moved_count], moved_ips_vec);
                    svst1_s32(pg_compact, &moved_new_bins[moved_count], moved_new_bins_vec);
                    svst1_s32(pg_compact, &moved_old_bins[moved_count], moved_old_bins_vec);
                    svst1_s32(pg_compact, &moved_idxs[moved_count], moved_idxs_vec1);

                    // 6. 更新总计数
                    moved_count += count_in_this_block;
                }
                if (moved_count > loop_np/8) {
                    rebuild=true;
                    break;
                }
                // svetime1[1]=rdtscv();
                // update1[1]+=(svetime1[1]-svetime1[0]);
            }
        }
        // printf("moved particels %d/%d\n",moved_count,loop_np);

        if (moved_count > loop_np/8) {
            rebuild=true;
        }else{
            // 为了高效更新 bin_length，先用一个临时map统计
            std::map<int, int> bin_decrement_counts;
            // svetime1[0]=rdtscv();
            for (int k = 0; k < moved_count; ++k) {
                int ip = moved_ips[k];
                int new_bin = moved_new_bins[k];
                int old_bin = moved_old_bins[k];
                int idx = moved_idxs[k];

                // 执行 push_back 操作
                m_pending_moves[new_bin].push_back(ip);
                free_slot[old_bin].push_back(idx);

                // 统计每个 old_bin 离开的粒子数
                bin_decrement_counts[old_bin]++;
            }
            // svetime1[1]=rdtscv();
            // update1[2]+=(svetime1[1]-svetime1[0]);
            

            // svetime1[0]=rdtscv();
            // 一次性更新 bin_length
            for (auto const& [bin, count] : bin_decrement_counts) {
                bin_length[bin] -= count;
            }
            // svetime1[1]=rdtscv();
            // update1[3]+=(svetime1[1]-svetime1[0]);
            
            // svetime[1]=rdtscv();
            // update[1]+=(svetime[1]-svetime[0]);

            // svetime[0]=rdtscv();
            float rebuild_weight=WarpX::GetInstance().m_rebuild_weight;
            // float rebuild_cost=1.2; // 重组开销权重，实验测定暂定1.2吧
            // 重组开销，增量开销未达到重组开销时就不用重组
            // 重组一个粒子需要扫描一遍粒子，扫描一边网格，扫描一遍带空槽的粒子,最后扫描一遍粒子
            // 这里+估计为1，*估计为3，默认数据IO都能在在寄存器里为1
            float Cost_Global = rebuild_weight *(np_to_deposit + numcell*5
                                                +(np_to_deposit * WarpX::GetInstance().m_gap_ratio)
                                                + np_to_deposit); 

            // 预计算局部重组开销（只向右边查找）：
            // 累加（用freeslot栈移出空位开销+需要借用第n个块的开销）
            // 廉价的移动方案开销极低，复杂的方案就直接重组了
            float slot_cost=1.; // 借用空槽的cost
                                // 借空槽只需要一次交换，一次填充，所以是1
            float move_cost=6.+np_to_deposit/(4*numcell); // 移动数据块的cost,交换操作一次3*2
                                // 采用交换法（不用压实然后memmove）的话开销和大概就是一次访存估计为3-5
            float total_move_cost=0; //总开销
            // float rebuild_weight=WarpX::GetInstance().m_rebuild_weight; //达到重组开销的90%（可修改）就直接跳出直接重组了
            
            std::vector<int> borrow_size(numcell,0);

            // 先处理首尾两个块
            int old_bin = numcell-1; //尾块
            // 添加使用空槽的开销
            if (m_pending_moves.find(old_bin)!=m_pending_moves.end()) {//有需要插空的才计算
                int needed_count = m_pending_moves.at(old_bin).size();
                if (needed_count > free_slot[old_bin].size()) {
                    // 添加移动块数据的开销
                    // 因为重组计算了遍历粒子的开销，所以这里把插空开销也直接算进来了
                    int needed_borrow = needed_count - free_slot[old_bin].size();
                    int can_borrow = 0;
                    total_move_cost+=(needed_count-needed_borrow)*slot_cost; //粒子插空的
                    //最多允许借左邻居隔壁1个块
                    int next_pending_moves=0;
                    int borrow_bin=old_bin-1;
                    if (m_pending_moves.find(borrow_bin)!=m_pending_moves.end()) {
                        //如果邻居有需要插空的就记录一下，否则就不需要
                        next_pending_moves=m_pending_moves.at(borrow_bin).size();
                    }
                    can_borrow=(free_slot[borrow_bin].size()
                                -next_pending_moves
                                -borrow_size[borrow_bin]);
                    //在左边借到了
                    if (needed_borrow > can_borrow) {
                        rebuild=true;
                        // 基本上不会在一开始就超，所以不要判断成本
                        // if(total_move_cost>Cost_Global){ 
                        //     rebuild=true;
                        //     break;
                        // }
                    }
                    borrow_size[borrow_bin]+=needed_borrow; //借到了跳出，空槽被借用
                    total_move_cost+=move_cost*needed_borrow;//needed_borrow个粒子交换了
                }
            }
            old_bin = 0; //首块
            // 添加使用空槽的开销
            if (m_pending_moves.find(old_bin)!=m_pending_moves.end() && !rebuild) {//有需要插空的才计算
                int needed_count = m_pending_moves.at(old_bin).size();
                if (needed_count > free_slot[old_bin].size()) {
                    // 添加移动块数据的开销
                    // 因为重组计算了遍历粒子的开销，所以这里把插空开销也直接算进来了
                    int needed_borrow = needed_count - free_slot[old_bin].size();
                    int can_borrow = 0;
                    total_move_cost+=(needed_count-needed_borrow)*slot_cost; //粒子插空的
                    int next_pending_moves=0;
                    int borrow_bin=old_bin+1;
                    if (m_pending_moves.find(borrow_bin)!=m_pending_moves.end()) {
                        //如果邻居有需要插空的就记录一下，否则就不需要
                        next_pending_moves=m_pending_moves.at(borrow_bin).size();
                    }
                    can_borrow=(free_slot[borrow_bin].size()
                                -next_pending_moves
                                -borrow_size[borrow_bin]);
                    //在左边借到了
                    if (needed_borrow > can_borrow) {
                        rebuild=true;
                    }
                    borrow_size[borrow_bin]+=needed_borrow; //借到了跳出，空槽被借用
                    total_move_cost+=move_cost*needed_borrow;//needed_borrow个粒子交换了
                }
            }
            // 处理右左借用，先借右边再借左边
            if(!rebuild && total_move_cost<=Cost_Global){
                // 首尾特殊单独处理了
                // for (int old_bin = 1; old_bin < numcell-1; ++old_bin) { 
                //     if (m_pending_moves.find(old_bin)==m_pending_moves.end()) continue;//有需要插空的才计算
                // #pragma omp simd
                for (const auto& pair : m_pending_moves) {
                    int old_bin=pair.first;
                    if (old_bin==0 || old_bin==numcell-1) continue;//有需要插空的才计算
                    // 添加使用空槽的开销
                    int needed_count = m_pending_moves.at(old_bin).size();

                    // printf("%d \n ",old_bin);
                    // amrex::Print() << free_slot.at(old_bin).size() << std::endl;

                    if (needed_count <= free_slot.at(old_bin).size()) {
                        continue;
                    }
                    // 添加移动块数据的开销
                    // 因为重组计算了遍历粒子的开销，所以这里把插空开销也直接算进来了
                    int needed_borrow = needed_count - free_slot[old_bin].size();
                    int can_borrow = 0;
                    total_move_cost+=(needed_count-needed_borrow)*slot_cost; //粒子插空的
                    //最多允许借左右邻居隔壁2个块
                    int next_pending_moves=0;
                    int borrow_bin=old_bin+1;
                    if (m_pending_moves.find(borrow_bin)!=m_pending_moves.end()) {
                        //如果邻居有需要插空的就记录一下，否则就不需要
                        next_pending_moves=m_pending_moves.at(borrow_bin).size();
                    }
                    can_borrow=(free_slot[borrow_bin].size()
                                -next_pending_moves
                                -borrow_size[borrow_bin]);
                    //在左边就借到了
                    if (needed_borrow <= can_borrow) {
                        borrow_size[borrow_bin]+=needed_borrow; //借到了跳出，空槽被借用
                        total_move_cost+=move_cost*needed_borrow;//needed_borrow个粒子交换了
                        if(total_move_cost>Cost_Global){ 
                            rebuild=true;
                            break;
                        }
                        continue;
                    }
                    //左边没借到就找右边
                    //如果左边没空槽就会跳出了
                    borrow_size[borrow_bin]=free_slot[borrow_bin].size()-next_pending_moves;
                    int borrow_bin2=borrow_bin-2; 
                    next_pending_moves=0;
                    if (m_pending_moves.find(borrow_bin2)!=m_pending_moves.end()) {
                        next_pending_moves=m_pending_moves.at(borrow_bin2).size();
                    }
                    int can_borrow2=(free_slot[borrow_bin2].size()
                                -next_pending_moves
                                -borrow_size[borrow_bin2]);
                    needed_borrow-=can_borrow;//不够，先更新needed_borrow，再更新borrow_size占满这个块
                    if(can_borrow2<needed_borrow){ 
                        // 不够借就直接跳出，否则就够借
                        rebuild=true;
                        break;
                    }
                    //先处理上一个块的借用情况
                    total_move_cost+=move_cost*can_borrow;
                    //接下来更新这个块的借用情况
                    borrow_size[borrow_bin2]+=needed_borrow; //被借用了多少
                    total_move_cost+=move_cost*needed_borrow;//左右借用都一样
                    if(total_move_cost>Cost_Global){ 
                        rebuild=true;
                        break;
                    }
                }
            }
            // svetime[1]=rdtscv();
            // presort+=(svetime[1]-svetime[0]); 
        }
    }
    else{
        rebuild=true;
    }
    svetime[1]=rdtscv();
    presort+=(svetime[1]-svetime[0]); 

    // rebuild=false;

    ptile.m_pid_to_bin_map.reserve(np_to_deposit+1);
    ptile.m_pid_to_index_map.reserve(np_to_deposit+1);
    ptile.m_pid_to_index_map.resize(np_to_deposit, -1);
    ptile.m_pid_to_bin_map.assign(newbin.begin(),
                              newbin.begin() + np_to_deposit);
    ptile.m_num_particles=np_to_deposit;
    ptile.m_was_rebuilt_this_step= false ;
    assert(newbin.size() >= np_to_deposit);
    assert(ptile.m_pid_to_bin_map.size() == np_to_deposit);

    if(!rebuild){ // 代价可以接受
        // printf("%d DO INCREMENT ADD!!\n",rebuild);
        //如果代价可以接受，就得顺便把一些参数增量更新了
        svetime[0]=rdtscv();
        ptile.m_num_empty_slots=ptile.m_capacity-np_to_deposit;
        // #pragma omp simd
        for (const auto& pair : m_pending_moves) {
            int new_bin=pair.first;
            std::vector<int>& particles_ip = m_pending_moves[new_bin];
            // printf("ADD: bin %d binlength change from %d ",new_bin,ptile.m_bin_lengths[new_bin]);
            ptile.m_bin_lengths[new_bin]+=particles_ip.size();
            // printf("to %d (+%d)\n",ptile.m_bin_lengths[new_bin],particles_ip.size());
            // for (const auto& pid : particles_ip) {
            // #pragma omp simd
            for (int i=particles_ip.size()-1; i>=0;i--) {
                int pid=particles_ip.back();
                int insert_idx = ptile.findEmptySlotInBin(new_bin);
                if (insert_idx != -1) {
                    // 直接填坑、退槽、长度增加（map已经完成更新）
                    ptile.m_local_index[insert_idx] = pid;
                    ptile.m_free_slots[new_bin].pop_back();
                    // ptile.m_bin_lengths[new_bin]++;
                    ptile.m_pid_to_index_map[pid]=insert_idx;
                    particles_ip.pop_back(); //一边填空一边更新pending_moves待插入的元素
                    // printf("[1] SLOT: inserted pid %d to bin %d at %d\n", pid, new_bin,insert_idx);
                } else {
                    break;
                }
            }
        }
        // svetime[1]=rdtscv();
        // insert+=(svetime[1]-svetime[0]);
    
        // svetime[0]=rdtscv();
        //还有没更新完的就需要借用了
        int new_bin = numcell-1;
        //判断这块有没有数据，有就操作，不然跳过
        if (m_pending_moves.find(new_bin)!=m_pending_moves.end()) {
            int needed_borrow = m_pending_moves.at(new_bin).size();
            std::vector<int>& particles_ip = m_pending_moves[new_bin];
            int borrow_bin = new_bin-1;
            int idx=ptile.m_bin_offsets[new_bin]-1; //指向第一个块的尾巴指针
            // #pragma omp simd
            while(needed_borrow>0){
                //idx一直指向需要插入的尾巴
                int insert_idx = ptile.findEmptySlotInBin(borrow_bin);//这是借用空槽的位置
                int pid=particles_ip.back();
                // printf("[2] Borrowing index %d from bin %d\n",idx,borrow_bin);
                if(insert_idx != -1) {
                    // 把借用位置的尾巴腾出空位
                    // ptile.m_free_slots[borrow_bin].pop_back();
                    // printf("\t1) Exchange ip %d at index %d with  ip %d at index %d \n",
                    //     insert_idx,ptile.m_local_index[idx],idx,
                    //     ptile.m_local_index[insert_idx]);
                    // ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                    // if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID)
                    //     ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                    if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID){
                        // printf("\t1) Right Exchange ip %d at index %d with  ip %d at index %d \n",
                        //     ptile.m_local_index[idx],idx,
                        //     ptile.m_local_index[insert_idx],insert_idx);    
                        ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                        ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                        ptile.m_free_slots[borrow_bin].pop_back();
                    } else {
                        // printf("\t1) Right Remove slot ip %d at index %d \n",
                        //     ptile.m_local_index[idx],idx);
                        auto it = std::find(ptile.m_free_slots[borrow_bin].begin(), 
                                            ptile.m_free_slots[borrow_bin].end(), 
                                            idx);
                        if (it != ptile.m_free_slots[borrow_bin].end()) {
                            *it = ptile.m_free_slots[borrow_bin].back();    // 用末尾那个元素覆盖它
                            ptile.m_free_slots[borrow_bin].pop_back();      // 弹出末尾
                        }
                    }
                    // 向借的位置填入粒子
                    // printf("\t2) Orgin borrow ip is %d \n",ptile.m_local_index[idx]);
                    // printf("\t3)Put ip %d in bin %d at index %d \n",
                    //     pid, new_bin, idx );
                    ptile.m_local_index[idx] = pid;
                    // ptile.m_bin_offsets[new_bin] 这两个参数统一更新了
                    // ptile.m_bin_lengths[new_bin]++;
                    ptile.m_pid_to_index_map[pid]=idx;
                    particles_ip.pop_back(); //一边填空一边更新pending_moves待插入的元素
                    needed_borrow--;
                    // num_borrow++;
                    idx--;
                } else {
                    amrex::Abort("ERROR: no more slot can borrow!!!");
                }
            }
            ptile.m_bin_offsets[new_bin]=idx+1;
            m_pending_moves.erase(numcell-1);
        }
        new_bin = 0;
        //判断这块有没有数据，有就操作，不然跳过
        if (m_pending_moves.find(new_bin)!=m_pending_moves.end()) {
            int needed_borrow = m_pending_moves.at(new_bin).size();
            std::vector<int>& particles_ip = m_pending_moves[new_bin];
            int borrow_bin = new_bin+1;
            int idx=ptile.m_bin_offsets[new_bin+1]; //指向第一个块的头指针
            // #pragma omp simd
            while(needed_borrow>0){
                //idx一直指向需要插入的尾巴
                int insert_idx = ptile.findEmptySlotInBin(borrow_bin);//这是借用空槽的位置
                int pid=particles_ip.back();
                // printf("[2] Borrowing index %d from bin %d\n",idx,borrow_bin);
                if(insert_idx != -1) {
                    // 把借用位置的尾巴腾出空位
                    // ptile.m_free_slots[borrow_bin].pop_back();
                    // printf("\t1) Exchange ip %d at index %d with  ip %d at index %d \n",
                    //     ptile.m_local_index[idx],idx,ptile.m_local_index[insert_idx],insert_idx);
                    // ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                    // if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID)
                    //     ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                    if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID){
                        // printf("\t1) Right Exchange ip %d at index %d with  ip %d at index %d \n",
                        //     ptile.m_local_index[idx],idx,
                        //     ptile.m_local_index[insert_idx],insert_idx);    
                        ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                        ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                        ptile.m_free_slots[borrow_bin].pop_back();
                    } else {
                        // printf("\t1) Right Remove slot ip %d at index %d \n",
                        //     ptile.m_local_index[idx],idx);
                        auto it = std::find(ptile.m_free_slots[borrow_bin].begin(), 
                                            ptile.m_free_slots[borrow_bin].end(), 
                                            idx);
                        if (it != ptile.m_free_slots[borrow_bin].end()) {
                            *it = ptile.m_free_slots[borrow_bin].back();    // 用末尾那个元素覆盖它
                            ptile.m_free_slots[borrow_bin].pop_back();      // 弹出末尾
                        }
                    }
                    // 向借的位置填入粒子
                    // printf("\t2) Orgin borrow ip is %d \n",ptile.m_local_index[idx]);
                    // printf("\t3)Put ip %d in bin %d at index %d \n",
                    //     pid, new_bin, idx );
                    ptile.m_local_index[idx] = pid;
                    // ptile.m_bin_offsets[new_bin] 这两个参数统一更新了
                    // ptile.m_bin_lengths[new_bin]++;
                    ptile.m_pid_to_index_map[pid]=idx;
                    particles_ip.pop_back(); //一边填空一边更新pending_moves待插入的元素
                    needed_borrow--;
                    // num_borrow++;
                    idx++;
                } else {
                    amrex::Abort("ERROR: no more slot can borrow!!!");
                }
            }
            ptile.m_bin_offsets[new_bin+1]=idx;
            m_pending_moves.erase(0);
        }

        //现在按顺序处理向右边两个允许借用
        // #pragma omp simd
        for (const auto& pair : m_pending_moves) {
            int new_bin=pair.first;
            std::vector<int>& particles_ip = m_pending_moves[new_bin];
            
            int needed_borrow = m_pending_moves.at(new_bin).size();
            int borrow_bin = new_bin+1;
            int idx=ptile.m_bin_offsets[new_bin+1]; //指向第一个块的头指针
            int borrow_flag=0; //指示
            // 先右后左，因为是向右顺序处理的
            // #pragma omp simd
            while(needed_borrow>0){
                borrow_flag=1;
                //idx一直指向需要插入的尾巴
                //先找右边
                int insert_idx = ptile.findEmptySlotInBin(borrow_bin);//这是借用空槽的位置
                if(insert_idx == -1 && borrow_bin==new_bin-1) amrex::Abort("ERROR borrow!");
                int pid=particles_ip.back();
                if(insert_idx != -1){
                    // printf("[2] Borrowing index %d from bin %d\n",idx,borrow_bin);
                    if (borrow_bin==new_bin+1) {
                        // 把借用位置的尾巴腾出空位
                        if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID){
                            // printf("\t1) Right Exchange ip %d at index %d with  ip %d at index %d \n",
                            //     ptile.m_local_index[idx],idx,
                            //     ptile.m_local_index[insert_idx],insert_idx);    
                            ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                            ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                            ptile.m_free_slots[borrow_bin].pop_back();
                        } else {
                            // printf("\t1) Right Remove slot ip %d at index %d \n",
                            //     ptile.m_local_index[idx],idx);
                            auto it = std::find(ptile.m_free_slots[borrow_bin].begin(), 
                                                ptile.m_free_slots[borrow_bin].end(), 
                                                idx);
                            if (it != ptile.m_free_slots[borrow_bin].end()) {
                                *it = ptile.m_free_slots[borrow_bin].back();    // 用末尾那个元素覆盖它
                                ptile.m_free_slots[borrow_bin].pop_back();      // 弹出末尾
                            }
                        }
                        // 向借的位置填入粒子
                        // printf("\t2) Orgin borrow ip is %d \n",ptile.m_local_index[idx]);
                        // printf("\t3)Put ip %d in bin %d at index %d \n",
                        //     pid, new_bin, idx );    
                        ptile.m_local_index[idx] = pid;
                        ptile.m_pid_to_index_map[pid]=idx;
                        particles_ip.pop_back(); //一边填空一边更新pending_moves待插入的元素
                        needed_borrow--;
                        idx++;
                        continue;
                    } 
                    if (borrow_bin==new_bin-1) {
                        // ptile.m_free_slots[borrow_bin].pop_back();
                        // printf("\t1) Left Exchange ip %d at index %d with  ip %d at index %d \n",
                        //     ptile.m_local_index[idx],idx,
                        //     ptile.m_local_index[insert_idx],insert_idx);    
                        // ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                        // if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID)
                        //     ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                        if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID){
                            // printf("\t1) Left Exchange ip %d at index %d with  ip %d at index %d \n",
                            //     ptile.m_local_index[idx],idx,
                            //     ptile.m_local_index[insert_idx],insert_idx);    
                            ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                            ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                            ptile.m_free_slots[borrow_bin].pop_back();
                        } else {
                            // printf("\t1) Left Remove slot ip %d at index %d \n",
                            //     ptile.m_local_index[idx],idx);
                            auto it = std::find(ptile.m_free_slots[borrow_bin].begin(), 
                                                ptile.m_free_slots[borrow_bin].end(), 
                                                idx);
                            if (it != ptile.m_free_slots[borrow_bin].end()) {
                                *it = ptile.m_free_slots[borrow_bin].back();    // 用末尾那个元素覆盖它
                                ptile.m_free_slots[borrow_bin].pop_back();      // 弹出末尾
                            }
                        }
                        // 向借的位置填入粒子
                        // printf("\t2) Orgin borrow ip is %d \n",ptile.m_local_index[idx]);
                        // printf("\t3)Put ip %d in bin %d at index %d \n",
                        //     pid, new_bin, idx );    
                        ptile.m_local_index[idx] = pid;
                        ptile.m_pid_to_index_map[pid]=idx;
                        particles_ip.pop_back(); //一边填空一边更新pending_moves待插入的元素
                        needed_borrow--;
                        idx--;
                        continue;
                    } 
                }else {
                    // printf("\t Right not enough!\n");
                    // printf("\tUpdate Right binoffsets from %d to %d \n",
                    //     ptile.m_bin_offsets[new_bin+1],idx);
                    ptile.m_bin_offsets[new_bin+1]=idx;
                    //右边找完还不够，就继续
                    borrow_bin = new_bin-1;
                    idx=ptile.m_bin_offsets[new_bin]-1; //指向第一个块的头指针
                }
            }
            if(borrow_flag){
                if (borrow_bin==new_bin+1) {
                    // printf("\tUpdate Right binoffsets from %d to %d \n",
                        // ptile.m_bin_offsets[new_bin+1],idx);
                    ptile.m_bin_offsets[new_bin+1]=idx;
                } else if((borrow_bin==new_bin-1)){
                    // printf("\tUpdate Left binoffsets from %d to %d \n",
                    //     ptile.m_bin_offsets[new_bin],idx+1);
                    ptile.m_bin_offsets[new_bin]=idx+1;
                }
            }
        }
        svetime[1]=rdtscv();
        borrow+=(svetime[1]-svetime[0]);

    }else{ //代价太高直接重组
        //重组就不需要增量修改那些，只需要pid_to_map正确即可
        // printf("DO REBUILD!\n");
        svetime[0]=rdtscv();
        const int vlf=svcntw();

        // svetime1[0]=rdtscv();
        ptile.m_was_rebuilt_this_step = true;
        std::vector<int> final_bin_counts(numcell, 0);
        // std::vector<int> final_bin_counts1(numcell, 0);
        float gap_ratio=WarpX::GetInstance().m_gap_ratio;
        const std::vector<int>& pid_to_bin_map = ptile.m_pid_to_bin_map;
        int np = ptile.m_num_particles;
        // #pragma omp simd
        // int* pointer_count=final_bin_counts.data();
        // #pragma omp simd reduction(+:pointer_count[:numcell])
        for(int ip=0;ip<np;ip++){
            // pointer_count[pid_to_bin_map[ip]]++;
            final_bin_counts[pid_to_bin_map[ip]]++;
        }  
        // svetime1[1]=rdtscv();
        // rebuild1[0]+=(svetime1[1]-svetime1[0]);
        //=========================
        // for(int i=0;i<numcell;i++){
        //     printf("final_bin_counts[%d]=%d\n",i,final_bin_counts[i]);
        // }
        // for(int i=0;i<np;i++){
        //     printf("pid_to_bin_map[%d]=%d size %d\n",i,pid_to_bin_map[i],pid_to_bin_map.size());
        // } 
        //==========================

        // svetime1[0]=rdtscv();
        ptile.m_bin_lengths = final_bin_counts;
        // ptile.m_capacity = np*(1+gap_ratio)+numcell*1.5;
        ptile.m_capacity = static_cast<int>(std::ceil(static_cast<double>(np) * (1.0 + gap_ratio)) + 2*numcell);
        // svetime1[1]=rdtscv();
        // rebuild1[1]+=(svetime1[1]-svetime1[0]);

        int current_offset = 0;
        ptile.m_bin_offsets[0] = 0;
        ptile.m_free_slots.assign(numcell,std::vector<int>());
        std::vector<int> gap(numcell,0);
        //===========================
        // int current_offset1 = 0;
        // std::vector<int> testoff=ptile.m_bin_offsets;
        // std::vector<std::vector<int>> testslot=ptile.m_free_slots;
        // std::vector<int> gap1(numcell,0);
        //===========================
        
        #pragma omp unroll
        for (int binID = 0; binID < numcell; binID+=vlf) {
            // svetime1[0]=rdtscv();
            svbool_t p_bin = svwhilelt_b32(binID,numcell);
            svint32_t np_in_bin=svld1_s32(p_bin,&final_bin_counts[binID]);
            // svst1_s32(p_bin,&ptile.m_bin_lengths[binID],np_in_bin);
            svint32_t gap_v=svadd_n_s32_x(p_bin,
                            svcvt_s32_f32_x(p_bin,svmul_n_f32_x(p_bin,
                            svcvt_f32_s32_x(p_bin,np_in_bin),gap_ratio)),
                            1);
            svst1_s32(p_bin,&gap[binID],gap_v);
            svint32_t block_size_v=svadd_s32_x(p_bin,gap_v,np_in_bin);
            //==========================
            // std::vector<int> gap1(vlf,0);
            // svst1_s32(p_bin,&gap1[0],gap_v);
            // std::vector<int> block_size(vlf,0);
            // svst1_s32(p_bin,&block_size[0],block_size_v);
            // const int vlf_len = std::min(vlf, static_cast<int>(numcell - binID));
            //==========================
            // svetime1[1]=rdtscv();
            // rebuild1[2]+=(svetime1[1]-svetime1[0]);

            // svetime1[0]=rdtscv();
            // 3. 向量化局部累加 (Intra-Vector Exclusive Scan)
            //    这是将串行依赖转换为并行计算的核心
            svint32_t local_scan_v = block_size_v;
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-1));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-2));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-4));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-8));
            local_scan_v = svadd_s32_m(p_bin, local_scan_v, svext_s32(svdup_s32(0), local_scan_v, 16-16));
            
            local_scan_v  = svadd_n_s32_x(p_bin, local_scan_v, current_offset);

            // 5. 存储最终计算出的偏移量结果
            //    注意，我们从 m_bin_offsets 的第 binID + 1 个位置开始存
            svst1_s32(p_bin, &ptile.m_bin_offsets[binID + 1], local_scan_v);
            // svst1_s32(p_bin, &testoff[binID + 1], final_offsets_v);

            // 6. 更新下一个块的全局偏移
            //    使用svaddv高效地计算当前块所有block_size的总和
            current_offset += svaddv_s32(p_bin, block_size_v);
            // svetime1[1]=rdtscv();
            // rebuild1[3]+=(svetime1[1]-svetime1[0]);

            //======================================
            // // #pragma omp simd
            // for(int ii=0;ii<vlf_len;ii++){
            //     current_offset1 += block_size[ii];
            //     // svetime1[0]=rdtscv();
            //     for(int i = current_offset1-1; i >= current_offset1-gap1[ii]; --i){
            //         testslot[binID+ii].push_back(i);
            //         printf("org push gap %d/%d into bin %d\n",
            //             i,
            //             gap1.size(),ii);
            //     }
            //     // svetime1[1]=rdtscv();
            //     // rebuild1[4]+=(svetime1[1]-svetime1[0]);
            //     // if(current_offset>ptile.m_capacity){
            //     //     amrex::Abort("ERROR: current_offset > m_capacity!!!");
            //     // }
            //     testoff[binID + 1+ii] = current_offset1;
            //     printf("block_size %d\n",block_size[ii]);
            // }
            //==================================
        }
        // svetime1[0]=rdtscv();
        if(ptile.m_bin_offsets[numcell]>=ptile.m_capacity){
            printf("ptile.m_bin_offsets[numcell] %d m_capacity %d \n"
                ,ptile.m_bin_offsets[numcell],ptile.m_capacity);
            amrex::Abort("ERROR: m_bin_offsets[numcell] >= m_capacity!!!");
        }
        // std::vector<int> target_vec;
        //下面对空slot的pushback操作也是一样的，由于vector<vector>在内存中散乱分布，
        //所以load的时候产生cachemiss导致额外开销，最好修改freeslot的数据结构以改善问题
        // svetime1[0]=rdtscv();
        std::vector<int>& binoff=ptile.m_bin_offsets;
        std::vector<std::vector<int>>& freeslot=ptile.m_free_slots;
        for (int binID = 0; binID < numcell; binID++) {
            int gap_size = gap[binID];
            int start_offset = binoff[binID + 1];
            auto& target_vec = freeslot[binID];
            target_vec.resize(gap_size);
            //=========================
            // for (int k = 0; k < gap_size; ++k) {
            //     target_vec[k] = start_offset - 1 - k;
            //     printf("sve push gap %d/%d into bin %d\n",
            //         target_vec[k],
            //         gap_size,binID);
            // }
            //=========================
            for (int k = 0; k < gap_size; k += vlf) {
                // 創建謂詞，安全處理最後一個不滿的向量塊
                svbool_t pg = svwhilelt_b32(k, gap_size);
            
                // a. 生成要寫入的數值向量
                //    首先，建立一個索引向量 [k, k+1, k+2, ...]
                svint32_t vec_k_indices = svindex_s32(k, 1);
                //    然後，建立一個填滿 start_offset-1 的向量
                svint32_t vec_base = svdup_n_s32(start_offset - 1);
                //    計算出最終要寫入的值：(start_offset-1) - k
                svint32_t values_to_store = svsub_s32_z(pg, vec_base, vec_k_indices);
            
                // b. 連續寫入 (Store)
                //    將產生的向量一次性寫入目標記憶體
                svst1_s32(pg, &target_vec[k], values_to_store);
            }
            //=========================
            // for (int k = 0; k < gap_size; ++k) {
            //     // target_vec[k] = start_offset - 1 - k;
            //     printf("sve push gap %d/%d into bin %d\n",
            //         target_vec[k],
            //         gap_size,binID);
            // }
            //=========================
        }
        // svetime1[1]=rdtscv();
        // rebuild1[4]+=(svetime1[1]-svetime1[0]);
        //====================================
        // int err=0;
        // for(int i=0;i<testoff.size();i++){
        //     printf("offset i %d sve %d org %d \n",i,testoff[i],ptile.m_bin_offsets[i]);
        //     if(testoff[i]!=ptile.m_bin_offsets[i]){
        //         err++;
        //     }
        // }
        // if(err>100) amrex::Abort("offset err!");
        // int err1=0;
        // for (int binID = 0; binID < numcell; binID++) {
        //     for(int i=0;i<testslot[binID].size();i++){
        //         printf("bin %d slot i %d sve %d org %d \n",binID,i
        //             ,testslot[binID][i]
        //             ,ptile.m_free_slots[binID][i]);
        //         if(testslot[binID][i]!=ptile.m_free_slots[binID][i]){
        //             err1++;
        //         }
        //     }
        // }
        // if(err1>100) amrex::Abort("slot err1!");
        //=======================================

        // svetime1[0]=rdtscv();
        ptile.m_capacity=ptile.m_bin_offsets[numcell];
        // ptile.m_num_particles=np;
        ptile.m_num_empty_slots = ptile.m_capacity - ptile.m_num_particles;
        ptile.m_local_index.assign(ptile.m_capacity, INVALID_PARTICLE_ID);
        // 初始化为每个 bin 的起始位置
        std::vector<int> next_write_slot = ptile.m_bin_offsets; 

        for(int ip=0;ip<np;ip++){
            int bin_id =pid_to_bin_map[ip];
            int insert_idx = next_write_slot[bin_id];
            // assert(insert_idx >= 0 && insert_idx < ptile.m_local_index.size());
            // assert(ip >= 0 && ip < ptile.m_pid_to_index_map.size());
            ptile.m_local_index[insert_idx] = ip;
            ptile.m_pid_to_index_map[ip]=insert_idx;
            next_write_slot[bin_id]++;
        }
        // svetime1[1]=rdtscv();
        // rebuild1[5]+=(svetime1[1]-svetime1[0]);

        ptile.m_was_rebuilt_this_step = true;
        // printf("%d DO FULL REBUILD!!!!!!!!!\n",rebuild);
        svetime[1]=rdtscv();
        rebuildtime+=(svetime[1]-svetime[0]);

    }
    m_pending_moves.clear();
#endif
    // svetime[1]=rdtscv();
    // sort_time+=(svetime[1]-svetime[0]); 

    // int n=10*12*13;
    // 三阶下面的rhocell是一个长方形，目前设计是x0y0z0 x0y1z0 x0y2z0 x0y3z0 x0y0z1 x0y1z1 x0y2z1 x0y3z1，这样的
    // 所以rhocell的尺寸就是x+1 y-2 z
    int nrho=(len.x+1)*(len.y-2)*(len.z);
    
    std::vector<amrex::Real> xrhocells(8*nrho);
    std::vector<amrex::Real> yrhocells(8*nrho);
    std::vector<amrex::Real> zrhocells(8*nrho);
    svetime[0]=rdtscv();
    // std::vector<amrex::Real> xrhocells(8*numcell, 0.0);
    // std::vector<amrex::Real> yrhocells(8*numcell, 0.0);
    // std::vector<amrex::Real> zrhocells(8*numcell, 0.0);
    // std::vector<amrex::Real> testsxwq(64*np_to_deposit, 0.0);

    // svetime[0]=rdtscv();
    sort_3d_sme_kernal_order_3_v3<3>(
        local_index,bin_length,bin_offsets,
        xrhocells,yrhocells,zrhocells,
        sx_mT,sy_mT,sz_mT,
        wqx,wqy,wqz,len,np_to_deposit,
        ip_list
    );
    // sort_3d_sme_kernal_order_3_v2<3>(
    //     local_index,bin_length,bin_offsets,
    //     xrhocells,yrhocells,zrhocells,
    //     sx_m,sy_m,sz_m,
    //     wqx,wqy,wqz,len,np_to_deposit,testsxwq,
    //     ip_list
    // );
    // sort_3d_sme_kernal_order_3_test<3>(
    //     local_index,bin_length,bin_offsets,
    //     xrhocells,yrhocells,zrhocells,
    //     sx_m,sy_m,sz_m,
    //     wqx,wqy,wqz,len,np_to_deposit,numcell,
    //     xjstride,xkstride,
    //     testsxwq);
    svetime[1]=rdtscv();
    cale_time+=(svetime[1]-svetime[0]);

    // test_sxwq=testsxwq;

    long nx=xjstride;
    long nxy=xkstride;
    long moff[8] = {0,nx,2*nx,3*nx,nxy,nxy+nx,nxy+2*nx,nxy+3*nx};
    // long moff[8] = {0, 1, nx, nx+1, nxy, nxy+1, nx+nxy, nx+nxy+1};
    // long moff[8] = {-1,0,1,2,2*nx-1,2*nx,2*nx+1,2*nx+2};
    // long moff[8] = {-nxy,0,nxy,2*nxy,nx-nxy,nx,nx+nxy,nx+2*nxy};
    // printf("xjstride %d xkstride %d\n",xjstride,xkstride);
    // printf("nnx %d nnxny %d\n",nnx,nnxny);
    long lnx=len.x+1;
    long lnxy=lnx*(len.y-2);

    svetime[0]=rdtscv();
    #pragma omp simd
    for (int iz = 0; iz < len.z; ++iz) {
        #pragma omp simd
        for (int iy = 0; iy < len.y-2; ++iy) { 
            #if 0
            for (int ix = 0; ix <= len.x; ix++) {
                // scalar mode
                // long j = lo.x + ix;
                // long k = lo.y + iy;
                // long l = lo.z + iz;
                // long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                long jxoffset = ix + iy * xjstride + iz * xkstride;
                long cell_idx=ix + iy * lnx + iz * lnxy;
                long xoffset=8*cell_idx;
                //===================
                // printf("ix %d iy %d iz %d\n",ix,iy,iz);
                // for(int ii=0;ii<8;ii++){
                //     printf("----jxoffset %d xoffset %d\n",jxoffset+moff[ii],xoffset+ii);
                //     printf("----jx_arr[%d+%d] %f += xrhocells[%d+%d] %f\n\n"
                //         ,jxoffset,moff[ii],jx_arr.p[jxoffset+moff[ii]],cell_idx,ii,xrhocells[ii+xoffset]);
                // }
                //===================
                jx_arr.p[jxoffset+moff[0]]+=xrhocells[0+xoffset];
                jx_arr.p[jxoffset+moff[1]]+=xrhocells[1+xoffset];
                jx_arr.p[jxoffset+moff[2]]+=xrhocells[2+xoffset];
                jx_arr.p[jxoffset+moff[3]]+=xrhocells[3+xoffset];
                jx_arr.p[jxoffset+moff[4]]+=xrhocells[4+xoffset];
                jx_arr.p[jxoffset+moff[5]]+=xrhocells[5+xoffset];
                jx_arr.p[jxoffset+moff[6]]+=xrhocells[6+xoffset];
                jx_arr.p[jxoffset+moff[7]]+=xrhocells[7+xoffset];
            }
            #endif

            #if 1
            #pragma unroll      
            for (int ix = 0; ix <= len.x; ix+=vl) {
                // svetime[0]=rdtscv();

                // vector
                svbool_t p=svwhilele_b64(ix,(len.x));
                svuint64_t rho_index = svindex_u64(0ULL, 8ULL);
                long jxoffset=ix + iy * xjstride + iz * xkstride;
                long cell_idx=ix + iy * lnx + iz * lnxy;
                // long jxoffset=xoffset;
                long irhox=8*cell_idx;
                Vec jx0=Vec::Load(p,&jx_arr.p[jxoffset+moff[0]]);
                svfloat64_t rhox0=svld1_gather_u64index_f64(p,&xrhocells[0+irhox],rho_index);
                jx0+=rhox0;
                jx0.Store(p,&jx_arr.p[jxoffset+moff[0]]);

                Vec jx1=Vec::Load(p,&jx_arr.p[jxoffset+moff[1]]);
                svfloat64_t rhox1=svld1_gather_u64index_f64(p,&xrhocells[1+irhox],rho_index);
                jx1+=rhox1;
                jx1.Store(p,&jx_arr.p[jxoffset+moff[1]]);

                Vec jx2=Vec::Load(p,&jx_arr.p[jxoffset+moff[2]]);
                svfloat64_t rhox2=svld1_gather_u64index_f64(p,&xrhocells[2+irhox],rho_index);
                jx2+=rhox2;
                jx2.Store(p,&jx_arr.p[jxoffset+moff[2]]);

                Vec jx3=Vec::Load(p,&jx_arr.p[jxoffset+moff[3]]);
                svfloat64_t rhox3=svld1_gather_u64index_f64(p,&xrhocells[3+irhox],rho_index);
                jx3+=rhox3;
                jx3.Store(p,&jx_arr.p[jxoffset+moff[3]]);

                Vec jx4=Vec::Load(p,&jx_arr.p[jxoffset+moff[4]]);
                svfloat64_t rhox4=svld1_gather_u64index_f64(p,&xrhocells[4+irhox],rho_index);
                jx4+=rhox4;
                jx4.Store(p,&jx_arr.p[jxoffset+moff[4]]);

                Vec jx5=Vec::Load(p,&jx_arr.p[jxoffset+moff[5]]);
                svfloat64_t rhox5=svld1_gather_u64index_f64(p,&xrhocells[5+irhox],rho_index);
                jx5+=rhox5;
                jx5.Store(p,&jx_arr.p[jxoffset+moff[5]]);

                Vec jx6=Vec::Load(p,&jx_arr.p[jxoffset+moff[6]]);
                svfloat64_t rhox6=svld1_gather_u64index_f64(p,&xrhocells[6+irhox],rho_index);
                jx6+=rhox6;
                jx6.Store(p,&jx_arr.p[jxoffset+moff[6]]);

                Vec jx7=Vec::Load(p,&jx_arr.p[jxoffset+moff[7]]);
                svfloat64_t rhox7=svld1_gather_u64index_f64(p,&xrhocells[7+irhox],rho_index);
                jx7+=rhox7;
                jx7.Store(p,&jx_arr.p[jxoffset+moff[7]]);
                
        //         // y
        //         // uint64_t irhoy = ix + iy * yjstride + iz * ykstride;
        //         // svuint64_t rhoy_index = svindex_u64(irhoy, 8ULL);
        //         // long jyoffset = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
        //         // long yoffset = ix + iy * yjstride + iz * ykstride;
        //         long jyoffset=xoffset;
        //         long irhoy=irhox;
        //         Vec jy0=Vec::Load(p,&jy_arr.p[jyoffset+moff[0]]);
        //         svfloat64_t rhoy0=svld1_gather_u64index_f64(p,&yrhocells[0+irhoy],rho_index);
        //         jy0+=rhoy0;
        //         jy0.Store(p,&jy_arr.p[jyoffset+moff[0]]);

        //         Vec jy1=Vec::Load(p,&jy_arr.p[jyoffset+moff[1]]);
        //         svfloat64_t rhoy1=svld1_gather_u64index_f64(p,&yrhocells[1+irhoy],rho_index);
        //         jy1+=rhoy1;
        //         jy1.Store(p,&jy_arr.p[jyoffset+moff[1]]);

        //         Vec jy2=Vec::Load(p,&jy_arr.p[jyoffset+moff[2]]);
        //         svfloat64_t rhoy2=svld1_gather_u64index_f64(p,&yrhocells[2+irhoy],rho_index);
        //         jy2+=rhoy2;
        //         jy2.Store(p,&jy_arr.p[jyoffset+moff[2]]);

        //         Vec jy3=Vec::Load(p,&jy_arr.p[jyoffset+moff[3]]);
        //         svfloat64_t rhoy3=svld1_gather_u64index_f64(p,&yrhocells[3+irhoy],rho_index);
        //         jy3+=rhoy3;
        //         jy3.Store(p,&jy_arr.p[jyoffset+moff[3]]);

        //         Vec jy4=Vec::Load(p,&jy_arr.p[jyoffset+moff[4]]);
        //         svfloat64_t rhoy4=svld1_gather_u64index_f64(p,&yrhocells[4+irhoy],rho_index);
        //         jy4+=rhoy4;
        //         jy4.Store(p,&jy_arr.p[jyoffset+moff[4]]);

        //         Vec jy5=Vec::Load(p,&jy_arr.p[jyoffset+moff[5]]);
        //         svfloat64_t rhoy5=svld1_gather_u64index_f64(p,&yrhocells[5+irhoy],rho_index);
        //         jy5+=rhoy5;
        //         jy5.Store(p,&jy_arr.p[jyoffset+moff[5]]);

        //         Vec jy6=Vec::Load(p,&jy_arr.p[jyoffset+moff[6]]);
        //         svfloat64_t rhoy6=svld1_gather_u64index_f64(p,&yrhocells[6+irhoy],rho_index);
        //         jy6+=rhoy6;
        //         jy6.Store(p,&jy_arr.p[jyoffset+moff[6]]);

        //         Vec jy7=Vec::Load(p,&jy_arr.p[jyoffset+moff[7]]);
        //         svfloat64_t rhoy7=svld1_gather_u64index_f64(p,&yrhocells[7+irhoy],rho_index);
        //         jy7+=rhoy7;
        //         jy7.Store(p,&jy_arr.p[jyoffset+moff[7]]);

        //         // z
        //         // uint64_t irhoz = ix + iy * zjstride + iz * zkstride;
        //         // svuint64_t rhoz_index = svindex_u64(irhoz, 8ULL);
        //         // long jzoffset = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
        //         long zoffset = ix + iy * zjstride + iz * zkstride;
        //         long jzoffset=xoffset;
        //         long irhoz=irhox;
        //         Vec jz0=Vec::Load(p,&jz_arr.p[jzoffset+moff[0]]);
        //         svfloat64_t rhoz0=svld1_gather_u64index_f64(p,&zrhocells[0+irhoz],rho_index);
        //         jz0+=rhoz0;
        //         jz0.Store(p,&jz_arr.p[jzoffset+moff[0]]);

        //         Vec jz1=Vec::Load(p,&jz_arr.p[jzoffset+moff[1]]);
        //         svfloat64_t rhoz1=svld1_gather_u64index_f64(p,&zrhocells[1+irhoz],rho_index);
        //         jz1+=rhoz1;
        //         jz1.Store(p,&jz_arr.p[jzoffset+moff[1]]);

        //         Vec jz2=Vec::Load(p,&jz_arr.p[jzoffset+moff[2]]);
        //         svfloat64_t rhoz2=svld1_gather_u64index_f64(p,&zrhocells[2+irhoz],rho_index);
        //         jz2+=rhoz2;
        //         jz2.Store(p,&jz_arr.p[jzoffset+moff[2]]);

        //         Vec jz3=Vec::Load(p,&jz_arr.p[jzoffset+moff[3]]);
        //         svfloat64_t rhoz3=svld1_gather_u64index_f64(p,&zrhocells[3+irhoz],rho_index);
        //         jz3+=rhoz3;
        //         jz3.Store(p,&jz_arr.p[jzoffset+moff[3]]);

        //         Vec jz4=Vec::Load(p,&jz_arr.p[jzoffset+moff[4]]);
        //         svfloat64_t rhoz4=svld1_gather_u64index_f64(p,&zrhocells[4+irhoz],rho_index);
        //         jz4+=rhoz4;
        //         jz4.Store(p,&jz_arr.p[jzoffset+moff[4]]);

        //         Vec jz5=Vec::Load(p,&jz_arr.p[jzoffset+moff[5]]);
        //         svfloat64_t rhoz5=svld1_gather_u64index_f64(p,&zrhocells[5+irhoz],rho_index);
        //         jz5+=rhoz5;
        //         jz5.Store(p,&jz_arr.p[jzoffset+moff[5]]);

        //         Vec jz6=Vec::Load(p,&jz_arr.p[jzoffset+moff[6]]);
        //         svfloat64_t rhoz6=svld1_gather_u64index_f64(p,&zrhocells[6+irhoz],rho_index);
        //         jz6+=rhoz6;
        //         jz6.Store(p,&jz_arr.p[jzoffset+moff[6]]);

        //         Vec jz7=Vec::Load(p,&jz_arr.p[jzoffset+moff[7]]);
        //         svfloat64_t rhoz7=svld1_gather_u64index_f64(p,&zrhocells[7+irhoz],rho_index);
        //         jz7+=rhoz7;
        //         jz7.Store(p,&jz_arr.p[jzoffset+moff[7]]);

                // svetime[1]=rdtscv();
                // reduce_time+=(svetime[1]-svetime[0]);
            }
            #endif
        }
    }
    svetime[1]=rdtscv();
    reduce_time+=(svetime[1]-svetime[0]);
    
    // total_time[1]=rdtscv();
    // total_time[2]+=total_time[1]-total_time[0];

    // int world_rank;
    // MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);
    // int tid = omp_get_thread_num();
    // if (world_rank == 0 && tid == 0) {
        printf("================SME=================\n");
        printf("SME Total:%llu \n",(unsigned long long)(precompute+
            total_sort_time+cale_time+reduce_time));
        // printf("SME Total:%d \n",total_time[2]);
        printf("\t precompute:%lu \n",precompute);
        printf("\t\t --precompute1:%lu \n",precompute1[0]);
        printf("\t\t --precompute2:%lu \n",precompute1[1]);
        // printf("\t\t --precompute3:%lu \n",precompute1[2]);
        // printf("\t\t --precompute4:%lu \n",precompute1[3]);
        printf("\t total_sort_time:%lu \n",total_sort_time);
        printf("\t\t --sort_time:%lu \n",sort_time[0]);
        printf("\t\t --pma compact:%lu \n",sort_time[1]);
        // printf("\t\t --presort:%lu \n",presort);
        // printf("\t\t --borrow:%lu \n",borrow);
        // printf("\t\t --rebuildtime:%lu \n",rebuildtime);
        printf("\t cale_time:%lu \n",cale_time);
        printf("\t reduce_time:%lu \n",reduce_time);
        // printf("\t\t update1:%d ",update[0]);
        // printf(" update2:%d \n",update[1]);
        // printf("\t\t --Dupdate0:%d \n",update1[0]);
        // printf("\t\t --Dupdate1:%d \n",update1[1]);
        // printf("\t\t --Dupdate2:%d \n",update1[2]);
        // printf("\t\t --Dupdate3:%d \n",update1[3]);
        // printf("\t\t --Dupdate4:%d \n",update1[4]);
        // printf("\t\t --Dupdate5:%d \n",update1[5]);
        // printf("\t\t presort:%d \n",presort);
        // printf("\t\t insert:%d \n",insert);
        // printf("\t\t borrow:%d \n",borrow);
        // printf("\t\t rebuildtime:%d \n",rebuildtime);
        // printf("\t\t --Drebuild0:%d \n",rebuild1[0]);
        // printf("\t\t --Drebuild1:%d \n",rebuild1[1]);
        // printf("\t\t --Drebuild2:%d \n",rebuild1[2]);
        // printf("\t\t --Drebuild3:%d \n",rebuild1[3]);
        // printf("\t\t --Drebuild4:%d \n",rebuild1[4]);
        // printf("\t\t --Drebuild5:%d \n",rebuild1[5]);
        // printf("\t reduce_time:%lu \n",reduce_time);
    // }
}

template <int depos_order>
void doDepositionShapeN_3d_sme_order3_compact (const GetParticlePosition<PIdx>& GetPosition,
                        const amrex::ParticleReal * const wp,
                        const amrex::ParticleReal * const uxp,
                        const amrex::ParticleReal * const uyp,
                        const amrex::ParticleReal * const uzp,
                        const int* ion_lev,
                        HBM_Inner_Vector_Real& wqx,
                        HBM_Inner_Vector_Real& wqy,
                        HBM_Inner_Vector_Real& wqz,
                        HBM_Inner_Vector_Real& sx_mT,
                        HBM_Inner_Vector_Real& sy_mT,
                        HBM_Inner_Vector_Real& sz_mT,
                        HBM_Inner_Vector_Real& xrhocells,
                        HBM_Inner_Vector_Real& yrhocells,
                        HBM_Inner_Vector_Real& zrhocells,
                        HBM_Inner_Vector_Int& newbin,
                        amrex::FArrayBox& jx_fab,
                        amrex::FArrayBox& jy_fab,
                        amrex::FArrayBox& jz_fab,
                        long np_to_deposit,
                        amrex::Real relative_time,
                        const amrex::XDim3 & dinv,
                        const amrex::XDim3 & xyzmin,
                        amrex::Dim3 lo,
                        amrex::Dim3 hi,
                        amrex::Dim3 len,
                        amrex::Real q,
                        std::vector<int>& test,
                        std::vector<double>& test0,
                        std::vector<int>& testbin,
                        std::vector<double>& test_sxm,
                        ParticleTileType& ptile, const amrex::Box& box,
                        std::vector<amrex::Real>& test_rhocells,
                        std::vector<amrex::Real>& test_sxwq,
                        [[maybe_unused]]int n_rz_azimuthal_modes)
{
    // WARPX_PROFILE("doDepositionShapeN_3d_sme_order3()");
    uint64_t total_time[3]={0};
    using namespace std::chrono;
    using namespace amrex::literals;
    uint64_t precompute=0;
    uint64_t precompute1[4]={0};
    uint64_t cale_time=0;
    uint64_t sort_time[2]={0};
    uint64_t total_sort_time={0};
        uint64_t update[2]={0};
        uint64_t update1[7]={0};
        uint64_t presort=0;
        uint64_t insert=0;
        uint64_t borrow=0;
        uint64_t rebuildtime=0;
        uint64_t rebuild1[7]={0};
    uint64_t reduce_time=0;
    uint64_t svetime[3]={0};
    uint64_t svetime1[3]={0};
    // uint64_t branch_time=0;
    
    total_time[0]=rdtscv();
    constexpr int nshapes = depos_order + 1;

    
    // std::vector<amrex::Real> wqx(np_to_deposit);
    // std::vector<amrex::Real> wqy(np_to_deposit);
    // std::vector<amrex::Real> wqz(np_to_deposit);
    // std::vector<amrex::Real> sx_mT(np_to_deposit*nshapes);
    // std::vector<amrex::Real> sy_mT(np_to_deposit*nshapes);
    // std::vector<amrex::Real> sz_mT(np_to_deposit*nshapes);
    // std::vector<int> newbin(np_to_deposit);

    svetime[0]=rdtscv();
    const bool do_ionization = ion_lev;
    const amrex::Real invvol = dinv.x*dinv.y*dinv.z; 
    const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;

    amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
    amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
    amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();

    
    int vl=svcntd();

    const amrex::ParticleReal* mx = GetPosition.m_x;
    const amrex::ParticleReal* my = GetPosition.m_y;
    const amrex::ParticleReal* mz = GetPosition.m_z;
    
    auto compute_shape_factor_order3_v2 = [](double* sx, Vec xmid, svbool_t p, int np) {
        intVec i_newv = svcvt_s64_f64_z(p, xmid);

        Vec j = svrintz_x(p, xmid);
        Vec xint = xmid - j;
        Vec temp = 1.0 - xint;

        Vec sx0 = (1.0 / 6.0) * temp * temp * temp;
        sx0.Store(p, &sx[0*np]);
        Vec sx1 = (2.0 / 3.0) - xint * xint * (1.0 - xint * 0.5);
        sx1.Store(p, &sx[1*np]);
        Vec sx2 = (2.0 / 3.0) - temp * temp * (1.0 - 0.5 *temp);
        sx2.Store(p, &sx[2*np]);
        Vec sx3 = (1.0 / 6.0) * xint * xint * xint;
        sx3.Store(p, &sx[3*np]);

        return i_newv-1;
    };

    // 预计算网格步长
    const int xjstride = jx_arr.jstride;
    const int xkstride = jx_arr.kstride;
    const int yjstride = jy_arr.jstride;
    const int ykstride = jy_arr.kstride;
    const int zjstride = jz_arr.jstride;
    const int zkstride = jz_arr.kstride;

    long nnx = len.x;
    long nny = len.y;
    long nnxny = nnx*nny;
    svetime[1]=rdtscv();
    precompute1[0]+=(svetime[1]-svetime[0]); 

    
    svetime[0]=rdtscv();
    #pragma unroll
    for(long ip=0;ip<np_to_deposit;ip+=vl){
        // svetime[0]=rdtscv();
        // 计算基本物理量
        svbool_t p=svwhilelt_b64(ip,np_to_deposit);

        // Inverse of Lorentz factor gamma
        Vec uxp_v=Vec::Load(p,&uxp[ip]);
        Vec uyp_v=Vec::Load(p,&uyp[ip]);
        Vec uzp_v=Vec::Load(p,&uzp[ip]);
        Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                    + uyp_v * uyp_v * clightsq
                                    + uzp_v * uzp_v * clightsq).Sqrt();
        // Product of particle charges and weights
        Vec wp_v=Vec::Load(p,&wp[ip]);
        Vec wq_v = q * wp_v;

        // Current particle positions (in physical units)
        Vec xp = Vec::Load(p, &mx[ip]);
        Vec yp = Vec::Load(p, &my[ip]);
        Vec zp = Vec::Load(p, &mz[ip]);

        // Particle velocities
        Vec vx_v = uxp_v * gaminv;
        Vec wqx_v = wq_v * invvol * vx_v;
        wqx_v.Store(p, &wqx[ip]);
        Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x;

        Vec vy_v = uyp_v * gaminv;
        Vec wqy_v = wq_v * invvol * vy_v;
        wqy_v.Store(p, &wqy[ip]);
        Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y;

        Vec vz_v = uzp_v * gaminv;
        Vec wqz_v = wq_v * invvol * vz_v;
        wqz_v.Store(p, &wqz[ip]);
        Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z;
        
        intVec j_cellv2 = compute_shape_factor_order3_v2( &sx_mT[ip], xmid, p,np_to_deposit);
        intVec k_cellv2 = compute_shape_factor_order3_v2( &sy_mT[ip], ymid, p,np_to_deposit);
        intVec l_cellv2 = compute_shape_factor_order3_v2( &sz_mT[ip], zmid, p,np_to_deposit); 
        intVec new_bin_v = (j_cellv2) + 
                (k_cellv2)* nnx + 
                (l_cellv2) * nnxny;
        svst1w_s64(p, &newbin[ip], new_bin_v);
    }
    svetime[1]=rdtscv();
    precompute1[1]+=(svetime[1]-svetime[0]);
    precompute=precompute1[0]+precompute1[1]; 
   
    const int numcell=ptile.m_num_bins;
    
    // 只允许找左右两边借的方案，更快更稳定，但是不能扩展
    ///////////判断、增量处理（删除、更新索引）、或重组过程////////////
    // for(int i=0;i<ptile.m_local_index.size();i++){
    //     printf("index[%d]=%d\n",i,ptile.m_local_index[i]);
    // }
    svetime[0]=rdtscv();
    // increment_sort_particles(np_to_deposit,ptile,newbin,numcell);
    increment_sort_particles3(np_to_deposit,ptile,newbin,numcell);
    svetime[1]=rdtscv();
    sort_time[0]+=(svetime[1]-svetime[0]);
    
    auto& local_index = ptile.m_local_index;
    auto& bin_offsets = ptile.m_bin_offsets;
    auto& bin_length = ptile.m_bin_lengths;
    
    svetime[0]=rdtscv();
    //=========================
    // for(int ip=0;ip<np_to_deposit;ip++){
    //     printf("m_pid_to_index_map[%d]=%d\n",ip,ptile.m_pid_to_index_map[ip]);

    // }
    // for(int i=0;i<local_index.size();i++){
    //     printf("index[%d]=%d\n",i,local_index[i]);
    // }
    // amrex::Abort("END");
    //========================
    // std::vector<int> ip_list(np_to_deposit); 
    // test_iplist(np_to_deposit,ptile,newbin,numcell);
    // sorted_pma_compact2(local_index,ip_list);
    //==========================================
    // std::vector<int> ip_list1(np_to_deposit);
    // sorted_pma_compact(local_index,bin_length,bin_offsets,
    //     np_to_deposit,numcell,ip_list1
    // );
    // int N=local_index.size();
    // for(int i=0;i<N;i++){
    //     printf("local_index[%d]=%d \n",i,local_index[i]);
    // }
    // for(int i=0;i<np_to_deposit;i++){
    //     printf("iplist[%d] %d, true %d\n",i,ip_list[i],ip_list1[i]);
    // }
    // exit(0);
    
    //==========================================
    svetime[1]=rdtscv();
    sort_time[1]+=(svetime[1]-svetime[0]);
    total_sort_time=(sort_time[0]+sort_time[1]);
    
    //=====================================
#if 0
    uint64_t looptime[2]={0};
    int binnx = len.x;
    int binny = len.y;
    int binnxy = binnx*binny;
    svetime[0]=rdtscv();

    // int ip_ptr=0;
    for (int iz = 0; iz < len.z-2; ++iz) {
        for (int iy = 0; iy < len.y-2; ++iy) {       
            for (int ix = 0; ix < len.x-2; ix++) {
                // svetime[0]=rdtscm();
                int old_bin=(ix) + (iy) * binnx + (iz) * binnxy;

                int binlength = bin_length[old_bin];
                int binoffset = bin_offsets[old_bin];
                for(int i=0;i<binlength;++i){
                    int ip = local_index[binoffset+i];
                    ip*=3;
                    asm volatile("" ::: "memory");
                }
            }
        }
    }
    svetime[1]=rdtscv();
    looptime[0]+=(svetime[1]-svetime[0]);
    svetime[0]=rdtscv();


    int ip_ptr=0;
    for (int iz = 0; iz < len.z-2; ++iz) {
        for (int iy = 0; iy < len.y-2; ++iy) {       
            for (int ix = 0; ix < len.x-2; ix++) {
                // svetime[0]=rdtscm();
                int old_bin=(ix) + (iy) * binnx + (iz) * binnxy;

                int binlength = bin_length[old_bin];
                for(int i=0;i<binlength;++i){
                    int ip = ip_list[ip_ptr+i];
                    ip*=3;
                    asm volatile("" ::: "memory");
                }
                ip_ptr+=binlength;
            }
        }
    }
    svetime[1]=rdtscv();
    looptime[1]+=(svetime[1]-svetime[0]);
    printf(" loop1:%d \n",looptime[0]);
    printf(" loop2:%d \n",looptime[1]);
#endif



    //================================

    // int n=10*12*13;
    // 三阶下面的rhocell是一个长方形，目前设计是x0y0z0 x0y1z0 x0y2z0 x0y3z0 x0y0z1 x0y1z1 x0y2z1 x0y3z1，这样的
    // 所以rhocell的尺寸就是x+1 y-2 z
    // int nrho=(len.x+1)*(len.y-2)*(len.z);
    
    // need move into HBM
    // std::vector<amrex::Real> xrhocells(8*nrho);
    // std::vector<amrex::Real> yrhocells(8*nrho);
    // std::vector<amrex::Real> zrhocells(8*nrho);
    
    svetime[0]=rdtscv();
    sort_3d_sme_kernal_order_3_compact_jxjyjz<3>(
        local_index,bin_length,bin_offsets,
        xrhocells,yrhocells,zrhocells,
        sx_mT,sy_mT,sz_mT,
        wqx,wqy,wqz,len,np_to_deposit
    );
    // sort_3d_sme_kernal_order_3_compact<3>(
    //     local_index,bin_length,bin_offsets,
    //     xrhocells,yrhocells,zrhocells,
    //     sx_mT,sy_mT,sz_mT,
    //     wqx,wqy,wqz,len,np_to_deposit
    // );
    svetime[1]=rdtscv();
    cale_time+=(svetime[1]-svetime[0]);
    printf("\t cale_time compact:%d \n",cale_time);


    // svetime[0]=rdtscv();
    // sort_3d_sme_kernal_order_3_v3<3>(
    //     local_index,bin_length,bin_offsets,
    //     xrhocells,yrhocells,zrhocells,
    //     sx_mT,sy_mT,sz_mT,
    //     wqx,wqy,wqz,len,np_to_deposit,
    //     ip_list
    // );
    // svetime[1]=rdtscv();
    // cale_time+=(svetime[1]-svetime[0]);
    // printf("\t cale_time v3:%d \n",cale_time);


    // test_sxwq=testsxwq;

    long nx=xjstride;
    long nxy=xkstride;
    long moff[8] = {0,nx,2*nx,3*nx,nxy,nxy+nx,nxy+2*nx,nxy+3*nx};
    
    long lnx=len.x+1;
    long lnxy=lnx*(len.y-2);

    svetime[0]=rdtscv();
    #pragma omp simd
    for (int iz = 0; iz < len.z; ++iz) {
        #pragma omp simd
        for (int iy = 0; iy < len.y-2; ++iy) { 
            #if 0
            for (int ix = 0; ix <= len.x; ix++) {
                // scalar mode
                // long j = lo.x + ix;
                // long k = lo.y + iy;
                // long l = lo.z + iz;
                // long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                long jxoffset = ix + iy * xjstride + iz * xkstride;
                long cell_idx=ix + iy * lnx + iz * lnxy;
                long xoffset=8*cell_idx;
                //===================
                // printf("ix %d iy %d iz %d\n",ix,iy,iz);
                // for(int ii=0;ii<8;ii++){
                //     printf("----jxoffset %d xoffset %d\n",jxoffset+moff[ii],xoffset+ii);
                //     printf("----jx_arr[%d+%d] %f += xrhocells[%d+%d] %f\n\n"
                //         ,jxoffset,moff[ii],jx_arr.p[jxoffset+moff[ii]],cell_idx,ii,xrhocells[ii+xoffset]);
                // }
                //===================
                jx_arr.p[jxoffset+moff[0]]+=xrhocells[0+xoffset];
                jx_arr.p[jxoffset+moff[1]]+=xrhocells[1+xoffset];
                jx_arr.p[jxoffset+moff[2]]+=xrhocells[2+xoffset];
                jx_arr.p[jxoffset+moff[3]]+=xrhocells[3+xoffset];
                jx_arr.p[jxoffset+moff[4]]+=xrhocells[4+xoffset];
                jx_arr.p[jxoffset+moff[5]]+=xrhocells[5+xoffset];
                jx_arr.p[jxoffset+moff[6]]+=xrhocells[6+xoffset];
                jx_arr.p[jxoffset+moff[7]]+=xrhocells[7+xoffset];
            }
            #endif

            #if 1
            #pragma unroll      
            for (int ix = 0; ix <= len.x; ix+=vl) {
                // svetime[0]=rdtscv();

                // vector
                svbool_t p=svwhilele_b64(ix,(len.x));
                svuint64_t rho_index = svindex_u64(0ULL, 8ULL);
                long jxoffset=ix + iy * xjstride + iz * xkstride;
                long cell_idx=ix + iy * lnx + iz * lnxy;
                // long jxoffset=xoffset;
                long irhox=8*cell_idx;
                Vec jx0=Vec::Load(p,&jx_arr.p[jxoffset+moff[0]]);
                svfloat64_t rhox0=svld1_gather_u64index_f64(p,&xrhocells[0+irhox],rho_index);
                jx0+=rhox0;
                jx0.Store(p,&jx_arr.p[jxoffset+moff[0]]);

                Vec jx1=Vec::Load(p,&jx_arr.p[jxoffset+moff[1]]);
                svfloat64_t rhox1=svld1_gather_u64index_f64(p,&xrhocells[1+irhox],rho_index);
                jx1+=rhox1;
                jx1.Store(p,&jx_arr.p[jxoffset+moff[1]]);

                Vec jx2=Vec::Load(p,&jx_arr.p[jxoffset+moff[2]]);
                svfloat64_t rhox2=svld1_gather_u64index_f64(p,&xrhocells[2+irhox],rho_index);
                jx2+=rhox2;
                jx2.Store(p,&jx_arr.p[jxoffset+moff[2]]);

                Vec jx3=Vec::Load(p,&jx_arr.p[jxoffset+moff[3]]);
                svfloat64_t rhox3=svld1_gather_u64index_f64(p,&xrhocells[3+irhox],rho_index);
                jx3+=rhox3;
                jx3.Store(p,&jx_arr.p[jxoffset+moff[3]]);

                Vec jx4=Vec::Load(p,&jx_arr.p[jxoffset+moff[4]]);
                svfloat64_t rhox4=svld1_gather_u64index_f64(p,&xrhocells[4+irhox],rho_index);
                jx4+=rhox4;
                jx4.Store(p,&jx_arr.p[jxoffset+moff[4]]);

                Vec jx5=Vec::Load(p,&jx_arr.p[jxoffset+moff[5]]);
                svfloat64_t rhox5=svld1_gather_u64index_f64(p,&xrhocells[5+irhox],rho_index);
                jx5+=rhox5;
                jx5.Store(p,&jx_arr.p[jxoffset+moff[5]]);

                Vec jx6=Vec::Load(p,&jx_arr.p[jxoffset+moff[6]]);
                svfloat64_t rhox6=svld1_gather_u64index_f64(p,&xrhocells[6+irhox],rho_index);
                jx6+=rhox6;
                jx6.Store(p,&jx_arr.p[jxoffset+moff[6]]);

                Vec jx7=Vec::Load(p,&jx_arr.p[jxoffset+moff[7]]);
                svfloat64_t rhox7=svld1_gather_u64index_f64(p,&xrhocells[7+irhox],rho_index);
                jx7+=rhox7;
                jx7.Store(p,&jx_arr.p[jxoffset+moff[7]]);
                
                // y
                // uint64_t irhoy = ix + iy * yjstride + iz * ykstride;
                // svuint64_t rhoy_index = svindex_u64(irhoy, 8ULL);
                // long jyoffset = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
                // long yoffset = ix + iy * yjstride + iz * ykstride;
                long jyoffset=jxoffset;
                long irhoy=irhox;
                Vec jy0=Vec::Load(p,&jy_arr.p[jyoffset+moff[0]]);
                svfloat64_t rhoy0=svld1_gather_u64index_f64(p,&yrhocells[0+irhoy],rho_index);
                jy0+=rhoy0;
                jy0.Store(p,&jy_arr.p[jyoffset+moff[0]]);

                Vec jy1=Vec::Load(p,&jy_arr.p[jyoffset+moff[1]]);
                svfloat64_t rhoy1=svld1_gather_u64index_f64(p,&yrhocells[1+irhoy],rho_index);
                jy1+=rhoy1;
                jy1.Store(p,&jy_arr.p[jyoffset+moff[1]]);

                Vec jy2=Vec::Load(p,&jy_arr.p[jyoffset+moff[2]]);
                svfloat64_t rhoy2=svld1_gather_u64index_f64(p,&yrhocells[2+irhoy],rho_index);
                jy2+=rhoy2;
                jy2.Store(p,&jy_arr.p[jyoffset+moff[2]]);

                Vec jy3=Vec::Load(p,&jy_arr.p[jyoffset+moff[3]]);
                svfloat64_t rhoy3=svld1_gather_u64index_f64(p,&yrhocells[3+irhoy],rho_index);
                jy3+=rhoy3;
                jy3.Store(p,&jy_arr.p[jyoffset+moff[3]]);

                Vec jy4=Vec::Load(p,&jy_arr.p[jyoffset+moff[4]]);
                svfloat64_t rhoy4=svld1_gather_u64index_f64(p,&yrhocells[4+irhoy],rho_index);
                jy4+=rhoy4;
                jy4.Store(p,&jy_arr.p[jyoffset+moff[4]]);

                Vec jy5=Vec::Load(p,&jy_arr.p[jyoffset+moff[5]]);
                svfloat64_t rhoy5=svld1_gather_u64index_f64(p,&yrhocells[5+irhoy],rho_index);
                jy5+=rhoy5;
                jy5.Store(p,&jy_arr.p[jyoffset+moff[5]]);

                Vec jy6=Vec::Load(p,&jy_arr.p[jyoffset+moff[6]]);
                svfloat64_t rhoy6=svld1_gather_u64index_f64(p,&yrhocells[6+irhoy],rho_index);
                jy6+=rhoy6;
                jy6.Store(p,&jy_arr.p[jyoffset+moff[6]]);

                Vec jy7=Vec::Load(p,&jy_arr.p[jyoffset+moff[7]]);
                svfloat64_t rhoy7=svld1_gather_u64index_f64(p,&yrhocells[7+irhoy],rho_index);
                jy7+=rhoy7;
                jy7.Store(p,&jy_arr.p[jyoffset+moff[7]]);

                // z
                // uint64_t irhoz = ix + iy * zjstride + iz * zkstride;
                // svuint64_t rhoz_index = svindex_u64(irhoz, 8ULL);
                // long jzoffset = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
                // long zoffset = ix + iy * zjstride + iz * zkstride;
                long jzoffset=jxoffset;
                long irhoz=irhox;
                Vec jz0=Vec::Load(p,&jz_arr.p[jzoffset+moff[0]]);
                svfloat64_t rhoz0=svld1_gather_u64index_f64(p,&zrhocells[0+irhoz],rho_index);
                jz0+=rhoz0;
                jz0.Store(p,&jz_arr.p[jzoffset+moff[0]]);

                Vec jz1=Vec::Load(p,&jz_arr.p[jzoffset+moff[1]]);
                svfloat64_t rhoz1=svld1_gather_u64index_f64(p,&zrhocells[1+irhoz],rho_index);
                jz1+=rhoz1;
                jz1.Store(p,&jz_arr.p[jzoffset+moff[1]]);

                Vec jz2=Vec::Load(p,&jz_arr.p[jzoffset+moff[2]]);
                svfloat64_t rhoz2=svld1_gather_u64index_f64(p,&zrhocells[2+irhoz],rho_index);
                jz2+=rhoz2;
                jz2.Store(p,&jz_arr.p[jzoffset+moff[2]]);

                Vec jz3=Vec::Load(p,&jz_arr.p[jzoffset+moff[3]]);
                svfloat64_t rhoz3=svld1_gather_u64index_f64(p,&zrhocells[3+irhoz],rho_index);
                jz3+=rhoz3;
                jz3.Store(p,&jz_arr.p[jzoffset+moff[3]]);

                Vec jz4=Vec::Load(p,&jz_arr.p[jzoffset+moff[4]]);
                svfloat64_t rhoz4=svld1_gather_u64index_f64(p,&zrhocells[4+irhoz],rho_index);
                jz4+=rhoz4;
                jz4.Store(p,&jz_arr.p[jzoffset+moff[4]]);

                Vec jz5=Vec::Load(p,&jz_arr.p[jzoffset+moff[5]]);
                svfloat64_t rhoz5=svld1_gather_u64index_f64(p,&zrhocells[5+irhoz],rho_index);
                jz5+=rhoz5;
                jz5.Store(p,&jz_arr.p[jzoffset+moff[5]]);

                Vec jz6=Vec::Load(p,&jz_arr.p[jzoffset+moff[6]]);
                svfloat64_t rhoz6=svld1_gather_u64index_f64(p,&zrhocells[6+irhoz],rho_index);
                jz6+=rhoz6;
                jz6.Store(p,&jz_arr.p[jzoffset+moff[6]]);

                Vec jz7=Vec::Load(p,&jz_arr.p[jzoffset+moff[7]]);
                svfloat64_t rhoz7=svld1_gather_u64index_f64(p,&zrhocells[7+irhoz],rho_index);
                jz7+=rhoz7;
                jz7.Store(p,&jz_arr.p[jzoffset+moff[7]]);

                // svetime[1]=rdtscv();
                // reduce_time+=(svetime[1]-svetime[0]);
            }
            #endif
        }
    }
    svetime[1]=rdtscv();
    reduce_time+=(svetime[1]-svetime[0]);
    
    // total_time[1]=rdtscv();
    // total_time[2]+=total_time[1]-total_time[0];

    // int world_rank;
    // MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);
    // int tid = omp_get_thread_num();
    // if (world_rank == 0 && tid == 0) {
        printf("================SME=================\n");
        printf("SME Total:%llu \n",(unsigned long long)(precompute+
            total_sort_time+cale_time+reduce_time));
        // printf("SME Total:%d \n",total_time[2]);
        printf("\t precompute:%lu \n",precompute);
        printf("\t\t --precompute1:%lu \n",precompute1[0]);
        printf("\t\t --precompute2:%lu \n",precompute1[1]);
        // printf("\t\t --precompute3:%lu \n",precompute1[2]);
        // printf("\t\t --precompute4:%lu \n",precompute1[3]);
        printf("\t total_sort_time:%lu \n",total_sort_time);
        printf("\t\t --sort_time:%lu \n",sort_time[0]);
        printf("\t\t --pma compact:%lu \n",sort_time[1]);
        // printf("\t\t --presort:%lu \n",presort);
        // printf("\t\t --borrow:%lu \n",borrow);
        // printf("\t\t --rebuildtime:%lu \n",rebuildtime);
        printf("\t cale_time:%lu \n",cale_time);
        printf("\t reduce_time:%lu \n",reduce_time);
        // printf("\t\t update1:%d ",update[0]);
        // printf(" update2:%d \n",update[1]);
        // printf("\t\t --Dupdate0:%d \n",update1[0]);
        // printf("\t\t --Dupdate1:%d \n",update1[1]);
        // printf("\t\t --Dupdate2:%d \n",update1[2]);
        // printf("\t\t --Dupdate3:%d \n",update1[3]);
        // printf("\t\t --Dupdate4:%d \n",update1[4]);
        // printf("\t\t --Dupdate5:%d \n",update1[5]);
        // printf("\t\t presort:%d \n",presort);
        // printf("\t\t insert:%d \n",insert);
        // printf("\t\t borrow:%d \n",borrow);
        // printf("\t\t rebuildtime:%d \n",rebuildtime);
        // printf("\t\t --Drebuild0:%d \n",rebuild1[0]);
        // printf("\t\t --Drebuild1:%d \n",rebuild1[1]);
        // printf("\t\t --Drebuild2:%d \n",rebuild1[2]);
        // printf("\t\t --Drebuild3:%d \n",rebuild1[3]);
        // printf("\t\t --Drebuild4:%d \n",rebuild1[4]);
        // printf("\t\t --Drebuild5:%d \n",rebuild1[5]);
        // printf("\t reduce_time:%lu \n",reduce_time);
    // }
}

template <int depos_order>
__arm_new("za") inline void sve_rhocell_sme_order3_kernel_cxj (
    HBM_Inner_Vector_Real& xrhocells,
    HBM_Inner_Vector_Real& yrhocells,
    HBM_Inner_Vector_Real& zrhocells,
    const HBM_Inner_Vector_Real& sx_m,
    const HBM_Inner_Vector_Real& sy_m,
    const HBM_Inner_Vector_Real& sz_m,
    const HBM_Inner_Vector_Real& wqx,
    const HBM_Inner_Vector_Real& wqy,
    const HBM_Inner_Vector_Real& wqz,
    const HBM_Inner_Vector_Int& rho_bin,
    int lenx,
    int leny,
    int lenz,
    long np_to_deposit
) __arm_streaming {
    constexpr int block_size = 8;
    svbool_t p_true = svwhilelt_b64(0, 8);
    svbool_t p_0_7 = svwhilelt_b64(0, 8);
    svbool_t p_0_3 = svwhilelt_b64(0, 4);
    MVec vzero(0);

    int np = static_cast<int>(np_to_deposit);
    // int sx_step[8] = {0, 1 * np, 2 * np, 3 * np, 0, 1 * np, 2 * np, 3 * np};
    // int sy_step[8] = {0, 0, 0, 0,np,np,np,np};
    // int sm_step[8] = {0, 1 * np, 2 * np, 3 * np, 1, 1 + 1 * np, 1 + 2 * np, 1 + 3 * np};

    const svuint64_t sm_index = svindex_u64(0, np);

    const int nrho = lenx * leny * lenz;

    // int rho_end = block_size < np_to_deposit  - ip ? block_size : np_to_deposit - ip;
    
    for (int iip = 0; iip < np_to_deposit; ++iip)
    {
        svzero_za();
        int rho_bin_idx = rho_bin[iip];

        MVec sx_v = svld1_gather_index(p_0_3, &sx_m[iip], sm_index);
        MVec sx_y0_v = sx_v * sy_m[0 * np + iip];
        MVec sx_y1_v = sx_v * sy_m[1 * np + iip];
        MVec sx_y_01_v = svsplice(p_0_3, sx_y0_v, sx_y1_v);
        MVec sz_v = svld1_gather_index(p_0_3, &sz_m[iip], sm_index);

        svmopa_za64_m(0, p_0_3, p_0_7, sz_v, sx_y_01_v);
        MVec sx_y01_z0 = svread_hor_za64_m(vzero, p_0_7, 0, 0);
        MVec sx_y01_z1 = svread_hor_za64_m(vzero, p_0_7, 0, 1);
        MVec sx_y01_z2 = svread_hor_za64_m(vzero, p_0_7, 0, 2);
        MVec sx_y01_z3 = svread_hor_za64_m(vzero, p_0_7, 0, 3);

        int rho_offset_iy01_z0 = (rho_bin_idx + 0 * lenx + 0 * lenx * leny) * 8;
        MVec xrhocells_iy01_z0_v = MVec::Load(p_true, &xrhocells[rho_offset_iy01_z0]);
        MVec yrhocells_iy01_z0_v = MVec::Load(p_true, &yrhocells[rho_offset_iy01_z0]);
        MVec zrhocells_iy01_z0_v = MVec::Load(p_true, &zrhocells[rho_offset_iy01_z0]);

        xrhocells_iy01_z0_v += sx_y01_z0 * wqx[iip];
        yrhocells_iy01_z0_v += sx_y01_z0 * wqy[iip];
        zrhocells_iy01_z0_v += sx_y01_z0 * wqz[iip];

        xrhocells_iy01_z0_v.Store(p_true, &xrhocells[rho_offset_iy01_z0]);
        yrhocells_iy01_z0_v.Store(p_true, &yrhocells[rho_offset_iy01_z0]);
        zrhocells_iy01_z0_v.Store(p_true, &zrhocells[rho_offset_iy01_z0]);

        int rho_offset_iy01_z1 = (rho_bin_idx + 0 * lenx + 1 * lenx * leny) * 8;
        MVec xrhocells_iy01_z1_v = MVec::Load(p_true, &xrhocells[rho_offset_iy01_z1]);
        MVec yrhocells_iy01_z1_v = MVec::Load(p_true, &yrhocells[rho_offset_iy01_z1]);
        MVec zrhocells_iy01_z1_v = MVec::Load(p_true, &zrhocells[rho_offset_iy01_z1]);

        xrhocells_iy01_z1_v += sx_y01_z1 * wqx[iip];
        yrhocells_iy01_z1_v += sx_y01_z1 * wqy[iip];
        zrhocells_iy01_z1_v += sx_y01_z1 * wqz[iip];

        xrhocells_iy01_z1_v.Store(p_true, &xrhocells[rho_offset_iy01_z1]);
        yrhocells_iy01_z1_v.Store(p_true, &yrhocells[rho_offset_iy01_z1]);
        zrhocells_iy01_z1_v.Store(p_true, &zrhocells[rho_offset_iy01_z1]);

        int rho_offset_iy01_z2 = (rho_bin_idx + 0 * lenx + 2 * lenx * leny) * 8;
        MVec xrhocells_iy01_z2_v = MVec::Load(p_true, &xrhocells[rho_offset_iy01_z2]);
        MVec yrhocells_iy01_z2_v = MVec::Load(p_true, &yrhocells[rho_offset_iy01_z2]);
        MVec zrhocells_iy01_z2_v = MVec::Load(p_true, &zrhocells[rho_offset_iy01_z2]);

        xrhocells_iy01_z2_v += sx_y01_z2 * wqx[iip];
        yrhocells_iy01_z2_v += sx_y01_z2 * wqy[iip];
        zrhocells_iy01_z2_v += sx_y01_z2 * wqz[iip];

        xrhocells_iy01_z2_v.Store(p_true, &xrhocells[rho_offset_iy01_z2]);
        yrhocells_iy01_z2_v.Store(p_true, &yrhocells[rho_offset_iy01_z2]);
        zrhocells_iy01_z2_v.Store(p_true, &zrhocells[rho_offset_iy01_z2]);

        int rho_offset_iy01_z3 = (rho_bin_idx + 0 * lenx + 3 * lenx * leny) * 8;
        MVec xrhocells_iy01_z3_v = MVec::Load(p_true, &xrhocells[rho_offset_iy01_z3]);
        MVec yrhocells_iy01_z3_v = MVec::Load(p_true, &yrhocells[rho_offset_iy01_z3]);
        MVec zrhocells_iy01_z3_v = MVec::Load(p_true, &zrhocells[rho_offset_iy01_z3]);

        xrhocells_iy01_z3_v += sx_y01_z3 * wqx[iip];
        yrhocells_iy01_z3_v += sx_y01_z3 * wqy[iip];
        zrhocells_iy01_z3_v += sx_y01_z3 * wqz[iip];

        xrhocells_iy01_z3_v.Store(p_true, &xrhocells[rho_offset_iy01_z3]);
        yrhocells_iy01_z3_v.Store(p_true, &yrhocells[rho_offset_iy01_z3]);
        zrhocells_iy01_z3_v.Store(p_true, &zrhocells[rho_offset_iy01_z3]);

        MVec sx_y2_v = sx_v * sy_m[2 * np + iip];
        MVec sx_y3_v = sx_v * sy_m[3 * np + iip];
        MVec sx_y_23_v = svsplice(p_0_3, sx_y2_v, sx_y3_v);
        svmopa_za64_m(1, p_0_3, p_0_7, sz_v, sx_y_23_v);
        MVec sx_y23_z0 = svread_hor_za64_m(vzero, p_0_7, 1, 0);
        MVec sx_y23_z1 = svread_hor_za64_m(vzero, p_0_7, 1, 1);
        MVec sx_y23_z2 = svread_hor_za64_m(vzero, p_0_7, 1, 2);
        MVec sx_y23_z3 = svread_hor_za64_m(vzero, p_0_7, 1, 3);

        int rho_offset_iy23_z0 = (rho_bin_idx + 2 * lenx + 0 * lenx * leny) * 8;
        MVec xrhocells_iy23_z0_v = MVec::Load(p_true, &xrhocells[rho_offset_iy23_z0]);
        MVec yrhocells_iy23_z0_v = MVec::Load(p_true, &yrhocells[rho_offset_iy23_z0]);
        MVec zrhocells_iy23_z0_v = MVec::Load(p_true, &zrhocells[rho_offset_iy23_z0]);

        xrhocells_iy23_z0_v += sx_y23_z0 * wqx[iip];
        yrhocells_iy23_z0_v += sx_y23_z0 * wqy[iip];
        zrhocells_iy23_z0_v += sx_y23_z0 * wqz[iip];

        xrhocells_iy23_z0_v.Store(p_true, &xrhocells[rho_offset_iy23_z0]);
        yrhocells_iy23_z0_v.Store(p_true, &yrhocells[rho_offset_iy23_z0]);
        zrhocells_iy23_z0_v.Store(p_true, &zrhocells[rho_offset_iy23_z0]);

        int rho_offset_iy23_z1 = (rho_bin_idx + 2 * lenx + 1 * lenx * leny) * 8;
        MVec xrhocells_iy23_z1_v = MVec::Load(p_true, &xrhocells[rho_offset_iy23_z1]);
        MVec yrhocells_iy23_z1_v = MVec::Load(p_true, &yrhocells[rho_offset_iy23_z1]);
        MVec zrhocells_iy23_z1_v = MVec::Load(p_true, &zrhocells[rho_offset_iy23_z1]);

        xrhocells_iy23_z1_v += sx_y23_z1 * wqx[iip];
        yrhocells_iy23_z1_v += sx_y23_z1 * wqy[iip];
        zrhocells_iy23_z1_v += sx_y23_z1 * wqz[iip];

        xrhocells_iy23_z1_v.Store(p_true, &xrhocells[rho_offset_iy23_z1]);
        yrhocells_iy23_z1_v.Store(p_true, &yrhocells[rho_offset_iy23_z1]);
        zrhocells_iy23_z1_v.Store(p_true, &zrhocells[rho_offset_iy23_z1]);

        int rho_offset_iy23_z2 = (rho_bin_idx + 2 * lenx + 2 * lenx * leny) * 8;
        MVec xrhocells_iy23_z2_v = MVec::Load(p_true, &xrhocells[rho_offset_iy23_z2]);
        MVec yrhocells_iy23_z2_v = MVec::Load(p_true, &yrhocells[rho_offset_iy23_z2]);
        MVec zrhocells_iy23_z2_v = MVec::Load(p_true, &zrhocells[rho_offset_iy23_z2]);

        xrhocells_iy23_z2_v += sx_y23_z2 * wqx[iip];
        yrhocells_iy23_z2_v += sx_y23_z2 * wqy[iip];
        zrhocells_iy23_z2_v += sx_y23_z2 * wqz[iip];

        xrhocells_iy23_z2_v.Store(p_true, &xrhocells[rho_offset_iy23_z2]);
        yrhocells_iy23_z2_v.Store(p_true, &yrhocells[rho_offset_iy23_z2]);
        zrhocells_iy23_z2_v.Store(p_true, &zrhocells[rho_offset_iy23_z2]);

        int rho_offset_iy23_z3 = (rho_bin_idx + 2 * lenx + 3 * lenx * leny) * 8;
        MVec xrhocells_iy23_z3_v = MVec::Load(p_true, &xrhocells[rho_offset_iy23_z3]);
        MVec yrhocells_iy23_z3_v = MVec::Load(p_true, &yrhocells[rho_offset_iy23_z3]);
        MVec zrhocells_iy23_z3_v = MVec::Load(p_true, &zrhocells[rho_offset_iy23_z3]);

        xrhocells_iy23_z3_v += sx_y23_z3 * wqx[iip];
        yrhocells_iy23_z3_v += sx_y23_z3 * wqy[iip];
        zrhocells_iy23_z3_v += sx_y23_z3 * wqz[iip];

        xrhocells_iy23_z3_v.Store(p_true, &xrhocells[rho_offset_iy23_z3]);
        yrhocells_iy23_z3_v.Store(p_true, &yrhocells[rho_offset_iy23_z3]);
        zrhocells_iy23_z3_v.Store(p_true, &zrhocells[rho_offset_iy23_z3]);
    }
}

template <int depos_order>
__arm_new("za") inline void sve_rhocell_sme_order3_kernel_sort_cxj (
    HBM_Inner_Vector_Real& xrhocells,
    HBM_Inner_Vector_Real& yrhocells,
    HBM_Inner_Vector_Real& zrhocells,
    const HBM_Inner_Vector_Real& sx_m,
    const HBM_Inner_Vector_Real& sy_m,
    const HBM_Inner_Vector_Real& sz_m,
    const HBM_Inner_Vector_Real& wqx,
    const HBM_Inner_Vector_Real& wqy,
    const HBM_Inner_Vector_Real& wqz,
    const HBM_Inner_Vector_Int& local_index,
    const std::vector<int>& bin_length,
    const std::vector<int>& bin_offsets,
    int lenx,
    int leny,
    int lenz,
    int rhonx,
    int rhonxy,
    int lenxy,
    long np_to_deposit
) __arm_streaming {
    constexpr int block_size = 8;
    svbool_t p_true = svwhilelt_b64(0, 8);
    svbool_t p_0_7 = svwhilelt_b64(0, 8);
    svbool_t p_0_3 = svwhilelt_b64(0, 4);
    MVec vzero(0);

    int np = static_cast<int>(np_to_deposit);

    const svuint64_t sm_index = svindex_u64(0, np);

    // int rhonx = lenx-3;
    // int rhonxy = rhonx*(leny);
    // int lenxy = lenx*leny;

    for (int iz = 0; iz < lenz-2; ++iz) {
        for (int iy = 0; iy < leny-2; ++iy) {       
            for (int ix = 0; ix < lenx-2; ix++) {
                int old_bin=(ix) + (iy) * lenx + (iz) * lenxy;
                int rho_bin=ix+iy*rhonx+iz*rhonxy;
                
                int binlength = bin_length[old_bin];
                int binoffset = bin_offsets[old_bin];
                
                svzero_za();
                for(int i=0;i<binlength;++i){
                    int ip = local_index[binoffset+i];

                    MVec sx_v = svld1_gather_index(p_0_3, &sx_m[ip], sm_index);
                    MVec sx_y0_v = sx_v * sy_m[0 * np + ip];
                    MVec sx_y1_v = sx_v * sy_m[1 * np + ip];
                    MVec sx_y_01_v = svsplice(p_0_3, sx_y0_v, sx_y1_v);
                    MVec sz_v = svld1_gather_index(p_0_3, &sz_m[ip], sm_index);
                    
                    MVec wqxsz_v = sz_v*wqx[ip];
                    svmopa_za64_m(0, p_0_3, p_0_7, wqxsz_v, sx_y_01_v);

                    MVec sx_y2_v = sx_v * sy_m[2 * np + ip];
                    MVec sx_y3_v = sx_v * sy_m[3 * np + ip];
                    MVec sx_y_23_v = svsplice(p_0_3, sx_y2_v, sx_y3_v);
                    svmopa_za64_m(1, p_0_3, p_0_7, wqxsz_v, sx_y_23_v);

                    MVec wqysz_v = sz_v*wqy[ip];
                    svmopa_za64_m(2, p_0_3, p_0_7, wqysz_v, sx_y_01_v);
                    svmopa_za64_m(3, p_0_3, p_0_7, wqysz_v, sx_y_23_v);

                    MVec wqzsz_v = sz_v*wqy[ip];
                    svmopa_za64_m(4, p_0_3, p_0_7, wqzsz_v, sx_y_01_v);
                    svmopa_za64_m(5, p_0_3, p_0_7, wqzsz_v, sx_y_23_v); 
                }
                // Jx_arr
                int rho_offset_iy01_z0 = (rho_bin + 0 * rhonx + 0 * rhonxy) * 8;
                int rho_offset_iy01_z1 = (rho_bin + 0 * rhonx + 1 * rhonxy) * 8;
                int rho_offset_iy01_z2 = (rho_bin + 0 * rhonx + 2 * rhonxy) * 8;
                int rho_offset_iy01_z3 = (rho_bin + 0 * rhonx + 3 * rhonxy) * 8;

                MVec wqx_sx_y01_z0 = svread_hor_za64_m(vzero, p_0_7, 0, 0);
                MVec xrhocells_iy01_z0_v = MVec::Load(p_true, &xrhocells[rho_offset_iy01_z0]);
                xrhocells_iy01_z0_v += wqx_sx_y01_z0;
                xrhocells_iy01_z0_v.Store(p_true, &xrhocells[rho_offset_iy01_z0]);

                MVec wqx_sx_y01_z1 = svread_hor_za64_m(vzero, p_0_7, 0, 1);
                MVec xrhocells_iy01_z1_v = MVec::Load(p_true, &xrhocells[rho_offset_iy01_z1]);
                xrhocells_iy01_z1_v += wqx_sx_y01_z1;
                xrhocells_iy01_z1_v.Store(p_true, &xrhocells[rho_offset_iy01_z1]);

                MVec wqx_sx_y01_z2 = svread_hor_za64_m(vzero, p_0_7, 0, 2);
                MVec xrhocells_iy01_z2_v = MVec::Load(p_true, &xrhocells[rho_offset_iy01_z2]);
                xrhocells_iy01_z2_v += wqx_sx_y01_z2;
                xrhocells_iy01_z2_v.Store(p_true, &xrhocells[rho_offset_iy01_z2]);

                MVec wqx_sx_y01_z3 = svread_hor_za64_m(vzero, p_0_7, 0, 3);
                MVec xrhocells_iy01_z3_v = MVec::Load(p_true, &xrhocells[rho_offset_iy01_z3]);
                xrhocells_iy01_z3_v += wqx_sx_y01_z3;
                xrhocells_iy01_z3_v.Store(p_true, &xrhocells[rho_offset_iy01_z3]);

                int rho_offset_iy23_z0 = (rho_bin + 2 * rhonx + 0 * rhonxy) * 8;
                int rho_offset_iy23_z1 = (rho_bin + 2 * rhonx + 1 * rhonxy) * 8;
                int rho_offset_iy23_z2 = (rho_bin + 2 * rhonx + 2 * rhonxy) * 8;
                int rho_offset_iy23_z3 = (rho_bin + 2 * rhonx + 3 * rhonxy) * 8;

                MVec wqx_sx_y23_z0 = svread_hor_za64_m(vzero, p_0_7, 1, 0);
                MVec xrhocells_iy23_z0_v = MVec::Load(p_true, &xrhocells[rho_offset_iy23_z0]);
                xrhocells_iy23_z0_v += wqx_sx_y23_z0;
                xrhocells_iy23_z0_v.Store(p_true, &xrhocells[rho_offset_iy23_z0]);

                MVec wqx_sx_y23_z1 = svread_hor_za64_m(vzero, p_0_7, 1, 1);
                MVec xrhocells_iy23_z1_v = MVec::Load(p_true, &xrhocells[rho_offset_iy23_z1]);
                xrhocells_iy23_z1_v += wqx_sx_y23_z1;
                xrhocells_iy23_z1_v.Store(p_true, &xrhocells[rho_offset_iy23_z1]);

                MVec wqx_sx_y23_z2 = svread_hor_za64_m(vzero, p_0_7, 1, 2);
                MVec xrhocells_iy23_z2_v = MVec::Load(p_true, &xrhocells[rho_offset_iy23_z2]);
                xrhocells_iy23_z2_v += wqx_sx_y23_z2;
                xrhocells_iy23_z2_v.Store(p_true, &xrhocells[rho_offset_iy23_z2]);

                MVec wqx_sx_y23_z3 = svread_hor_za64_m(vzero, p_0_7, 1, 3);
                MVec xrhocells_iy23_z3_v = MVec::Load(p_true, &xrhocells[rho_offset_iy23_z3]);
                xrhocells_iy23_z3_v += wqx_sx_y23_z3;
                xrhocells_iy23_z3_v.Store(p_true, &xrhocells[rho_offset_iy23_z3]);
        
                // Jy_arr
                MVec wqy_sx_y01_z0 = svread_hor_za64_m(vzero, p_0_7, 2, 0);
                MVec yrhocells_iy01_z0_v = MVec::Load(p_true, &yrhocells[rho_offset_iy01_z0]);
                yrhocells_iy01_z0_v += wqy_sx_y01_z0;
                yrhocells_iy01_z0_v.Store(p_true, &yrhocells[rho_offset_iy01_z0]);

                MVec wqy_sx_y01_z1 = svread_hor_za64_m(vzero, p_0_7, 2, 1);
                MVec yrhocells_iy01_z1_v = MVec::Load(p_true, &yrhocells[rho_offset_iy01_z1]);
                yrhocells_iy01_z1_v += wqy_sx_y01_z1;
                yrhocells_iy01_z1_v.Store(p_true, &yrhocells[rho_offset_iy01_z1]);

                MVec wqy_sx_y01_z2 = svread_hor_za64_m(vzero, p_0_7, 2, 2);
                MVec yrhocells_iy01_z2_v = MVec::Load(p_true, &yrhocells[rho_offset_iy01_z2]);
                yrhocells_iy01_z2_v += wqy_sx_y01_z2;
                yrhocells_iy01_z2_v.Store(p_true, &yrhocells[rho_offset_iy01_z2]);

                MVec wqy_sx_y01_z3 = svread_hor_za64_m(vzero, p_0_7, 2, 3);
                MVec yrhocells_iy01_z3_v = MVec::Load(p_true, &yrhocells[rho_offset_iy01_z3]);
                yrhocells_iy01_z3_v += wqy_sx_y01_z3;
                yrhocells_iy01_z3_v.Store(p_true, &yrhocells[rho_offset_iy01_z3]);

                MVec wqy_sx_y23_z0 = svread_hor_za64_m(vzero, p_0_7, 3, 0);
                MVec yrhocells_iy23_z0_v = MVec::Load(p_true, &yrhocells[rho_offset_iy23_z0]);
                yrhocells_iy23_z0_v += wqy_sx_y23_z0;
                yrhocells_iy23_z0_v.Store(p_true, &yrhocells[rho_offset_iy23_z0]);

                MVec wqy_sx_y23_z1 = svread_hor_za64_m(vzero, p_0_7, 3, 1);
                MVec yrhocells_iy23_z1_v = MVec::Load(p_true, &yrhocells[rho_offset_iy23_z1]);
                yrhocells_iy23_z1_v += wqy_sx_y23_z1;
                yrhocells_iy23_z1_v.Store(p_true, &yrhocells[rho_offset_iy23_z1]);

                MVec wqy_sx_y23_z2 = svread_hor_za64_m(vzero, p_0_7, 3, 2);
                MVec yrhocells_iy23_z2_v = MVec::Load(p_true, &yrhocells[rho_offset_iy23_z2]);
                yrhocells_iy23_z2_v += wqy_sx_y23_z2;
                yrhocells_iy23_z2_v.Store(p_true, &yrhocells[rho_offset_iy23_z2]);

                MVec wqy_sx_y23_z3 = svread_hor_za64_m(vzero, p_0_7, 3, 3);
                MVec yrhocells_iy23_z3_v = MVec::Load(p_true, &yrhocells[rho_offset_iy23_z3]);
                yrhocells_iy23_z3_v += wqy_sx_y23_z3;
                yrhocells_iy23_z3_v.Store(p_true, &yrhocells[rho_offset_iy23_z3]);

                // Jz_arr
                MVec wqz_sx_y01_z0 = svread_hor_za64_m(vzero, p_0_7, 4, 0);
                MVec zrhocells_iy01_z0_v = MVec::Load(p_true, &zrhocells[rho_offset_iy01_z0]);
                zrhocells_iy01_z0_v += wqz_sx_y01_z0;
                zrhocells_iy01_z0_v.Store(p_true, &zrhocells[rho_offset_iy01_z0]);

                MVec wqz_sx_y01_z1 = svread_hor_za64_m(vzero, p_0_7, 4, 1);
                MVec zrhocells_iy01_z1_v = MVec::Load(p_true, &zrhocells[rho_offset_iy01_z1]);
                zrhocells_iy01_z1_v += wqz_sx_y01_z1;
                zrhocells_iy01_z1_v.Store(p_true, &zrhocells[rho_offset_iy01_z1]);

                MVec wqz_sx_y01_z2 = svread_hor_za64_m(vzero, p_0_7, 4, 2);
                MVec zrhocells_iy01_z2_v = MVec::Load(p_true, &zrhocells[rho_offset_iy01_z2]);
                zrhocells_iy01_z2_v += wqz_sx_y01_z2;
                zrhocells_iy01_z2_v.Store(p_true, &zrhocells[rho_offset_iy01_z2]);

                MVec wqz_sx_y01_z3 = svread_hor_za64_m(vzero, p_0_7, 4, 3);
                MVec zrhocells_iy01_z3_v = MVec::Load(p_true, &zrhocells[rho_offset_iy01_z3]);
                zrhocells_iy01_z3_v += wqz_sx_y01_z3;
                zrhocells_iy01_z3_v.Store(p_true, &zrhocells[rho_offset_iy01_z3]);

                MVec wqz_sx_y23_z0 = svread_hor_za64_m(vzero, p_0_7, 5, 0);
                MVec zrhocells_iy23_z0_v = MVec::Load(p_true, &zrhocells[rho_offset_iy23_z0]);
                zrhocells_iy23_z0_v += wqz_sx_y23_z0;
                zrhocells_iy23_z0_v.Store(p_true, &zrhocells[rho_offset_iy23_z0]);

                MVec wqz_sx_y23_z1 = svread_hor_za64_m(vzero, p_0_7, 5, 1);
                MVec zrhocells_iy23_z1_v = MVec::Load(p_true, &zrhocells[rho_offset_iy23_z1]);
                zrhocells_iy23_z1_v += wqz_sx_y23_z1;
                zrhocells_iy23_z1_v.Store(p_true, &zrhocells[rho_offset_iy23_z1]);

                MVec wqz_sx_y23_z2 = svread_hor_za64_m(vzero, p_0_7, 5, 2);
                MVec zrhocells_iy23_z2_v = MVec::Load(p_true, &zrhocells[rho_offset_iy23_z2]);
                zrhocells_iy23_z2_v += wqz_sx_y23_z2;
                zrhocells_iy23_z2_v.Store(p_true, &zrhocells[rho_offset_iy23_z2]);

                MVec wqz_sx_y23_z3 = svread_hor_za64_m(vzero, p_0_7, 5, 3);
                MVec zrhocells_iy23_z3_v = MVec::Load(p_true, &zrhocells[rho_offset_iy23_z3]);
                zrhocells_iy23_z3_v += wqz_sx_y23_z3;
                zrhocells_iy23_z3_v.Store(p_true, &zrhocells[rho_offset_iy23_z3]);
            }
        }
    }
}


template <int depos_order>
void doDepositionShapeN_sve_rhocell_sme_order3_cxj (const GetParticlePosition<PIdx>& GetPosition,
                        const amrex::ParticleReal * const wp,
                        const amrex::ParticleReal * const uxp,
                        const amrex::ParticleReal * const uyp,
                        const amrex::ParticleReal * const uzp,
                        const int* ion_lev,
                        amrex::FArrayBox& jx_fab,
                        amrex::FArrayBox& jy_fab,
                        amrex::FArrayBox& jz_fab,
                        long np_to_deposit,
                        amrex::Real relative_time,
                        const amrex::XDim3 & dinv,
                        const amrex::XDim3 & xyzmin,
                        amrex::Dim3 len,
                        amrex::Real q,
                        [[maybe_unused]]int n_rz_azimuthal_modes,
                        HBM_Inner_Vector_Real& wqx,
                        HBM_Inner_Vector_Real& wqy,
                        HBM_Inner_Vector_Real& wqz,
                        HBM_Inner_Vector_Real& sx_m,
                        HBM_Inner_Vector_Real& sy_m,
                        HBM_Inner_Vector_Real& sz_m,
                        HBM_Inner_Vector_Real& xrhocells,
                        HBM_Inner_Vector_Real& yrhocells,
                        HBM_Inner_Vector_Real& zrhocells,
                        HBM_Inner_Vector_Int& newbin,
                        ParticleTileType& ptile, const amrex::Box& box
                    )
{

    using namespace amrex::literals;

    const bool do_ionization = ion_lev;

    const amrex::Real invvol = dinv.x*dinv.y*dinv.z;

    const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;

    amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
    amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
    amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
    
    constexpr int nshapes = 1 + 3;
    // const int block_size = 8;
    // long n_blocks = np_to_deposit / block_size;
    // long remainder = np_to_deposit - n_blocks * block_size;
    const int vl = svcntd();

    const amrex::ParticleReal* mx = GetPosition.m_x;
    const amrex::ParticleReal* my = GetPosition.m_y;
    const amrex::ParticleReal* mz = GetPosition.m_z;
    
    // 预计算网格步长
    const int xjstride = jx_arr.jstride;
    const int xkstride = jx_arr.kstride;
    const int yjstride = jy_arr.jstride;
    const int ykstride = jy_arr.kstride;
    const int zjstride = jz_arr.jstride;
    const int zkstride = jz_arr.kstride;

    auto compute_shape_factor_sve_order3 = [](double* sx, Vec xmid, svbool_t p, long np) {
        intVec i_newv = svcvt_s64_f64_z(p, xmid);

        Vec j = svrintz_x(p, xmid);
        Vec xint = xmid - j;
        Vec one_minus_xint = 1.0 - xint;

        Vec sx0 = (1.0 / 6.0) * one_minus_xint * one_minus_xint * one_minus_xint;
        sx0.Store(p, &sx[0 * np]);
        Vec sx1 = (2.0 / 3.0) - xint * xint * (1.0 - xint * 0.5);
        sx1.Store(p, &sx[1 * np]);
        Vec sx2 = (2.0 / 3.0) - one_minus_xint * one_minus_xint * (1.0 - 0.5 *one_minus_xint);
        sx2.Store(p, &sx[2 * np]);
        Vec sx3 = (1.0 / 6.0) * xint * xint * xint;
        sx3.Store(p, &sx[3 * np]);

        return i_newv - 1;
    };

    // std::vector<int64_t> j_cell(np_to_deposit, 0);
    // std::vector<int64_t> k_cell(np_to_deposit, 0);
    // std::vector<int64_t> l_cell(np_to_deposit, 0);

    std::vector<long> rho_bin(np_to_deposit);
    svbool_t p_ix = svwhilelt_b64(0, nshapes);

    const int lenx = len.x;
    const int leny = len.y;
    const int lenz = len.z;
    const int lenxy = lenx*leny;
    // const int lenx = len.x - 3;
    // const int leny = len.y;
    // const int lenz = len.z + 1;
    // const int nrho = lenx * leny * lenz;

    svbool_t p_true = svwhilelt_b64(0, 8);
    svbool_t p_0_3 = svwhilelt_b64(0, 4);

    // int sx_step[8] = {0, 1 * block_size, 2 * block_size, 3 * block_size, 0, 1 * block_size, 2 * block_size, 3 * block_size};
    // int sy_step[8] = {0, 0, 0, 0,block_size,block_size,block_size,block_size};

    for(long ip = 0; ip < np_to_deposit; ip += vl)
    {
        svbool_t p_ip = svwhilelt_b64(ip, np_to_deposit);
        
        Vec uxp_v = Vec::Load(p_ip, &uxp[ip]);
        Vec uyp_v = Vec::Load(p_ip, &uyp[ip]);
        Vec uzp_v = Vec::Load(p_ip, &uzp[ip]);
        Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                    + uyp_v * uyp_v * clightsq
                                    + uzp_v * uzp_v * clightsq).Sqrt();
        Vec vx_v = uxp_v * gaminv;
        Vec vy_v = uyp_v * gaminv;
        Vec vz_v = uzp_v * gaminv;

        Vec wp_v = Vec::Load(p_ip, &wp[ip]);
        
        Vec wq_v = q * wp_v;
        if (do_ionization) 
        {
            wq_v *= ion_lev[ip];
        }

        Vec wqx_v = wq_v * invvol * vx_v;
        Vec wqy_v = wq_v * invvol * vy_v;
        Vec wqz_v = wq_v * invvol * vz_v;

        wqx_v.Store(p_ip, &wqx[ip]);
        wqy_v.Store(p_ip, &wqy[ip]);
        wqz_v.Store(p_ip, &wqz[ip]);

        Vec xp = Vec::Load(p_ip, &mx[ip]);
        Vec yp = Vec::Load(p_ip, &my[ip]);
        Vec zp = Vec::Load(p_ip, &mz[ip]);

        Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x;
        Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y;
        Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z;
        
        intVec j_cellv = compute_shape_factor_sve_order3(&sx_m[ip], xmid, p_ip, np_to_deposit);
        intVec k_cellv = compute_shape_factor_sve_order3(&sy_m[ip], ymid, p_ip, np_to_deposit);
        intVec l_cellv = compute_shape_factor_sve_order3(&sz_m[ip], zmid, p_ip, np_to_deposit);

        intVec rho_bin_v = j_cellv + k_cellv * lenx + l_cellv * lenxy;
        // rho_bin_v.Store(p_ip, &rho_bin[ip]);
        svst1w_s64(p_ip, &newbin[ip], rho_bin_v);
    }

    const int numcell=ptile.m_num_bins;
    // increment_sort_particles3_HBM2(np_to_deposit,ptile,newbin,numcell,len);
    increment_sort_particles3_HBM(np_to_deposit,ptile,newbin,numcell);

    // std::vector<amrex::Real> xrhocells(8 * nrho, 0.0);
    // HBM_Inner_Vector_Real xrhocells(8 * numcell);
    // HBM_Inner_Vector_Real yrhocells(8 * nrho);
    // HBM_Inner_Vector_Real zrhocells(8 * nrho);

    auto& local_index = ptile.m_local_index_hbm;
    auto& bin_offsets = ptile.m_bin_offsets;
    auto& bin_length = ptile.m_bin_lengths;
    int rhonx = lenx-3;
    int rhonxy = rhonx*(leny);
    
    sve_rhocell_sme_order3_kernel_sort_cxj<3>(
        xrhocells, yrhocells, zrhocells, 
        sx_m, sy_m, sz_m,
        wqx, wqy, wqz, 
        local_index,bin_length,bin_offsets,
        lenx, leny, lenz,
        rhonx, rhonxy, lenxy, 
        np_to_deposit);

    
    for (int iz = 0; iz <= len.z; ++iz)
    {
        for (int iy = 0; iy <= len.y - 1; ++iy)
        {
            for(int ix = 0; ix <= len.x - 4; ix++){
                int arr_offset = ix + iy * xjstride + iz * xkstride;
                int rho_offset = 8 * (ix + iy * rhonx + iz * rhonxy);
                // int rho_offset = 8 * (ix + iy * lenx + iz * lenx * leny);

                Vec xrhocells_0_3_v = Vec::Load(p_0_3, &xrhocells[0 + rho_offset]);
                Vec xrhocells_4_7_v = Vec::Load(p_0_3, &xrhocells[4 + rho_offset]);
                Vec jx_arr_0_3_v = Vec::Load(p_0_3, &jx_arr.p[0 + arr_offset]);
                Vec jx_arr_4_7_v = Vec::Load(p_0_3, &jx_arr.p[xjstride + arr_offset]);

                Vec yrhocells_0_3_v = Vec::Load(p_0_3, &yrhocells[0 + rho_offset]);
                Vec yrhocells_4_7_v = Vec::Load(p_0_3, &yrhocells[4 + rho_offset]);
                Vec jy_arr_0_3_v = Vec::Load(p_0_3, &jy_arr.p[0 + arr_offset]);
                Vec jy_arr_4_7_v = Vec::Load(p_0_3, &jy_arr.p[xjstride + arr_offset]);
                
                Vec zrhocells_0_3_v = Vec::Load(p_0_3, &zrhocells[0 + rho_offset]);
                Vec zrhocells_4_7_v = Vec::Load(p_0_3, &zrhocells[4 + rho_offset]);
                Vec jz_arr_0_3_v = Vec::Load(p_0_3, &jz_arr.p[0 + arr_offset]);
                Vec jz_arr_4_7_v = Vec::Load(p_0_3, &jz_arr.p[xjstride + arr_offset]);

                jx_arr_0_3_v += xrhocells_0_3_v;
                jy_arr_0_3_v += yrhocells_0_3_v;
                jz_arr_0_3_v += zrhocells_0_3_v;
                jx_arr_4_7_v += xrhocells_4_7_v;
                jy_arr_4_7_v += yrhocells_4_7_v;
                jz_arr_4_7_v += zrhocells_4_7_v;

                jx_arr_0_3_v.Store(p_0_3, &jx_arr.p[0 + arr_offset]);
                jy_arr_0_3_v.Store(p_0_3, &jy_arr.p[0 + arr_offset]);
                jz_arr_0_3_v.Store(p_0_3, &jz_arr.p[0 + arr_offset]);

                jx_arr_4_7_v.Store(p_0_3, &jx_arr.p[xjstride + arr_offset]);
                jy_arr_4_7_v.Store(p_0_3, &jy_arr.p[xjstride + arr_offset]);
                jz_arr_4_7_v.Store(p_0_3, &jz_arr.p[xjstride + arr_offset]);
            }
        }
    }
}

template <int depos_order>
void doDepositionShapeN_sve_rhocell_sme_order3_org_cxj (const GetParticlePosition<PIdx>& GetPosition,
                        const amrex::ParticleReal * const wp,
                        const amrex::ParticleReal * const uxp,
                        const amrex::ParticleReal * const uyp,
                        const amrex::ParticleReal * const uzp,
                        const int* ion_lev,
                        amrex::FArrayBox& jx_fab,
                        amrex::FArrayBox& jy_fab,
                        amrex::FArrayBox& jz_fab,
                        long np_to_deposit,
                        amrex::Real relative_time,
                        const amrex::XDim3 & dinv,
                        const amrex::XDim3 & xyzmin,
                        amrex::Dim3 len,
                        amrex::Real q,
                        [[maybe_unused]]int n_rz_azimuthal_modes,
                        HBM_Inner_Vector_Real& wqx,
                        HBM_Inner_Vector_Real& wqy,
                        HBM_Inner_Vector_Real& wqz,
                        HBM_Inner_Vector_Real& sx_m,
                        HBM_Inner_Vector_Real& sy_m,
                        HBM_Inner_Vector_Real& sz_m,
                        HBM_Inner_Vector_Real& xrhocells,
                        HBM_Inner_Vector_Real& yrhocells,
                        HBM_Inner_Vector_Real& zrhocells,
                        HBM_Inner_Vector_Int& newbin,
                        ParticleTileType& ptile, const amrex::Box& box
                    )
{

    using namespace amrex::literals;

    const bool do_ionization = ion_lev;

    const amrex::Real invvol = dinv.x*dinv.y*dinv.z;

    const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;

    amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
    amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
    amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
    
    constexpr int nshapes = 1 + 3;
    // const int block_size = 8;
    // long n_blocks = np_to_deposit / block_size;
    // long remainder = np_to_deposit - n_blocks * block_size;
    const int vl = svcntd();

    const amrex::ParticleReal* mx = GetPosition.m_x;
    const amrex::ParticleReal* my = GetPosition.m_y;
    const amrex::ParticleReal* mz = GetPosition.m_z;
    
    // 预计算网格步长
    const int xjstride = jx_arr.jstride;
    const int xkstride = jx_arr.kstride;
    const int yjstride = jy_arr.jstride;
    const int ykstride = jy_arr.kstride;
    const int zjstride = jz_arr.jstride;
    const int zkstride = jz_arr.kstride;

    auto compute_shape_factor_sve_order3 = [](double* sx, Vec xmid, svbool_t p, long np) {
        intVec i_newv = svcvt_s64_f64_z(p, xmid);

        Vec j = svrintz_x(p, xmid);
        Vec xint = xmid - j;
        Vec one_minus_xint = 1.0 - xint;

        Vec sx0 = (1.0 / 6.0) * one_minus_xint * one_minus_xint * one_minus_xint;
        sx0.Store(p, &sx[0 * np]);
        Vec sx1 = (2.0 / 3.0) - xint * xint * (1.0 - xint * 0.5);
        sx1.Store(p, &sx[1 * np]);
        Vec sx2 = (2.0 / 3.0) - one_minus_xint * one_minus_xint * (1.0 - 0.5 *one_minus_xint);
        sx2.Store(p, &sx[2 * np]);
        Vec sx3 = (1.0 / 6.0) * xint * xint * xint;
        sx3.Store(p, &sx[3 * np]);

        return i_newv - 1;
    };

    // std::vector<int64_t> j_cell(np_to_deposit, 0);
    // std::vector<int64_t> k_cell(np_to_deposit, 0);
    // std::vector<int64_t> l_cell(np_to_deposit, 0);

    std::vector<long> rho_bin(np_to_deposit);
    svbool_t p_ix = svwhilelt_b64(0, nshapes);

    const int lenx = len.x;
    const int leny = len.y;
    const int lenz = len.z;
    const int lenxy = lenx*leny;
    // const int lenx = len.x - 3;
    // const int leny = len.y;
    // const int lenz = len.z + 1;
    // const int nrho = lenx * leny * lenz;

    svbool_t p_true = svwhilelt_b64(0, 8);
    svbool_t p_0_3 = svwhilelt_b64(0, 4);
    int rhonx = lenx-3;
    int rhonxy = rhonx*(leny);

    for(long ip = 0; ip < np_to_deposit; ip += vl)
    {
        svbool_t p_ip = svwhilelt_b64(ip, np_to_deposit);
        
        Vec uxp_v = Vec::Load(p_ip, &uxp[ip]);
        Vec uyp_v = Vec::Load(p_ip, &uyp[ip]);
        Vec uzp_v = Vec::Load(p_ip, &uzp[ip]);
        Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                    + uyp_v * uyp_v * clightsq
                                    + uzp_v * uzp_v * clightsq).Sqrt();
        Vec vx_v = uxp_v * gaminv;
        Vec vy_v = uyp_v * gaminv;
        Vec vz_v = uzp_v * gaminv;

        Vec wp_v = Vec::Load(p_ip, &wp[ip]);
        
        Vec wq_v = q * wp_v;
        if (do_ionization) 
        {
            wq_v *= ion_lev[ip];
        }

        Vec wqx_v = wq_v * invvol * vx_v;
        Vec wqy_v = wq_v * invvol * vy_v;
        Vec wqz_v = wq_v * invvol * vz_v;

        wqx_v.Store(p_ip, &wqx[ip]);
        wqy_v.Store(p_ip, &wqy[ip]);
        wqz_v.Store(p_ip, &wqz[ip]);

        Vec xp = Vec::Load(p_ip, &mx[ip]);
        Vec yp = Vec::Load(p_ip, &my[ip]);
        Vec zp = Vec::Load(p_ip, &mz[ip]);

        Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x;
        Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y;
        Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z;
        
        intVec j_cellv = compute_shape_factor_sve_order3(&sx_m[ip], xmid, p_ip, np_to_deposit);
        intVec k_cellv = compute_shape_factor_sve_order3(&sy_m[ip], ymid, p_ip, np_to_deposit);
        intVec l_cellv = compute_shape_factor_sve_order3(&sz_m[ip], zmid, p_ip, np_to_deposit);

        intVec rho_bin_v = j_cellv + k_cellv * rhonx + l_cellv * rhonxy;
        // rho_bin_v.Store(p_ip, &rho_bin[ip]);
        svst1w_s64(p_ip, &newbin[ip], rho_bin_v);
    }

    sve_rhocell_sme_order3_kernel_cxj<3> (
        xrhocells, yrhocells, zrhocells, 
        sx_m, sy_m, sz_m,
        wqx, wqy, wqz, newbin,
        lenx, leny, lenz, 
        np_to_deposit);

    
    for (int iz = 0; iz <= len.z; ++iz)
    {
        for (int iy = 0; iy <= len.y - 1; ++iy)
        {
            for(int ix = 0; ix <= len.x - 4; ix++){
                int arr_offset = ix + iy * xjstride + iz * xkstride;
                int rho_offset = 8 * (ix + iy * rhonx + iz * rhonxy);
                // int rho_offset = 8 * (ix + iy * lenx + iz * lenx * leny);

                Vec xrhocells_0_3_v = Vec::Load(p_0_3, &xrhocells[0 + rho_offset]);
                Vec xrhocells_4_7_v = Vec::Load(p_0_3, &xrhocells[4 + rho_offset]);
                Vec jx_arr_0_3_v = Vec::Load(p_0_3, &jx_arr.p[0 + arr_offset]);
                Vec jx_arr_4_7_v = Vec::Load(p_0_3, &jx_arr.p[xjstride + arr_offset]);

                Vec yrhocells_0_3_v = Vec::Load(p_0_3, &yrhocells[0 + rho_offset]);
                Vec yrhocells_4_7_v = Vec::Load(p_0_3, &yrhocells[4 + rho_offset]);
                Vec jy_arr_0_3_v = Vec::Load(p_0_3, &jy_arr.p[0 + arr_offset]);
                Vec jy_arr_4_7_v = Vec::Load(p_0_3, &jy_arr.p[xjstride + arr_offset]);
                
                Vec zrhocells_0_3_v = Vec::Load(p_0_3, &zrhocells[0 + rho_offset]);
                Vec zrhocells_4_7_v = Vec::Load(p_0_3, &zrhocells[4 + rho_offset]);
                Vec jz_arr_0_3_v = Vec::Load(p_0_3, &jz_arr.p[0 + arr_offset]);
                Vec jz_arr_4_7_v = Vec::Load(p_0_3, &jz_arr.p[xjstride + arr_offset]);

                jx_arr_0_3_v += xrhocells_0_3_v;
                jy_arr_0_3_v += yrhocells_0_3_v;
                jz_arr_0_3_v += zrhocells_0_3_v;
                jx_arr_4_7_v += xrhocells_4_7_v;
                jy_arr_4_7_v += yrhocells_4_7_v;
                jz_arr_4_7_v += zrhocells_4_7_v;

                jx_arr_0_3_v.Store(p_0_3, &jx_arr.p[0 + arr_offset]);
                jy_arr_0_3_v.Store(p_0_3, &jy_arr.p[0 + arr_offset]);
                jz_arr_0_3_v.Store(p_0_3, &jz_arr.p[0 + arr_offset]);

                jx_arr_4_7_v.Store(p_0_3, &jx_arr.p[xjstride + arr_offset]);
                jy_arr_4_7_v.Store(p_0_3, &jy_arr.p[xjstride + arr_offset]);
                jz_arr_4_7_v.Store(p_0_3, &jz_arr.p[xjstride + arr_offset]);
            }
        }
    }
}

template <int depos_order>
void doDepositionShapeN_3d_sme_order3_compact_HBM (const GetParticlePosition<PIdx>& GetPosition,
                        const amrex::ParticleReal * const wp,
                        const amrex::ParticleReal * const uxp,
                        const amrex::ParticleReal * const uyp,
                        const amrex::ParticleReal * const uzp,
                        const int* ion_lev,
                        HBM_Inner_Vector_Real& wqx,
                        HBM_Inner_Vector_Real& wqy,
                        HBM_Inner_Vector_Real& wqz,
                        HBM_Inner_Vector_Real& sx_mT,
                        HBM_Inner_Vector_Real& sy_mT,
                        HBM_Inner_Vector_Real& sz_mT,
                        HBM_Inner_Vector_Real& xrhocells,
                        HBM_Inner_Vector_Real& yrhocells,
                        HBM_Inner_Vector_Real& zrhocells,
                        HBM_Inner_Vector_Int& newbin,
                        amrex::FArrayBox& jx_fab,
                        amrex::FArrayBox& jy_fab,
                        amrex::FArrayBox& jz_fab,
                        long np_to_deposit,
                        amrex::Real relative_time,
                        const amrex::XDim3 & dinv,
                        const amrex::XDim3 & xyzmin,
                        amrex::Dim3 lo,
                        amrex::Dim3 hi,
                        amrex::Dim3 len,
                        amrex::Real q,
                        ParticleTileType& ptile, const amrex::Box& box,
                        [[maybe_unused]]int n_rz_azimuthal_modes,
                        std::vector<amrex::Real>& test_sxwq)
{
    // WARPX_PROFILE("doDepositionShapeN_3d_sme_order3()");
    using namespace amrex::literals;
#ifdef BREAKDOWN
    uint64_t total_time[3]={0};
    using namespace std::chrono;
    uint64_t precompute=0;
    uint64_t precompute1[4]={0};
    uint64_t cale_time=0;
    uint64_t sort_time[2]={0};
    uint64_t total_sort_time={0};
        uint64_t update[2]={0};
        uint64_t update1[7]={0};
        uint64_t presort=0;
        uint64_t insert=0;
        uint64_t borrow=0;
        uint64_t rebuildtime=0;
        uint64_t rebuild1[7]={0};
    uint64_t reduce_time=0;
    uint64_t svetime[3]={0};
    uint64_t svetime1[3]={0};
    // uint64_t branch_time=0;
    
    total_time[0]=rdtscv();
#endif
    constexpr int nshapes = depos_order + 1;
#ifdef BREAKDOWN
    svetime[0]=rdtscv();
#endif
    const bool do_ionization = ion_lev;
    const amrex::Real invvol = dinv.x*dinv.y*dinv.z; 
    const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;

    amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
    amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
    amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();

    
    int vl=svcntd();

    const amrex::ParticleReal* mx = GetPosition.m_x;
    const amrex::ParticleReal* my = GetPosition.m_y;
    const amrex::ParticleReal* mz = GetPosition.m_z;
    
    auto compute_shape_factor_order3_v2 = [](double* sx, Vec xmid, svbool_t p, int np) {
        intVec i_newv = svcvt_s64_f64_z(p, xmid);

        Vec j = svrintz_x(p, xmid);
        Vec xint = xmid - j;
        Vec temp = 1.0 - xint;

        Vec sx0 = (1.0 / 6.0) * temp * temp * temp;
        sx0.Store(p, &sx[0*np]);
        Vec sx1 = (2.0 / 3.0) - xint * xint * (1.0 - xint * 0.5);
        sx1.Store(p, &sx[1*np]);
        Vec sx2 = (2.0 / 3.0) - temp * temp * (1.0 - 0.5 *temp);
        sx2.Store(p, &sx[2*np]);
        Vec sx3 = (1.0 / 6.0) * xint * xint * xint;
        sx3.Store(p, &sx[3*np]);

        return i_newv-1;
    };

    // 预计算网格步长
    const int xjstride = jx_arr.jstride;
    const int xkstride = jx_arr.kstride;
    const int yjstride = jy_arr.jstride;
    const int ykstride = jy_arr.kstride;
    const int zjstride = jz_arr.jstride;
    const int zkstride = jz_arr.kstride;

    long nnx = len.x;
    long nny = len.y;
    long nnxny = nnx*nny;
#ifdef BREAKDOWN
    svetime[1]=rdtscv();
    precompute1[0]+=(svetime[1]-svetime[0]); 
#endif

#ifdef BREAKDOWN
    svetime[0]=rdtscv();
#endif
    #pragma unroll
    for(long ip=0;ip<np_to_deposit;ip+=vl){
        // svetime[0]=rdtscv();
        // 计算基本物理量
        svbool_t p=svwhilelt_b64(ip,np_to_deposit);

        // Inverse of Lorentz factor gamma
        Vec uxp_v=Vec::Load(p,&uxp[ip]);
        Vec uyp_v=Vec::Load(p,&uyp[ip]);
        Vec uzp_v=Vec::Load(p,&uzp[ip]);
        Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                    + uyp_v * uyp_v * clightsq
                                    + uzp_v * uzp_v * clightsq).Sqrt();
        // Product of particle charges and weights
        Vec wp_v=Vec::Load(p,&wp[ip]);
        Vec wq_v = q * wp_v;

        // Current particle positions (in physical units)
        Vec xp = Vec::Load(p, &mx[ip]);
        Vec yp = Vec::Load(p, &my[ip]);
        Vec zp = Vec::Load(p, &mz[ip]);

        // Particle velocities
        Vec vx_v = uxp_v * gaminv;
        Vec wqx_v = wq_v * invvol * vx_v;
        wqx_v.Store(p, &wqx[ip]);
        Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x;

        Vec vy_v = uyp_v * gaminv;
        Vec wqy_v = wq_v * invvol * vy_v;
        wqy_v.Store(p, &wqy[ip]);
        Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y;

        Vec vz_v = uzp_v * gaminv;
        Vec wqz_v = wq_v * invvol * vz_v;
        wqz_v.Store(p, &wqz[ip]);
        Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z;
        
        intVec j_cellv2 = compute_shape_factor_order3_v2( &sx_mT[ip], xmid, p,np_to_deposit);
        intVec k_cellv2 = compute_shape_factor_order3_v2( &sy_mT[ip], ymid, p,np_to_deposit);
        intVec l_cellv2 = compute_shape_factor_order3_v2( &sz_mT[ip], zmid, p,np_to_deposit); 
        intVec new_bin_v = (j_cellv2) + 
                (k_cellv2)* nnx + 
                (l_cellv2) * nnxny;
        svst1w_s64(p, &newbin[ip], new_bin_v);
    }
#ifdef BREAKDOWN
    svetime[1]=rdtscv();
    precompute1[1]+=(svetime[1]-svetime[0]);
    precompute=precompute1[0]+precompute1[1]; 
#endif
   
    const int numcell=ptile.m_num_bins;

#ifdef BREAKDOWN
    svetime[0]=rdtscv();
#endif
    // increment_sort_particles(np_to_deposit,ptile,newbin,numcell);
    increment_sort_particles3_HBM(np_to_deposit,ptile,newbin,numcell);
#ifdef BREAKDOWN
    svetime[1]=rdtscv();
    sort_time[0]+=(svetime[1]-svetime[0]);
#endif
    
    // return;
    auto& local_index = ptile.m_local_index_hbm;
    auto& bin_offsets = ptile.m_bin_offsets;
    auto& bin_length = ptile.m_bin_lengths;
#ifdef BREAKDOWN
    total_sort_time=(sort_time[0]);
    
    svetime[0]=rdtscv();
#endif
    sort_3d_sme_kernal_order_3_compact_jxjyjz_HBM<3>(
        local_index,bin_length,bin_offsets,
        xrhocells,yrhocells,zrhocells,
        sx_mT,sy_mT,sz_mT,
        wqx,wqy,wqz,len,np_to_deposit
    );
    // sort_3d_sme_kernal_order_3_compact_jxjyjz<3>(
    //     local_index,bin_length,bin_offsets,
    //     xrhocells,yrhocells,zrhocells,
    //     sx_mT,sy_mT,sz_mT,
    //     wqx,wqy,wqz,len,np_to_deposit
    // );
#ifdef BREAKDOWN
    svetime[1]=rdtscv();
    cale_time+=(svetime[1]-svetime[0]);
    printf("\t cale_time compact:%d \n",cale_time);
#endif
    //=========================
    // test_sxwq.resize(64*np_to_deposit);
    // sort_3d_sme_kernal_order_3_compact_HBM_test<3>(
    //     local_index,bin_length,bin_offsets,
    //     xrhocells,yrhocells,zrhocells,
    //     sx_mT,sy_mT,sz_mT,
    //     wqx,wqy,wqz,len,np_to_deposit,test_sxwq
    // );
    //=======================


    // svetime[0]=rdtscv();
    // sort_3d_sme_kernal_order_3_v3<3>(
    //     local_index,bin_length,bin_offsets,
    //     xrhocells,yrhocells,zrhocells,
    //     sx_mT,sy_mT,sz_mT,
    //     wqx,wqy,wqz,len,np_to_deposit,
    //     ip_list
    // );
    // svetime[1]=rdtscv();
    // cale_time+=(svetime[1]-svetime[0]);
    // printf("\t cale_time v3:%d \n",cale_time);


    // test_sxwq=testsxwq;

    long nx=xjstride;
    long nxy=xkstride;
    long moff[8] = {0,nx,2*nx,3*nx,nxy,nxy+nx,nxy+2*nx,nxy+3*nx};
    
    long lnx=len.x+1;
    long lnxy=lnx*(len.y-2);
#ifdef BREAKDOWN
    svetime[0]=rdtscv();
#endif
    #pragma omp simd
    for (int iz = 0; iz < len.z; ++iz) {
        #pragma omp simd
        for (int iy = 0; iy < len.y-2; ++iy) { 
            #if 1
            #pragma unroll      
            for (int ix = 0; ix <= len.x; ix+=vl) {
                // svetime[0]=rdtscv();

                // vector
                svbool_t p=svwhilele_b64(ix,(len.x));
                svuint64_t rho_index = svindex_u64(0ULL, 8ULL);
                long jxoffset=ix + iy * xjstride + iz * xkstride;
                long cell_idx=ix + iy * lnx + iz * lnxy;
                // long jxoffset=xoffset;
                long irhox=8*cell_idx;
                Vec jx0=Vec::Load(p,&jx_arr.p[jxoffset+moff[0]]);
                svfloat64_t rhox0=svld1_gather_u64index_f64(p,&xrhocells[0+irhox],rho_index);
                jx0+=rhox0;
                jx0.Store(p,&jx_arr.p[jxoffset+moff[0]]);

                Vec jx1=Vec::Load(p,&jx_arr.p[jxoffset+moff[1]]);
                svfloat64_t rhox1=svld1_gather_u64index_f64(p,&xrhocells[1+irhox],rho_index);
                jx1+=rhox1;
                jx1.Store(p,&jx_arr.p[jxoffset+moff[1]]);

                Vec jx2=Vec::Load(p,&jx_arr.p[jxoffset+moff[2]]);
                svfloat64_t rhox2=svld1_gather_u64index_f64(p,&xrhocells[2+irhox],rho_index);
                jx2+=rhox2;
                jx2.Store(p,&jx_arr.p[jxoffset+moff[2]]);

                Vec jx3=Vec::Load(p,&jx_arr.p[jxoffset+moff[3]]);
                svfloat64_t rhox3=svld1_gather_u64index_f64(p,&xrhocells[3+irhox],rho_index);
                jx3+=rhox3;
                jx3.Store(p,&jx_arr.p[jxoffset+moff[3]]);

                Vec jx4=Vec::Load(p,&jx_arr.p[jxoffset+moff[4]]);
                svfloat64_t rhox4=svld1_gather_u64index_f64(p,&xrhocells[4+irhox],rho_index);
                jx4+=rhox4;
                jx4.Store(p,&jx_arr.p[jxoffset+moff[4]]);

                Vec jx5=Vec::Load(p,&jx_arr.p[jxoffset+moff[5]]);
                svfloat64_t rhox5=svld1_gather_u64index_f64(p,&xrhocells[5+irhox],rho_index);
                jx5+=rhox5;
                jx5.Store(p,&jx_arr.p[jxoffset+moff[5]]);

                Vec jx6=Vec::Load(p,&jx_arr.p[jxoffset+moff[6]]);
                svfloat64_t rhox6=svld1_gather_u64index_f64(p,&xrhocells[6+irhox],rho_index);
                jx6+=rhox6;
                jx6.Store(p,&jx_arr.p[jxoffset+moff[6]]);

                Vec jx7=Vec::Load(p,&jx_arr.p[jxoffset+moff[7]]);
                svfloat64_t rhox7=svld1_gather_u64index_f64(p,&xrhocells[7+irhox],rho_index);
                jx7+=rhox7;
                jx7.Store(p,&jx_arr.p[jxoffset+moff[7]]);
                
                // y
                // uint64_t irhoy = ix + iy * yjstride + iz * ykstride;
                // svuint64_t rhoy_index = svindex_u64(irhoy, 8ULL);
                // long jyoffset = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
                // long yoffset = ix + iy * yjstride + iz * ykstride;
                long jyoffset=jxoffset;
                long irhoy=irhox;
                Vec jy0=Vec::Load(p,&jy_arr.p[jyoffset+moff[0]]);
                svfloat64_t rhoy0=svld1_gather_u64index_f64(p,&yrhocells[0+irhoy],rho_index);
                jy0+=rhoy0;
                jy0.Store(p,&jy_arr.p[jyoffset+moff[0]]);

                Vec jy1=Vec::Load(p,&jy_arr.p[jyoffset+moff[1]]);
                svfloat64_t rhoy1=svld1_gather_u64index_f64(p,&yrhocells[1+irhoy],rho_index);
                jy1+=rhoy1;
                jy1.Store(p,&jy_arr.p[jyoffset+moff[1]]);

                Vec jy2=Vec::Load(p,&jy_arr.p[jyoffset+moff[2]]);
                svfloat64_t rhoy2=svld1_gather_u64index_f64(p,&yrhocells[2+irhoy],rho_index);
                jy2+=rhoy2;
                jy2.Store(p,&jy_arr.p[jyoffset+moff[2]]);

                Vec jy3=Vec::Load(p,&jy_arr.p[jyoffset+moff[3]]);
                svfloat64_t rhoy3=svld1_gather_u64index_f64(p,&yrhocells[3+irhoy],rho_index);
                jy3+=rhoy3;
                jy3.Store(p,&jy_arr.p[jyoffset+moff[3]]);

                Vec jy4=Vec::Load(p,&jy_arr.p[jyoffset+moff[4]]);
                svfloat64_t rhoy4=svld1_gather_u64index_f64(p,&yrhocells[4+irhoy],rho_index);
                jy4+=rhoy4;
                jy4.Store(p,&jy_arr.p[jyoffset+moff[4]]);

                Vec jy5=Vec::Load(p,&jy_arr.p[jyoffset+moff[5]]);
                svfloat64_t rhoy5=svld1_gather_u64index_f64(p,&yrhocells[5+irhoy],rho_index);
                jy5+=rhoy5;
                jy5.Store(p,&jy_arr.p[jyoffset+moff[5]]);

                Vec jy6=Vec::Load(p,&jy_arr.p[jyoffset+moff[6]]);
                svfloat64_t rhoy6=svld1_gather_u64index_f64(p,&yrhocells[6+irhoy],rho_index);
                jy6+=rhoy6;
                jy6.Store(p,&jy_arr.p[jyoffset+moff[6]]);

                Vec jy7=Vec::Load(p,&jy_arr.p[jyoffset+moff[7]]);
                svfloat64_t rhoy7=svld1_gather_u64index_f64(p,&yrhocells[7+irhoy],rho_index);
                jy7+=rhoy7;
                jy7.Store(p,&jy_arr.p[jyoffset+moff[7]]);

                // z
                // uint64_t irhoz = ix + iy * zjstride + iz * zkstride;
                // svuint64_t rhoz_index = svindex_u64(irhoz, 8ULL);
                // long jzoffset = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
                // long zoffset = ix + iy * zjstride + iz * zkstride;
                long jzoffset=jxoffset;
                long irhoz=irhox;
                Vec jz0=Vec::Load(p,&jz_arr.p[jzoffset+moff[0]]);
                svfloat64_t rhoz0=svld1_gather_u64index_f64(p,&zrhocells[0+irhoz],rho_index);
                jz0+=rhoz0;
                jz0.Store(p,&jz_arr.p[jzoffset+moff[0]]);

                Vec jz1=Vec::Load(p,&jz_arr.p[jzoffset+moff[1]]);
                svfloat64_t rhoz1=svld1_gather_u64index_f64(p,&zrhocells[1+irhoz],rho_index);
                jz1+=rhoz1;
                jz1.Store(p,&jz_arr.p[jzoffset+moff[1]]);

                Vec jz2=Vec::Load(p,&jz_arr.p[jzoffset+moff[2]]);
                svfloat64_t rhoz2=svld1_gather_u64index_f64(p,&zrhocells[2+irhoz],rho_index);
                jz2+=rhoz2;
                jz2.Store(p,&jz_arr.p[jzoffset+moff[2]]);

                Vec jz3=Vec::Load(p,&jz_arr.p[jzoffset+moff[3]]);
                svfloat64_t rhoz3=svld1_gather_u64index_f64(p,&zrhocells[3+irhoz],rho_index);
                jz3+=rhoz3;
                jz3.Store(p,&jz_arr.p[jzoffset+moff[3]]);

                Vec jz4=Vec::Load(p,&jz_arr.p[jzoffset+moff[4]]);
                svfloat64_t rhoz4=svld1_gather_u64index_f64(p,&zrhocells[4+irhoz],rho_index);
                jz4+=rhoz4;
                jz4.Store(p,&jz_arr.p[jzoffset+moff[4]]);

                Vec jz5=Vec::Load(p,&jz_arr.p[jzoffset+moff[5]]);
                svfloat64_t rhoz5=svld1_gather_u64index_f64(p,&zrhocells[5+irhoz],rho_index);
                jz5+=rhoz5;
                jz5.Store(p,&jz_arr.p[jzoffset+moff[5]]);

                Vec jz6=Vec::Load(p,&jz_arr.p[jzoffset+moff[6]]);
                svfloat64_t rhoz6=svld1_gather_u64index_f64(p,&zrhocells[6+irhoz],rho_index);
                jz6+=rhoz6;
                jz6.Store(p,&jz_arr.p[jzoffset+moff[6]]);

                Vec jz7=Vec::Load(p,&jz_arr.p[jzoffset+moff[7]]);
                svfloat64_t rhoz7=svld1_gather_u64index_f64(p,&zrhocells[7+irhoz],rho_index);
                jz7+=rhoz7;
                jz7.Store(p,&jz_arr.p[jzoffset+moff[7]]);

                // svetime[1]=rdtscv();
                // reduce_time+=(svetime[1]-svetime[0]);
            }
            #endif
        }
    }
#ifdef BREAKDOWN
    svetime[1]=rdtscv();
    reduce_time+=(svetime[1]-svetime[0]);
    
    // total_time[1]=rdtscv();
    // total_time[2]+=total_time[1]-total_time[0];

    // int world_rank;
    // MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);
    // int tid = omp_get_thread_num();
    // if (world_rank == 0 && tid == 0) {
        printf("================SME=================\n");
        printf("SME Total:%llu \n",(unsigned long long)(precompute+
            total_sort_time+cale_time+reduce_time));
        // printf("SME Total:%d \n",total_time[2]);
        printf("\t precompute:%lu \n",precompute);
        printf("\t\t --precompute1:%lu \n",precompute1[0]);
        printf("\t\t --precompute2:%lu \n",precompute1[1]);
        // printf("\t\t --precompute3:%lu \n",precompute1[2]);
        // printf("\t\t --precompute4:%lu \n",precompute1[3]);
        printf("\t total_sort_time:%lu \n",total_sort_time);
        printf("\t\t --sort_time:%lu \n",sort_time[0]);
        printf("\t\t --pma compact:%lu \n",sort_time[1]);
        // printf("\t\t --presort:%lu \n",presort);
        // printf("\t\t --borrow:%lu \n",borrow);
        // printf("\t\t --rebuildtime:%lu \n",rebuildtime);
        printf("\t cale_time:%lu \n",cale_time);
        printf("\t reduce_time:%lu \n",reduce_time);
        // printf("\t\t update1:%d ",update[0]);
        // printf(" update2:%d \n",update[1]);
        // printf("\t\t --Dupdate0:%d \n",update1[0]);
        // printf("\t\t --Dupdate1:%d \n",update1[1]);
        // printf("\t\t --Dupdate2:%d \n",update1[2]);
        // printf("\t\t --Dupdate3:%d \n",update1[3]);
        // printf("\t\t --Dupdate4:%d \n",update1[4]);
        // printf("\t\t --Dupdate5:%d \n",update1[5]);
        // printf("\t\t presort:%d \n",presort);
        // printf("\t\t insert:%d \n",insert);
        // printf("\t\t borrow:%d \n",borrow);
        // printf("\t\t rebuildtime:%d \n",rebuildtime);
        // printf("\t\t --Drebuild0:%d \n",rebuild1[0]);
        // printf("\t\t --Drebuild1:%d \n",rebuild1[1]);
        // printf("\t\t --Drebuild2:%d \n",rebuild1[2]);
        // printf("\t\t --Drebuild3:%d \n",rebuild1[3]);
        // printf("\t\t --Drebuild4:%d \n",rebuild1[4]);
        // printf("\t\t --Drebuild5:%d \n",rebuild1[5]);
        // printf("\t reduce_time:%lu \n",reduce_time);
    // }
#endif
}


 template <int depos_order>
 void doDepositionShapeN_3d_sme (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Dim3 hi,
                          amrex::Dim3 len,
                          amrex::Real q,
                          std::vector<int>& test,
                          std::vector<double>& test0,
                          std::vector<double>& test1,
                          ParticleTileType& ptile, const amrex::Box& box,
                          std::vector<amrex::Real>& test_rhocells,
                          std::vector<amrex::Real>& test_sxwq,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     WARPX_PROFILE("doDepositionShapeN_3d_sme()");
     // uint64_t total_time[3]={0};
     using namespace std::chrono;
     using namespace amrex::literals;
     double total_time=0;
     // auto total_start=high_resolution_clock::now();
     uint64_t precompute=0;
     uint64_t cale_time=0;
     uint64_t sort_time=0;
         uint64_t count_time=0;
         uint64_t presum_time=0;
         uint64_t binlist_time=0;
     uint64_t reduce_time=0;
     uint64_t svetime[3]={0};
     uint64_t branch_time=0;
     
     // total_time[0]=rdtscv();
     
 
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z; 
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
 
     constexpr int nshapes = depos_order + 1;
     // constexpr int nshapes = 2;
     int vl=svcntd();
 
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
 
     auto compute_shape_factor_v1 = [](double* sx, Vec xmid, svbool_t p) {
         const svuint64_t sx_index = svindex_u64(0, 2);
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // double test[8];
         // xint.Store(p,&test[0]);
         // for(int ii=0;ii<8;ii++){
         //     // printf("ii %d xind %f \n",ii,test[ii]);
         //     sx[ii][0]=1.0-test[ii];
         //     sx[ii][1]=test[ii];
         // }
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         // double sx00[8];
         // double sx01[8];
         // sx0.Store(p,&sx00[0]);
         // sx1.Store(p,&sx01[0]);
         // for(int ii=0;ii<8;ii++){
         //     // printf("ii %d xind %f \n",ii,test[ii]);
         //     sx[ii][0]=sx00[ii];
         //     sx[ii][1]=sx01[ii];
         // }
         svst1_scatter_index(p,&sx[0],sx_index,sx0);
         svst1_scatter_index(p,&sx[1],sx_index,sx1);
         // sx0.Store(p, sx[0]);
         // sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
     // // const long numcell = jx_fab.box().numPts();
     // const long numcell = ptile.m_bin_offsets.size();
 
     // std::vector<amrex::Real> xrhocells(8*numcell, 0.0);
     // std::vector<amrex::Real> yrhocells(8*numcell, 0.0);
     // std::vector<amrex::Real> zrhocells(8*numcell, 0.0);
     // one roll x
    //  uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
    //  uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
    //  uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
    //  long nx=xjstride;
    //  long nxy=xkstride;
    //  long moff[8] = {0, 1, nx, nx+1, nxy, nxy+1, nx+nxy, nx+nxy+1};
    //  svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
    //  svbool_t px = svcmpeq_n_u64(svptrue_b64(), rmx_v, 0);
    //  svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
    //  svbool_t py = svcmpeq_n_u64(svptrue_b64(), rmy_v, 0);
    //  svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
    //  svbool_t pz = svcmpeq_n_u64(svptrue_b64(), rmz_v, 0);
 
     std::vector<amrex::Real> wqx(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqy(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqz(np_to_deposit, 0.0);
 
     std::vector<amrex::Real> sx_m(np_to_deposit*nshapes, 0.);
     std::vector<amrex::Real> sy_m(np_to_deposit*nshapes, 0.);
     std::vector<amrex::Real> sz_m(np_to_deposit*nshapes, 0.);
     alignas(64) long xoffsets[np_to_deposit]; 
     // alignas(64) long yoffsets[np_to_deposit];
     // alignas(64) long zoffsets[np_to_deposit];
     long bx = 2, by = 2, bz = 2;
     amrex::IntVect box_shape = box.length();
     // amrex::Print() << "Box shape: " << box_shape << std::endl;
     long nnx = len.x;
     long nny = len.y;
     long nnxny = nnx*nny;
     alignas(64) std::vector<long> newbin(np_to_deposit);
     // alignas(64) long newbin[np_to_deposit];
     
     // #pragma omp simd
     for(long ip=0;ip<np_to_deposit;ip+=vl){
         // svetime[0]=rdtscv();
 
         // 计算基本物理量
         svbool_t p=svwhilele_b64(ip,np_to_deposit);
         // Inverse of Lorentz factor gamma
         Vec uxp_v=Vec::Load(p,&uxp[ip]);
         Vec uyp_v=Vec::Load(p,&uyp[ip]);
         Vec uzp_v=Vec::Load(p,&uzp[ip]);
         Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                     + uyp_v * uyp_v * clightsq
                                     + uzp_v * uzp_v * clightsq).Sqrt();
         // Product of particle charges and weights
         Vec wp_v=Vec::Load(p,&wp[ip]);
         Vec wq_v = q * wp_v;
 
         // Current particle positions (in physical units)
         Vec xp = Vec::Load(p, &mx[ip]);
         Vec yp = Vec::Load(p, &my[ip]);
         Vec zp = Vec::Load(p, &mz[ip]);
 
         // Particle velocities
         Vec vx_v = uxp_v * gaminv;
         Vec vy_v = uyp_v * gaminv;
         Vec vz_v = uzp_v * gaminv;
 
         // if (do_ionization) wq *= ion_lev[ip];
         Vec wqx_v = wq_v * invvol * vx_v;
         Vec wqy_v = wq_v * invvol * vy_v;
         Vec wqz_v = wq_v * invvol * vz_v;
 
         wqx_v.Store(p, &wqx[ip]);
         wqy_v.Store(p, &wqy[ip]);
         wqz_v.Store(p, &wqz[ip]);
 
         Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x;
         Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y;
         Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z;
         // xmid.Store(p, &test0[ip]);
         // double* sx_temp[nshapes] = {&sx_m[0][ip], &sx_m[1][ip]};
         intVec j_cellv = compute_shape_factor_v1( &sx_m[ip*2], xmid, p);
         // j_cellv.Store(p, &test[ip]);
         intVec k_cellv = compute_shape_factor_v1( &sy_m[ip*2], ymid, p);
         intVec l_cellv = compute_shape_factor_v1( &sz_m[ip*2], zmid, p); 
 
         intVec xoffsets_v = j_cellv + k_cellv * xjstride + l_cellv * xkstride;
         // intVec yoffsets_v = j_cellv + k_cellv * yjstride + l_cellv * ykstride;
         // intVec zoffsets_v = j_cellv + k_cellv * zjstride + l_cellv * zkstride;
 
         xoffsets_v.Store(p,&xoffsets[ip]);
         intVec new_bin_v = (j_cellv) + 
                             (k_cellv)* nnx + 
                             (l_cellv) * nnxny;
         new_bin_v.Store(p,&newbin[ip]);
         // yoffsets_v.Store(p,&yoffsets[ip]);
         // zoffsets_v.Store(p,&zoffsets[ip]);
 
         // 原子操作，不可避免
         // const int vec_len = std::min(vl, static_cast<int>(np_to_deposit-ip));
         // svetime[2]=rdtscv();
         // for(int off=0;off<vec_len;off++){
         //     xcount[xoffsets[ip+off]]++;
         //     // ycount[yoffsets[ip+off]]++;
         //     // zcount[zoffsets[ip+off]]++;
         // }
         // svetime[1]=rdtscv();
         // count_time+=(svetime[1]-svetime[2]);
 
         // printf("after STORE\n");
         // svetime[1]=rdtscv();
         // precompute+=(svetime[1]-svetime[0]); 
         // printf("after SAVE\n");
     }
    //  test0=sx_m;
    test0.assign(2*np_to_deposit,0);
    test1=wqx;
//  for(int ip=0;ip<np_to_deposit;ip++){
//     test
//  }
    // const long numcell = jx_fab.box().numPts();
    // const long numcell = ptile.m_bin_offsets.size()-1;
    const int numcell=ptile.m_num_bins;
    // if(numcell!=ptile.m_num_bins){
        // printf("numcell %d m_num_bins %d \n",numcell,ptile.m_num_bins);
        // printf("len.x %d y %d z %d xyz %d \n",len.x,len.y,len.z,len.z*len.y*len.x);
        // printf("xjstride %d xkstride %d \n",xjstride,xkstride);
        // printf("nnx %d nny %d nnxnny \n",nnx,nny,nnxny);
        // amrex::Abort("numcell !=ptile.m_num_binss");
    // }

    std::vector<amrex::Real> xrhocells(8*numcell, 0.0);
    std::vector<amrex::Real> testsxwq(8*np_to_deposit, 0.0);
    std::vector<amrex::Real> yrhocells(8*numcell, 0.0);
    std::vector<amrex::Real> zrhocells(8*numcell, 0.0);
    // for(int ip=0;ip<np_to_deposit;ip++){
    //     if(newbin[ip]>=numcell){
    //         // printf("%d out numcell!!\n",newbin[ip]);
    //         newbin[ip]=numcell-1;
    //     }
    //     if(newbin[ip]<0){
    //         // printf("%d out numcell!!\n",newbin[ip]);
    //         newbin[ip]=0;
    //     }
    // }
    // for(int ip=0;ip<np_to_deposit;ip++){
    //     printf("[1] pid_to_index_map[%d] = %d\n",ip,ptile.m_pid_to_index_map[ip]);
    // }
    // amrex::Abort("a");
# if 0 //只往右边找的方案，目前只允许找右边2个，可扩展到n个
    ///////////判断、增量处理（删除、更新索引）、或重组过程////////////
    auto& local_index = ptile.m_local_index;
    auto& bin_offsets = ptile.m_bin_offsets;
    auto& bin_length = ptile.m_bin_lengths;
    auto& num_particles = ptile.m_num_particles;
    // const long numcell = ptile.m_bin_offsets.size()-1;
    // const long numcell = jx_fab.box().numPts();
    auto& pid_to_bin_map = ptile.m_pid_to_bin_map;
    auto& pid_to_index_map = ptile.m_pid_to_index_map; 
    auto& free_slot = ptile.m_free_slots;
    // std::vector<ParticleMove> m_pending_moves;
    std::unordered_map<int, std::vector<int>> m_pending_moves;
    // pid_to_bin_map.assign(newbin.begin(),newbin.end());
    bool rebuild=false;
    // std::vector<int> borrow_size(np_to_deposit,0);

    // L1：粒子总数超过最大容量直接重组
    if(np_to_deposit<ptile.m_capacity){
        // 先统一操作，搜索一遍所有待增量更新的粒子
        // 新增粒子添加
        for(int ip=num_particles;ip<np_to_deposit;ip++){
            int new_bin=newbin[ip];
            m_pending_moves[new_bin].push_back(ip);
        }
        // 减少的粒子删除
        for(int ip=np_to_deposit;ip<num_particles;ip++){
            int old_bin=pid_to_bin_map[ip];
            int idx=pid_to_index_map[ip]; 
            //打洞、长度缩减、压栈
            ptile.m_local_index[idx] = INVALID_PARTICLE_ID;
            bin_length[old_bin]--;
            free_slot[old_bin].push_back(idx);
        }
        // 对变化的粒子先做了删除操作
        for(int ip=0;ip<=num_particles;ip++){
            int new_bin=newbin[ip];
            int old_bin=pid_to_bin_map[ip]; //这个时候pid_to_bin_map还代表旧binID
            if(old_bin!=new_bin){
                // 打洞、长度减1、空槽压栈
                int idx=pid_to_index_map[ip]; //这个时候pid_to_index_map还代表旧index
                m_pending_moves[new_bin].push_back(ip);
                local_index[idx] = INVALID_PARTICLE_ID;
                bin_length[old_bin]--;
                free_slot[old_bin].push_back(idx);
            }
        }
        // // L2：粗粒度判断，单个空槽位中待添加的粒子超出最大单bin容量直接重组
        // for (int old_bin = 0; old_bin < numcell; ++old_bin) {
        //     int needed_count = m_pending_moves.at(old_bin).size();
        //     if (needed_count > ptile.m_max_bin_capacity) break;
        // }
        // 其实也暂时不需要这个容量判断，和L3的策略重复了

        // L3：通过对比移动增量开销和重组开销来判断重组
        float rebuild_weight=WarpX::GetInstance().m_rebuild_weight;
        // float rebuild_cost=1.2; // 重组开销权重，实验测定暂定1.2吧
        // 重组开销，增量开销未达到重组开销时就不用重组
        // 重组一个粒子需要扫描一遍粒子，扫描一边网格，扫描一遍带空槽的粒子,最后扫描一遍粒子
        // 这里+估计为1，*估计为3，默认数据IO都能在在寄存器里为1
        float Cost_Global = rebuild_weight *(np_to_deposit + numcell*5
                                            +(np_to_deposit * WarpX::GetInstance().m_gap_ratio)
                                            + np_to_deposit); 

        // 预计算局部重组开销（只向右边查找）：
        // 累加（用freeslot栈移出空位开销+需要借用第n个块的开销）
        // 廉价的移动方案开销极低，复杂的方案就直接重组了
        float slot_cost=1.; // 借用空槽的cost
                            // 借空槽只需要一次交换，一次填充，所以是1
        float move_cost=6.; // 移动数据块的cost,交换操作一次3*2
                            // 采用交换法（不用压实然后memmove）的话开销和大概就是一次访存估计为3-5
        float total_move_cost=0; //总开销
        // float rebuild_weight=WarpX::GetInstance().m_rebuild_weight; //达到重组开销的90%（可修改）就直接跳出直接重组了
        
        std::vector<int> borrow_size(np_to_deposit,0);
        // for (const auto& pair : m_pending_moves) {
        //     int old_bin=pair.first;
        // }

        // 先处理最后两个块，允许向左查找
        for (int old_bin = numcell-1; old_bin >= numcell-2; --old_bin) { // 因为只找右边，所以末尾2块需要特殊处理
            // 添加使用空槽的开销
            if (m_pending_moves.find(old_bin)==m_pending_moves.end()) continue;//有需要才计算
            int needed_count = m_pending_moves.at(old_bin).size();
            if (needed_count <= free_slot[old_bin].size()) {
                continue;
            }
            // 添加移动块数据的开销
            // 因为重组计算了遍历粒子的开销，所以这里把插空开销也直接算进来了
            int needed_borrow = needed_count - free_slot[old_bin].size();
            total_move_cost+=(needed_count-needed_borrow)*slot_cost; //粒子插空的
            // total_move_cost+=move_cost*needed_borrow;//needed_borrow个粒子交换了
            //最多允许借左边隔壁2个块
            int next_pending_moves=0;
            int borrow_bin=old_bin-1;
            if (m_pending_moves.find(borrow_bin)!=m_pending_moves.end()) {//有空槽才能借用
                next_pending_moves=m_pending_moves.at(borrow_bin).size();
                if (needed_borrow <= (free_slot[borrow_bin].size()
                                        -next_pending_moves
                                        -borrow_size[borrow_bin])) {
                    borrow_size[borrow_bin]+=needed_borrow; //借到了跳出，空槽被借用
                    total_move_cost+=move_cost*needed_borrow;//needed_borrow个粒子交换了
                    if(total_move_cost>Cost_Global){ 
                        rebuild=true;
                        break;
                    }
                    continue;
                }
            }
            if (m_pending_moves.find(borrow_bin-1)!=m_pending_moves.end()) {//第2块还没空槽就直接跳出了
                //先处理上一个块的借用情况
                total_move_cost+=move_cost*(free_slot[borrow_bin].size()
                                        -next_pending_moves
                                        -borrow_size[borrow_bin]);
                needed_borrow-=(free_slot[borrow_bin].size()
                                    -next_pending_moves
                                    -borrow_size[borrow_bin]);//不够，先更新needed_borrow，再更新borrow_size占满这个块
                borrow_size[borrow_bin]=free_slot[borrow_bin].size()-next_pending_moves; 
                //接下来更新这个块的借用情况
                next_pending_moves=m_pending_moves.at(borrow_bin-1).size();
                if (needed_borrow <= (free_slot[borrow_bin-1].size()
                                        -next_pending_moves
                                        -borrow_size[borrow_bin-1])) {
                    borrow_size[borrow_bin-1]+=needed_borrow; //距离为2的空槽被借用
                    total_move_cost+=move_cost*needed_borrow*2;//和上一个不一样，借一个要移动两次
                    if(total_move_cost>Cost_Global){ 
                        rebuild=true;
                        break;
                    }
                    continue;
                }
            }
            //如果上面顺利就不会到这一步，到了这一步说明借不到空槽，必须重组了
            rebuild=true;
            break;
        }
        // 再处理其他块
        // 因为只找右边，所以末尾2块需要特殊处理
        if(!rebuild){
            for (int old_bin = 0; old_bin < numcell-2; ++old_bin) { 
                // 添加使用空槽的开销
                if (m_pending_moves.find(old_bin)==m_pending_moves.end()) continue;//有需要才计算
                int needed_count = m_pending_moves.at(old_bin).size();
                if (needed_count <= free_slot[old_bin].size()) {
                    continue;
                }
                // 添加移动块数据的开销
                // 因为重组计算了遍历粒子的开销，所以这里把插空开销也直接算进来了
                int needed_borrow = needed_count - free_slot[old_bin].size();
                total_move_cost+=(needed_count-needed_borrow)*slot_cost; //粒子插空的
                //最多允许借隔壁2个块
                int next_pending_moves=0;
                int borrow_bin=old_bin+1;
                if (m_pending_moves.find(borrow_bin)!=m_pending_moves.end()) {//有空槽才能借用
                    next_pending_moves=m_pending_moves.at(borrow_bin).size();
                    if (needed_borrow <= (free_slot[borrow_bin].size()
                                            -next_pending_moves
                                            -borrow_size[borrow_bin])) {
                        borrow_size[borrow_bin]+=needed_borrow; //借到了跳出，空槽被借用
                        total_move_cost+=move_cost*needed_borrow;//needed_borrow个粒子交换了
                        if(total_move_cost>Cost_Global){ 
                            rebuild=true;
                            break;
                        }
                        continue;
                    }
                }
                if (m_pending_moves.find(borrow_bin+1)!=m_pending_moves.end()) {//第2块还没空槽就直接跳出了
                    //先处理上一个块的借用情况
                    total_move_cost+=move_cost*(free_slot[borrow_bin].size()
                                            -next_pending_moves
                                            -borrow_size[borrow_bin]);
                    needed_borrow-=(free_slot[borrow_bin].size()
                                        -next_pending_moves
                                        -borrow_size[borrow_bin]);//不够，先更新needed_borrow，再更新borrow_size占满这个块
                    borrow_size[borrow_bin]=free_slot[borrow_bin].size()-next_pending_moves; 
                    //接下来更新这个块的借用情况
                    next_pending_moves=m_pending_moves.at(borrow_bin+1).size();
                    if (needed_borrow <= (free_slot[borrow_bin+1].size()
                                            -next_pending_moves
                                            -borrow_size[borrow_bin+1])) {
                        borrow_size[borrow_bin+1]+=needed_borrow; //距离为2的空槽被借用
                        total_move_cost+=move_cost*needed_borrow*2;//和上一个不一样，借一个要移动两次
                        if(total_move_cost>Cost_Global){ 
                            rebuild=true;
                            break;
                        }
                        continue;
                    }
                }
                //如果上面顺利就不会到这一步，到了这一步说明借不到空槽，必须重组了
                rebuild=true;
                break;
            }
            //这是用压实法的代价计算，现在不用了
            // for (int old_bin = 0; old_bin < numcell-2; ++old_bin) { 
            //     if (m_pending_moves.find(old_bin)==m_pending_moves.end()) continue;
            //     // 添加使用空槽的开销
            //     int needed_count = m_pending_moves.at(old_bin).size();
            //     // total_move_cost+=needed_count*slot_cost; // 纯使用空槽的开销不计
            //     if (needed_count <= free_slot[old_bin].size()) {
            //         continue;
            //     }
            //     // 添加移动块数据的开销
            //     int needed_borrow = needed_count - free_slot[old_bin].size();
            //     total_move_cost+=needed_borrow*slot_cost; // 借用别人的空槽的开销要计算
            //     int len_borrow=std::min(old_bin+3,numcell-2);//最多允许借右边隔壁2个块
            //     for (int i = old_bin+1; i < len_borrow; ++i) {
            //         int next_pending_moves=0;
            //         if (m_pending_moves.find(i)!=m_pending_moves.end()) next_pending_moves=m_pending_moves.at(i).size();
            //         total_move_cost+=move_cost*(bin_length[i-1]
            //                                     +m_pending_moves.at(i-1).size()
            //                                     +borrow_size[i-1]);//计算移动的开销      
            //         if (needed_borrow <= (free_slot[i].size()
            //                                 -next_pending_moves
            //                                 -borrow_size[i])) {
            //             borrow_size[i]+=needed_borrow; //借到了跳出，空槽被借用
            //             break;
            //         }
            //         needed_borrow-=(free_slot[i].size()
            //                         -next_pending_moves
            //                         -borrow_size[i]);//不够，先更新needed_borrow，再更新borrow_size占满这个块
            //         borrow_size[i]+=(free_slot[i].size()
            //                         -next_pending_moves
            //                         -borrow_size[i]); 
            //     }
            //     //如果代价太高或者借不到就直接重组
            //     //如果全部都只使用了空槽是一定不会触发重组的
            //     if(total_move_cost>rebuild_weight*Cost_Global || 
            //         needed_borrow>0){ 
            //         rebuild=true;
            //         break;
            //     }
            // }
        }
    }
    else{
        rebuild=true;
    }
    ptile.m_pid_to_bin_map.assign(newbin.begin(),newbin.end());
    ptile.m_num_particles=np_to_deposit;
    ptile.m_was_rebuilt_this_step= false ;

    if(!rebuild){ // 代价可以接受
        //如果代价可以接受，就得顺便把一些参数增量更新了
        ptile.m_num_empty_slots=ptile.m_capacity-np_to_deposit;
        for (const auto& pair : m_pending_moves) {
            int new_bin=pair.first;
            std::vector<int>& particles_ip = m_pending_moves[new_bin];
            ptile.m_bin_lengths[new_bin]+=particles_ip.size();
            // for (const auto& pid : particles_ip) {
            for (int i=particles_ip.size()-1; i>=0;i--) {
                int pid=particles_ip.back();
                int insert_idx = ptile.findEmptySlotInBin(new_bin);
                if (insert_idx != -1) {
                    // 直接填坑、退槽、长度增加（map已经完成更新）
                    ptile.m_local_index[insert_idx] = pid;
                    ptile.m_free_slots[new_bin].pop_back();
                    // ptile.m_bin_lengths[new_bin]++;
                    ptile.m_pid_to_index_map[pid]=insert_idx;
                    particles_ip.pop_back(); //一边填空一边更新pending_moves待插入的元素
                    // printf("inserted pid %d to bin %d at %d\n", mv.pid, mv.new_bin,insert_idx);
                } else {
                    break;
                }
            }
        }
        //还有没更新完的就需要借用了
        //最多允许借右边隔壁2个块
        //先处理末尾两个允许向左借用
        for (int new_bin = numcell-1; new_bin >= numcell-2; --new_bin) { 
            //判断这块有没有数据，有就操作，不然跳过
            if (m_pending_moves.find(new_bin)==m_pending_moves.end()) continue;
            int needed_borrow = m_pending_moves.at(new_bin).size();
            std::vector<int>& particles_ip = m_pending_moves[new_bin];

            int borrow_bin = new_bin-1;
            // int num_borrow = 0;
            int idx=ptile.m_bin_offsets[new_bin]-1; //指向第一个块的尾巴指针
            int idx2=ptile.m_bin_offsets[new_bin-1]-1; //指向第二个块的尾巴指针
            // for (int i = 0; borrow_bin >= new_bin-2; --borrow_bin) {
            while(needed_borrow>0 || borrow_bin >= new_bin-2){
                //idx一直指向需要插入的尾巴
                int insert_idx = ptile.findEmptySlotInBin(borrow_bin);//这是借用空槽的位置
                int pid=particles_ip.back();
                if(insert_idx != -1) {
                    if (borrow_bin==new_bin-1) {
                        // 把借用位置的尾巴腾出空位
                        ptile.m_free_slots[borrow_bin].pop_back();
                        ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                        if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID)
                            ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                        // 向借的位置填入粒子
                        ptile.m_local_index[insert_idx] = pid;
                        // ptile.m_bin_offsets[new_bin] 这两个参数统一更新了
                        // ptile.m_bin_lengths[new_bin]++;
                        ptile.m_pid_to_index_map[pid]=idx;
                        particles_ip.pop_back(); //一边填空一边更新pending_moves待插入的元素
                        needed_borrow--;
                        // num_borrow++;
                        idx--;
                        continue;
                    } 
                    // int idx2=ptile.m_bin_offsets[borrow_bin]-1;
                    if (borrow_bin==new_bin-2) {
                        // 把借用位置的尾巴腾出空位
                        ptile.m_free_slots[borrow_bin].pop_back();
                        ptile.m_local_index[insert_idx]=ptile.m_local_index[idx2];
                        if(ptile.m_local_index[idx2]!=INVALID_PARTICLE_ID)
                            ptile.m_pid_to_index_map[ptile.m_local_index[idx2]]=insert_idx;
                        // 先向借用位置交换上一个大块的尾巴数据
                        ptile.m_local_index[idx2] = ptile.m_local_index[idx];
                        ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=ptile.m_local_index[idx2];
                        // 向借的第一块中已经流出来的位置填入粒子
                        ptile.m_local_index[idx] = pid;
                        ptile.m_pid_to_index_map[pid]=idx;
                        particles_ip.pop_back(); 
                        needed_borrow--;
                        // num_borrow++;
                        //两个尾巴指针同时更新
                        idx--;
                        idx2--;
                    } // 换两次位置的策略，不用memmove了
                }
                else {
                    //往前挪动一块，同时更新一次offsets
                    //直接更新第二个块的offsets也没问题，因为尾指针没变化
                    borrow_bin--;
                    ptile.m_bin_offsets[new_bin]=idx+1;
                    ptile.m_bin_offsets[new_bin-1]=idx2+1;
                }
            }
        }
        m_pending_moves.erase(numcell-1);
        m_pending_moves.erase(numcell-2);
        //现在按顺序处理向右边两个允许借用
        for (const auto& pair : m_pending_moves) {
            int new_bin=pair.first;
            std::vector<int>& particles_ip = m_pending_moves[new_bin];
            
            int needed_borrow = m_pending_moves.at(new_bin).size();
            int borrow_bin = new_bin+1;
            // int num_borrow = 0;
            int idx=ptile.m_bin_offsets[new_bin+1]; //指向第一个块的头指针
            int idx2=ptile.m_bin_offsets[new_bin+2]; //指向第二个块的头指针
            while(needed_borrow>0 || borrow_bin >= new_bin+2){
                //idx一直指向需要插入的尾巴
                int insert_idx = ptile.findEmptySlotInBin(borrow_bin);//这是借用空槽的位置
                int pid=particles_ip.back();
                if(insert_idx != -1) {
                    if (borrow_bin==new_bin+1) {
                        // 把借用位置的尾巴腾出空位
                        ptile.m_free_slots[borrow_bin].pop_back();
                        ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                        if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID)
                            ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                        // 向借的位置填入粒子
                        ptile.m_local_index[insert_idx] = pid;
                        // ptile.m_bin_offsets[new_bin] 这两个参数统一更新了
                        // ptile.m_bin_lengths[new_bin]++;
                        ptile.m_pid_to_index_map[pid]=idx;
                        particles_ip.pop_back(); //一边填空一边更新pending_moves待插入的元素
                        needed_borrow--;
                        // num_borrow++;
                        idx++;
                        continue;
                    } 
                    if (borrow_bin==new_bin+2) {
                        // 把借用位置的尾巴腾出空位
                        ptile.m_free_slots[borrow_bin].pop_back();
                        ptile.m_local_index[insert_idx]=ptile.m_local_index[idx2];
                        if(ptile.m_local_index[idx2]!=INVALID_PARTICLE_ID)
                            ptile.m_pid_to_index_map[ptile.m_local_index[idx2]]=insert_idx;
                        // 先向借用位置交换上一个大块的尾巴数据
                        ptile.m_local_index[idx2] = ptile.m_local_index[idx];
                        ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=ptile.m_local_index[idx2];
                        // 向借的第一块中已经流出来的位置填入粒子
                        ptile.m_local_index[idx] = pid;
                        ptile.m_pid_to_index_map[pid]=idx;
                        particles_ip.pop_back(); 
                        needed_borrow--;
                        //两个尾巴指针同时更新
                        idx++;
                        idx2++;
                    } // 换两次位置的策略，不用memmove了
                }
                else {
                    //往后挪动一块，同时更新一次offsets
                    //直接更新第二个块的offsets也没问题，因为尾指针没变化
                    borrow_bin++;
                    ptile.m_bin_offsets[new_bin+1]=idx;
                    ptile.m_bin_offsets[new_bin+2]=idx2;
                }
            }
        }
    }else{ //代价太高直接重组
        //重组就不需要增量修改那些，只需要pid_to_map正确即可
        ptile.m_was_rebuilt_this_step = true;
        std::vector<int> final_bin_counts(numcell, 0);
        float gap_ratio=WarpX::GetInstance().m_gap_ratio;
        pid_to_bin_map = ptile.m_pid_to_bin_map;
        int np = ptile.m_num_particles;

        for(int ip=0;ip<np;ip++){
            final_bin_counts[pid_to_bin_map[ip]]++;
        }  
        // ptile.m_capacity = np*(1+gap_ratio)+numcell*1.5;
        ptile.m_capacity = static_cast<int>(std::ceil(static_cast<double>(np) * (1.0 + gap_ratio)) + 2*numcell);

        int current_offset = 0;
        ptile.m_bin_offsets[0] = 0;
        for (int binID = 0; binID < numcell; ++binID) {
            int np_in_bin = final_bin_counts[binID];
            ptile.m_bin_lengths[binID] = np_in_bin; // 存储最终的有效粒子数
            int gap = (np_in_bin > 0) ? static_cast<int>(std::ceil(np_in_bin * gap_ratio)) : 1; // 至少留一个空槽
            int block_size = np_in_bin + gap;
            // ptile.m_num_empty_slots+=gap;
            current_offset += block_size;
            ptile.m_free_slots[binID].clear();
            for(int i = current_offset-1; i >= current_offset-gap; --i){
                ptile.m_free_slots[binID].push_back(i);
            }
            if(current_offset>ptile.m_capacity){
                amrex::Abort("ERROR: current_offset > m_capacity!!!");
            }
            ptile.m_bin_offsets[binID + 1] = current_offset;
        }
        if(ptile.m_bin_offsets[numcell]>=ptile.m_capacity){
            printf("ptile.m_bin_offsets[numcell] %d m_capacity %d \n"
                ,ptile.m_bin_offsets[numcell],ptile.m_capacity);
            amrex::Abort("ERROR: m_bin_offsets[numcell] >= m_capacity!!!");
        }
        ptile.m_capacity=ptile.m_bin_offsets[numcell];
        // ptile.m_num_particles=np;
        ptile.m_num_empty_slots = ptile.m_capacity - ptile.m_num_particles;
        ptile.m_local_index.assign(ptile.m_capacity, INVALID_PARTICLE_ID);
        // 初始化为每个 bin 的起始位置
        std::vector<int> next_write_slot = ptile.m_bin_offsets; 
        for(int ip=0;ip<np;ip++){
            int bin_id =pid_to_bin_map[ip];
            int insert_idx = next_write_slot[bin_id];
            ptile.m_local_index[insert_idx] = ip;
            ptile.m_pid_to_index_map[ip]=insert_idx;
            next_write_slot[bin_id]++;
        }
        // ptile.m_local_index.resize(ptile.m_capacity, INVALID_PARTICLE_ID);
        // ptile.m_num_particles = np;
        ptile.m_was_rebuilt_this_step = true;
        // printf("rebuild!!!!!!!!!\n");
    }
    m_pending_moves.clear();

    //////////////////////////////////////////////////////
# endif

# if 1 //只允许找左右两边借的方案，更快更稳定，但是不能扩展
    ///////////判断、增量处理（删除、更新索引）、或重组过程////////////
    auto& local_index = ptile.m_local_index;
    auto& bin_offsets = ptile.m_bin_offsets;
    auto& bin_length = ptile.m_bin_lengths;
    auto& num_particles = ptile.m_num_particles;
    // const long numcell = ptile.m_bin_offsets.size()-1;
    // const long numcell = jx_fab.box().numPts();
    auto& pid_to_bin_map = ptile.m_pid_to_bin_map;
    auto& pid_to_index_map = ptile.m_pid_to_index_map; 
    auto& free_slot = ptile.m_free_slots;
    // std::vector<ParticleMove> m_pending_moves;
    std::unordered_map<int, std::vector<int>> m_pending_moves;
    // pid_to_bin_map.assign(newbin.begin(),newbin.end());
    bool rebuild=false;
    // std::vector<int> borrow_size(np_to_deposit,0);

    // L1：粒子总数超过最大容量直接重组
    if(np_to_deposit<ptile.m_capacity){
        // 先统一操作，搜索一遍所有待增量更新的粒子
        // 新增粒子添加
        for(int ip=num_particles;ip<np_to_deposit;ip++){
            int new_bin=newbin[ip];
            m_pending_moves[new_bin].push_back(ip);
        }
        // 减少的粒子删除
        for(int ip=np_to_deposit;ip<num_particles;ip++){
            int old_bin=pid_to_bin_map[ip];
            int idx=pid_to_index_map[ip]; 
            //打洞、长度缩减、压栈
            ptile.m_local_index[idx] = INVALID_PARTICLE_ID;
            bin_length[old_bin]--;
            free_slot[old_bin].push_back(idx);
        }
        // 对变化的粒子先做了删除操作
        for(int ip=0;ip<num_particles;ip++){
            int new_bin=newbin[ip];
            int old_bin=pid_to_bin_map[ip]; //这个时候pid_to_bin_map还代表旧binID
            if(old_bin!=new_bin){
                // 打洞、长度减1、空槽压栈
                int idx=pid_to_index_map[ip]; //这个时候pid_to_index_map还代表旧index
                m_pending_moves[new_bin].push_back(ip);
                local_index[idx] = INVALID_PARTICLE_ID;
                bin_length[old_bin]--;
                free_slot[old_bin].push_back(idx);
            }
        }
        // // L2：粗粒度判断，单个空槽位中待添加的粒子超出最大单bin容量直接重组
        // for (int old_bin = 0; old_bin < numcell; ++old_bin) {
        //     int needed_count = m_pending_moves.at(old_bin).size();
        //     if (needed_count > ptile.m_max_bin_capacity) break;
        // }
        // 其实也暂时不需要这个容量判断，和L3的策略重复了

        // L3：通过对比移动增量开销和重组开销来判断重组
        float rebuild_weight=WarpX::GetInstance().m_rebuild_weight;
        // float rebuild_cost=1.2; // 重组开销权重，实验测定暂定1.2吧
        // 重组开销，增量开销未达到重组开销时就不用重组
        // 重组一个粒子需要扫描一遍粒子，扫描一边网格，扫描一遍带空槽的粒子,最后扫描一遍粒子
        // 这里+估计为1，*估计为3，默认数据IO都能在在寄存器里为1
        float Cost_Global = rebuild_weight *(np_to_deposit + numcell*5
                                            +(np_to_deposit * WarpX::GetInstance().m_gap_ratio)
                                            + np_to_deposit); 

        // 预计算局部重组开销（只向右边查找）：
        // 累加（用freeslot栈移出空位开销+需要借用第n个块的开销）
        // 廉价的移动方案开销极低，复杂的方案就直接重组了
        float slot_cost=1.; // 借用空槽的cost
                            // 借空槽只需要一次交换，一次填充，所以是1
        float move_cost=6.; // 移动数据块的cost,交换操作一次3*2
                            // 采用交换法（不用压实然后memmove）的话开销和大概就是一次访存估计为3-5
        float total_move_cost=0; //总开销
        // float rebuild_weight=WarpX::GetInstance().m_rebuild_weight; //达到重组开销的90%（可修改）就直接跳出直接重组了
        
        std::vector<int> borrow_size(np_to_deposit,0);

        // 先处理首尾两个块
        int old_bin = numcell-1; //尾块
        // 添加使用空槽的开销
        if (m_pending_moves.find(old_bin)==m_pending_moves.end()) {//有需要插空的才计算
            int needed_count = m_pending_moves.at(old_bin).size();
            if (needed_count > free_slot[old_bin].size()) {
                // 添加移动块数据的开销
                // 因为重组计算了遍历粒子的开销，所以这里把插空开销也直接算进来了
                int needed_borrow = needed_count - free_slot[old_bin].size();
                int can_borrow = 0;
                total_move_cost+=(needed_count-needed_borrow)*slot_cost; //粒子插空的
                //最多允许借左邻居隔壁1个块
                int next_pending_moves=0;
                int borrow_bin=old_bin-1;
                if (m_pending_moves.find(borrow_bin)!=m_pending_moves.end()) {
                    //如果邻居有需要插空的就记录一下，否则就不需要
                    next_pending_moves=m_pending_moves.at(borrow_bin).size();
                }
                can_borrow=(free_slot[borrow_bin].size()
                            -next_pending_moves
                            -borrow_size[borrow_bin]);
                //在左边借到了
                if (needed_borrow > can_borrow) {
                    rebuild=true;
                    // 基本上不会在一开始就超，所以不要判断成本
                    // if(total_move_cost>Cost_Global){ 
                    //     rebuild=true;
                    //     break;
                    // }
                }
                borrow_size[borrow_bin]+=needed_borrow; //借到了跳出，空槽被借用
                total_move_cost+=move_cost*needed_borrow;//needed_borrow个粒子交换了
            }
        }
        old_bin = 0; //首块
        // 添加使用空槽的开销
        if (m_pending_moves.find(old_bin)==m_pending_moves.end() && !rebuild) {//有需要插空的才计算
            int needed_count = m_pending_moves.at(old_bin).size();
            if (needed_count > free_slot[old_bin].size()) {
                // 添加移动块数据的开销
                // 因为重组计算了遍历粒子的开销，所以这里把插空开销也直接算进来了
                int needed_borrow = needed_count - free_slot[old_bin].size();
                int can_borrow = 0;
                total_move_cost+=(needed_count-needed_borrow)*slot_cost; //粒子插空的
                int next_pending_moves=0;
                int borrow_bin=old_bin+1;
                if (m_pending_moves.find(borrow_bin)!=m_pending_moves.end()) {
                    //如果邻居有需要插空的就记录一下，否则就不需要
                    next_pending_moves=m_pending_moves.at(borrow_bin).size();
                }
                can_borrow=(free_slot[borrow_bin].size()
                            -next_pending_moves
                            -borrow_size[borrow_bin]);
                //在左边借到了
                if (needed_borrow > can_borrow) {
                    rebuild=true;
                }
                borrow_size[borrow_bin]+=needed_borrow; //借到了跳出，空槽被借用
                total_move_cost+=move_cost*needed_borrow;//needed_borrow个粒子交换了
            }
        }
        // 处理左右借用，先借左边再借右边
        if(!rebuild && total_move_cost<=Cost_Global){
            // 首尾特殊单独处理了
            // for (int old_bin = 1; old_bin < numcell-1; ++old_bin) { 
            //     if (m_pending_moves.find(old_bin)==m_pending_moves.end()) continue;//有需要插空的才计算
            for (const auto& pair : m_pending_moves) {
                int old_bin=pair.first;
                if (old_bin==0 || old_bin==numcell-1) continue;//有需要插空的才计算
                // 添加使用空槽的开销
                int needed_count = m_pending_moves.at(old_bin).size();
                if (needed_count <= free_slot[old_bin].size()) {
                    continue;
                }
                // 添加移动块数据的开销
                // 因为重组计算了遍历粒子的开销，所以这里把插空开销也直接算进来了
                int needed_borrow = needed_count - free_slot[old_bin].size();
                int can_borrow = 0;
                total_move_cost+=(needed_count-needed_borrow)*slot_cost; //粒子插空的
                //最多允许借左右邻居隔壁2个块
                int next_pending_moves=0;
                int borrow_bin=old_bin-1;
                if (m_pending_moves.find(borrow_bin)!=m_pending_moves.end()) {
                    //如果邻居有需要插空的就记录一下，否则就不需要
                    next_pending_moves=m_pending_moves.at(borrow_bin).size();
                }
                can_borrow=(free_slot[borrow_bin].size()
                            -next_pending_moves
                            -borrow_size[borrow_bin]);
                //在左边就借到了
                if (needed_borrow <= can_borrow) {
                    borrow_size[borrow_bin]+=needed_borrow; //借到了跳出，空槽被借用
                    total_move_cost+=move_cost*needed_borrow;//needed_borrow个粒子交换了
                    if(total_move_cost>Cost_Global){ 
                        rebuild=true;
                        break;
                    }
                    continue;
                }
                //左边没借到就找右边
                //如果左边没空槽就会跳出了
                borrow_size[borrow_bin]=free_slot[borrow_bin].size()-next_pending_moves;
                int borrow_bin2=borrow_bin+2; 
                next_pending_moves=0;
                if (m_pending_moves.find(borrow_bin2)!=m_pending_moves.end()) {
                    next_pending_moves=m_pending_moves.at(borrow_bin2).size();
                }
                int can_borrow2=(free_slot[borrow_bin2].size()
                            -next_pending_moves
                            -borrow_size[borrow_bin2]);
                needed_borrow-=can_borrow;//不够，先更新needed_borrow，再更新borrow_size占满这个块
                if(can_borrow2<needed_borrow){ 
                    // 不够借就直接跳出，否则就够借
                    rebuild=true;
                    break;
                }
                //先处理上一个块的借用情况
                total_move_cost+=move_cost*can_borrow;
                //接下来更新这个块的借用情况
                borrow_size[borrow_bin2]+=needed_borrow; //被借用了多少
                total_move_cost+=move_cost*needed_borrow;//左右借用都一样
                if(total_move_cost>Cost_Global){ 
                    rebuild=true;
                    break;
                }
            }
        }
    }
    else{
        rebuild=true;
    }
    ptile.m_pid_to_bin_map.assign(newbin.begin(),newbin.end());
    ptile.m_num_particles=np_to_deposit;
    ptile.m_was_rebuilt_this_step= false ;

    if(!rebuild){ // 代价可以接受
        //如果代价可以接受，就得顺便把一些参数增量更新了
        ptile.m_num_empty_slots=ptile.m_capacity-np_to_deposit;
        for (const auto& pair : m_pending_moves) {
            int new_bin=pair.first;
            std::vector<int>& particles_ip = m_pending_moves[new_bin];
            ptile.m_bin_lengths[new_bin]+=particles_ip.size();
            // for (const auto& pid : particles_ip) {
            for (int i=particles_ip.size()-1; i>=0;i--) {
                int pid=particles_ip.back();
                int insert_idx = ptile.findEmptySlotInBin(new_bin);
                if (insert_idx != -1) {
                    // 直接填坑、退槽、长度增加（map已经完成更新）
                    ptile.m_local_index[insert_idx] = pid;
                    ptile.m_free_slots[new_bin].pop_back();
                    // ptile.m_bin_lengths[new_bin]++;
                    ptile.m_pid_to_index_map[pid]=insert_idx;
                    particles_ip.pop_back(); //一边填空一边更新pending_moves待插入的元素
                    // printf("inserted pid %d to bin %d at %d\n", mv.pid, mv.new_bin,insert_idx);
                } else {
                    break;
                }
            }
        }
        //还有没更新完的就需要借用了
        int new_bin = numcell-1;
        //判断这块有没有数据，有就操作，不然跳过
        if (m_pending_moves.find(new_bin)==m_pending_moves.end()) {
            int needed_borrow = m_pending_moves.at(new_bin).size();
            std::vector<int>& particles_ip = m_pending_moves[new_bin];
            int borrow_bin = new_bin-1;
            int idx=ptile.m_bin_offsets[new_bin]-1; //指向第一个块的尾巴指针
            while(needed_borrow>0){
                //idx一直指向需要插入的尾巴
                int insert_idx = ptile.findEmptySlotInBin(borrow_bin);//这是借用空槽的位置
                int pid=particles_ip.back();
                if(insert_idx != -1) {
                    // 把借用位置的尾巴腾出空位
                    ptile.m_free_slots[borrow_bin].pop_back();
                    ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                    if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID)
                        ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                    // 向借的位置填入粒子
                    ptile.m_local_index[insert_idx] = pid;
                    // ptile.m_bin_offsets[new_bin] 这两个参数统一更新了
                    // ptile.m_bin_lengths[new_bin]++;
                    ptile.m_pid_to_index_map[pid]=idx;
                    particles_ip.pop_back(); //一边填空一边更新pending_moves待插入的元素
                    needed_borrow--;
                    // num_borrow++;
                    idx--;
                } else {
                    amrex::Abort("ERROR: no more slot can borrow!!!");
                }
            }
            ptile.m_bin_offsets[new_bin]=idx+1;
            m_pending_moves.erase(numcell-1);
        }
        new_bin = 0;
        //判断这块有没有数据，有就操作，不然跳过
        if (m_pending_moves.find(new_bin)==m_pending_moves.end()) {
            int needed_borrow = m_pending_moves.at(new_bin).size();
            std::vector<int>& particles_ip = m_pending_moves[new_bin];
            int borrow_bin = new_bin+1;
            int idx=ptile.m_bin_offsets[new_bin+1]; //指向第一个块的头指针
            while(needed_borrow>0){
                //idx一直指向需要插入的尾巴
                int insert_idx = ptile.findEmptySlotInBin(borrow_bin);//这是借用空槽的位置
                int pid=particles_ip.back();
                if(insert_idx != -1) {
                    // 把借用位置的尾巴腾出空位
                    ptile.m_free_slots[borrow_bin].pop_back();
                    ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                    if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID)
                        ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                    // 向借的位置填入粒子
                    ptile.m_local_index[insert_idx] = pid;
                    // ptile.m_bin_offsets[new_bin] 这两个参数统一更新了
                    // ptile.m_bin_lengths[new_bin]++;
                    ptile.m_pid_to_index_map[pid]=idx;
                    particles_ip.pop_back(); //一边填空一边更新pending_moves待插入的元素
                    needed_borrow--;
                    // num_borrow++;
                    idx++;
                } else {
                    amrex::Abort("ERROR: no more slot can borrow!!!");
                }
            }
            ptile.m_bin_offsets[new_bin+1]=idx;
            m_pending_moves.erase(0);
        }

        //现在按顺序处理向右边两个允许借用
        for (const auto& pair : m_pending_moves) {
            int new_bin=pair.first;
            std::vector<int>& particles_ip = m_pending_moves[new_bin];
            
            int needed_borrow = m_pending_moves.at(new_bin).size();
            int borrow_bin = new_bin+1;
            int idx=ptile.m_bin_offsets[new_bin+1]; //指向第一个块的头指针
            // 先右后左，因为是向右顺序处理的
            while(needed_borrow>0){
                //idx一直指向需要插入的尾巴
                //先找右边
                int insert_idx = ptile.findEmptySlotInBin(borrow_bin);//这是借用空槽的位置
                int pid=particles_ip.back();
                if(insert_idx != -1){
                    if (borrow_bin==new_bin+1) {
                        // 把借用位置的尾巴腾出空位
                        ptile.m_free_slots[borrow_bin].pop_back();
                        ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                        if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID)
                            ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                        // 向借的位置填入粒子
                        ptile.m_local_index[insert_idx] = pid;
                        ptile.m_pid_to_index_map[pid]=idx;
                        particles_ip.pop_back(); //一边填空一边更新pending_moves待插入的元素
                        needed_borrow--;
                        idx++;
                        continue;
                    } 
                    if (borrow_bin==new_bin-1) {
                        ptile.m_free_slots[borrow_bin].pop_back();
                        ptile.m_local_index[insert_idx]=ptile.m_local_index[idx];
                        if(ptile.m_local_index[idx]!=INVALID_PARTICLE_ID)
                            ptile.m_pid_to_index_map[ptile.m_local_index[idx]]=insert_idx;
                        // 向借的位置填入粒子
                        ptile.m_local_index[insert_idx] = pid;
                        ptile.m_pid_to_index_map[pid]=idx;
                        particles_ip.pop_back(); //一边填空一边更新pending_moves待插入的元素
                        needed_borrow--;
                        idx--;
                        continue;
                    } 
                }else {
                    ptile.m_bin_offsets[new_bin+1]=idx;
                    //右边找完还不够，就继续
                    borrow_bin = new_bin-1;
                    idx=ptile.m_bin_offsets[new_bin]-1; //指向第一个块的头指针
                }
            }
            if (borrow_bin==new_bin-1) ptile.m_bin_offsets[new_bin]=idx+1;
        }
    }else{ //代价太高直接重组
        //重组就不需要增量修改那些，只需要pid_to_map正确即可
        ptile.m_was_rebuilt_this_step = true;
        std::vector<int> final_bin_counts(numcell, 0);
        float gap_ratio=WarpX::GetInstance().m_gap_ratio;
        pid_to_bin_map = ptile.m_pid_to_bin_map;
        int np = ptile.m_num_particles;

        for(int ip=0;ip<np;ip++){
            final_bin_counts[pid_to_bin_map[ip]]++;
        }  
        // ptile.m_capacity = np*(1+gap_ratio)+numcell*1.5;
        ptile.m_capacity = static_cast<int>(std::ceil(static_cast<double>(np) * (1.0 + gap_ratio)) + 2*numcell);

        int current_offset = 0;
        ptile.m_bin_offsets[0] = 0;
        for (int binID = 0; binID < numcell; ++binID) {
            int np_in_bin = final_bin_counts[binID];
            ptile.m_bin_lengths[binID] = np_in_bin; // 存储最终的有效粒子数
            int gap = (np_in_bin > 0) ? static_cast<int>(std::ceil(np_in_bin * gap_ratio)) : 1; // 至少留一个空槽
            int block_size = np_in_bin + gap;
            // ptile.m_num_empty_slots+=gap;
            current_offset += block_size;
            ptile.m_free_slots[binID].clear();
            for(int i = current_offset-1; i >= current_offset-gap; --i){
                ptile.m_free_slots[binID].push_back(i);
            }
            if(current_offset>ptile.m_capacity){
                amrex::Abort("ERROR: current_offset > m_capacity!!!");
            }
            ptile.m_bin_offsets[binID + 1] = current_offset;
        }
        if(ptile.m_bin_offsets[numcell]>=ptile.m_capacity){
            printf("ptile.m_bin_offsets[numcell] %d m_capacity %d \n"
                ,ptile.m_bin_offsets[numcell],ptile.m_capacity);
            amrex::Abort("ERROR: m_bin_offsets[numcell] >= m_capacity!!!");
        }
        ptile.m_capacity=ptile.m_bin_offsets[numcell];
        // ptile.m_num_particles=np;
        ptile.m_num_empty_slots = ptile.m_capacity - ptile.m_num_particles;
        ptile.m_local_index.assign(ptile.m_capacity, INVALID_PARTICLE_ID);
        // 初始化为每个 bin 的起始位置
        std::vector<int> next_write_slot = ptile.m_bin_offsets; 
        for(int ip=0;ip<np;ip++){
            int bin_id =pid_to_bin_map[ip];
            int insert_idx = next_write_slot[bin_id];
            ptile.m_local_index[insert_idx] = ip;
            ptile.m_pid_to_index_map[ip]=insert_idx;
            next_write_slot[bin_id]++;
        }
        // ptile.m_local_index.resize(ptile.m_capacity, INVALID_PARTICLE_ID);
        // ptile.m_num_particles = np;
        ptile.m_was_rebuilt_this_step = true;
        // printf("rebuild!!!!!!!!!\n");
    }
    m_pending_moves.clear();

    //////////////////////////////////////////////////////
# endif

    // m_overflow_particles.clear();
    
    // printf("rebuild_weight=%f\n",rebuild_weight);
    // amrex::Abort("END");




# if 0
        // pid_to_bin_map.assign(newbin.begin(),newbin.end());
        // pid_to_bin_map.resize(np_to_deposit, -1); 
        
        //先把短了的PMA加长
        #pragma omp simd
        for(int ip=ptile.m_num_particles;ip<np_to_deposit;ip++){
            // map更新（map已经被扩展）、添加进待进区
            int new_bin=newbin[ip];
            pid_to_bin_map[ip]=new_bin;
            m_pending_moves[new_bin].push_back(ip);
            // m_pending_moves.push_back({ip, new_bin});
            // printf("[1]insert pid_to_bin_map[%d] %d\n",ip,pid_to_bin_map[ip]);
        }
        ptile.m_num_particles=np_to_deposit;
        ptile.m_num_empty_slots=ptile.m_capacity-np_to_deposit;
        //如果加长了后面的ip就是-1的bin
        //如果截断了，后面的ip就找不到了
        // pid_to_bin_map.assign(newbin.begin(),newbin.end());
        for (int old_bin = 0; old_bin < numcell; ++old_bin) {
            if (bin_length[old_bin] == 0) continue;
            const int start = bin_offsets[old_bin];
            const int end   = bin_offsets[old_bin+1];
            int i_length=0;
            int ibin_length=bin_length[old_bin];
            for (int idx = start; idx < end; ++idx) {
                const int ip = local_index[idx];
                // if(i_length==ibin_length) break;
                if (ip == INVALID_PARTICLE_ID) continue;  
                // 如果需要截断就删除
                if (ip >= np_to_deposit) {
                    //打洞、长度缩减、压栈（map已经统一被截断）
                    ptile.m_local_index[idx] = INVALID_PARTICLE_ID;
                    ptile.m_bin_lengths[old_bin]--;
                    // ptile.m_num_empty_slots++;
                    // ptile.m_num_particles--;
                    free_slot[old_bin].push_back(idx);
                    continue;
                }
                
                int new_bin=newbin[ip];
                // 剩下的old bin不可能小于0了
                // 先在原位置删除等着添加
                if(new_bin>=numcell || new_bin<0){
                    printf("new_bin %d numcell %d\n",new_bin,numcell);
                    amrex::Abort("ERROR ilegal new bin!!!");
                }
                if(old_bin!=new_bin){
                    // m_pending_moves.push_back({ip, new_bin});
                    m_pending_moves[new_bin].push_back(ip);
                    // printf("\n old_bin %d new_bin %d \n",old_bin,new_bin);
                    // printf("org pid[%d] %d ",ip,pid_to_bin_map[ip]);
                    if(old_bin!=pid_to_bin_map[ip]) {
                        amrex::Print() << ptile.m_was_rebuilt_this_step << std::endl;
                        for (int idx = bin_offsets[old_bin]; idx < bin_offsets[old_bin+1]
                            ; ++idx) {
                            printf("[1] ip=local_index[%d] is %d in bin %d at offset %d \n", idx,
                                local_index[idx],old_bin,bin_offsets[old_bin]);
                        }
                        for (int idx = bin_offsets[old_bin-1]; idx < bin_offsets[old_bin]
                            ; ++idx) {
                            printf("[2]ip=local_index[%d] is %d in bin %d at offset %d\n", idx,
                                local_index[idx],old_bin-1,bin_offsets[old_bin-1]);
                        }
                        amrex::Abort("[2]old_bin!=pid_to_bin_map[ip]");
                    }
                    // map更新、打洞、长度减1、空槽压栈
                    pid_to_bin_map[ip]=new_bin;
                    // printf("pid_to_bin_map[%d] %d newbin %d \n",
                    //     ip,ptile.m_pid_to_bin_map[ip],new_bin);
                    // amrex::Print() << ptile.m_was_rebuilt_this_step << std::endl;
                    ptile.m_local_index[idx] = INVALID_PARTICLE_ID;
                    ptile.m_bin_lengths[old_bin]--;
                    // if(free_slot[old_bin].empty())printf("empty\n");
                    free_slot[old_bin].push_back(idx);
                    // ptile.m_num_empty_slots++;
                    // ptile.m_num_particles--;
                }
                i_length++;
            }
        }
        if(pid_to_bin_map.size()!=newbin.size())
        {
            printf("pid_to_bin_map %d newbin len %d \n",pid_to_bin_map.size(),newbin.size());
            amrex::Abort("[3]pid_to_bin_map LEN FALSE!!");
        }
        bool flag=false;
        for(int i=0;i<np_to_deposit;i++){
            if(pid_to_bin_map[i]!=newbin[i]){
                printf("pid_to_bin_map[%d] %d newbin[%d] %d\n",i,pid_to_bin_map[i],i,newbin[i]);
                flag=true;
            }
        }
        if(flag) amrex::Abort("[4]Error pid_to_bin_map != newbin!");
    }
    pid_to_bin_map.assign(newbin.begin(),newbin.end());

    // std::vector<int> testtt(newbin.begin(),newbin.end());
    // if(std::equal(pid_to_bin_map.begin(),pid_to_bin_map.end(),testtt.begin())){
    //     // printf("True len %d sme len %d \n",len1,len2);
    //     amrex::Abort("pid_to_bin_map != newbin!!");
    // }
    applyPendingMoves_3(numcell, ptile, m_pending_moves);
#endif
    // ///////////////////////////
#if 0
    printf("\n=================TEST CORRNETNESS================\n");
    for (int old_bin = 0; old_bin < numcell; ++old_bin) {
        if (bin_length[old_bin] == 0) continue;
        const int start = bin_offsets[old_bin];
        const int end   = bin_offsets[old_bin+1];
        int i_length=0;
        int ibin_length=bin_length[old_bin];
        for (int idxx = start; idxx < end; ++idxx) {
            const int ip = local_index[idxx];
            // if(i_length==ibin_length) break;
            if (ip == INVALID_PARTICLE_ID) continue;    
            int new_bin=newbin[ip];

            if(old_bin!=new_bin){
                printf("\n old_bin %d new_bin %d \n",old_bin,new_bin);
                printf("org pid[%d] in pid_to_bin_map %d ",ip,pid_to_bin_map[ip]);
                if(old_bin!=pid_to_bin_map[ip]) {
                    amrex::Print() << ptile.m_was_rebuilt_this_step << std::endl;
                    for (int idx = bin_offsets[old_bin]; idx < bin_offsets[old_bin+1]
                        ; ++idx) {
                        printf("[1] ip=local_index[%d] is %d in bin %d at offset %d \n", idx,
                            local_index[idx],old_bin,idx);
                    }
                    for (int idx = bin_offsets[old_bin-1]; idx < bin_offsets[old_bin]
                        ; ++idx) {
                        printf("[2]ip=local_index[%d] is %d in bin %d at offset %d\n", idx,
                            local_index[idx],old_bin-1,idx);
                    }
                    printf("free slot!!!!\n");
                    for(int idx=0;idx<ptile.m_free_slots[old_bin].size();idx++)
                    {
                        printf("old_bin %d m_free_slots[%d] is %d\n"
                            ,old_bin,idx,ptile.m_free_slots[old_bin][idx]);
                    }
                    for(int idx=0;idx<ptile.m_free_slots[new_bin].size();idx++)
                    {
                        printf("newbin %d m_free_slots[%d] is %d\n"
                            ,new_bin,idx,ptile.m_free_slots[new_bin][idx]);
                    }
                    amrex::Abort("[3]old_bin!=pid_to_bin_map[ip]");
                }
            }
            i_length++;
        }
    }
    if(pid_to_bin_map.size()!=newbin.size())
    {
        printf("pid_to_bin_map %d newbin len %d \n",pid_to_bin_map.size(),newbin.size());
        amrex::Abort("[3]pid_to_bin_map LEN FALSE!!");
    }
    bool flag=false;
    for(int i=0;i<np_to_deposit;i++){
        if(pid_to_bin_map[i]!=newbin[i]){
            printf("pid_to_bin_map[%d] %d newbin[%d] %d\n",i,pid_to_bin_map[i],i,newbin[i]);
            flag=true;
        }
    }
    if(flag) amrex::Abort("[4]Error pid_to_bin_map != newbin!");
    test1=newbin;
    test=ptile.m_local_index;
    test0=ptile.m_bin_offsets;
    return;
#endif
 
    // 预计算网格步长
    // const int xjstride = jx_arr.jstride;
    // const int xkstride = jx_arr.kstride;
    // const int yjstride = jy_arr.jstride;
    // const int ykstride = jy_arr.kstride;
    // const int zjstride = jz_arr.jstride;
    // const int zkstride = jz_arr.kstride;

    sort_3d_sme_kernal_3<1>(
        numcell,local_index,
        bin_length,bin_offsets,
        xrhocells,yrhocells,zrhocells,
        sx_m,sy_m,sz_m,
        wqx,wqy,wqz,len,testsxwq,test0,test1);
    // bool flag1=false;
    // printf("\nChecking szm.......\n");
    // for(long ip=0;ip<np_to_deposit;ip++){
    //     if(test0[2*ip]!=sz_m[2*ip]){
    //         printf("[00] szm[%d] = %f true %f \n", ip,test0[2*ip],sz_m[2*ip]);
    //         flag1=true;
    //     }
    // }
    // if(flag1) amrex::Abort("wqx1");
    // printf("szm checked!\n");
    // sort_3d_sme_kernal_2<1>(
    //     numcell,local_index,
    //     bin_length,bin_offsets,
    //     xrhocells,yrhocells,zrhocells,
    //     sx_m,sy_m,sz_m,
    //     wqx,wqy,wqz,len);
#if 1
// for (int old_bin = 1; old_bin <= numcell; ++old_bin) {
//     if (bin_length[old_bin-1] == 0) continue;
//     int start = bin_offsets[old_bin-1];
//     int end = bin_offsets[old_bin];
//     svzero_za();
//     int ipp=0;
//     int first_idx=-1;
//     for(int i=start;i<end;i++){
//         if (local_index[i] == INVALID_PARTICLE_ID) {
//             continue;
//         } 
//         if(first_idx<0){
//             first_idx=i;
//         }else{
//             int idx1 = first_idx;
//             int idx2=i;
//             int ip1 = local_index[idx1];
//             int ip2 = local_index[idx2];
            
//             first_idx=-1;
//         }
        
//     }

//     // svzero_za();
//     if(first_idx>=0){
//         int ip1 = local_index[first_idx];
//     }
// }
test_sxwq=testsxwq;
//  test1=newbin;
//  test=ptile.m_local_index;
//  test0=ptile.m_bin_offsets;
test_rhocells=xrhocells;
return;
#endif
    // one roll x
    // uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
    // uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
    // uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
    // // long nx=xjstride;
    // // long nxy=xkstride;
    // int moff[8] = {0, 1, nx, nx+1, nxny, nxny+1, nx+nxny, nx+nxny+1};
    // svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
    // svbool_t px = svcmpeq_n_u64(svptrue_b64(), rmx_v, 0);
    // svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
    // svbool_t py = svcmpeq_n_u64(svptrue_b64(), rmy_v, 0);
    // svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
    // svbool_t pz = svcmpeq_n_u64(svptrue_b64(), rmz_v, 0);
    // for (int iz = bx; iz < len.z-bx; ++iz) {
    //     for (int iy = bx; iy < len.y-bx; ++iy) {       
    //         for (int ix = bx; ix < len.x-bx; ix+=vl) {
    uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
    uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
    uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
    long nx=xjstride;
    long nxy=xkstride;
    long moff[8] = {0, 1, nx, nx+1, nxy, nxy+1, nx+nxy, nx+nxy+1};
    svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
    svbool_t px = svcmpeq_n_u64(svptrue_b64(), rmx_v, 0);
    svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
    svbool_t py = svcmpeq_n_u64(svptrue_b64(), rmy_v, 0);
    svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
    svbool_t pz = svcmpeq_n_u64(svptrue_b64(), rmz_v, 0);
    
    for (int iz = 0; iz < len.z; ++iz) {
        for (int iy = 0; iy < len.y; ++iy) {       
            for (int ix = 0; ix < len.x; ix+=vl) {
                // svetime[0]=rdtscv();

                // vector
                svbool_t p=svwhilelt_b64(ix,(len.x));
                // long j = lo.x + ix;
                // long k = lo.y + iy;
                // long l = lo.z + iz;
                // x
                // uint64_t irhox = 8*(ix + iy * xjstride + iz * xkstride);
                // svuint64_t rhox_index = svindex_u64(0, 8ULL);
                // long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                svuint64_t rho_index = svindex_u64(0ULL, 8ULL);
                long xoffset=ix + iy * xjstride + iz * xkstride;
                // long xoffset=(ix-bx) + (iy-by) * nnx + (iz-bz) * nnxny;
                // long cell_idx=(ix-bx) + (iy-by) * nnx + (iz-bz) * nnxny+1;
                long cell_idx=ix + iy * nnx + iz * nnxny+1;
                long jxoffset=xoffset;
                // long irhox=8*xoffset;
                long irhox=8*cell_idx;
                Vec jx0=Vec::Load(p,&jx_arr.p[jxoffset+moff[0]]);
                svfloat64_t rhox0=svld1_gather_u64index_f64(p,&xrhocells[0+irhox],rho_index);
                jx0+=rhox0;
                jx0.Store(p,&jx_arr.p[jxoffset+moff[0]]);

                Vec jx1=Vec::Load(p,&jx_arr.p[jxoffset+moff[1]]);
                svfloat64_t rhox1=svld1_gather_u64index_f64(p,&xrhocells[1+irhox],rho_index);
                jx1+=rhox1;
                jx1.Store(p,&jx_arr.p[jxoffset+moff[1]]);

                Vec jx2=Vec::Load(p,&jx_arr.p[jxoffset+moff[2]]);
                svfloat64_t rhox2=svld1_gather_u64index_f64(p,&xrhocells[2+irhox],rho_index);
                jx2+=rhox2;
                jx2.Store(p,&jx_arr.p[jxoffset+moff[2]]);

                Vec jx3=Vec::Load(p,&jx_arr.p[jxoffset+moff[3]]);
                svfloat64_t rhox3=svld1_gather_u64index_f64(p,&xrhocells[3+irhox],rho_index);
                jx3+=rhox3;
                jx3.Store(p,&jx_arr.p[jxoffset+moff[3]]);

                Vec jx4=Vec::Load(p,&jx_arr.p[jxoffset+moff[4]]);
                svfloat64_t rhox4=svld1_gather_u64index_f64(p,&xrhocells[4+irhox],rho_index);
                jx4+=rhox4;
                jx4.Store(p,&jx_arr.p[jxoffset+moff[4]]);

                Vec jx5=Vec::Load(p,&jx_arr.p[jxoffset+moff[5]]);
                svfloat64_t rhox5=svld1_gather_u64index_f64(p,&xrhocells[5+irhox],rho_index);
                jx5+=rhox5;
                jx5.Store(p,&jx_arr.p[jxoffset+moff[5]]);

                Vec jx6=Vec::Load(p,&jx_arr.p[jxoffset+moff[6]]);
                svfloat64_t rhox6=svld1_gather_u64index_f64(p,&xrhocells[6+irhox],rho_index);
                jx6+=rhox6;
                jx6.Store(p,&jx_arr.p[jxoffset+moff[6]]);

                Vec jx7=Vec::Load(p,&jx_arr.p[jxoffset+moff[7]]);
                svfloat64_t rhox7=svld1_gather_u64index_f64(p,&xrhocells[7+irhox],rho_index);
                jx7+=rhox7;
                jx7.Store(p,&jx_arr.p[jxoffset+moff[7]]);
                
                // y
                // uint64_t irhoy = ix + iy * yjstride + iz * ykstride;
                // svuint64_t rhoy_index = svindex_u64(irhoy, 8ULL);
                // long jyoffset = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
                // long yoffset = ix + iy * yjstride + iz * ykstride;
                long jyoffset=xoffset;
                long irhoy=irhox;
                Vec jy0=Vec::Load(p,&jy_arr.p[jyoffset+moff[0]]);
                svfloat64_t rhoy0=svld1_gather_u64index_f64(p,&yrhocells[0+irhoy],rho_index);
                jy0+=rhoy0;
                jy0.Store(p,&jy_arr.p[jyoffset+moff[0]]);

                Vec jy1=Vec::Load(p,&jy_arr.p[jyoffset+moff[1]]);
                svfloat64_t rhoy1=svld1_gather_u64index_f64(p,&yrhocells[1+irhoy],rho_index);
                jy1+=rhoy1;
                jy1.Store(p,&jy_arr.p[jyoffset+moff[1]]);

                Vec jy2=Vec::Load(p,&jy_arr.p[jyoffset+moff[2]]);
                svfloat64_t rhoy2=svld1_gather_u64index_f64(p,&yrhocells[2+irhoy],rho_index);
                jy2+=rhoy2;
                jy2.Store(p,&jy_arr.p[jyoffset+moff[2]]);

                Vec jy3=Vec::Load(p,&jy_arr.p[jyoffset+moff[3]]);
                svfloat64_t rhoy3=svld1_gather_u64index_f64(p,&yrhocells[3+irhoy],rho_index);
                jy3+=rhoy3;
                jy3.Store(p,&jy_arr.p[jyoffset+moff[3]]);

                Vec jy4=Vec::Load(p,&jy_arr.p[jyoffset+moff[4]]);
                svfloat64_t rhoy4=svld1_gather_u64index_f64(p,&yrhocells[4+irhoy],rho_index);
                jy4+=rhoy4;
                jy4.Store(p,&jy_arr.p[jyoffset+moff[4]]);

                Vec jy5=Vec::Load(p,&jy_arr.p[jyoffset+moff[5]]);
                svfloat64_t rhoy5=svld1_gather_u64index_f64(p,&yrhocells[5+irhoy],rho_index);
                jy5+=rhoy5;
                jy5.Store(p,&jy_arr.p[jyoffset+moff[5]]);

                Vec jy6=Vec::Load(p,&jy_arr.p[jyoffset+moff[6]]);
                svfloat64_t rhoy6=svld1_gather_u64index_f64(p,&yrhocells[6+irhoy],rho_index);
                jy6+=rhoy6;
                jy6.Store(p,&jy_arr.p[jyoffset+moff[6]]);

                Vec jy7=Vec::Load(p,&jy_arr.p[jyoffset+moff[7]]);
                svfloat64_t rhoy7=svld1_gather_u64index_f64(p,&yrhocells[7+irhoy],rho_index);
                jy7+=rhoy7;
                jy7.Store(p,&jy_arr.p[jyoffset+moff[7]]);

                // z
                // uint64_t irhoz = ix + iy * zjstride + iz * zkstride;
                // svuint64_t rhoz_index = svindex_u64(irhoz, 8ULL);
                // long jzoffset = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
                long zoffset = ix + iy * zjstride + iz * zkstride;
                long jzoffset=xoffset;
                long irhoz=irhox;
                Vec jz0=Vec::Load(p,&jz_arr.p[jzoffset+moff[0]]);
                svfloat64_t rhoz0=svld1_gather_u64index_f64(p,&zrhocells[0+irhoz],rho_index);
                jz0+=rhoz0;
                jz0.Store(p,&jz_arr.p[jzoffset+moff[0]]);

                Vec jz1=Vec::Load(p,&jz_arr.p[jzoffset+moff[1]]);
                svfloat64_t rhoz1=svld1_gather_u64index_f64(p,&zrhocells[1+irhoz],rho_index);
                jz1+=rhoz1;
                jz1.Store(p,&jz_arr.p[jzoffset+moff[1]]);

                Vec jz2=Vec::Load(p,&jz_arr.p[jzoffset+moff[2]]);
                svfloat64_t rhoz2=svld1_gather_u64index_f64(p,&zrhocells[2+irhoz],rho_index);
                jz2+=rhoz2;
                jz2.Store(p,&jz_arr.p[jzoffset+moff[2]]);

                Vec jz3=Vec::Load(p,&jz_arr.p[jzoffset+moff[3]]);
                svfloat64_t rhoz3=svld1_gather_u64index_f64(p,&zrhocells[3+irhoz],rho_index);
                jz3+=rhoz3;
                jz3.Store(p,&jz_arr.p[jzoffset+moff[3]]);

                Vec jz4=Vec::Load(p,&jz_arr.p[jzoffset+moff[4]]);
                svfloat64_t rhoz4=svld1_gather_u64index_f64(p,&zrhocells[4+irhoz],rho_index);
                jz4+=rhoz4;
                jz4.Store(p,&jz_arr.p[jzoffset+moff[4]]);

                Vec jz5=Vec::Load(p,&jz_arr.p[jzoffset+moff[5]]);
                svfloat64_t rhoz5=svld1_gather_u64index_f64(p,&zrhocells[5+irhoz],rho_index);
                jz5+=rhoz5;
                jz5.Store(p,&jz_arr.p[jzoffset+moff[5]]);

                Vec jz6=Vec::Load(p,&jz_arr.p[jzoffset+moff[6]]);
                svfloat64_t rhoz6=svld1_gather_u64index_f64(p,&zrhocells[6+irhoz],rho_index);
                jz6+=rhoz6;
                jz6.Store(p,&jz_arr.p[jzoffset+moff[6]]);

                Vec jz7=Vec::Load(p,&jz_arr.p[jzoffset+moff[7]]);
                svfloat64_t rhoz7=svld1_gather_u64index_f64(p,&zrhocells[7+irhoz],rho_index);
                jz7+=rhoz7;
                jz7.Store(p,&jz_arr.p[jzoffset+moff[7]]);

                // svetime[1]=rdtscv();
                // reduce_time+=(svetime[1]-svetime[0]);
            }
        }
    }
}
 
 template <int depos_order>
 void doDepositionShapeN_3d_sme_v0522 (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Dim3 hi,
                          amrex::Dim3 len,
                          amrex::Real q,
                          std::vector<int>& test,
                          std::vector<int>& test0,
                          std::vector<long>& test1,
                          ParticleTileType& ptile, const amrex::Box& box,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     WARPX_PROFILE("doDepositionShapeN_3d_sme()");
     // uint64_t total_time[3]={0};
     using namespace std::chrono;
     using namespace amrex::literals;
     double total_time=0;
     // auto total_start=high_resolution_clock::now();
     uint64_t precompute=0;
     uint64_t cale_time=0;
     uint64_t sort_time=0;
         uint64_t count_time=0;
         uint64_t presum_time=0;
         uint64_t binlist_time=0;
     uint64_t reduce_time=0;
     uint64_t svetime[3]={0};
     uint64_t branch_time=0;
     
     // total_time[0]=rdtscv();
     
 
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z; 
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
 
     constexpr int nshapes = depos_order + 1;
     // constexpr int nshapes = 2;
     int vl=svcntd();
 
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
 
     auto compute_shape_factor_v2 = [](std::vector<double>* sx, Vec xmid, svbool_t p) {
         const svuint64_t sx_index = svindex_u64(0ULL, 2ULL);
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         svst1_scatter_index(p,&sx[0][0],sx_index,sx0);
         svst1_scatter_index(p,&sx[0][1],sx_index,sx1);
         // sx0.Store(p, sx[0]);
         // sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
     auto compute_shape_factor_v1 = [](double* sx, Vec xmid, svbool_t p) {
         const svuint64_t sx_index = svindex_u64(0, 2);
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // double test[8];
         // xint.Store(p,&test[0]);
         // for(int ii=0;ii<8;ii++){
         //     // printf("ii %d xind %f \n",ii,test[ii]);
         //     sx[ii][0]=1.0-test[ii];
         //     sx[ii][1]=test[ii];
         // }
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         // double sx00[8];
         // double sx01[8];
         // sx0.Store(p,&sx00[0]);
         // sx1.Store(p,&sx01[0]);
         // for(int ii=0;ii<8;ii++){
         //     // printf("ii %d xind %f \n",ii,test[ii]);
         //     sx[ii][0]=sx00[ii];
         //     sx[ii][1]=sx01[ii];
         // }
         svst1_scatter_index(p,&sx[0],sx_index,sx0);
         svst1_scatter_index(p,&sx[1],sx_index,sx1);
         // sx0.Store(p, sx[0]);
         // sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
     // // const long numcell = jx_fab.box().numPts();
     // const long numcell = ptile.m_bin_offsets.size();
 
     // std::vector<amrex::Real> xrhocells(8*numcell, 0.0);
     // std::vector<amrex::Real> yrhocells(8*numcell, 0.0);
     // std::vector<amrex::Real> zrhocells(8*numcell, 0.0);
     // one roll x
     uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
     uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
     uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
     long nx=xjstride;
     long nxy=xkstride;
     long moff[8] = {0, 1, nx, nx+1, nxy, nxy+1, nx+nxy, nx+nxy+1};
     svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
     svbool_t px = svcmpeq_n_u64(svptrue_b64(), rmx_v, 0);
     svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
     svbool_t py = svcmpeq_n_u64(svptrue_b64(), rmy_v, 0);
     svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
     svbool_t pz = svcmpeq_n_u64(svptrue_b64(), rmz_v, 0);
 
     std::vector<amrex::Real> wqx(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqy(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqz(np_to_deposit, 0.0);
 
     std::vector<amrex::Real> sx_m(np_to_deposit*nshapes, 0.);
     std::vector<amrex::Real> sy_m(np_to_deposit*nshapes, 0.);
     std::vector<amrex::Real> sz_m(np_to_deposit*nshapes, 0.);
     alignas(64) long xoffsets[np_to_deposit]; 
     // alignas(64) long yoffsets[np_to_deposit];
     // alignas(64) long zoffsets[np_to_deposit];
     long bx = 2, by = 2, bz = 2;
     amrex::IntVect box_shape = box.length();
     // amrex::Print() << "Box shape: " << box_shape << std::endl;
     long nnx = box_shape[0];
     long nny = box_shape[1];
     long nnxny = nnx*nny;
     alignas(64) std::vector<long> newbin(np_to_deposit);
     // alignas(64) long newbin[np_to_deposit];
     
 
     for(long ip=0;ip<np_to_deposit;ip+=vl){
         // svetime[0]=rdtscv();
 
         // 计算基本物理量
         svbool_t p=svwhilele_b64(ip,np_to_deposit);
         // Inverse of Lorentz factor gamma
         Vec uxp_v=Vec::Load(p,&uxp[ip]);
         Vec uyp_v=Vec::Load(p,&uyp[ip]);
         Vec uzp_v=Vec::Load(p,&uzp[ip]);
         Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                     + uyp_v * uyp_v * clightsq
                                     + uzp_v * uzp_v * clightsq).Sqrt();
         // Product of particle charges and weights
         Vec wp_v=Vec::Load(p,&wp[ip]);
         Vec wq_v = q * wp_v;
 
         // Current particle positions (in physical units)
         Vec xp = Vec::Load(p, &mx[ip]);
         Vec yp = Vec::Load(p, &my[ip]);
         Vec zp = Vec::Load(p, &mz[ip]);
 
         // Particle velocities
         Vec vx_v = uxp_v * gaminv;
         Vec vy_v = uyp_v * gaminv;
         Vec vz_v = uzp_v * gaminv;
 
         // if (do_ionization) wq *= ion_lev[ip];
         Vec wqx_v = wq_v * invvol * vx_v;
         Vec wqy_v = wq_v * invvol * vy_v;
         Vec wqz_v = wq_v * invvol * vz_v;
 
         wqx_v.Store(p, &wqx[ip]);
         wqy_v.Store(p, &wqy[ip]);
         wqz_v.Store(p, &wqz[ip]);
 
         Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x;
         Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y;
         Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z;
         // xmid.Store(p, &test0[ip]);
         // double* sx_temp[nshapes] = {&sx_m[0][ip], &sx_m[1][ip]};
         intVec j_cellv = compute_shape_factor_v1( &sx_m[ip*2], xmid, p);
         // j_cellv.Store(p, &test[ip]);
         intVec k_cellv = compute_shape_factor_v1( &sy_m[ip*2], ymid, p);
         intVec l_cellv = compute_shape_factor_v1( &sz_m[ip*2], zmid, p); 
 
         intVec xoffsets_v = j_cellv + k_cellv * xjstride + l_cellv * xkstride;
         // intVec yoffsets_v = j_cellv + k_cellv * yjstride + l_cellv * ykstride;
         // intVec zoffsets_v = j_cellv + k_cellv * zjstride + l_cellv * zkstride;
 
         xoffsets_v.Store(p,&xoffsets[ip]);
         intVec new_bin_v = (j_cellv-bx) + 
                             (k_cellv-by)* nnx + 
                             (l_cellv-bz) * nnxny;
         new_bin_v.Store(p,&newbin[ip]);
         // yoffsets_v.Store(p,&yoffsets[ip]);
         // zoffsets_v.Store(p,&zoffsets[ip]);
 
         // 原子操作，不可避免
         // const int vec_len = std::min(vl, static_cast<int>(np_to_deposit-ip));
         // svetime[2]=rdtscv();
         // for(int off=0;off<vec_len;off++){
         //     xcount[xoffsets[ip+off]]++;
         //     // ycount[yoffsets[ip+off]]++;
         //     // zcount[zoffsets[ip+off]]++;
         // }
         // svetime[1]=rdtscv();
         // count_time+=(svetime[1]-svetime[2]);
 
         // printf("after STORE\n");
         // svetime[1]=rdtscv();
         // precompute+=(svetime[1]-svetime[0]); 
         // printf("after SAVE\n");
     }
     // const long numcell = jx_fab.box().numPts();
     const long numcell = ptile.m_bin_offsets.size()-1;
 
     std::vector<amrex::Real> xrhocells(8*numcell, 0.0);
     std::vector<amrex::Real> yrhocells(8*numcell, 0.0);
     std::vector<amrex::Real> zrhocells(8*numcell, 0.0);
     int numhigh=0;
     int numlow=0;
     for(int ip=0;ip<np_to_deposit;ip++){
         if(newbin[ip]>=numcell){
             // printf("%d out numcell!!\n",newbin[ip]);
             // newbin[ip]=numcell-1;
             numhigh++;
         }
         if(newbin[ip]<0){
             // printf("%d out numcell!!\n",newbin[ip]);
             // newbin[ip]=0;
             numlow++;
         }
     }
     printf("particle lower %d, particle higher %d, Total %d \n",numlow,numhigh,numhigh+numlow);
      
     //////////////////////////
     auto& local_index = ptile.m_local_index;
     auto& bin_offsets = ptile.m_bin_offsets;
     auto& bin_length = ptile.m_bin_lengths;
     // const long numcell = ptile.m_bin_offsets.size()-1;
     // const long numcell = jx_fab.box().numPts();
     auto& pid_to_bin_map = ptile.m_pid_to_bin_map;
     auto& free_slot = ptile.m_free_slots;
     std::vector<ParticleMove> m_pending_moves;
 
     // test=ptile.m_local_index;
     // test0=ptile.m_bin_offsets;
     // return;
 
     //先把短了的PMA加长
     for(int ip=pid_to_bin_map.size();ip<np_to_deposit;ip++){
         int new_bin=newbin[ip];
         m_pending_moves.push_back({ip, new_bin});
     }
     //如果加长了后面的ip就是-1的bin
     //如果截断了，后面的ip就找不到了
     pid_to_bin_map.resize(np_to_deposit, -1); 
     // pid_to_bin_map.assign(newbin.begin(),newbin.end());
     for (int old_bin = 0; old_bin < numcell; ++old_bin) {
         if (bin_length[old_bin] == 0) continue;
         const int start = bin_offsets[old_bin];
         const int end   = bin_offsets[old_bin+1];
         for (int idx = start; idx < end; ++idx) {
             const int ip = local_index[idx];
             if (ip == INVALID_PARTICLE_ID) continue;
             // 如果需要截断就删除
             if (ip >= np_to_deposit) {
                 ptile.m_local_index[idx] = INVALID_PARTICLE_ID;
                 ptile.m_bin_lengths[old_bin]--;
                 ptile.m_num_empty_slots++;
                 ptile.m_num_particles--;
                 free_slot[old_bin].push_back(idx);
                 continue;
             }
             int new_bin=newbin[ip];
             // 剩下的old bin不可能小于0了
             // 先在原位置删除等着添加
             if(new_bin>=numcell){
                 printf("new_bin %d numcell %d\n",new_bin,numcell);
                 amrex::Abort("ERROR ilegal new bin!!!");
             }
             if(old_bin!=new_bin){
                 m_pending_moves.push_back({ip, new_bin});
                 pid_to_bin_map[ip]=new_bin;
                 ptile.m_bin_lengths[old_bin]--;
                 // if(free_slot[old_bin].empty())printf("empty\n");
                 free_slot[old_bin].push_back(idx);
                 ptile.m_num_empty_slots++;
                 ptile.m_num_particles--;
             }
         }
     }
     // if(pid_to_bin_map.size()!=newbin.size())
     // {
     //     printf("pid_to_bin_map %d newbin len %d \n",pid_to_bin_map.size(),newbin.size());
     //     amrex::Abort("LEN FALSE!!");
     // }
     // for(int i=0;i<np_to_deposit;i++){
     //     if(pid_to_bin_map[i]!=newbin[i]){
     //         printf("pid_to_bin_map %d newbin %d\n",pid_to_bin_map[i],newbin[i]);
     //     }
     // }
     // std::vector<int> testtt(newbin.begin(),newbin.end());
     // if(std::equal(pid_to_bin_map.begin(),pid_to_bin_map.end(),testtt.begin())){
     //     // printf("True len %d sme len %d \n",len1,len2);
     //     amrex::Abort("pid_to_bin_map != newbin!!");
     // }
     applyPendingMoves_1(numcell, ptile, m_pending_moves);
     // ///////////////////////////
 #if 1
     test1=newbin;
     test=ptile.m_local_index;
     test0=ptile.m_bin_offsets;
     return;
 #endif
 
     // 预计算网格步长
     // const int xjstride = jx_arr.jstride;
     // const int xkstride = jx_arr.kstride;
     // const int yjstride = jy_arr.jstride;
     // const int ykstride = jy_arr.kstride;
     // const int zjstride = jz_arr.jstride;
     // const int zkstride = jz_arr.kstride;
 
     // for (int old_bin = 1; old_bin <= numcell; ++old_bin) {
     //     if (bin_length[old_bin-1] == 0) continue;
     //     int start = bin_offsets[old_bin-1];
     //     int end = bin_offsets[old_bin];
         // for (int idx = start; idx < end; idx+=vl) {
             sort_3d_sme_kernal_1<1>(
                 numcell,local_index,
                 bin_length,bin_offsets,
                 xrhocells,yrhocells,zrhocells,
                 sx_m,sy_m,sz_m,
                 wqx,wqy,wqz);
         // }
     // }
 
     // one roll x
     // uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
     // uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
     // uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
     // // long nx=xjstride;
     // // long nxy=xkstride;
     // int moff[8] = {0, 1, nx, nx+1, nxny, nxny+1, nx+nxny, nx+nxny+1};
     // svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
     // svbool_t px = svcmpeq_n_u64(svptrue_b64(), rmx_v, 0);
     // svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
     // svbool_t py = svcmpeq_n_u64(svptrue_b64(), rmy_v, 0);
     // svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
     // svbool_t pz = svcmpeq_n_u64(svptrue_b64(), rmz_v, 0);
     for (int iz = bx; iz < len.z-bx; ++iz) {
         for (int iy = bx; iy < len.y-bx; ++iy) {       
             for (int ix = bx; ix < len.x-bx; ix+=vl) {
     // for (int iz = 0; iz <= len.z; ++iz) {
     //     for (int iy = 0; iy <= len.y; ++iy) {       
     //         for (int ix = 0; ix <= len.x; ix+=vl) {
                 // svetime[0]=rdtscv();
 
                 // vector
                 svbool_t p=svwhilelt_b64(ix,(len.x-2));
                 // long j = lo.x + ix;
                 // long k = lo.y + iy;
                 // long l = lo.z + iz;
                 // x
                 // uint64_t irhox = 8*(ix + iy * xjstride + iz * xkstride);
                 // svuint64_t rhox_index = svindex_u64(0, 8ULL);
                 // long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                 svuint64_t rho_index = svindex_u64(0ULL, 8ULL);
                 long xoffset=ix + iy * xjstride + iz * xkstride;
                 // long xoffset=(ix-bx) + (iy-by) * nnx + (iz-bz) * nnxny;
                 long cell_idx=(ix-bx) + (iy-by) * nnx + (iz-bz) * nnxny+1;
                 long jxoffset=xoffset;
                 // long irhox=8*xoffset;
                 long irhox=8*cell_idx;
                 Vec jx0=Vec::Load(p,&jx_arr.p[jxoffset+moff[0]]);
                 svfloat64_t rhox0=svld1_gather_u64index_f64(p,&xrhocells[0+irhox],rho_index);
                 jx0+=rhox0;
                 jx0.Store(p,&jx_arr.p[jxoffset+moff[0]]);
 
                 Vec jx1=Vec::Load(p,&jx_arr.p[jxoffset+moff[1]]);
                 svfloat64_t rhox1=svld1_gather_u64index_f64(p,&xrhocells[1+irhox],rho_index);
                 jx1+=rhox1;
                 jx1.Store(p,&jx_arr.p[jxoffset+moff[1]]);
 
                 Vec jx2=Vec::Load(p,&jx_arr.p[jxoffset+moff[2]]);
                 svfloat64_t rhox2=svld1_gather_u64index_f64(p,&xrhocells[2+irhox],rho_index);
                 jx2+=rhox2;
                 jx2.Store(p,&jx_arr.p[jxoffset+moff[2]]);
 
                 Vec jx3=Vec::Load(p,&jx_arr.p[jxoffset+moff[3]]);
                 svfloat64_t rhox3=svld1_gather_u64index_f64(p,&xrhocells[3+irhox],rho_index);
                 jx3+=rhox3;
                 jx3.Store(p,&jx_arr.p[jxoffset+moff[3]]);
 
                 Vec jx4=Vec::Load(p,&jx_arr.p[jxoffset+moff[4]]);
                 svfloat64_t rhox4=svld1_gather_u64index_f64(p,&xrhocells[4+irhox],rho_index);
                 jx4+=rhox4;
                 jx4.Store(p,&jx_arr.p[jxoffset+moff[4]]);
 
                 Vec jx5=Vec::Load(p,&jx_arr.p[jxoffset+moff[5]]);
                 svfloat64_t rhox5=svld1_gather_u64index_f64(p,&xrhocells[5+irhox],rho_index);
                 jx5+=rhox5;
                 jx5.Store(p,&jx_arr.p[jxoffset+moff[5]]);
 
                 Vec jx6=Vec::Load(p,&jx_arr.p[jxoffset+moff[6]]);
                 svfloat64_t rhox6=svld1_gather_u64index_f64(p,&xrhocells[6+irhox],rho_index);
                 jx6+=rhox6;
                 jx6.Store(p,&jx_arr.p[jxoffset+moff[6]]);
 
                 Vec jx7=Vec::Load(p,&jx_arr.p[jxoffset+moff[7]]);
                 svfloat64_t rhox7=svld1_gather_u64index_f64(p,&xrhocells[7+irhox],rho_index);
                 jx7+=rhox7;
                 jx7.Store(p,&jx_arr.p[jxoffset+moff[7]]);
                 
                 // y
                 // uint64_t irhoy = ix + iy * yjstride + iz * ykstride;
                 // svuint64_t rhoy_index = svindex_u64(irhoy, 8ULL);
                 // long jyoffset = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
                 // long yoffset = ix + iy * yjstride + iz * ykstride;
                 long jyoffset=xoffset;
                 long irhoy=irhox;
                 Vec jy0=Vec::Load(p,&jy_arr.p[jyoffset+moff[0]]);
                 svfloat64_t rhoy0=svld1_gather_u64index_f64(p,&yrhocells[0+irhoy],rho_index);
                 jy0+=rhoy0;
                 jy0.Store(p,&jy_arr.p[jyoffset+moff[0]]);
 
                 Vec jy1=Vec::Load(p,&jy_arr.p[jyoffset+moff[1]]);
                 svfloat64_t rhoy1=svld1_gather_u64index_f64(p,&yrhocells[1+irhoy],rho_index);
                 jy1+=rhoy1;
                 jy1.Store(p,&jy_arr.p[jyoffset+moff[1]]);
 
                 Vec jy2=Vec::Load(p,&jy_arr.p[jyoffset+moff[2]]);
                 svfloat64_t rhoy2=svld1_gather_u64index_f64(p,&yrhocells[2+irhoy],rho_index);
                 jy2+=rhoy2;
                 jy2.Store(p,&jy_arr.p[jyoffset+moff[2]]);
 
                 Vec jy3=Vec::Load(p,&jy_arr.p[jyoffset+moff[3]]);
                 svfloat64_t rhoy3=svld1_gather_u64index_f64(p,&yrhocells[3+irhoy],rho_index);
                 jy3+=rhoy3;
                 jy3.Store(p,&jy_arr.p[jyoffset+moff[3]]);
 
                 Vec jy4=Vec::Load(p,&jy_arr.p[jyoffset+moff[4]]);
                 svfloat64_t rhoy4=svld1_gather_u64index_f64(p,&yrhocells[4+irhoy],rho_index);
                 jy4+=rhoy4;
                 jy4.Store(p,&jy_arr.p[jyoffset+moff[4]]);
 
                 Vec jy5=Vec::Load(p,&jy_arr.p[jyoffset+moff[5]]);
                 svfloat64_t rhoy5=svld1_gather_u64index_f64(p,&yrhocells[5+irhoy],rho_index);
                 jy5+=rhoy5;
                 jy5.Store(p,&jy_arr.p[jyoffset+moff[5]]);
 
                 Vec jy6=Vec::Load(p,&jy_arr.p[jyoffset+moff[6]]);
                 svfloat64_t rhoy6=svld1_gather_u64index_f64(p,&yrhocells[6+irhoy],rho_index);
                 jy6+=rhoy6;
                 jy6.Store(p,&jy_arr.p[jyoffset+moff[6]]);
 
                 Vec jy7=Vec::Load(p,&jy_arr.p[jyoffset+moff[7]]);
                 svfloat64_t rhoy7=svld1_gather_u64index_f64(p,&yrhocells[7+irhoy],rho_index);
                 jy7+=rhoy7;
                 jy7.Store(p,&jy_arr.p[jyoffset+moff[7]]);
 
                 // z
                 // uint64_t irhoz = ix + iy * zjstride + iz * zkstride;
                 // svuint64_t rhoz_index = svindex_u64(irhoz, 8ULL);
                 // long jzoffset = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
                 long zoffset = ix + iy * zjstride + iz * zkstride;
                 long jzoffset=xoffset;
                 long irhoz=irhox;
                 Vec jz0=Vec::Load(p,&jz_arr.p[jzoffset+moff[0]]);
                 svfloat64_t rhoz0=svld1_gather_u64index_f64(p,&zrhocells[0+irhoz],rho_index);
                 jz0+=rhoz0;
                 jz0.Store(p,&jz_arr.p[jzoffset+moff[0]]);
 
                 Vec jz1=Vec::Load(p,&jz_arr.p[jzoffset+moff[1]]);
                 svfloat64_t rhoz1=svld1_gather_u64index_f64(p,&zrhocells[1+irhoz],rho_index);
                 jz1+=rhoz1;
                 jz1.Store(p,&jz_arr.p[jzoffset+moff[1]]);
 
                 Vec jz2=Vec::Load(p,&jz_arr.p[jzoffset+moff[2]]);
                 svfloat64_t rhoz2=svld1_gather_u64index_f64(p,&zrhocells[2+irhoz],rho_index);
                 jz2+=rhoz2;
                 jz2.Store(p,&jz_arr.p[jzoffset+moff[2]]);
 
                 Vec jz3=Vec::Load(p,&jz_arr.p[jzoffset+moff[3]]);
                 svfloat64_t rhoz3=svld1_gather_u64index_f64(p,&zrhocells[3+irhoz],rho_index);
                 jz3+=rhoz3;
                 jz3.Store(p,&jz_arr.p[jzoffset+moff[3]]);
 
                 Vec jz4=Vec::Load(p,&jz_arr.p[jzoffset+moff[4]]);
                 svfloat64_t rhoz4=svld1_gather_u64index_f64(p,&zrhocells[4+irhoz],rho_index);
                 jz4+=rhoz4;
                 jz4.Store(p,&jz_arr.p[jzoffset+moff[4]]);
 
                 Vec jz5=Vec::Load(p,&jz_arr.p[jzoffset+moff[5]]);
                 svfloat64_t rhoz5=svld1_gather_u64index_f64(p,&zrhocells[5+irhoz],rho_index);
                 jz5+=rhoz5;
                 jz5.Store(p,&jz_arr.p[jzoffset+moff[5]]);
 
                 Vec jz6=Vec::Load(p,&jz_arr.p[jzoffset+moff[6]]);
                 svfloat64_t rhoz6=svld1_gather_u64index_f64(p,&zrhocells[6+irhoz],rho_index);
                 jz6+=rhoz6;
                 jz6.Store(p,&jz_arr.p[jzoffset+moff[6]]);
 
                 Vec jz7=Vec::Load(p,&jz_arr.p[jzoffset+moff[7]]);
                 svfloat64_t rhoz7=svld1_gather_u64index_f64(p,&zrhocells[7+irhoz],rho_index);
                 jz7+=rhoz7;
                 jz7.Store(p,&jz_arr.p[jzoffset+moff[7]]);
 
                 // svetime[1]=rdtscv();
                 // reduce_time+=(svetime[1]-svetime[0]);
             }
         }
     }
     
 }
 
 template <int depos_order>
 void doDepositionShapeN_full_special (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Dim3 hi,
                          amrex::Dim3 len,
                          amrex::Real q,
                          std::vector<int>& test,
                          std::vector<int>& test0,
                          std::vector<long>& test1,
                          ParticleTileType& ptile, const amrex::Box& box,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     WARPX_PROFILE("[0] USER doDepositionShapeN_special()");
     WARPX_PROFILE_VAR_NS("[1] USER SME_sortanrpre", bl_sort);
     WARPX_PROFILE_VAR_NS("[2] USER SME_kernal", bl_sme);
     WARPX_PROFILE_VAR_NS("[3] USER SME_post", bl_post);
     // uint64_t total_time[3]={0};
     using namespace std::chrono;
     using namespace amrex::literals;
     
     const bool do_ionization = ion_lev;
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z; 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
 
     constexpr int nshapes = depos_order + 1;
     // constexpr int nshapes = 2;
     int vl=svcntd();
 
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
 
     auto compute_shape_factor_v2 = [](std::vector<double>* sx, Vec xmid, svbool_t p) {
         const svuint64_t sx_index = svindex_u64(0ULL, 2ULL);
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         svst1_scatter_index(p,&sx[0][0],sx_index,sx0);
         svst1_scatter_index(p,&sx[0][1],sx_index,sx1);
         // sx0.Store(p, sx[0]);
         // sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
     auto compute_shape_factor_v1 = [](double* sx, Vec xmid, svbool_t p) {
         const svuint64_t sx_index = svindex_u64(0, 2);
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // double test[8];
         // xint.Store(p,&test[0]);
         // for(int ii=0;ii<8;ii++){
         //     // printf("ii %d xind %f \n",ii,test[ii]);
         //     sx[ii][0]=1.0-test[ii];
         //     sx[ii][1]=test[ii];
         // }
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         // double sx00[8];
         // double sx01[8];
         // sx0.Store(p,&sx00[0]);
         // sx1.Store(p,&sx01[0]);
         // for(int ii=0;ii<8;ii++){
         //     // printf("ii %d xind %f \n",ii,test[ii]);
         //     sx[ii][0]=sx00[ii];
         //     sx[ii][1]=sx01[ii];
         // }
         svst1_scatter_index(p,&sx[0],sx_index,sx0);
         svst1_scatter_index(p,&sx[1],sx_index,sx1);
         // sx0.Store(p, sx[0]);
         // sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
     // // const long numcell = jx_fab.box().numPts();
     // const long numcell = ptile.m_bin_offsets.size();
 
     // std::vector<amrex::Real> xrhocells(8*numcell, 0.0);
     // std::vector<amrex::Real> yrhocells(8*numcell, 0.0);
     // std::vector<amrex::Real> zrhocells(8*numcell, 0.0);
     // one roll x
     uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
     uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
     uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
     long nx=xjstride;
     long nxy=xkstride;
     long moff[8] = {0, 1, nx, nx+1, nxy, nxy+1, nx+nxy, nx+nxy+1};
     svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
     svbool_t px = svcmpeq_n_u64(svptrue_b64(), rmx_v, 0);
     svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
     svbool_t py = svcmpeq_n_u64(svptrue_b64(), rmy_v, 0);
     svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
     svbool_t pz = svcmpeq_n_u64(svptrue_b64(), rmz_v, 0);
 
     std::vector<amrex::Real> wqx(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqy(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqz(np_to_deposit, 0.0);
 
     std::vector<amrex::Real> sx_m(np_to_deposit*nshapes, 0.);
     std::vector<amrex::Real> sy_m(np_to_deposit*nshapes, 0.);
     std::vector<amrex::Real> sz_m(np_to_deposit*nshapes, 0.);
     alignas(64) long xoffsets[np_to_deposit]; 
     // alignas(64) long yoffsets[np_to_deposit];
     // alignas(64) long zoffsets[np_to_deposit];
     long bx = 2, by = 2, bz = 2;
     amrex::IntVect box_shape = box.length();
     // amrex::Print() << "Box shape: " << box_shape << std::endl;
     long nnx = box_shape[0];
     long nny = box_shape[1];
     long nnxny = nnx*nny;
     alignas(64) std::vector<long> newbin(np_to_deposit);
     // alignas(64) long newbin[np_to_deposit];
     WARPX_PROFILE_VAR_START(bl_sort);
 
     for(long ip=0;ip<np_to_deposit;ip+=vl){
         // svetime[0]=rdtscv();
 
         // 计算基本物理量
         svbool_t p=svwhilele_b64(ip,np_to_deposit);
         // Inverse of Lorentz factor gamma
         Vec uxp_v=Vec::Load(p,&uxp[ip]);
         Vec uyp_v=Vec::Load(p,&uyp[ip]);
         Vec uzp_v=Vec::Load(p,&uzp[ip]);
         Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                     + uyp_v * uyp_v * clightsq
                                     + uzp_v * uzp_v * clightsq).Sqrt();
         // Product of particle charges and weights
         Vec wp_v=Vec::Load(p,&wp[ip]);
         Vec wq_v = q * wp_v;
 
         // Current particle positions (in physical units)
         Vec xp = Vec::Load(p, &mx[ip]);
         Vec yp = Vec::Load(p, &my[ip]);
         Vec zp = Vec::Load(p, &mz[ip]);
 
         // Particle velocities
         Vec vx_v = uxp_v * gaminv;
         Vec vy_v = uyp_v * gaminv;
         Vec vz_v = uzp_v * gaminv;
 
         // if (do_ionization) wq *= ion_lev[ip];
         Vec wqx_v = wq_v * invvol * vx_v;
         Vec wqy_v = wq_v * invvol * vy_v;
         Vec wqz_v = wq_v * invvol * vz_v;
 
         wqx_v.Store(p, &wqx[ip]);
         wqy_v.Store(p, &wqy[ip]);
         wqz_v.Store(p, &wqz[ip]);
 
         Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x;
         Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y;
         Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z;
         // xmid.Store(p, &test0[ip]);
         // double* sx_temp[nshapes] = {&sx_m[0][ip], &sx_m[1][ip]};
         intVec j_cellv = compute_shape_factor_v1( &sx_m[ip*2], xmid, p);
         // j_cellv.Store(p, &test[ip]);
         intVec k_cellv = compute_shape_factor_v1( &sy_m[ip*2], ymid, p);
         intVec l_cellv = compute_shape_factor_v1( &sz_m[ip*2], zmid, p); 
 
         intVec xoffsets_v = j_cellv + k_cellv * xjstride + l_cellv * xkstride;
         // intVec yoffsets_v = j_cellv + k_cellv * yjstride + l_cellv * ykstride;
         // intVec zoffsets_v = j_cellv + k_cellv * zjstride + l_cellv * zkstride;
 
         xoffsets_v.Store(p,&xoffsets[ip]);
         intVec new_bin_v = (j_cellv-bx) + 
                             (k_cellv-by)* nnx + 
                             (l_cellv-bz) * nnxny;
         new_bin_v.Store(p,&newbin[ip]);
     }
     // const long numcell = jx_fab.box().numPts();
     const long numcell = ptile.m_bin_offsets.size()-1;
 
     std::vector<amrex::Real> xrhocells(8*numcell, 0.0);
     std::vector<amrex::Real> yrhocells(8*numcell, 0.0);
     std::vector<amrex::Real> zrhocells(8*numcell, 0.0);
     for(int ip=0;ip<np_to_deposit;ip++){
         if(newbin[ip]>=numcell){
             // printf("%d out numcell!!\n",newbin[ip]);
             newbin[ip]=numcell-1;
         }
         if(newbin[ip]<0){
             // printf("%d out numcell!!\n",newbin[ip]);
             newbin[ip]=0;
         }
     }
      
     //////////////////////////
     auto& local_index = ptile.m_local_index;
     auto& bin_offsets = ptile.m_bin_offsets;
     auto& bin_length = ptile.m_bin_lengths;
     // const long numcell = ptile.m_bin_offsets.size()-1;
     // const long numcell = jx_fab.box().numPts();
     auto& pid_to_bin_map = ptile.m_pid_to_bin_map;
     auto& free_slot = ptile.m_free_slots;
     std::vector<ParticleMove> m_pending_moves;
 
     // test=ptile.m_local_index;
     // test0=ptile.m_bin_offsets;
     // return;
     
     // WARPX_PROFILE_VAR_START(bl_sort);
     //先把短了的PMA加长
     for(int ip=pid_to_bin_map.size();ip<np_to_deposit;ip++){
         int new_bin=newbin[ip];
         m_pending_moves.push_back({ip, new_bin});
     }
     //如果加长了后面的ip就是-1的bin
     //如果截断了，后面的ip就找不到了
     pid_to_bin_map.resize(np_to_deposit, -1); 
     // pid_to_bin_map.assign(newbin.begin(),newbin.end());
     for (int old_bin = 0; old_bin < numcell; ++old_bin) {
         if (bin_length[old_bin] == 0) continue;
         const int start = bin_offsets[old_bin];
         const int end   = bin_offsets[old_bin+1];
         for (int idx = start; idx < end; ++idx) {
             const int ip = local_index[idx];
             if (ip == INVALID_PARTICLE_ID) continue;
             // 如果需要截断就删除
             if (ip >= np_to_deposit) {
                 ptile.m_local_index[idx] = INVALID_PARTICLE_ID;
                 ptile.m_bin_lengths[old_bin]--;
                 ptile.m_num_empty_slots++;
                 ptile.m_num_particles--;
                 free_slot[old_bin].push_back(idx);
                 continue;
             }
             int new_bin=newbin[ip];
             // 剩下的old bin不可能小于0了
             // 先在原位置删除等着添加
             if(new_bin>=numcell){
                 printf("new_bin %d numcell %d\n",new_bin,numcell);
                 amrex::Abort("ERROR ilegal new bin!!!");
             }
             if(old_bin!=new_bin){
                 m_pending_moves.push_back({ip, new_bin});
                 pid_to_bin_map[ip]=new_bin;
                 ptile.m_bin_lengths[old_bin]--;
                 // if(free_slot[old_bin].empty())printf("empty\n");
                 free_slot[old_bin].push_back(idx);
                 ptile.m_num_empty_slots++;
                 ptile.m_num_particles--;
             }
         }
     }
     
     applyPendingMoves_special(numcell, ptile, m_pending_moves);
     WARPX_PROFILE_VAR_STOP(bl_sort);
 
     WARPX_PROFILE_VAR_START(bl_sme);
     sort_3d_sme_kernal_special<1>(
         numcell,local_index,
         bin_length,bin_offsets,
         xrhocells,yrhocells,zrhocells,
         sx_m,sy_m,sz_m,
         wqx,wqy,wqz);
     WARPX_PROFILE_VAR_STOP(bl_sme);
     WARPX_PROFILE_VAR_START(bl_post);
     for (int iz = bx; iz < len.z-bx; ++iz) {
         for (int iy = bx; iy < len.y-bx; ++iy) {       
             for (int ix = bx; ix < len.x-bx; ix+=vl) {
    
                 // vector
                 svbool_t p=svwhilelt_b64(ix,(len.x-2));
 
                 svuint64_t rho_index = svindex_u64(0ULL, 8ULL);
                 long xoffset=ix + iy * xjstride + iz * xkstride;
                 // long xoffset=(ix-bx) + (iy-by) * nnx + (iz-bz) * nnxny;
                 long cell_idx=(ix-bx) + (iy-by) * nnx + (iz-bz) * nnxny+1;
                 long jxoffset=xoffset;
                 // long irhox=8*xoffset;
                 long irhox=8*cell_idx;
                 Vec jx0=Vec::Load(p,&jx_arr.p[jxoffset+moff[0]]);
                 svfloat64_t rhox0=svld1_gather_u64index_f64(p,&xrhocells[0+irhox],rho_index);
                 jx0+=rhox0;
                 jx0.Store(p,&jx_arr.p[jxoffset+moff[0]]);
 
                 Vec jx1=Vec::Load(p,&jx_arr.p[jxoffset+moff[1]]);
                 svfloat64_t rhox1=svld1_gather_u64index_f64(p,&xrhocells[1+irhox],rho_index);
                 jx1+=rhox1;
                 jx1.Store(p,&jx_arr.p[jxoffset+moff[1]]);
 
                 Vec jx2=Vec::Load(p,&jx_arr.p[jxoffset+moff[2]]);
                 svfloat64_t rhox2=svld1_gather_u64index_f64(p,&xrhocells[2+irhox],rho_index);
                 jx2+=rhox2;
                 jx2.Store(p,&jx_arr.p[jxoffset+moff[2]]);
 
                 Vec jx3=Vec::Load(p,&jx_arr.p[jxoffset+moff[3]]);
                 svfloat64_t rhox3=svld1_gather_u64index_f64(p,&xrhocells[3+irhox],rho_index);
                 jx3+=rhox3;
                 jx3.Store(p,&jx_arr.p[jxoffset+moff[3]]);
 
                 Vec jx4=Vec::Load(p,&jx_arr.p[jxoffset+moff[4]]);
                 svfloat64_t rhox4=svld1_gather_u64index_f64(p,&xrhocells[4+irhox],rho_index);
                 jx4+=rhox4;
                 jx4.Store(p,&jx_arr.p[jxoffset+moff[4]]);
 
                 Vec jx5=Vec::Load(p,&jx_arr.p[jxoffset+moff[5]]);
                 svfloat64_t rhox5=svld1_gather_u64index_f64(p,&xrhocells[5+irhox],rho_index);
                 jx5+=rhox5;
                 jx5.Store(p,&jx_arr.p[jxoffset+moff[5]]);
 
                 Vec jx6=Vec::Load(p,&jx_arr.p[jxoffset+moff[6]]);
                 svfloat64_t rhox6=svld1_gather_u64index_f64(p,&xrhocells[6+irhox],rho_index);
                 jx6+=rhox6;
                 jx6.Store(p,&jx_arr.p[jxoffset+moff[6]]);
 
                 Vec jx7=Vec::Load(p,&jx_arr.p[jxoffset+moff[7]]);
                 svfloat64_t rhox7=svld1_gather_u64index_f64(p,&xrhocells[7+irhox],rho_index);
                 jx7+=rhox7;
                 jx7.Store(p,&jx_arr.p[jxoffset+moff[7]]);
                 
                 // y
                 // uint64_t irhoy = ix + iy * yjstride + iz * ykstride;
                 // svuint64_t rhoy_index = svindex_u64(irhoy, 8ULL);
                 // long jyoffset = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
                 // long yoffset = ix + iy * yjstride + iz * ykstride;
                 long jyoffset=xoffset;
                 long irhoy=irhox;
                 Vec jy0=Vec::Load(p,&jy_arr.p[jyoffset+moff[0]]);
                 svfloat64_t rhoy0=svld1_gather_u64index_f64(p,&yrhocells[0+irhoy],rho_index);
                 jy0+=rhoy0;
                 jy0.Store(p,&jy_arr.p[jyoffset+moff[0]]);
 
                 Vec jy1=Vec::Load(p,&jy_arr.p[jyoffset+moff[1]]);
                 svfloat64_t rhoy1=svld1_gather_u64index_f64(p,&yrhocells[1+irhoy],rho_index);
                 jy1+=rhoy1;
                 jy1.Store(p,&jy_arr.p[jyoffset+moff[1]]);
 
                 Vec jy2=Vec::Load(p,&jy_arr.p[jyoffset+moff[2]]);
                 svfloat64_t rhoy2=svld1_gather_u64index_f64(p,&yrhocells[2+irhoy],rho_index);
                 jy2+=rhoy2;
                 jy2.Store(p,&jy_arr.p[jyoffset+moff[2]]);
 
                 Vec jy3=Vec::Load(p,&jy_arr.p[jyoffset+moff[3]]);
                 svfloat64_t rhoy3=svld1_gather_u64index_f64(p,&yrhocells[3+irhoy],rho_index);
                 jy3+=rhoy3;
                 jy3.Store(p,&jy_arr.p[jyoffset+moff[3]]);
 
                 Vec jy4=Vec::Load(p,&jy_arr.p[jyoffset+moff[4]]);
                 svfloat64_t rhoy4=svld1_gather_u64index_f64(p,&yrhocells[4+irhoy],rho_index);
                 jy4+=rhoy4;
                 jy4.Store(p,&jy_arr.p[jyoffset+moff[4]]);
 
                 Vec jy5=Vec::Load(p,&jy_arr.p[jyoffset+moff[5]]);
                 svfloat64_t rhoy5=svld1_gather_u64index_f64(p,&yrhocells[5+irhoy],rho_index);
                 jy5+=rhoy5;
                 jy5.Store(p,&jy_arr.p[jyoffset+moff[5]]);
 
                 Vec jy6=Vec::Load(p,&jy_arr.p[jyoffset+moff[6]]);
                 svfloat64_t rhoy6=svld1_gather_u64index_f64(p,&yrhocells[6+irhoy],rho_index);
                 jy6+=rhoy6;
                 jy6.Store(p,&jy_arr.p[jyoffset+moff[6]]);
 
                 Vec jy7=Vec::Load(p,&jy_arr.p[jyoffset+moff[7]]);
                 svfloat64_t rhoy7=svld1_gather_u64index_f64(p,&yrhocells[7+irhoy],rho_index);
                 jy7+=rhoy7;
                 jy7.Store(p,&jy_arr.p[jyoffset+moff[7]]);
 
                 // z
                 // uint64_t irhoz = ix + iy * zjstride + iz * zkstride;
                 // svuint64_t rhoz_index = svindex_u64(irhoz, 8ULL);
                 // long jzoffset = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
                 long zoffset = ix + iy * zjstride + iz * zkstride;
                 long jzoffset=xoffset;
                 long irhoz=irhox;
                 Vec jz0=Vec::Load(p,&jz_arr.p[jzoffset+moff[0]]);
                 svfloat64_t rhoz0=svld1_gather_u64index_f64(p,&zrhocells[0+irhoz],rho_index);
                 jz0+=rhoz0;
                 jz0.Store(p,&jz_arr.p[jzoffset+moff[0]]);
 
                 Vec jz1=Vec::Load(p,&jz_arr.p[jzoffset+moff[1]]);
                 svfloat64_t rhoz1=svld1_gather_u64index_f64(p,&zrhocells[1+irhoz],rho_index);
                 jz1+=rhoz1;
                 jz1.Store(p,&jz_arr.p[jzoffset+moff[1]]);
 
                 Vec jz2=Vec::Load(p,&jz_arr.p[jzoffset+moff[2]]);
                 svfloat64_t rhoz2=svld1_gather_u64index_f64(p,&zrhocells[2+irhoz],rho_index);
                 jz2+=rhoz2;
                 jz2.Store(p,&jz_arr.p[jzoffset+moff[2]]);
 
                 Vec jz3=Vec::Load(p,&jz_arr.p[jzoffset+moff[3]]);
                 svfloat64_t rhoz3=svld1_gather_u64index_f64(p,&zrhocells[3+irhoz],rho_index);
                 jz3+=rhoz3;
                 jz3.Store(p,&jz_arr.p[jzoffset+moff[3]]);
 
                 Vec jz4=Vec::Load(p,&jz_arr.p[jzoffset+moff[4]]);
                 svfloat64_t rhoz4=svld1_gather_u64index_f64(p,&zrhocells[4+irhoz],rho_index);
                 jz4+=rhoz4;
                 jz4.Store(p,&jz_arr.p[jzoffset+moff[4]]);
 
                 Vec jz5=Vec::Load(p,&jz_arr.p[jzoffset+moff[5]]);
                 svfloat64_t rhoz5=svld1_gather_u64index_f64(p,&zrhocells[5+irhoz],rho_index);
                 jz5+=rhoz5;
                 jz5.Store(p,&jz_arr.p[jzoffset+moff[5]]);
 
                 Vec jz6=Vec::Load(p,&jz_arr.p[jzoffset+moff[6]]);
                 svfloat64_t rhoz6=svld1_gather_u64index_f64(p,&zrhocells[6+irhoz],rho_index);
                 jz6+=rhoz6;
                 jz6.Store(p,&jz_arr.p[jzoffset+moff[6]]);
 
                 Vec jz7=Vec::Load(p,&jz_arr.p[jzoffset+moff[7]]);
                 svfloat64_t rhoz7=svld1_gather_u64index_f64(p,&zrhocells[7+irhoz],rho_index);
                 jz7+=rhoz7;
                 jz7.Store(p,&jz_arr.p[jzoffset+moff[7]]);
 
                 // svetime[1]=rdtscv();
                 // reduce_time+=(svetime[1]-svetime[0]);
             }
         }
     }
     WARPX_PROFILE_VAR_STOP(bl_post);
 }
 
 
 
 template <int depos_order>
 void doDepositionShapeN_3d_sme_hybrid_incrsort_noGPMA (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Dim3 hi,
                          amrex::Dim3 len,
                          amrex::Real q,
                          std::vector<int>& test,
                          std::vector<int>& test0,std::vector<long>& test1,
                          ParticleTileType& ptile, const amrex::Box& box,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     WARPX_PROFILE("doDepositionShapeN_3d_sme()");
     // uint64_t total_time[3]={0};
     using namespace std::chrono;
     using namespace amrex::literals;
     double total_time=0;
     // auto total_start=high_resolution_clock::now();
     uint64_t precompute=0;
     uint64_t cale_time=0;
     uint64_t sort_time=0;
         uint64_t count_time=0;
         uint64_t presum_time=0;
         uint64_t binlist_time=0;
     uint64_t reduce_time=0;
     uint64_t svetime[3]={0};
     uint64_t branch_time=0;
     
     // total_time[0]=rdtscv();
     
 
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z; 
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
 
     constexpr int nshapes = depos_order + 1;
     // constexpr int nshapes = 2;
     int vl=svcntd();
 
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
 
     auto compute_shape_factor_v2 = [](std::vector<double>* sx, Vec xmid, svbool_t p) {
         const svuint64_t sx_index = svindex_u64(0ULL, 2ULL);
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         svst1_scatter_index(p,&sx[0][0],sx_index,sx0);
         svst1_scatter_index(p,&sx[0][1],sx_index,sx1);
         // sx0.Store(p, sx[0]);
         // sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
     auto compute_shape_factor_v1 = [](double* sx, Vec xmid, svbool_t p) {
         const svuint64_t sx_index = svindex_u64(0, 2);
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // double test[8];
         // xint.Store(p,&test[0]);
         // for(int ii=0;ii<8;ii++){
         //     // printf("ii %d xind %f \n",ii,test[ii]);
         //     sx[ii][0]=1.0-test[ii];
         //     sx[ii][1]=test[ii];
         // }
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         // double sx00[8];
         // double sx01[8];
         // sx0.Store(p,&sx00[0]);
         // sx1.Store(p,&sx01[0]);
         // for(int ii=0;ii<8;ii++){
         //     // printf("ii %d xind %f \n",ii,test[ii]);
         //     sx[ii][0]=sx00[ii];
         //     sx[ii][1]=sx01[ii];
         // }
         svst1_scatter_index(p,&sx[0],sx_index,sx0);
         svst1_scatter_index(p,&sx[1],sx_index,sx1);
         // sx0.Store(p, sx[0]);
         // sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
     // const long numcell = jx_fab.box().numPts();
     // const int numcell = ptile.num_bins;
     const long numcell = ptile.m_bin_offsets.size()-1;
 
     std::vector<amrex::Real> xrhocells(8*numcell, 0.0);
     std::vector<amrex::Real> yrhocells(8*numcell, 0.0);
     std::vector<amrex::Real> zrhocells(8*numcell, 0.0);
     // one roll x
     uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
     uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
     uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
     long nx=xjstride;
     long nxy=xkstride;
     long moff[8] = {0, 1, nx, nx+1, nxy, nxy+1, nx+nxy, nx+nxy+1};
     svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
     svbool_t px = svcmpeq_n_u64(svptrue_b64(), rmx_v, 0);
     svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
     svbool_t py = svcmpeq_n_u64(svptrue_b64(), rmy_v, 0);
     svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
     svbool_t pz = svcmpeq_n_u64(svptrue_b64(), rmz_v, 0);
 
     std::vector<amrex::Real> wqx(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqy(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqz(np_to_deposit, 0.0);
 
     std::vector<amrex::Real> sx_m(np_to_deposit*nshapes, 0.);
     std::vector<amrex::Real> sy_m(np_to_deposit*nshapes, 0.);
     std::vector<amrex::Real> sz_m(np_to_deposit*nshapes, 0.);
     alignas(64) long xoffsets[np_to_deposit]; 
     // alignas(64) long yoffsets[np_to_deposit];
     // alignas(64) long zoffsets[np_to_deposit];
     long bx = 2, by = 2, bz = 2;
     amrex::IntVect box_shape = box.length();
     // amrex::Print() << "Box shape: " << box_shape << std::endl;
     long nnx = box_shape[0];
     long nny = box_shape[1];
     long nnxny = nnx*nny;
     alignas(64) std::vector<long> newbin(np_to_deposit,-1);
     
 
     for(long ip=0;ip<np_to_deposit;ip+=vl){
         // svetime[0]=rdtscv();
 
         // 计算基本物理量
         svbool_t p=svwhilele_b64(ip,np_to_deposit);
         // Inverse of Lorentz factor gamma
         Vec uxp_v=Vec::Load(p,&uxp[ip]);
         Vec uyp_v=Vec::Load(p,&uyp[ip]);
         Vec uzp_v=Vec::Load(p,&uzp[ip]);
         Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                     + uyp_v * uyp_v * clightsq
                                     + uzp_v * uzp_v * clightsq).Sqrt();
         // Product of particle charges and weights
         Vec wp_v=Vec::Load(p,&wp[ip]);
         Vec wq_v = q * wp_v;
 
         // Current particle positions (in physical units)
         Vec xp = Vec::Load(p, &mx[ip]);
         Vec yp = Vec::Load(p, &my[ip]);
         Vec zp = Vec::Load(p, &mz[ip]);
 
         // Particle velocities
         Vec vx_v = uxp_v * gaminv;
         Vec vy_v = uyp_v * gaminv;
         Vec vz_v = uzp_v * gaminv;
 
         // if (do_ionization) wq *= ion_lev[ip];
         Vec wqx_v = wq_v * invvol * vx_v;
         Vec wqy_v = wq_v * invvol * vy_v;
         Vec wqz_v = wq_v * invvol * vz_v;
 
         wqx_v.Store(p, &wqx[ip]);
         wqy_v.Store(p, &wqy[ip]);
         wqz_v.Store(p, &wqz[ip]);
 
         Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x;
         Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y;
         Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z;
         // xmid.Store(p, &test0[ip]);
         // double* sx_temp[nshapes] = {&sx_m[0][ip], &sx_m[1][ip]};
         intVec j_cellv = compute_shape_factor_v1( &sx_m[ip*2], xmid, p);
         // j_cellv.Store(p, &test[ip]);
         intVec k_cellv = compute_shape_factor_v1( &sy_m[ip*2], ymid, p);
         intVec l_cellv = compute_shape_factor_v1( &sz_m[ip*2], zmid, p); 
 
         intVec xoffsets_v = j_cellv + k_cellv * xjstride + l_cellv * xkstride;
         // intVec yoffsets_v = j_cellv + k_cellv * yjstride + l_cellv * ykstride;
         // intVec zoffsets_v = j_cellv + k_cellv * zjstride + l_cellv * zkstride;
 
         xoffsets_v.Store(p,&xoffsets[ip]);
         intVec new_bin_v = (j_cellv-bx) + 
                             (k_cellv-by)* nnx + 
                             (l_cellv-bz) * nnxny;
         new_bin_v.Store(p,&newbin[ip]);
         // yoffsets_v.Store(p,&yoffsets[ip]);
         // zoffsets_v.Store(p,&zoffsets[ip]);
 
         // 原子操作，不可避免
         // const int vec_len = std::min(vl, static_cast<int>(np_to_deposit-ip));
         // svetime[2]=rdtscv();
         // for(int off=0;off<vec_len;off++){
         //     xcount[xoffsets[ip+off]]++;
         //     // ycount[yoffsets[ip+off]]++;
         //     // zcount[zoffsets[ip+off]]++;
         // }
         // svetime[1]=rdtscv();
         // count_time+=(svetime[1]-svetime[2]);
 
         // printf("after STORE\n");
         // svetime[1]=rdtscv();
         // precompute+=(svetime[1]-svetime[0]); 
         // printf("after SAVE\n");
     }
     
 
     for(int ip=0;ip<np_to_deposit;ip++){
         if(newbin[ip]>=numcell){
             printf("%d out numcell!!\n",newbin[ip]);
             newbin[ip]=(numcell-1);
         }
         if(newbin[ip]<0){
             printf("%d out numcell!!\n",newbin[ip]);
             // newbin[ip]=0;
             newbin[ip]=0;
         }
     }
     test1=newbin;
     //////////////////////////
     // auto& local_index = ptile.m_local_index;
     // auto& bin_offsets = ptile.m_bin_offsets;
     // auto& bin_length = ptile.m_bin_lengths;
     // const long numcell = ptile.m_bin_offsets.size()-1;
     // const long numcell = jx_fab.box().numPts();
     // auto& pid_to_bin_map = ptile.m_pid_to_bin_map;
     // auto& free_slot = ptile.m_free_slots;
     // std::vector<ParticleMove> m_pending_moves;
 
     // test=ptile.m_local_index;
     // test0=ptile.m_bin_offsets;
     // return;
 
     //先把短了的PMA加长
     ///////////////////////////
     std::vector<int> local_index=ptile.m_local_index;
     std::vector<int> bin_offsets=ptile.m_bin_offsets;
     auto& pid_to_bin_map = ptile.m_pid_to_bin_map;
     if(pid_to_bin_map.size()==newbin.size() 
         && std::equal(pid_to_bin_map.begin(),pid_to_bin_map.end(),newbin.begin())){
     // if(pid_to_bin_map==newbin){
         // break;
         printf("pid_to_bin_map == newbin SKIPPING!\n");
         applyPendingMoves_nogpma(numcell, ptile, newbin,np_to_deposit);
         pid_to_bin_map.reserve(newbin.size());
         pid_to_bin_map.assign(newbin.begin(),newbin.end());
     }else{
         applyPendingMoves_nogpma(numcell, ptile, newbin,np_to_deposit);
         pid_to_bin_map.reserve(newbin.size());
         pid_to_bin_map.assign(newbin.begin(),newbin.end());
     }
     // test=ptile.m_local_index;
     // test0=ptile.m_bin_offsets;
     // // test1=n
     // return;
     // return;
 
     // 预计算网格步长
     // const int xjstride = jx_arr.jstride;
     // const int xkstride = jx_arr.kstride;
     // const int yjstride = jy_arr.jstride;
     // const int ykstride = jy_arr.kstride;
     // const int zjstride = jz_arr.jstride;
     // const int zkstride = jz_arr.kstride;
 
     // for (int old_bin = 1; old_bin <= numcell; ++old_bin) {
     //     if (bin_length[old_bin-1] == 0) continue;
     //     int start = bin_offsets[old_bin-1];
     //     int end = bin_offsets[old_bin];
         // for (int idx = start; idx < end; idx+=vl) {
             // sort_3d_sme_kernal_1<1>(
             //     numcell,local_index,
             //     bin_length,bin_offsets,
             //     xrhocells,yrhocells,zrhocells,
             //     sx_m,sy_m,sz_m,
             //     wqx,wqy,wqz);
     sort_real_sme_kernal_4<1>(
             numcell,local_index,
             bin_offsets,
             xrhocells,yrhocells,zrhocells,
             sx_m,sy_m,sz_m,
             wqx,wqy,wqz);
         // }
     // }
 
     // one roll x
     // uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
     // uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
     // uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
     // // long nx=xjstride;
     // // long nxy=xkstride;
     // int moff[8] = {0, 1, nx, nx+1, nxny, nxny+1, nx+nxny, nx+nxny+1};
     // svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
     // svbool_t px = svcmpeq_n_u64(svptrue_b64(), rmx_v, 0);
     // svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
     // svbool_t py = svcmpeq_n_u64(svptrue_b64(), rmy_v, 0);
     // svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
     // svbool_t pz = svcmpeq_n_u64(svptrue_b64(), rmz_v, 0);
     for (int iz = bx; iz < len.z-bx; ++iz) {
         for (int iy = bx; iy < len.y-bx; ++iy) {       
             for (int ix = bx; ix < len.x-bx; ix+=vl) {
     // for (int iz = 0; iz <= len.z; ++iz) {
     //     for (int iy = 0; iy <= len.y; ++iy) {       
     //         for (int ix = 0; ix <= len.x; ix+=vl) {
                 // svetime[0]=rdtscv();
 
                 // vector
                 svbool_t p=svwhilelt_b64(ix,(len.x-2));
                 // long j = lo.x + ix;
                 // long k = lo.y + iy;
                 // long l = lo.z + iz;
                 // x
                 // uint64_t irhox = 8*(ix + iy * xjstride + iz * xkstride);
                 // svuint64_t rhox_index = svindex_u64(0, 8ULL);
                 // long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                 svuint64_t rho_index = svindex_u64(0ULL, 8ULL);
                 long xoffset=ix + iy * xjstride + iz * xkstride;
                 // long xoffset=(ix-bx) + (iy-by) * nnx + (iz-bz) * nnxny;
                 long cell_idx=(ix-bx) + (iy-by) * nnx + (iz-bz) * nnxny+1;
                 long jxoffset=xoffset;
                 // long irhox=8*xoffset;
                 long irhox=8*cell_idx;
                 Vec jx0=Vec::Load(p,&jx_arr.p[jxoffset+moff[0]]);
                 svfloat64_t rhox0=svld1_gather_u64index_f64(p,&xrhocells[0+irhox],rho_index);
                 jx0+=rhox0;
                 jx0.Store(p,&jx_arr.p[jxoffset+moff[0]]);
 
                 Vec jx1=Vec::Load(p,&jx_arr.p[jxoffset+moff[1]]);
                 svfloat64_t rhox1=svld1_gather_u64index_f64(p,&xrhocells[1+irhox],rho_index);
                 jx1+=rhox1;
                 jx1.Store(p,&jx_arr.p[jxoffset+moff[1]]);
 
                 Vec jx2=Vec::Load(p,&jx_arr.p[jxoffset+moff[2]]);
                 svfloat64_t rhox2=svld1_gather_u64index_f64(p,&xrhocells[2+irhox],rho_index);
                 jx2+=rhox2;
                 jx2.Store(p,&jx_arr.p[jxoffset+moff[2]]);
 
                 Vec jx3=Vec::Load(p,&jx_arr.p[jxoffset+moff[3]]);
                 svfloat64_t rhox3=svld1_gather_u64index_f64(p,&xrhocells[3+irhox],rho_index);
                 jx3+=rhox3;
                 jx3.Store(p,&jx_arr.p[jxoffset+moff[3]]);
 
                 Vec jx4=Vec::Load(p,&jx_arr.p[jxoffset+moff[4]]);
                 svfloat64_t rhox4=svld1_gather_u64index_f64(p,&xrhocells[4+irhox],rho_index);
                 jx4+=rhox4;
                 jx4.Store(p,&jx_arr.p[jxoffset+moff[4]]);
 
                 Vec jx5=Vec::Load(p,&jx_arr.p[jxoffset+moff[5]]);
                 svfloat64_t rhox5=svld1_gather_u64index_f64(p,&xrhocells[5+irhox],rho_index);
                 jx5+=rhox5;
                 jx5.Store(p,&jx_arr.p[jxoffset+moff[5]]);
 
                 Vec jx6=Vec::Load(p,&jx_arr.p[jxoffset+moff[6]]);
                 svfloat64_t rhox6=svld1_gather_u64index_f64(p,&xrhocells[6+irhox],rho_index);
                 jx6+=rhox6;
                 jx6.Store(p,&jx_arr.p[jxoffset+moff[6]]);
 
                 Vec jx7=Vec::Load(p,&jx_arr.p[jxoffset+moff[7]]);
                 svfloat64_t rhox7=svld1_gather_u64index_f64(p,&xrhocells[7+irhox],rho_index);
                 jx7+=rhox7;
                 jx7.Store(p,&jx_arr.p[jxoffset+moff[7]]);
                 
                 // y
                 // uint64_t irhoy = ix + iy * yjstride + iz * ykstride;
                 // svuint64_t rhoy_index = svindex_u64(irhoy, 8ULL);
                 // long jyoffset = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
                 // long yoffset = ix + iy * yjstride + iz * ykstride;
                 long jyoffset=xoffset;
                 long irhoy=irhox;
                 Vec jy0=Vec::Load(p,&jy_arr.p[jyoffset+moff[0]]);
                 svfloat64_t rhoy0=svld1_gather_u64index_f64(p,&yrhocells[0+irhoy],rho_index);
                 jy0+=rhoy0;
                 jy0.Store(p,&jy_arr.p[jyoffset+moff[0]]);
 
                 Vec jy1=Vec::Load(p,&jy_arr.p[jyoffset+moff[1]]);
                 svfloat64_t rhoy1=svld1_gather_u64index_f64(p,&yrhocells[1+irhoy],rho_index);
                 jy1+=rhoy1;
                 jy1.Store(p,&jy_arr.p[jyoffset+moff[1]]);
 
                 Vec jy2=Vec::Load(p,&jy_arr.p[jyoffset+moff[2]]);
                 svfloat64_t rhoy2=svld1_gather_u64index_f64(p,&yrhocells[2+irhoy],rho_index);
                 jy2+=rhoy2;
                 jy2.Store(p,&jy_arr.p[jyoffset+moff[2]]);
 
                 Vec jy3=Vec::Load(p,&jy_arr.p[jyoffset+moff[3]]);
                 svfloat64_t rhoy3=svld1_gather_u64index_f64(p,&yrhocells[3+irhoy],rho_index);
                 jy3+=rhoy3;
                 jy3.Store(p,&jy_arr.p[jyoffset+moff[3]]);
 
                 Vec jy4=Vec::Load(p,&jy_arr.p[jyoffset+moff[4]]);
                 svfloat64_t rhoy4=svld1_gather_u64index_f64(p,&yrhocells[4+irhoy],rho_index);
                 jy4+=rhoy4;
                 jy4.Store(p,&jy_arr.p[jyoffset+moff[4]]);
 
                 Vec jy5=Vec::Load(p,&jy_arr.p[jyoffset+moff[5]]);
                 svfloat64_t rhoy5=svld1_gather_u64index_f64(p,&yrhocells[5+irhoy],rho_index);
                 jy5+=rhoy5;
                 jy5.Store(p,&jy_arr.p[jyoffset+moff[5]]);
 
                 Vec jy6=Vec::Load(p,&jy_arr.p[jyoffset+moff[6]]);
                 svfloat64_t rhoy6=svld1_gather_u64index_f64(p,&yrhocells[6+irhoy],rho_index);
                 jy6+=rhoy6;
                 jy6.Store(p,&jy_arr.p[jyoffset+moff[6]]);
 
                 Vec jy7=Vec::Load(p,&jy_arr.p[jyoffset+moff[7]]);
                 svfloat64_t rhoy7=svld1_gather_u64index_f64(p,&yrhocells[7+irhoy],rho_index);
                 jy7+=rhoy7;
                 jy7.Store(p,&jy_arr.p[jyoffset+moff[7]]);
 
                 // z
                 // uint64_t irhoz = ix + iy * zjstride + iz * zkstride;
                 // svuint64_t rhoz_index = svindex_u64(irhoz, 8ULL);
                 // long jzoffset = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
                 long zoffset = ix + iy * zjstride + iz * zkstride;
                 long jzoffset=xoffset;
                 long irhoz=irhox;
                 Vec jz0=Vec::Load(p,&jz_arr.p[jzoffset+moff[0]]);
                 svfloat64_t rhoz0=svld1_gather_u64index_f64(p,&zrhocells[0+irhoz],rho_index);
                 jz0+=rhoz0;
                 jz0.Store(p,&jz_arr.p[jzoffset+moff[0]]);
 
                 Vec jz1=Vec::Load(p,&jz_arr.p[jzoffset+moff[1]]);
                 svfloat64_t rhoz1=svld1_gather_u64index_f64(p,&zrhocells[1+irhoz],rho_index);
                 jz1+=rhoz1;
                 jz1.Store(p,&jz_arr.p[jzoffset+moff[1]]);
 
                 Vec jz2=Vec::Load(p,&jz_arr.p[jzoffset+moff[2]]);
                 svfloat64_t rhoz2=svld1_gather_u64index_f64(p,&zrhocells[2+irhoz],rho_index);
                 jz2+=rhoz2;
                 jz2.Store(p,&jz_arr.p[jzoffset+moff[2]]);
 
                 Vec jz3=Vec::Load(p,&jz_arr.p[jzoffset+moff[3]]);
                 svfloat64_t rhoz3=svld1_gather_u64index_f64(p,&zrhocells[3+irhoz],rho_index);
                 jz3+=rhoz3;
                 jz3.Store(p,&jz_arr.p[jzoffset+moff[3]]);
 
                 Vec jz4=Vec::Load(p,&jz_arr.p[jzoffset+moff[4]]);
                 svfloat64_t rhoz4=svld1_gather_u64index_f64(p,&zrhocells[4+irhoz],rho_index);
                 jz4+=rhoz4;
                 jz4.Store(p,&jz_arr.p[jzoffset+moff[4]]);
 
                 Vec jz5=Vec::Load(p,&jz_arr.p[jzoffset+moff[5]]);
                 svfloat64_t rhoz5=svld1_gather_u64index_f64(p,&zrhocells[5+irhoz],rho_index);
                 jz5+=rhoz5;
                 jz5.Store(p,&jz_arr.p[jzoffset+moff[5]]);
 
                 Vec jz6=Vec::Load(p,&jz_arr.p[jzoffset+moff[6]]);
                 svfloat64_t rhoz6=svld1_gather_u64index_f64(p,&zrhocells[6+irhoz],rho_index);
                 jz6+=rhoz6;
                 jz6.Store(p,&jz_arr.p[jzoffset+moff[6]]);
 
                 Vec jz7=Vec::Load(p,&jz_arr.p[jzoffset+moff[7]]);
                 svfloat64_t rhoz7=svld1_gather_u64index_f64(p,&zrhocells[7+irhoz],rho_index);
                 jz7+=rhoz7;
                 jz7.Store(p,&jz_arr.p[jzoffset+moff[7]]);
 
                 // svetime[1]=rdtscv();
                 // reduce_time+=(svetime[1]-svetime[0]);
             }
         }
     }
     
 }
 
 template <int depos_order>
 __arm_new("za") inline void sme_kernal_2(
     long np_to_deposit,
     std::vector<int>& newbin,
     std::vector<amrex::Real> &xrhocells,
     std::vector<amrex::Real> &yrhocells,
     std::vector<amrex::Real> &zrhocells,
     std::vector<amrex::Real> &sx_m,
     std::vector<amrex::Real> &sy_m,
     std::vector<amrex::Real> &sz_m,
     std::vector<amrex::Real> &wqx,
     std::vector<amrex::Real> &wqy,
     std::vector<amrex::Real> &wqz
     // std::vector<double> &test
     ) __arm_streaming
 {
     using namespace amrex::literals;
     svbool_t p_4 = svwhilelt_b64(0, 4);
     svbool_t p_4_8 = svbic_z(svptrue_b64(), svptrue_b64(), p_4);
     svbool_t p0 = svwhilelt_b64(0, 2);
     svbool_t p1 = svbic_z(p_4, p_4, p0);
     svbool_t p = svptrue_b64();
     MVec vzero(0);
 
     
     int last=np_to_deposit%2;
     for (int idx = 0; idx < np_to_deposit-last; idx += 2)
     {
         svzero_za();
         int ip1 = idx;
         int ip2 = idx + 1;
         // const int c = (j_m[ip] - 2) + (k_m[ip] - 2) * nx + (l_m[ip] - 2) * nxny;
         // const int c = (j_m[ip]) + (k_m[ip] ) * nx + (l_m[ip]) * nxny;
 
         MVec sz_xv=svdup_n_f64(0);
         MVec sz_yv=svdup_n_f64(0);
         MVec sz_zv=svdup_n_f64(0);
         MVec sz_x1 = svld1(p0,&sz_m[ip1*2]);
         MVec sz_x2 = svld1(p1,&sz_m[ip1*2]);
         // MVec sz_y1 = sz_x1; 
         // MVec sz_y2 = sz_x2; 
         // MVec sz_z1 = sz_x1;
         // MVec sz_z2 = sz_x2;
         // svbool_t p1=svwhilelt_b64(2,4);
         // sz_x1*=wqx[ip1];
         sz_xv=svsel(p0,sz_x1,sz_xv);
         // sz_x2*=wqx[ip2];
         sz_xv=svsel(p1,sz_x2,sz_xv);
         // sz_y1*=wqy[ip1];
         // sz_yv=svsel(p0,sz_y1,sz_yv);
         // sz_y2*=wqy[ip2];
         // sz_yv=svsel(p1,sz_y2,sz_yv);
         // sz_z1*=wqz[ip1];
         // sz_zv=svsel(p0,sz_z1,sz_zv);
         // sz_z2*=wqz[ip2];
         // sz_zv=svsel(p1,sz_z2,sz_zv);
 
 
         MVec vx1=MVec::Load(p0, &sx_m[ip1*2]);
         MVec vx2=MVec::Load(p0, &sx_m[ip2*2]);
 
         MVec vy1=MVec::Load(p0, &sy_m[ip1*2]);
         MVec vy2=MVec::Load(p0, &sy_m[ip2*2]);
 
         const uint64_t x_indices[8]={0,2,0,2,1,3,1,3};
         MVec vx_broadcast=svtbl(svzip1(vx1,vx2),svld1_u64(svptrue_b64(),x_indices));
         const uint64_t y_indices[8]={0,0,2,2,1,1,3,3};
         MVec vy_broadcast=svtbl(svzip1(vy1,vy2),svld1_u64(svptrue_b64(),y_indices));
 
         MVec sxsy_v=vx_broadcast*vy_broadcast;      
 
         // svzero_za();
         svmopa_za64_m(0, p_4, svptrue_b64(), sz_xv, sxsy_v);
         // svmopa_za64_m(1, p_4, svptrue_b64(), sz_yv, sxsy_v);
         // svmopa_za64_m(2, p_4, svptrue_b64(), sz_zv, sxsy_v);
 
         int idx1=newbin[ip1];
         MVec wwx = MVec::Load(p,&xrhocells[8*(idx1)]);
         MVec wwy = MVec::Load(p,&yrhocells[8*(idx1)]);
         MVec wwz = MVec::Load(p,&zrhocells[8*(idx1)]);
         MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,0);
         MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4,0,1);
         MVec s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
         wwx+=(s*wqx[ip1]);
         wwy+=(s*wqy[ip1]);
         wwz+=(s*wqz[ip1]);
         wwx.Store(p,&xrhocells[8*(idx1)]);
         wwy.Store(p,&yrhocells[8*(idx1)]);
         wwz.Store(p,&zrhocells[8*(idx1)]);
 
         int idx2=newbin[ip2];
         wwx = MVec::Load(p,&xrhocells[8*(idx2)]);
         wwy = MVec::Load(p,&yrhocells[8*(idx2)]);
         wwz = MVec::Load(p,&zrhocells[8*(idx2)]);
         wxsxsysz0 = svread_hor_za64_m(vzero,p_4_8,0,2);
         wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,0,3);
         MVec B=svext(wxsxsysz1,wxsxsysz1,4);
         MVec s2=svext(wxsxsysz0,B,4);
         wwx+=(s2*wqx[ip2]);
         wwy+=(s2*wqy[ip2]);
         wwz+=(s2*wqz[ip2]);
         wwx.Store(p,&xrhocells[8*(idx2)]);
         wwy.Store(p,&yrhocells[8*(idx2)]);
         wwz.Store(p,&zrhocells[8*(idx2)]); 
     }
 
 
     if(np_to_deposit%2){
         svzero_za();
 
         int ip1 = np_to_deposit-1;
         MVec sz_v=svdup_n_f64(0);
         MVec sz_1 = svld1(p0,&sz_m[ip1*2]);
         // sz_1*=wqx[ip1];
         sz_v=svsel(p0,sz_1,sz_v);
         // svbool_t p1=svwhilelt_b64(2,4);
         MVec vx1=MVec::Load(p0, &sx_m[ip1*2]);
         MVec vy1=MVec::Load(p0, &sy_m[ip1*2]);
         MVec sxsy_v=svsplice(p0,vx1,vy1);
         svmopa_za64_m(0, p0, p_4, sz_v, sxsy_v);
         int idx1=newbin[ip1];
         MVec wwx = MVec::Load(p,&xrhocells[8*(idx1)]);
         MVec wwy = MVec::Load(p,&yrhocells[8*(idx1)]);
         MVec wwz = MVec::Load(p,&zrhocells[8*(idx1)]);
         MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,0);
         MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4,0,1);
         MVec s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
         wwx+=(s*wqx[ip1]);
         wwy+=(s*wqy[ip1]);
         wwz+=(s*wqz[ip1]);
         wwx.Store(p,&xrhocells[8*(idx1)]);
         wwy.Store(p,&yrhocells[8*(idx1)]);
         wwz.Store(p,&zrhocells[8*(idx1)]);
     }
 
 }
 
 
 template <int depos_order>
 void doDepositionShapeN_pura_sme(const GetParticlePosition<PIdx> &GetPosition,
                                           const amrex::ParticleReal *const wp,
                                           const amrex::ParticleReal *const uxp,
                                           const amrex::ParticleReal *const uyp,
                                           const amrex::ParticleReal *const uzp,
                                           const int *ion_lev,
                                           amrex::FArrayBox &jx_fab,
                                           amrex::FArrayBox &jy_fab,
                                           amrex::FArrayBox &jz_fab,
                                           long np_to_deposit,
                                           amrex::Real relative_time,
                                           const amrex::XDim3 &dinv,
                                           const amrex::XDim3 &xyzmin,
                                           amrex::Dim3 lo,
                                           amrex::Dim3 hi,
                                           amrex::Dim3 len,
                                           amrex::Real q,
                                           std::vector<int> &test,
                                           std::vector<int> &test0,
                                           WarpXParticleContainer::ParticleTileType &ptile, const amrex::Box &box,
                                           [[maybe_unused]] int n_rz_azimuthal_modes)
 {
     // 数据预处理开始======================================================
     // uint64_t total_time[3]={0};
     using namespace std::chrono;
     using namespace amrex::literals;
     // WARPX_PROFILE_REGION("USERDEFINE:doDepositionShapeN_pura_sme_1");
     // WARPX_PROFILE("[1]USERDEFINE:warpxDEPO::doDepositionShapeN_pura_sme_1");
     // WARPX_PROFILE_VAR_NS("doDepositionShapeN_pura_sme:dataPreprocessing", dataPreprocessing);
     // WARPX_PROFILE_VAR_NS("doDepositionShapeN_pura_sme:dataReduce", dataReduce);
     // WARPX_PROFILE_VAR_NS("doDepositionShapeN_pura_sme:sort_3d_sme_kernal", sme_kernal);
     
     amrex::Array4<amrex::Real> const &jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const &jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const &jz_arr = jz_fab.array();
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
     long nx = xjstride;
     long nxy = xkstride;
     long moff[8] = {0, 1, nx, nx + 1, nxy, nxy + 1, nx + nxy, nx + nxy + 1};
 
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x * dinv.y * dinv.z;
 
     const amrex::Real clightsq = 1.0_rt / PhysConst::c / PhysConst::c;
 
     const long numcell = jx_fab.box().numPts();
 
     // amrex::Array4<amrex::Real> const &jx_arr = jx_fab.array();
     // amrex::Array4<amrex::Real> const &jy_arr = jy_fab.array();
     // amrex::Array4<amrex::Real> const &jz_arr = jz_fab.array();
     amrex::IntVect const jx_type = jx_fab.box().type();
     amrex::IntVect const jy_type = jy_fab.box().type();
     amrex::IntVect const jz_type = jz_fab.box().type();
 
     std::vector<amrex::Real> wqx(np_to_deposit, 0.0_rt), wqy(np_to_deposit, 0.0_rt), wqz(np_to_deposit, 0.0_rt);
     // std::vector<int> j_jx(np_to_deposit, 0), j_jy(np_to_deposit, 0), j_jz(np_to_deposit, 0);
     // std::vector<int> k_jx(np_to_deposit, 0), k_jy(np_to_deposit, 0), k_jz(np_to_deposit, 0);
     // std::vector<int> l_jx(np_to_deposit, 0), l_jy(np_to_deposit, 0), l_jz(np_to_deposit, 0);
     // std::vector<std::vector<amrex::Real>> sx_jx(np_to_deposit, std::vector<amrex::Real>(depos_order + 1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sx_jy(np_to_deposit, std::vector<amrex::Real>(depos_order + 1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sx_jz(np_to_deposit, std::vector<amrex::Real>(depos_order + 1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sy_jx(np_to_deposit, std::vector<amrex::Real>(depos_order + 1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sy_jy(np_to_deposit, std::vector<amrex::Real>(depos_order + 1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sy_jz(np_to_deposit, std::vector<amrex::Real>(depos_order + 1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sz_jx(np_to_deposit, std::vector<amrex::Real>(depos_order + 1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sz_jy(np_to_deposit, std::vector<amrex::Real>(depos_order + 1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sz_jz(np_to_deposit, std::vector<amrex::Real>(depos_order + 1, 0.0_rt));
 
     // std::vector<std::vector<amrex::Real>> sx_m(np_to_deposit, std::vector<amrex::Real>(depos_order + 1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sy_m(np_to_deposit, std::vector<amrex::Real>(depos_order + 1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sz_m(np_to_deposit, std::vector<amrex::Real>(depos_order + 1, 0.0_rt));
 
     
     std::vector<amrex::Real> sx_m(2 * np_to_deposit, 0);
     std::vector<amrex::Real> sy_m(2 * np_to_deposit, 0);
     std::vector<amrex::Real> sz_m(2 * np_to_deposit, 0);
 
     std::vector<amrex::Real> xrhocells(8 * numcell, 0.0);
     std::vector<amrex::Real> yrhocells(8 * numcell, 0.0);
     std::vector<amrex::Real> zrhocells(8 * numcell, 0.0);
 
     // std::vector<long> j_m(np_to_deposit, 0);
     // std::vector<long> k_m(np_to_deposit, 0);
     // std::vector<long> l_m(np_to_deposit, 0);
     int j_m=-1;
     int k_m=-1;
     int l_m=-1;
     alignas(64) std::vector<int> newbin(np_to_deposit,-1);
 
     // std::vector<std::vector<amrex::Real>> sz_jx(np_to_deposit, std::vector<amrex::Real>(depos_order + 1, 0.0_rt));
     // std::vector<int> l_jx(np_to_deposit, 0), l_jy(np_to_deposit, 0), l_jz(np_to_deposit, 0);
     for (int ip = 0; ip < np_to_deposit; ip++)
     {
         // for(int ip=ptile.m_num_particles;ip<np_to_deposit;ip++){
         amrex::ParticleReal xp, yp, zp;
         GetPosition(ip, xp, yp, zp);
 
         // --- Get particle quantities
         const amrex::Real gaminv = 1.0_rt / std::sqrt(1.0_rt + uxp[ip] * uxp[ip] * clightsq + uyp[ip] * uyp[ip] * clightsq + uzp[ip] * uzp[ip] * clightsq);
         const amrex::Real vx = uxp[ip] * gaminv;
         const amrex::Real vy = uyp[ip] * gaminv;
         const amrex::Real vz = uzp[ip] * gaminv;
 
         amrex::Real wq = q * wp[ip];
         if (do_ionization)
         {
             wq *= ion_lev[ip];
         }
 
         constexpr int NODE = amrex::IndexType::NODE;
         constexpr int CELL = amrex::IndexType::CELL;
 
         // wqx, wqy wqz are particle current in each direction
         wqx[ip] = wq * invvol * vx;
         wqy[ip] = wq * invvol * vy;
         wqz[ip] = wq * invvol * vz;
 
         // --- Compute shape factors
         Compute_shape_factor<depos_order> const compute_shape_factor;
 
         // const auto j = static_cast<int>(xmid);
         // x direction
         // Get particle position after 1/2 push back in position
         // Keep these double to avoid bug in single precision
 
         const double xmid = ((xp - xyzmin.x) + relative_time * vx) * dinv.x;
 
         double sx_node[depos_order + 1] = {0.};
         double sx_cell[depos_order + 1] = {0.};
         int j_node = 0;
         int j_cell = 0;
         if (jx_type[0] == NODE || jy_type[0] == NODE || jz_type[0] == NODE)
         {
             j_node = compute_shape_factor(sx_node, xmid);
         }
         if (jx_type[0] == CELL || jy_type[0] == CELL || jz_type[0] == CELL)
         {
             j_cell = compute_shape_factor(sx_cell, xmid - 0.5);
         }
 
         // amrex::Real sx_jx[depos_order + 1] = {0._rt};
         // amrex::Real sx_jy[depos_order + 1] = {0._rt};
         // amrex::Real sx_jz[depos_order + 1] = {0._rt};
         for (int ix = 0; ix <= depos_order; ix++)
         {
             // sx_jx[ip][ix] = ((jx_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
             // sx_jy[ip][ix] = ((jy_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
             // sx_jz[ip][ix] = ((jz_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
             sx_m[ip * 2 + ix] = ((jx_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
         }
 
         // int const j_jx = ((jx_type[0] == NODE) ? j_node : j_cell);
         // j_jx[ip] = ((jx_type[0] == NODE) ? j_node : j_cell);
         // j_jy[ip] = ((jy_type[0] == NODE) ? j_node : j_cell);
         // j_jz[ip] = ((jz_type[0] == NODE) ? j_node : j_cell);
         // j_m[ip] = ((jz_type[0] == NODE) ? j_node : j_cell);
         j_m = ((jz_type[0] == NODE) ? j_node : j_cell);
 
         // y direction
         // Keep these double to avoid bug in single precision
         const double ymid = ((yp - xyzmin.y) + relative_time * vy) * dinv.y;
         double sy_node[depos_order + 1] = {0.};
         double sy_cell[depos_order + 1] = {0.};
         int k_node = 0;
         int k_cell = 0;
         if (jx_type[1] == NODE || jy_type[1] == NODE || jz_type[1] == NODE)
         {
             k_node = compute_shape_factor(sy_node, ymid);
         }
         if (jx_type[1] == CELL || jy_type[1] == CELL || jz_type[1] == CELL)
         {
             k_cell = compute_shape_factor(sy_cell, ymid - 0.5);
         }
         // amrex::Real sy_jx[depos_order + 1] = {0._rt};
         // amrex::Real sy_jy[depos_order + 1] = {0._rt};
         // amrex::Real sy_jz[depos_order + 1] = {0._rt};
         for (int iy = 0; iy <= depos_order; iy++)
         {
             // sy_jx[ip][iy] = ((jx_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
             // sy_jy[ip][iy] = ((jy_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
             // sy_jz[ip][iy] = ((jz_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
             sy_m[ip * 2 + iy] = ((jx_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
         }
         // k_jx[ip] = ((jx_type[1] == NODE) ? k_node : k_cell);
         // k_jy[ip] = ((jy_type[1] == NODE) ? k_node : k_cell);
         // k_jz[ip] = ((jz_type[1] == NODE) ? k_node : k_cell);
         // k_m[ip] = ((jx_type[1] == NODE) ? k_node : k_cell);
         k_m = ((jx_type[1] == NODE) ? k_node : k_cell);
 
         // z direction
         // Keep these double to avoid bug in single precision
         constexpr int zdir = WARPX_ZINDEX;
         const double zmid = ((zp - xyzmin.z) + relative_time * vz) * dinv.z;
         double sz_node[depos_order + 1] = {0.};
         double sz_cell[depos_order + 1] = {0.};
         int l_node = 0;
         int l_cell = 0;
         if (jx_type[zdir] == NODE || jy_type[zdir] == NODE || jz_type[zdir] == NODE)
         {
             l_node = compute_shape_factor(sz_node, zmid);
         }
         if (jx_type[zdir] == CELL || jy_type[zdir] == CELL || jz_type[zdir] == CELL)
         {
             l_cell = compute_shape_factor(sz_cell, zmid - 0.5);
         }
         // amrex::Real sz_jx[depos_order + 1] = {0._rt};
         // amrex::Real sz_jy[depos_order + 1] = {0._rt};
         // amrex::Real sz_jz[depos_order + 1] = {0._rt};
         for (int iz = 0; iz <= depos_order; iz++)
         {
             // sz_jx[ip][iz] = ((jx_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
             // sz_jy[ip][iz] = ((jy_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
             // sz_jz[ip][iz] = ((jz_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
             sz_m[ip * 2 + iz] = ((jx_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
         }
         // l_jx[ip] = ((jx_type[zdir] == NODE) ? l_node : l_cell);
         // l_jy[ip] = ((jy_type[zdir] == NODE) ? l_node : l_cell);
         // l_jz[ip] = ((jz_type[zdir] == NODE) ? l_node : l_cell);
         // l_m[ip] = ((jz_type[zdir] == NODE) ? l_node : l_cell);
         l_m = ((jz_type[zdir] == NODE) ? l_node : l_cell);
         newbin[ip]=j_m+k_m*xjstride+l_m*xkstride;
     }
 
     amrex::IntVect box_shape = box.length();
 
     int nx_box = box_shape[0];
     int ny_box = box_shape[1];
     int nxny_box = nx_box * ny_box;
 
     // WARPX_PROFILE_VAR_START(sme_kernal);
     // TODO 把你的sme函数调用传递的数据修改的可以利用上面的数组
     sme_kernal_2<1>(np_to_deposit,  // xbinList不需要
                     newbin,
                     xrhocells, yrhocells, zrhocells,
                     sx_m, sy_m, sz_m,
                     wqx, wqy, wqz);
     // WARPX_PROFILE_VAR_STOP(sme_kernal);
     // WARPX_PROFILE_VAR_STOP(dataPreprocessing);
 
 
     // 数据预处理结束=======================================================
 
     // this can be SME
     // WARPX_PROFILE_VAR_START(dataReduce);
     int errcount = 0;
     for (int iz = 0; iz <= len.z; ++iz)
     {
         for (int iy = 0; iy <= len.y; ++iy)
         {
             // scalar mode
             for(int ix = 0; ix <= len.x; ix++){
                 
                 long jxoffset = ix + iy * xjstride + iz * xkstride;
                 long xoffset = 8*jxoffset;
                 // long xoffset = 8*(ix + iy * xjstride + iz * xkstride);
                
                 jx_arr.p[jxoffset+moff[0]]+=xrhocells[0+xoffset];
                 jx_arr.p[jxoffset+moff[1]]+=xrhocells[1+xoffset];
                 jx_arr.p[jxoffset+moff[2]]+=xrhocells[2+xoffset];
                 jx_arr.p[jxoffset+moff[3]]+=xrhocells[3+xoffset];
                 jx_arr.p[jxoffset+moff[4]]+=xrhocells[4+xoffset];
                 jx_arr.p[jxoffset+moff[5]]+=xrhocells[5+xoffset];
                 jx_arr.p[jxoffset+moff[6]]+=xrhocells[6+xoffset];
                 jx_arr.p[jxoffset+moff[7]]+=xrhocells[7+xoffset];
                 
             // }
 
             // for(int ix = 0; ix <= len.x; ix++) {
                 long jyoffset = jxoffset;
                 long yoffset = xoffset;
                 // long jyoffset = ix + iy * yjstride + iz * ykstride;
                 // long yoffset = 8*(ix + iy * yjstride + iz * ykstride);
                 jy_arr.p[jyoffset+moff[0]]+=yrhocells[0+yoffset];
                 jy_arr.p[jyoffset+moff[1]]+=yrhocells[1+yoffset];
                 jy_arr.p[jyoffset+moff[2]]+=yrhocells[2+yoffset];
                 jy_arr.p[jyoffset+moff[3]]+=yrhocells[3+yoffset];
                 jy_arr.p[jyoffset+moff[4]]+=yrhocells[4+yoffset];
                 jy_arr.p[jyoffset+moff[5]]+=yrhocells[5+yoffset];
                 jy_arr.p[jyoffset+moff[6]]+=yrhocells[6+yoffset];
                 jy_arr.p[jyoffset+moff[7]]+=yrhocells[7+yoffset];
             // }
 
 
             // for(int ix = 0; ix <= len.x; ix++) {
                 long jzoffset = jxoffset;
                 long zoffset = xoffset;
                 // long jzoffset = ix + iy * zjstride + iz * zkstride;
                 // long zoffset = 8*(ix + iy * zjstride + iz * zkstride);
                 jz_arr.p[jzoffset+moff[0]]+=zrhocells[0+zoffset];
                 jz_arr.p[jzoffset+moff[1]]+=zrhocells[1+zoffset];
                 jz_arr.p[jzoffset+moff[2]]+=zrhocells[2+zoffset];
                 jz_arr.p[jzoffset+moff[3]]+=zrhocells[3+zoffset];
                 jz_arr.p[jzoffset+moff[4]]+=zrhocells[4+zoffset];
                 jz_arr.p[jzoffset+moff[5]]+=zrhocells[5+zoffset];
                 jz_arr.p[jzoffset+moff[6]]+=zrhocells[6+zoffset];
                 jz_arr.p[jzoffset+moff[7]]+=zrhocells[7+zoffset];
             }
 
         }
     }
     // WARPX_PROFILE_VAR_STOP(dataReduce);
 
     // auto total_stop=high_resolution_clock::now();
 
 }
 
 template <int depos_order>
 void doDepositionShapeN_org_sp(const GetParticlePosition<PIdx> &GetPosition,
                                           const amrex::ParticleReal *const wp,
                                           const amrex::ParticleReal *const uxp,
                                           const amrex::ParticleReal *const uyp,
                                           const amrex::ParticleReal *const uzp,
                                           const int *ion_lev,
                                           amrex::FArrayBox &jx_fab,
                                           amrex::FArrayBox &jy_fab,
                                           amrex::FArrayBox &jz_fab,
                                           long np_to_deposit,
                                           amrex::Real relative_time,
                                           const amrex::XDim3 &dinv,
                                           const amrex::XDim3 &xyzmin,
                                           amrex::Dim3 lo,
                                           amrex::Dim3 hi,
                                           amrex::Dim3 len,
                                           amrex::Real q,
                                           std::vector<int> &test,
                                           std::vector<int> &test0,
                                           WarpXParticleContainer::ParticleTileType &ptile, const amrex::Box &box,
                                           [[maybe_unused]] int n_rz_azimuthal_modes)
 {
     // 数据预处理开始======================================================
     // uint64_t total_time[3]={0};
     using namespace std::chrono;
     using namespace amrex::literals;
     // WARPX_PROFILE_REGION("USERDEFINE:doDepositionShapeN_pura_sme_1");
     // WARPX_PROFILE("[1]USERDEFINE:warpxDEPO::doDepositionShapeN_pura_sme_1");
     // WARPX_PROFILE_VAR_NS("doDepositionShapeN_pura_sme:dataPreprocessing", dataPreprocessing);
     // WARPX_PROFILE_VAR_NS("doDepositionShapeN_pura_sme:dataReduce", dataReduce);
     // WARPX_PROFILE_VAR_NS("doDepositionShapeN_pura_sme:sort_3d_sme_kernal", sme_kernal);
     WARPX_PROFILE("[0] USER org()");
     WARPX_PROFILE_VAR_NS("[1] USER org_pre", bl_sort);
     WARPX_PROFILE_VAR_NS("[2] USER org_cmp&sav", bl_sme);
     // WARPX_PROFILE_VAR_NS("[3] USER org_post", bl_post);
     
     // WARPX_PROFILE_VAR_START(dataPreprocessing);
     WARPX_PROFILE_VAR_START(bl_sort);
 
     // WARPX_PROFILE_VAR_START(dataPreprocessing);
 
     amrex::Array4<amrex::Real> const &jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const &jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const &jz_arr = jz_fab.array();
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
     long nx = xjstride;
     long nxy = xkstride;
     long moff[8] = {0, 1, nx, nx + 1, nxy, nxy + 1, nx + nxy, nx + nxy + 1};
 
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x * dinv.y * dinv.z;
 
     const amrex::Real clightsq = 1.0_rt / PhysConst::c / PhysConst::c;
 
     const long numcell = jx_fab.box().numPts();
 
     amrex::IntVect const jx_type = jx_fab.box().type();
     amrex::IntVect const jy_type = jy_fab.box().type();
     amrex::IntVect const jz_type = jz_fab.box().type();
 
     std::vector<amrex::Real> wqx(np_to_deposit, 0.0_rt), wqy(np_to_deposit, 0.0_rt), wqz(np_to_deposit, 0.0_rt);
     
     std::vector<amrex::Real> sx_m(2 * np_to_deposit, 0);
     std::vector<amrex::Real> sy_m(2 * np_to_deposit, 0);
     std::vector<amrex::Real> sz_m(2 * np_to_deposit, 0);
 
     int j_m=-1;
     int k_m=-1;
     int l_m=-1;
     alignas(64) std::vector<int> newbin(np_to_deposit,-1);
 
     // std::vector<std::vector<amrex::Real>> sz_jx(np_to_deposit, std::vector<amrex::Real>(depos_order + 1, 0.0_rt));
     // std::vector<int> l_jx(np_to_deposit, 0), l_jy(np_to_deposit, 0), l_jz(np_to_deposit, 0);
     for (int ip = 0; ip < np_to_deposit; ip++)
     {
         // for(int ip=ptile.m_num_particles;ip<np_to_deposit;ip++){
         amrex::ParticleReal xp, yp, zp;
         GetPosition(ip, xp, yp, zp);
 
         // --- Get particle quantities
         const amrex::Real gaminv = 1.0_rt / std::sqrt(1.0_rt + uxp[ip] * uxp[ip] * clightsq + uyp[ip] * uyp[ip] * clightsq + uzp[ip] * uzp[ip] * clightsq);
         const amrex::Real vx = uxp[ip] * gaminv;
         const amrex::Real vy = uyp[ip] * gaminv;
         const amrex::Real vz = uzp[ip] * gaminv;
 
         amrex::Real wq = q * wp[ip];
         if (do_ionization)
         {
             wq *= ion_lev[ip];
         }
 
         constexpr int NODE = amrex::IndexType::NODE;
         constexpr int CELL = amrex::IndexType::CELL;
 
         // wqx, wqy wqz are particle current in each direction
         wqx[ip] = wq * invvol * vx;
         wqy[ip] = wq * invvol * vy;
         wqz[ip] = wq * invvol * vz;
 
         // --- Compute shape factors
         Compute_shape_factor<depos_order> const compute_shape_factor;
 
         // const auto j = static_cast<int>(xmid);
         // x direction
         // Get particle position after 1/2 push back in position
         // Keep these double to avoid bug in single precision
 
         const double xmid = ((xp - xyzmin.x) + relative_time * vx) * dinv.x;
 
         double sx_node[depos_order + 1] = {0.};
         double sx_cell[depos_order + 1] = {0.};
         int j_node = 0;
         int j_cell = 0;
         if (jx_type[0] == NODE || jy_type[0] == NODE || jz_type[0] == NODE)
         {
             j_node = compute_shape_factor(sx_node, xmid);
         }
         if (jx_type[0] == CELL || jy_type[0] == CELL || jz_type[0] == CELL)
         {
             j_cell = compute_shape_factor(sx_cell, xmid - 0.5);
         }
 
         // amrex::Real sx_jx[depos_order + 1] = {0._rt};
         // amrex::Real sx_jy[depos_order + 1] = {0._rt};
         // amrex::Real sx_jz[depos_order + 1] = {0._rt};
         for (int ix = 0; ix <= depos_order; ix++)
         {
             // sx_jx[ip][ix] = ((jx_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
             // sx_jy[ip][ix] = ((jy_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
             // sx_jz[ip][ix] = ((jz_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
             sx_m[ip * 2 + ix] = ((jx_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
         }
 
         // int const j_jx = ((jx_type[0] == NODE) ? j_node : j_cell);
         // j_jx[ip] = ((jx_type[0] == NODE) ? j_node : j_cell);
         // j_jy[ip] = ((jy_type[0] == NODE) ? j_node : j_cell);
         // j_jz[ip] = ((jz_type[0] == NODE) ? j_node : j_cell);
         // j_m[ip] = ((jz_type[0] == NODE) ? j_node : j_cell);
         j_m = ((jz_type[0] == NODE) ? j_node : j_cell);
 
         // y direction
         // Keep these double to avoid bug in single precision
         const double ymid = ((yp - xyzmin.y) + relative_time * vy) * dinv.y;
         double sy_node[depos_order + 1] = {0.};
         double sy_cell[depos_order + 1] = {0.};
         int k_node = 0;
         int k_cell = 0;
         if (jx_type[1] == NODE || jy_type[1] == NODE || jz_type[1] == NODE)
         {
             k_node = compute_shape_factor(sy_node, ymid);
         }
         if (jx_type[1] == CELL || jy_type[1] == CELL || jz_type[1] == CELL)
         {
             k_cell = compute_shape_factor(sy_cell, ymid - 0.5);
         }
         // amrex::Real sy_jx[depos_order + 1] = {0._rt};
         // amrex::Real sy_jy[depos_order + 1] = {0._rt};
         // amrex::Real sy_jz[depos_order + 1] = {0._rt};
         for (int iy = 0; iy <= depos_order; iy++)
         {
             // sy_jx[ip][iy] = ((jx_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
             // sy_jy[ip][iy] = ((jy_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
             // sy_jz[ip][iy] = ((jz_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
             sy_m[ip * 2 + iy] = ((jx_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
         }
         // k_jx[ip] = ((jx_type[1] == NODE) ? k_node : k_cell);
         // k_jy[ip] = ((jy_type[1] == NODE) ? k_node : k_cell);
         // k_jz[ip] = ((jz_type[1] == NODE) ? k_node : k_cell);
         // k_m[ip] = ((jx_type[1] == NODE) ? k_node : k_cell);
         k_m = ((jx_type[1] == NODE) ? k_node : k_cell);
 
         // z direction
         // Keep these double to avoid bug in single precision
         constexpr int zdir = WARPX_ZINDEX;
         const double zmid = ((zp - xyzmin.z) + relative_time * vz) * dinv.z;
         double sz_node[depos_order + 1] = {0.};
         double sz_cell[depos_order + 1] = {0.};
         int l_node = 0;
         int l_cell = 0;
         if (jx_type[zdir] == NODE || jy_type[zdir] == NODE || jz_type[zdir] == NODE)
         {
             l_node = compute_shape_factor(sz_node, zmid);
         }
         if (jx_type[zdir] == CELL || jy_type[zdir] == CELL || jz_type[zdir] == CELL)
         {
             l_cell = compute_shape_factor(sz_cell, zmid - 0.5);
         }
         // amrex::Real sz_jx[depos_order + 1] = {0._rt};
         // amrex::Real sz_jy[depos_order + 1] = {0._rt};
         // amrex::Real sz_jz[depos_order + 1] = {0._rt};
         for (int iz = 0; iz <= depos_order; iz++)
         {
             // sz_jx[ip][iz] = ((jx_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
             // sz_jy[ip][iz] = ((jy_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
             // sz_jz[ip][iz] = ((jz_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
             sz_m[ip * 2 + iz] = ((jx_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
         }
         // l_jx[ip] = ((jx_type[zdir] == NODE) ? l_node : l_cell);
         // l_jy[ip] = ((jy_type[zdir] == NODE) ? l_node : l_cell);
         // l_jz[ip] = ((jz_type[zdir] == NODE) ? l_node : l_cell);
         // l_m[ip] = ((jz_type[zdir] == NODE) ? l_node : l_cell);
         l_m = ((jz_type[zdir] == NODE) ? l_node : l_cell);
         newbin[ip]=j_m+k_m*xjstride+l_m*xkstride;
     }
     WARPX_PROFILE_VAR_STOP(bl_sort);
     WARPX_PROFILE_VAR_START(bl_sme);
 
     amrex::IntVect box_shape = box.length();
 
     int nx_box = box_shape[0];
     int ny_box = box_shape[1];
     int nxny_box = nx_box * ny_box;
     std::vector<double> jx_t(numcell,0),jy_t(numcell,0),jz_t(numcell,0);
     for (int ip = 0; ip < np_to_deposit; ip++){
         for (int iz=0; iz<=depos_order; iz++){
             for (int iy=0; iy<=depos_order; iy++){
                 for (int ix=0; ix<=depos_order; ix++){
                     double sxsysz= sx_m[ip * 2 + ix]*sy_m[ip * 2 + iy]*sz_m[ip * 2 + iz];
                     long idx = ix + iy * xjstride + iz * xkstride;
                     // jx_t[idx]+=sxsysz*wqx[ip];
                     // jy_t[idx]+=sxsysz*wqy[ip];
                     // jz_t[idx]+=sxsysz*wqz[ip];
                     amrex::Gpu::Atomic::AddNoRet( &jx_arr.p[idx],sxsysz*wqx[ip]);
                     amrex::Gpu::Atomic::AddNoRet( &jy_arr.p[idx],sxsysz*wqy[ip]);
                     amrex::Gpu::Atomic::AddNoRet( &jz_arr.p[idx],sxsysz*wqz[ip]);
                     // amrex::Gpu::Atomic::AddNoRet(
                     //     &jx_arr(lo.x+j_jx+ix, lo.y+k_jx+iy, lo.z+l_jx+iz),
                     //     sx_jx[ix]*sy_jx[iy]*sz_jx[iz]*wqx);
                     // amrex::Gpu::Atomic::AddNoRet(
                     //     &jy_arr(lo.x+j_jy+ix, lo.y+k_jy+iy, lo.z+l_jy+iz),
                     //     sx_jy[ix]*sy_jy[iy]*sz_jy[iz]*wqy);
                     // amrex::Gpu::Atomic::AddNoRet(
                     //     &jz_arr(lo.x+j_jz+ix, lo.y+k_jz+iy, lo.z+l_jz+iz),
                     //     sx_jz[ix]*sy_jz[iy]*sz_jz[iz]*wqz);
                     }
                 }
             }
         }
         WARPX_PROFILE_VAR_STOP(bl_sme);
     // WARPX_PROFILE_VAR_STOP(dataReduce);
 
     // auto total_stop=high_resolution_clock::now();
 
 }
 
 
 template <int depos_order>
 void doDepositionShapeN_3d_sme_bak (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Dim3 hi,
                          amrex::Dim3 len,
                          amrex::Real q,
                          std::vector<long>& test,
                          std::vector<double>& test0,
                          ParticleTileType& ptile, const amrex::Box& box,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     WARPX_PROFILE("doDepositionShapeN_3d_sme()");
     // uint64_t total_time[3]={0};
     using namespace std::chrono;
     using namespace amrex::literals;
     double total_time=0;
     // auto total_start=high_resolution_clock::now();
     uint64_t precompute=0;
     uint64_t cale_time=0;
     uint64_t sort_time=0;
         uint64_t count_time=0;
         uint64_t presum_time=0;
         uint64_t binlist_time=0;
     uint64_t reduce_time=0;
     uint64_t svetime[3]={0};
     uint64_t branch_time=0;
     WARPX_PROFILE_VAR_NS("doDepositionShapeN_3d_sme:applyPendingMoves", bl_sort);
     
     // Whether ion_lev is a null pointer (do_ionization=0) or a real pointer
     // (do_ionization=1)
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z;
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
     amrex::IntVect const jx_type = jx_fab.box().type();
     amrex::IntVect const jy_type = jy_fab.box().type();
     amrex::IntVect const jz_type = jz_fab.box().type();
     
 
     std::vector<amrex::Real> wqx(np_to_deposit,0.0_rt), wqy(np_to_deposit,0.0_rt), wqz(np_to_deposit,0.0_rt);
     // std::vector<int> j_jx(np_to_deposit,0), j_jy(np_to_deposit,0), j_jz(np_to_deposit,0);
     // std::vector<int> k_jx(np_to_deposit,0), k_jy(np_to_deposit,0), k_jz(np_to_deposit,0);
     // std::vector<int> l_jx(np_to_deposit,0), l_jy(np_to_deposit,0), l_jz(np_to_deposit,0);
     // std::vector<std::vector<amrex::Real>> sx_jx(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sx_jy(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sx_jz(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sy_jx(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sy_jy(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sy_jz(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sz_jx(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sz_jy(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
     // std::vector<std::vector<amrex::Real>> sz_jz(np_to_deposit, std::vector<amrex::Real>(depos_order+1, 0.0_rt));
 
 
     // const long numcell = jx_fab.box().numPts();
     // ParticleTileType& ptile = ParticlesAt(0, pti);  // <-- 正确获取粒子tile
     auto& local_index = ptile.m_local_index;
     auto& bin_offsets = ptile.m_bin_offsets;
     const long numcell = ptile.m_bin_offsets.size()-1;
     // std::cout << ptile.idd << "deposit particle m_local_index shape: " << local_index.size() << std::endl;
     // std::cout << ptile.idd << "deposit particle m_bin_offsets shape: " << bin_offsets.size() << std::endl;
     int reserve_size=np_to_deposit/10;
     std::vector<std::vector<int>> newBins(np_to_deposit);
     for (int i = 0; i < numcell; ++i) {
         newBins[i].reserve(reserve_size);
     }
     
     // 存储所有发生bin变化的粒子信息
     std::vector<ParticleMove> m_pending_moves;
 
         
     // int bx = box.smallEnd(0), by = box.smallEnd(1), bz = box.smallEnd(2);
     int bx = 2, by = 2, bz = 2;
     // int nx = box.bigEnd(0) + 1;
     // int ny = box.bigEnd(1) + 1;
     amrex::IntVect box_shape = box.length();
     // amrex::Print() << "Box shape: " << box_shape << std::endl;
     int nx = box_shape[0];
     int ny = box_shape[1];
     int nxny = nx*ny;
     // int numcell = nx*ny*nz;
     // const int binend = bin_offsets[numcell-1];
     // int removeip=0;    
     auto& bin_length = ptile.m_bin_lengths;
     // printf("numcell %d\n", numcell);
     // [1] SORT TIME
     // const std::vector<amrex::Real> vx(np_to_deposit,0.0_rt),vy(np_to_deposit,0.0_rt),vz(np_to_deposit,0.0_rt);
     // const std::vector<amrex::Real> gaminv(np_to_deposit,0.0_rt);
     std::vector<double> xmid(np_to_deposit,0.0),ymid(np_to_deposit,0.0),zmid(np_to_deposit,0.0);
     // deal with newly add particles
     for(int ip=ptile.m_num_particles;ip<np_to_deposit;ip++){
         amrex::ParticleReal xp, yp, zp;
         GetPosition(ip, xp, yp, zp);
 
         // --- Get particle quantities
         const amrex::Real gaminv = 1.0_rt/std::sqrt(1.0_rt + uxp[ip]*uxp[ip]*clightsq
                                                     + uyp[ip]*uyp[ip]*clightsq
                                                     + uzp[ip]*uzp[ip]*clightsq);
         const amrex::Real vx = uxp[ip]*gaminv;
         const amrex::Real vy = uyp[ip]*gaminv;
         const amrex::Real vz = uzp[ip]*gaminv;
 
         amrex::Real wq = q*wp[ip];
         if (do_ionization){
             wq *= ion_lev[ip];
         }
 
         
         // wqx, wqy wqz are particle current in each direction
         wqx[ip] = wq*invvol*vx;
         wqy[ip] = wq*invvol*vy;
         wqz[ip] = wq*invvol*vz;
 
         // const auto xmid_v = GetCellIndices(xp, yp, zp, dinv, xyzmin);
         xmid[ip] = ((xp - xyzmin.x) + relative_time*vx)*dinv.x;
         ymid[ip] = ((yp - xyzmin.y) + relative_time*vy)*dinv.y;
         zmid[ip] = ((zp - xyzmin.z) + relative_time*vz)*dinv.z;
         // printf("ip %d xmid %f \n",ip,xmid_v[ip]);
 
         // const auto cell = GetCellIndices(xp, yp, zp, dinv, xyzmin);
         int i = static_cast<int>(xmid[ip]);
         const int j = static_cast<int>(ymid[ip]);
         const int k = static_cast<int>(zmid[ip]);
 
         // if(j_jx[ip]==3&&k_jx[ip]==3&&l_jx[ip]==3){
         // if(i==3){
         //     i-=1;
         //     xmid[ip]-=1;
         //     // printf("old_bin %d: i %d j %d k %d\n",old_bin-1,i,j,k);
         // }
 
         const int new_bin = (i-bx) + (j-by)*nx + (k-bz)*nxny;
         m_pending_moves.push_back({ip, new_bin});
     }
     // dea; with org particles 
     // also delete particels outside this tile
     for (int old_bin = 1; old_bin <= numcell; ++old_bin) {
         if (bin_length[old_bin-1] == 0) continue;
         const int start = bin_offsets[old_bin-1];
         const int end   = bin_offsets[old_bin];
         // printf("st %d en %d len %d \n",start,end,bin_length[old_bin-1]);
         // #pragma omp simd
         for (int idx = start; idx < end; ++idx) {
             const int ip = local_index[idx];
             if (ip == INVALID_PARTICLE_ID) continue;
 
             // 针对“假”粒子（>np_to_deposit）仍保持原逻辑
             if (ip >= np_to_deposit) {
                 ptile.m_local_index[idx] = INVALID_PARTICLE_ID;
                 ptile.m_bin_lengths[old_bin-1]--;
                 ptile.m_num_empty_slots++;
                 ptile.m_num_particles--;
                 continue;
             }
             amrex::ParticleReal xp, yp, zp;
             GetPosition(ip, xp, yp, zp);
 
             // --- Get particle quantities
             const amrex::Real gaminv = 1.0_rt/std::sqrt(1.0_rt + uxp[ip]*uxp[ip]*clightsq
                                                         + uyp[ip]*uyp[ip]*clightsq
                                                         + uzp[ip]*uzp[ip]*clightsq);
             const amrex::Real vx = uxp[ip]*gaminv;
             const amrex::Real vy = uyp[ip]*gaminv;
             const amrex::Real vz = uzp[ip]*gaminv;
 
             amrex::Real wq = q*wp[ip];
             if (do_ionization){
                 wq *= ion_lev[ip];
             }
 
             
             // wqx, wqy wqz are particle current in each direction
             wqx[ip] = wq*invvol*vx;
             wqy[ip] = wq*invvol*vy;
             wqz[ip] = wq*invvol*vz;
 
             // const auto xmid_v = GetCellIndices(xp, yp, zp, dinv, xyzmin);
             xmid[ip] = ((xp - xyzmin.x) + relative_time*vx)*dinv.x;
             ymid[ip] = ((yp - xyzmin.y) + relative_time*vy)*dinv.y;
             zmid[ip] = ((zp - xyzmin.z) + relative_time*vz)*dinv.z;
             // printf("ip %d xmid %f \n",ip,xmid_v[ip]);
 
             // const auto cell = GetCellIndices(xp, yp, zp, dinv, xyzmin);
             int i = static_cast<int>(xmid[ip]);
             const int j = static_cast<int>(ymid[ip]);
             const int k = static_cast<int>(zmid[ip]);
 
             // if(j_jx[ip]==3&&k_jx[ip]==3&&l_jx[ip]==3){
             // if(i==3){
             //     i-=1;
             //     xmid[ip]-=1;
             //     // printf("old_bin %d: i %d j %d k %d\n",old_bin-1,i,j,k);
             // }
 
             const int new_bin = (i-bx) + (j-by)*nx + (k-bz)*nxny;
             const int actual_old_bin = old_bin - 1;
 
             if (new_bin != actual_old_bin) {
                 // printf("new_bin %d actual_old_bin %d \n",new_bin,actual_old_bin);
                 // printf("ptile.m_bin_lengths[actual_old_bin] %d\n",ptile.m_bin_lengths[actual_old_bin]);
                 m_pending_moves.push_back({ip, new_bin});
                 ptile.m_local_index[idx] = INVALID_PARTICLE_ID;
                 ptile.m_bin_lengths[actual_old_bin]--;
                 ptile.m_num_empty_slots++;
                 ptile.m_num_particles--;
             }
 
         }
     }
 
     // printf("sort!!\n");
     WARPX_PROFILE_VAR_START(bl_sort);
     applyPendingMoves(numcell, ptile, m_pending_moves);
     WARPX_PROFILE_VAR_STOP(bl_sort);
 
     // constexpr int nshapes = depos_order + 1;
     // // constexpr int nshapes = 2;
     // int vl=svcntd();
 
     // const amrex::ParticleReal* mx = GetPosition.m_x;
     // const amrex::ParticleReal* my = GetPosition.m_y;
     // const amrex::ParticleReal* mz = GetPosition.m_z;
 
     auto compute_shape_factor_v1 = [](double* sx, Vec xmid, svbool_t p) {
         const svuint64_t sx_index = svindex_u64(0, 2);
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         svst1_scatter_index(p,&sx[0],sx_index,sx0);
         svst1_scatter_index(p,&sx[1],sx_index,sx1);
         return i_newv;
     };
 
     auto compute_shape_factor_sme = [](double* sx, Vec xmid, svbool_t p, uint64_t count) {
         const svuint64_t sx_index = svindex_u64(0, 2);
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         sx0=svcompact_f64(p,sx0);
         sx1=svcompact_f64(p,sx1);
         svbool_t pp=svwhilelt_b64(uint64_t(0),count);
         svst1_scatter_index(pp,&sx[0],sx_index,sx0);
         svst1_scatter_index(pp,&sx[1],sx_index,sx1);
     };
 
     constexpr int NODE = amrex::IndexType::NODE;
     constexpr int CELL = amrex::IndexType::CELL;
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
     std::vector<amrex::Real> xrhocells(8*numcell, 0.0);
     std::vector<amrex::Real> yrhocells(8*numcell, 0.0);
     std::vector<amrex::Real> zrhocells(8*numcell, 0.0);
 
     constexpr int nshapes = depos_order + 1;
     int vl=svcntd();
 
     for (int old_bin = 1; old_bin <= numcell; ++old_bin) {
         if (bin_length[old_bin-1] == 0) continue;
         int start = bin_offsets[old_bin-1];
         int end = bin_offsets[old_bin];
         // int end = start+ bin_length[old_bin-1];
         // int idx = start;
         std::vector<amrex::Real> sx_m(bin_length[old_bin-1]*nshapes, 0.);
         std::vector<amrex::Real> sy_m(bin_length[old_bin-1]*nshapes, 0.);
         std::vector<amrex::Real> sz_m(bin_length[old_bin-1]*nshapes, 0.);
 
         int ipp=0;
         for (int idx = start; idx < end; idx+=vl) {
             svbool_t p=svwhilelt_b64(start,end);
             // long* ip_vp=long(&local_index[idx]);
             // for(int i=0;i<vl;i++){
             //     printf("local_index[%d]: %d\n",i+idx,local_index[idx+i]);
             // }
             intVec ip_v=svld1sw_s64(p,&local_index[idx]);
             svbool_t pp = svcmpne_n_s64(p, ip_v, INVALID_PARTICLE_ID);
             uint64_t count_ip=svcntp_b64(pp,svptrue_b64());
             // long test[8];
             // svst1_s64(pp,&test[0],ip_v);
             // for(uint64_t i=0;i<8;i++){
             //     printf("test[%d]: %d\n",i,test[i]);
             // }
             Vec xmid_v=svld1_gather_s64index_f64(pp,&xmid[0], ip_v);
             Vec ymid_v=svld1_gather_s64index_f64(pp,&ymid[0], ip_v);
             Vec zmid_v=svld1_gather_s64index_f64(pp,&zmid[0], ip_v);
             compute_shape_factor_sme( &sx_m[nshapes*ipp], xmid_v, pp,count_ip);
             compute_shape_factor_sme( &sy_m[nshapes*ipp], ymid_v, pp,count_ip);
             compute_shape_factor_sme( &sz_m[nshapes*ipp], zmid_v, pp,count_ip);
 
             ipp+=count_ip;   
         }
  
         sort_3d_sme_kernal<1>(numcell,local_index,
             bin_length[old_bin-1],start,old_bin,
             xrhocells,yrhocells,zrhocells,
             sx_m,sy_m,sz_m,
             wqx,wqy,wqz);
     }
     int errcount=0;
     // one roll x
     uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
     uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
     uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
     // long nx=xjstride;
     // long nxy=xkstride;
     int moff[8] = {0, 1, nx, nx+1, nxny, nxny+1, nx+nxny, nx+nxny+1};
     svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
     svbool_t px = svcmpeq_n_u64(svptrue_b64(), rmx_v, 0);
     svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
     svbool_t py = svcmpeq_n_u64(svptrue_b64(), rmy_v, 0);
     svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
     svbool_t pz = svcmpeq_n_u64(svptrue_b64(), rmz_v, 0);
     for (int iz = 0; iz <= len.z; ++iz) {
         for (int iy = 0; iy <= len.y; ++iy) {       
             for (int ix = 0; ix <= len.x; ix+=vl) {
                 // svetime[0]=rdtscv();
 
                 // vector
                 svbool_t p=svwhilele_b64(ix,len.x);
                 // long j = lo.x + ix;
                 // long k = lo.y + iy;
                 // long l = lo.z + iz;
                 // x
                 // uint64_t irhox = 8*(ix + iy * xjstride + iz * xkstride);
                 // svuint64_t rhox_index = svindex_u64(0, 8ULL);
                 // long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                 svuint64_t rho_index = svindex_u64(0ULL, 8ULL);
                 long xoffset=ix + iy * xjstride + iz * xkstride;
                 long jxoffset=xoffset;
                 long irhox=8*xoffset;
                 Vec jx0=Vec::Load(p,&jx_arr.p[jxoffset+moff[0]]);
                 svfloat64_t rhox0=svld1_gather_u64index_f64(p,&xrhocells[0+irhox],rho_index);
                 jx0+=rhox0;
                 jx0.Store(p,&jx_arr.p[jxoffset+moff[0]]);
 
                 Vec jx1=Vec::Load(p,&jx_arr.p[jxoffset+moff[1]]);
                 svfloat64_t rhox1=svld1_gather_u64index_f64(p,&xrhocells[1+irhox],rho_index);
                 jx1+=rhox1;
                 jx1.Store(p,&jx_arr.p[jxoffset+moff[1]]);
 
                 Vec jx2=Vec::Load(p,&jx_arr.p[jxoffset+moff[2]]);
                 svfloat64_t rhox2=svld1_gather_u64index_f64(p,&xrhocells[2+irhox],rho_index);
                 jx2+=rhox2;
                 jx2.Store(p,&jx_arr.p[jxoffset+moff[2]]);
 
                 Vec jx3=Vec::Load(p,&jx_arr.p[jxoffset+moff[3]]);
                 svfloat64_t rhox3=svld1_gather_u64index_f64(p,&xrhocells[3+irhox],rho_index);
                 jx3+=rhox3;
                 jx3.Store(p,&jx_arr.p[jxoffset+moff[3]]);
 
                 Vec jx4=Vec::Load(p,&jx_arr.p[jxoffset+moff[4]]);
                 svfloat64_t rhox4=svld1_gather_u64index_f64(p,&xrhocells[4+irhox],rho_index);
                 jx4+=rhox4;
                 jx4.Store(p,&jx_arr.p[jxoffset+moff[4]]);
 
                 Vec jx5=Vec::Load(p,&jx_arr.p[jxoffset+moff[5]]);
                 svfloat64_t rhox5=svld1_gather_u64index_f64(p,&xrhocells[5+irhox],rho_index);
                 jx5+=rhox5;
                 jx5.Store(p,&jx_arr.p[jxoffset+moff[5]]);
 
                 Vec jx6=Vec::Load(p,&jx_arr.p[jxoffset+moff[6]]);
                 svfloat64_t rhox6=svld1_gather_u64index_f64(p,&xrhocells[6+irhox],rho_index);
                 jx6+=rhox6;
                 jx6.Store(p,&jx_arr.p[jxoffset+moff[6]]);
 
                 Vec jx7=Vec::Load(p,&jx_arr.p[jxoffset+moff[7]]);
                 svfloat64_t rhox7=svld1_gather_u64index_f64(p,&xrhocells[7+irhox],rho_index);
                 jx7+=rhox7;
                 jx7.Store(p,&jx_arr.p[jxoffset+moff[7]]);
                 
                 // y
                 // uint64_t irhoy = ix + iy * yjstride + iz * ykstride;
                 // svuint64_t rhoy_index = svindex_u64(irhoy, 8ULL);
                 // long jyoffset = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
                 long yoffset = ix + iy * yjstride + iz * ykstride;
                 long jyoffset=yoffset;
                 long irhoy=8*yoffset;
                 Vec jy0=Vec::Load(p,&jy_arr.p[jyoffset+moff[0]]);
                 svfloat64_t rhoy0=svld1_gather_u64index_f64(p,&yrhocells[0+irhoy],rho_index);
                 jy0+=rhoy0;
                 jy0.Store(p,&jy_arr.p[jyoffset+moff[0]]);
 
                 Vec jy1=Vec::Load(p,&jy_arr.p[jyoffset+moff[1]]);
                 svfloat64_t rhoy1=svld1_gather_u64index_f64(p,&yrhocells[1+irhoy],rho_index);
                 jy1+=rhoy1;
                 jy1.Store(p,&jy_arr.p[jyoffset+moff[1]]);
 
                 Vec jy2=Vec::Load(p,&jy_arr.p[jyoffset+moff[2]]);
                 svfloat64_t rhoy2=svld1_gather_u64index_f64(p,&yrhocells[2+irhoy],rho_index);
                 jy2+=rhoy2;
                 jy2.Store(p,&jy_arr.p[jyoffset+moff[2]]);
 
                 Vec jy3=Vec::Load(p,&jy_arr.p[jyoffset+moff[3]]);
                 svfloat64_t rhoy3=svld1_gather_u64index_f64(p,&yrhocells[3+irhoy],rho_index);
                 jy3+=rhoy3;
                 jy3.Store(p,&jy_arr.p[jyoffset+moff[3]]);
 
                 Vec jy4=Vec::Load(p,&jy_arr.p[jyoffset+moff[4]]);
                 svfloat64_t rhoy4=svld1_gather_u64index_f64(p,&yrhocells[4+irhoy],rho_index);
                 jy4+=rhoy4;
                 jy4.Store(p,&jy_arr.p[jyoffset+moff[4]]);
 
                 Vec jy5=Vec::Load(p,&jy_arr.p[jyoffset+moff[5]]);
                 svfloat64_t rhoy5=svld1_gather_u64index_f64(p,&yrhocells[5+irhoy],rho_index);
                 jy5+=rhoy5;
                 jy5.Store(p,&jy_arr.p[jyoffset+moff[5]]);
 
                 Vec jy6=Vec::Load(p,&jy_arr.p[jyoffset+moff[6]]);
                 svfloat64_t rhoy6=svld1_gather_u64index_f64(p,&yrhocells[6+irhoy],rho_index);
                 jy6+=rhoy6;
                 jy6.Store(p,&jy_arr.p[jyoffset+moff[6]]);
 
                 Vec jy7=Vec::Load(p,&jy_arr.p[jyoffset+moff[7]]);
                 svfloat64_t rhoy7=svld1_gather_u64index_f64(p,&yrhocells[7+irhoy],rho_index);
                 jy7+=rhoy7;
                 jy7.Store(p,&jy_arr.p[jyoffset+moff[7]]);
 
                 // z
                 // uint64_t irhoz = ix + iy * zjstride + iz * zkstride;
                 // svuint64_t rhoz_index = svindex_u64(irhoz, 8ULL);
                 // long jzoffset = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
                 long zoffset = ix + iy * zjstride + iz * zkstride;
                 long jzoffset=zoffset;
                 long irhoz=8*zoffset;
                 Vec jz0=Vec::Load(p,&jz_arr.p[jzoffset+moff[0]]);
                 svfloat64_t rhoz0=svld1_gather_u64index_f64(p,&zrhocells[0+irhoz],rho_index);
                 jz0+=rhoz0;
                 jz0.Store(p,&jz_arr.p[jzoffset+moff[0]]);
 
                 Vec jz1=Vec::Load(p,&jz_arr.p[jzoffset+moff[1]]);
                 svfloat64_t rhoz1=svld1_gather_u64index_f64(p,&zrhocells[1+irhoz],rho_index);
                 jz1+=rhoz1;
                 jz1.Store(p,&jz_arr.p[jzoffset+moff[1]]);
 
                 Vec jz2=Vec::Load(p,&jz_arr.p[jzoffset+moff[2]]);
                 svfloat64_t rhoz2=svld1_gather_u64index_f64(p,&zrhocells[2+irhoz],rho_index);
                 jz2+=rhoz2;
                 jz2.Store(p,&jz_arr.p[jzoffset+moff[2]]);
 
                 Vec jz3=Vec::Load(p,&jz_arr.p[jzoffset+moff[3]]);
                 svfloat64_t rhoz3=svld1_gather_u64index_f64(p,&zrhocells[3+irhoz],rho_index);
                 jz3+=rhoz3;
                 jz3.Store(p,&jz_arr.p[jzoffset+moff[3]]);
 
                 Vec jz4=Vec::Load(p,&jz_arr.p[jzoffset+moff[4]]);
                 svfloat64_t rhoz4=svld1_gather_u64index_f64(p,&zrhocells[4+irhoz],rho_index);
                 jz4+=rhoz4;
                 jz4.Store(p,&jz_arr.p[jzoffset+moff[4]]);
 
                 Vec jz5=Vec::Load(p,&jz_arr.p[jzoffset+moff[5]]);
                 svfloat64_t rhoz5=svld1_gather_u64index_f64(p,&zrhocells[5+irhoz],rho_index);
                 jz5+=rhoz5;
                 jz5.Store(p,&jz_arr.p[jzoffset+moff[5]]);
 
                 Vec jz6=Vec::Load(p,&jz_arr.p[jzoffset+moff[6]]);
                 svfloat64_t rhoz6=svld1_gather_u64index_f64(p,&zrhocells[6+irhoz],rho_index);
                 jz6+=rhoz6;
                 jz6.Store(p,&jz_arr.p[jzoffset+moff[6]]);
 
                 Vec jz7=Vec::Load(p,&jz_arr.p[jzoffset+moff[7]]);
                 svfloat64_t rhoz7=svld1_gather_u64index_f64(p,&zrhocells[7+irhoz],rho_index);
                 jz7+=rhoz7;
                 jz7.Store(p,&jz_arr.p[jzoffset+moff[7]]);
 
                 // svetime[1]=rdtscv();
                 // reduce_time+=(svetime[1]-svetime[0]);
             }
         }
     }
     
 }
 
 
 template <int depos_order>
 void doDepositionShapeN_simd_org (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Real q,
                          std::vector<long>& test,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     using namespace amrex::literals;
 
     // Whether ion_lev is a null pointer (do_ionization=0) or a real pointer
     // (do_ionization=1)
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z;
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
     
     constexpr int nshapes = 1 + 1;
     const int block_size=256;
     long n_blocks=np_to_deposit/block_size;
     const int vl=svcntd();
 
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
 
     // auto compute_shape_factor_v2 = [](int64_t* i_new,double* sx[], Vec xmid, svbool_t p) {
     //     Vec j = svrintz_x(p, xmid);
     //     Vec xint = xmid - j;
     //     Vec temp = 1.0 - xint;
     //     Vec sx0 = (1.0 / 6.0) * temp * temp * temp;
     //     Vec sx1 = (2.0 / 3.0) - xint * xint * (1.0 - xint * 0.5);
     //     Vec sx2 = (2.0 / 3.0) - temp * temp * (1.0 - 0.5 *temp);
     //     Vec sx3 = (1.0 / 6.0) * xint * xint * xint;
     //     sx0.Store(p, sx[0]);
     //     sx1.Store(p, sx[1]);
     //     sx2.Store(p, sx[2]);
     //     sx3.Store(p, sx[3]);
     //     svint64_t i_newv=svsub_x(p, svcvt_s64_x(p,j), svdup_s64(1));
     //     svst1(p, i_new, i_newv);
     //     return i_newv;
     // };
 
     auto compute_shape_factor_v2 = [](double* sx[], Vec xmid, svbool_t p) {
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         sx0.Store(p, sx[0]);
         sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
     for(int block_id=0;block_id<n_blocks;block_id++){
 
         std::vector<int64_t> j_cell(block_size, 0);
         std::vector<int64_t> k_cell(block_size, 0);
         std::vector<int64_t> l_cell(block_size, 0);
         std::vector<amrex::Real> wqx(block_size, 0.0);
         std::vector<amrex::Real> wqy(block_size, 0.0);
         std::vector<amrex::Real> wqz(block_size, 0.0);
         double sx_m[nshapes][block_size] = {0.};
         double sy_m[nshapes][block_size] = {0.};
         double sz_m[nshapes][block_size] = {0.};
 
         for(int iip=0;iip<block_size;iip+=vl){
             long ip=iip+block_id*block_size;
             // 计算基本物理量
             svbool_t p_ip=svwhilele_b64(ip,np_to_deposit);
             // Inverse of Lorentz factor gamma
             Vec uxp_v=Vec::Load(p_ip,&uxp[ip]);
             Vec uyp_v=Vec::Load(p_ip,&uyp[ip]);
             Vec uzp_v=Vec::Load(p_ip,&uzp[ip]);
             Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                         + uyp_v * uyp_v * clightsq
                                         + uzp_v * uzp_v * clightsq).Sqrt();
             // Product of particle charges and weights
             Vec wp_v=Vec::Load(p_ip,&wp[ip]);
             Vec wq_v = q * wp_v;
 
             // Current particle positions (in physical units)
 
             // Particle velocities
             Vec vx_v = uxp_v * gaminv;
             Vec vy_v = uyp_v * gaminv;
             Vec vz_v = uzp_v * gaminv;
 
             // if (do_ionization) wq *= ion_lev[ip];
             Vec wqx_v = wq_v * invvol * vx_v;
             Vec wqy_v = wq_v * invvol * vy_v;
             Vec wqz_v = wq_v * invvol * vz_v;
 
             wqx_v.Store(p_ip, &wqx[iip]);
             wqy_v.Store(p_ip, &wqy[iip]);
             wqz_v.Store(p_ip, &wqz[iip]);
 
             Vec xp = Vec::Load(p_ip, &mx[ip]);
             Vec yp = Vec::Load(p_ip, &my[ip]);
             Vec zp = Vec::Load(p_ip, &mz[ip]);
 
             Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x;
             Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y;
             Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z;
             // Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x - 0.5;
             // Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y - 0.5;
             // Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z - 0.5;
             // TODO : 2d matrix --> 1d list
             // TODO: no need to return
             double* sx_temp[nshapes] = {&sx_m[0][iip], &sx_m[1][iip]};
             intVec j_cellv = compute_shape_factor_v2( sx_temp, xmid, p_ip);
             j_cellv.Store(p_ip,&j_cell[iip]);
             double* sy_temp[nshapes] = {&sy_m[0][iip], &sy_m[1][iip]};
             intVec k_cellv = compute_shape_factor_v2( sy_temp, ymid, p_ip);
             k_cellv.Store(p_ip,&k_cell[iip]);
             double* sz_temp[nshapes] = {&sz_m[0][iip], &sz_m[1][iip]};
             intVec l_cellv = compute_shape_factor_v2( sz_temp, zmid, p_ip);
             l_cellv.Store(p_ip,&l_cell[iip]);
             
         }
         // alignas(64) long   xoffsets[vl];
         // alignas(64) long   yoffsets[vl];
         // alignas(64) long   zoffsets[vl];
         // alignas(64) double jx_vals[vl] = {0};
         // alignas(64) double jy_vals[vl] = {0};
         // alignas(64) double jz_vals[vl] = {0};
         alignas(64) long   xoffsets[8];
         alignas(64) long   yoffsets[8];
         alignas(64) long   zoffsets[8];
         alignas(64) double jx_vals[8] = {0};
         alignas(64) double jy_vals[8] = {0};
         alignas(64) double jz_vals[8] = {0};
 
         for (int iz = 0; iz < nshapes; ++iz) {
             double* sz=sz_m[iz];
             for (int iy = 0; iy < nshapes; ++iy) {
                 double* sy=sy_m[iy];
                 for (int ix = 0; ix < nshapes; ++ix) {
                     double* sx=sx_m[ix];
                     // 分块处理粒子
                     for (long iip = 0; iip < block_size; iip += vl) {
                         long ip=iip+block_id*block_size;
                         svbool_t p=svwhilelt_b64(ip,np_to_deposit);
 
                         intVec j_cell_v = intVec::Load(p, &j_cell[iip]);
                         intVec j = lo.x + j_cell_v + ix;
                         intVec k_cell_v = intVec::Load(p, &k_cell[iip]);
                         intVec k = lo.y + k_cell_v + iy;
                         intVec l_cell_v = intVec::Load(p, &l_cell[iip]);
                         intVec l = lo.z + l_cell_v + iz;
 
 
                         intVec xoffsets_v = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                         xoffsets_v.Store(p,&xoffsets[0]);
                         intVec yoffsets_v = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
                         yoffsets_v.Store(p,&yoffsets[0]);
                         intVec zoffsets_v = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
                         zoffsets_v.Store(p,&zoffsets[0]);
                         
                         // int64_t intj = lo.x + j_cell[iip] + ix;
                         // int64_t intk = lo.y + k_cell[iip] + iy;
                         // int64_t intl = lo.z + l_cell[iip] + iz;
                         // int64_t base_xoffset = intj - jx_arr.begin.x + 
                         //                         (intk - jx_arr.begin.y) * xjstride + 
                         //                         (intl - jx_arr.begin.z) * xkstride;
                         // int64_t base_yoffset = intj - jy_arr.begin.x + 
                         //                         (intk - jy_arr.begin.y) * yjstride + 
                         //                         (intl - jy_arr.begin.z) * ykstride;
                         // int64_t base_zoffset = intj - jz_arr.begin.x + 
                         //                         (intk - jz_arr.begin.y) * zjstride + 
                         //                         (intl - jz_arr.begin.z) * zkstride;
 
                         // intVec xindices = xoffsets_v - base_xoffset;
                         // long xindx[8];
                         // xoffsets_v.Store(p,&xindx[0]);
                         // for(int idx=0;idx<8;idx++){
                         //     printf("offset %ld xindices %ld \n",xindx[idx],&jx_arr.p[xindx[idx]]);
                         //     int ij = lo.x + j_cell[iip+idx] + ix;
                         //     int ik = lo.y + k_cell[iip+idx] + iy;
                         //     int il = lo.z + l_cell[iip+idx] + iz;
                         //     int xx = ij - jx_arr.begin.x + (ik - jx_arr.begin.y) * xjstride + (il - jx_arr.begin.z) * xkstride;
                         //     printf("off %ld ind %ld \n",xx,&jx_arr.p[xx]);
 
                         // }
                         // amrex::Abort("no");
                         // intVec yindices = yoffsets_v - base_yoffset;
                         // intVec zindices = zoffsets_v - base_zoffset;
 
                         Vec sx_v = Vec::Load(p, &sx[iip]);
                         Vec sy_v = Vec::Load(p, &sy[iip]);
                         Vec sz_v = Vec::Load(p, &sz[iip]);
                         Vec s = sx_v * sy_v * sz_v;
 
                         Vec wqx_v = Vec::Load(p, &wqx[iip]);
                         Vec jx_arr_v=s* wqx_v;
                         jx_arr_v.Store(p,&jx_vals[0]);
                         Vec wqy_v = Vec::Load(p, &wqy[iip]);
                         Vec jy_arr_v=s* wqy_v;
                         jy_arr_v.Store(p,&jy_vals[0]);
                         Vec wqz_v = Vec::Load(p, &wqz[iip]);
                         Vec jz_arr_v=s* wqz_v;
                         jz_arr_v.Store(p,&jz_vals[0]);
 
                         const int vec_len = std::min(vl, static_cast<int>(np_to_deposit - ip));
                         for (int iv = 0; iv < vec_len; ++iv) {
                             amrex::Gpu::Atomic::AddNoRet(&jx_arr.p[xoffsets[iv]], jx_vals[iv]);
                             amrex::Gpu::Atomic::AddNoRet(&jy_arr.p[yoffsets[iv]], jy_vals[iv]);
                             amrex::Gpu::Atomic::AddNoRet(&jz_arr.p[zoffsets[iv]], jz_vals[iv]);
                         }
                         
                         // Vec jx_arr_v(svld1_gather_index(p,&jx_arr.p[base_xoffset],xindices));
                         // jx_arr_v+=s* wqx_v;
                         // svst1_scatter_index(p,&jx_arr.p[base_xoffset],xindices,jx_arr_v);
                         // if(iz==0 && iy==0 && ix==0){
                         //     long   xoffsets[8];
                         //     double   jxtest[8];
                         //     Vec jx_v=s* wqx_v;
                         //     xoffsets_v.Store(p,&xoffsets[0]);
                         //     jx_v.Store(p,&jxtest[0]);
                         //     for(int idx=0;idx<8;idx++){
                         //         // jx_arr.p[xoffsets[idx]]+=jxtest[idx];
                         //         test[ip+idx]=jx_arr.p[xoffsets[idx]];
                         //     }
                         // }
                         // Vec jy_arr_v(svld1_gather_index(p,&jy_arr.p[base_yoffset],yindices));
                         // jy_arr_v+=s* wqy_v;
                         // svst1_scatter_index(p,&jy_arr.p[base_yoffset],yindices,jy_arr_v);
                         // Vec jz_arr_v(svld1_gather_index(p,&jz_arr.p[base_zoffset],zindices));
                         // jz_arr_v+=s* wqz_v;
                         // svst1_scatter_index(p,&jz_arr.p[base_zoffset],zindices,jz_arr_v);
 
                         // Vec jx_v = s* wqx_v;
                         // Vec jy_v = s* wqy_v;
                         // Vec jz_v = s* wqz_v;
 
                         // jx_v.Store(p,&jx_vals[0]);
                         // jy_v.Store(p,&jy_vals[0]);
                         // jz_v.Store(p,&jz_vals[0]);
 
 
 
 
 
                         // xoffsets_v.Store(p,&xoffsets[0]);
                         // yoffsets_v.Store(p,&yoffsets[0]);
                         // zoffsets_v.Store(p,&zoffsets[0]);
                         // const int vec_len = std::min(vl, static_cast<int>(np_to_deposit - ip));
 
 
                         // for (int iv = 0; iv < vec_len; ++iv) {
                         //     amrex::Gpu::Atomic::AddNoRet(&jx_arr.p[xoffsets[iv]], jx_vals[iv]);
                         //     amrex::Gpu::Atomic::AddNoRet(&jy_arr.p[yoffsets[iv]], jy_vals[iv]);
                         //     amrex::Gpu::Atomic::AddNoRet(&jz_arr.p[zoffsets[iv]], jz_vals[iv]);
                         // }
                         
                     }
                 }
             }
         }    
     }
     
 }
 
 
 // uint64_t total_time[3]={0};
 // uint64_t precompute=0;
 // uint64_t cale_time=0;
 // uint64_t reduce_time=0;
 // uint64_t svetime[2]={0};
 // depos_order = 1
 // block sve rhocell
 template <int depos_order>
 void doDepositionShapeN_sve1 (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Dim3 hi,
                          amrex::Dim3 len,
                          amrex::Real q,
                          std::vector<double>& test,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     using namespace std::chrono;
     using namespace amrex::literals;
     double total_time=0;
     auto total_start=high_resolution_clock::now();
     // uint64_t total_time[3]={0};
     uint64_t precompute=0;
     uint64_t cale_time=0;
     uint64_t reduce_time=0;
     uint64_t svetime[2]={0};
     // total_time[0]=rdtscv();
     // Whether ion_lev is a null pointer (do_ionization=0) or a real pointer
     // (do_ionization=1)
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z;
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
 
     constexpr int nshapes = depos_order + 1;
     const int block_size=512;
     long n_blocks=np_to_deposit/block_size;
     int vl=svcntd();
 
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
 
     auto compute_shape_factor_v2 = [](double* sx[], Vec xmid, svbool_t p) {
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         sx0.Store(p, sx[0]);
         sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
     const long numcell = jx_fab.box().numPts();
 
     // auto xrhocells = std::make_unique<double[]>(8*numcell);
     // auto yrhocells = std::make_unique<double[]>(8*numcell);
     // auto zrhocells = std::make_unique<double[]>(8*numcell);
     std::vector<double> xrhocells(8*numcell,0.0);
     std::vector<double> yrhocells(8*numcell,0.0);
     std::vector<double> zrhocells(8*numcell,0.0);
     // one roll x
     uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
     uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
     uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
 
     svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
     svbool_t px = svcmpeq_n_u64(svptrue_b64(), rmx_v, 0);
     svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
     svbool_t py = svcmpeq_n_u64(svptrue_b64(), rmy_v, 0);
     svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
     svbool_t pz = svcmpeq_n_u64(svptrue_b64(), rmz_v, 0);
 
     // #pragma omp parallel for
     for(int block_id=0;block_id<n_blocks;block_id++){
         // std::vector<double> sx_cell(nshapes * block_size, 0.0);
         // std::vector<double> sy_cell(nshapes * block_size, 0.0);
         // std::vector<double> sz_cell(nshapes * block_size, 0.0);
         // std::vector<int64_t> j_cell(8, 0);
         // std::vector<double> xmidt(8, 0);
         // std::vector<int> k_cell(block_size, 0);
         // std::vector<int> l_cell(block_size, 0);
         std::vector<amrex::Real> wqx(block_size, 0.0);
         std::vector<amrex::Real> wqy(block_size, 0.0);
         std::vector<amrex::Real> wqz(block_size, 0.0);
         // std::vector<amrex::Real> vx(block_size, 0.0);
         // std::vector<amrex::Real> vy(block_size, 0.0);
         // std::vector<amrex::Real> vz(block_size, 0.0);
         double sx_m[nshapes][block_size] = {0.};
         double sy_m[nshapes][block_size] = {0.};
         double sz_m[nshapes][block_size] = {0.};
 
         alignas(64) long xoffsets[block_size];
         alignas(64) long yoffsets[block_size];
         alignas(64) long zoffsets[block_size];
         // alignas(64) long base_offset= lo.x - jx_arr.begin.x + (lo.y - jx_arr.begin.y) * xjstride + (lo.z - jx_arr.begin.z) * xkstride;
         // Vec j = lo.x + j_cell[ip];
         // Vec k = lo.y + k_cell[ip];
         // Vec l = lo.z + l_cell[ip];
         // Vec xoffsets_v = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
         // xoffsets_v.Store(p,&xICELL[iip]);
 
         for(int iip=0;iip<block_size;iip+=vl){
             svetime[0]=rdtscv();
 
             long ip=iip+block_id*block_size;
             // 计算基本物理量
             svbool_t p_ip=svwhilele_b64(ip,np_to_deposit);
             // Inverse of Lorentz factor gamma
             Vec uxp_v=Vec::Load(p_ip,&uxp[ip]);
             Vec uyp_v=Vec::Load(p_ip,&uyp[ip]);
             Vec uzp_v=Vec::Load(p_ip,&uzp[ip]);
             Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                         + uyp_v * uyp_v * clightsq
                                         + uzp_v * uzp_v * clightsq).Sqrt();
             // Product of particle charges and weights
             Vec wp_v=Vec::Load(p_ip,&wp[ip]);
             Vec wq_v = q * wp_v;
 
             // Current particle positions (in physical units)
             Vec xp = Vec::Load(p_ip, &mx[ip]);
             Vec yp = Vec::Load(p_ip, &my[ip]);
             Vec zp = Vec::Load(p_ip, &mz[ip]);
 
             // Particle velocities
             Vec vx_v = uxp_v * gaminv;
             Vec vy_v = uyp_v * gaminv;
             Vec vz_v = uzp_v * gaminv;
 
             // if (do_ionization) wq *= ion_lev[ip];
             Vec wqx_v = wq_v * invvol * vx_v;
             Vec wqy_v = wq_v * invvol * vy_v;
             Vec wqz_v = wq_v * invvol * vz_v;
 
             wqx_v.Store(p_ip, &wqx[iip]);
             wqy_v.Store(p_ip, &wqy[iip]);
             wqz_v.Store(p_ip, &wqz[iip]);
 
             // Vec xp = Vec::Load(p_ip, &mx[ip]);
             // Vec yp = Vec::Load(p_ip, &my[ip]);
             // Vec zp = Vec::Load(p_ip, &mz[ip]);
 
             Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x;
             Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y;
             Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z;
             // Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x - 0.5;
             // Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y - 0.5;
             // Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z - 0.5;
 
             // intVec j_cellv;
             // intVec k_cellv;
             // intVec l_cellv;
 
             double* sx_temp[nshapes] = {&sx_m[0][iip], &sx_m[1][iip]};
             intVec j_cellv = compute_shape_factor_v2( sx_temp, xmid, p_ip);
             double* sy_temp[nshapes] = {&sy_m[0][iip], &sy_m[1][iip]};
             intVec k_cellv = compute_shape_factor_v2( sy_temp, ymid, p_ip);
             double* sz_temp[nshapes] = {&sz_m[0][iip], &sz_m[1][iip]};
             intVec l_cellv = compute_shape_factor_v2( sz_temp, zmid, p_ip);
 
             // intVec j = lo.x + j_cellv;
             // intVec k = lo.y + k_cellv;
             // intVec l = lo.z + l_cellv;
 
             // intVec xoffsets_v = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
             // intVec yoffsets_v = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
             // intVec zoffsets_v = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
             intVec xoffsets_v = j_cellv + (k_cellv) * xjstride + (l_cellv) * xkstride;
             intVec yoffsets_v = j_cellv + (k_cellv) * yjstride + (l_cellv) * ykstride;
             intVec zoffsets_v = j_cellv + (k_cellv) * zjstride + (l_cellv) * zkstride;
             xoffsets_v.Store(p_ip,&xoffsets[iip]);
             yoffsets_v.Store(p_ip,&yoffsets[iip]);
             zoffsets_v.Store(p_ip,&zoffsets[iip]);
             // j_cellv.Store(p_ip, &test[ip]);
             // xmid.Store(p_ip, &xmidt[0]);
             // for (int i=0;i<8;i++){
             //     int tt=iip+i;
             //     printf("iip: %d, lo.x %d, jx_arr.begin.x, %d, jx_arr.begin.y, %d,jx_arr.begin.z, %d, xjstride: %d, xkstride: %d xoffsets[iip] : %d \n", 
             //             tt,   lo.x , jx_arr.begin.x, jx_arr.begin.y,jx_arr.begin.z, xjstride, xkstride,xoffsets[tt] );
                 // printf("j_cell %d: %ld , xmid %f \n",i,j_cell[i], xmidt[i]);
             // }
             svetime[1]=rdtscv();
             precompute+=(svetime[1]-svetime[0]);
 
             
         }
         // alignas(64) double jx_vals[vl] = {0};
         // alignas(64) double jy_vals[vl] = {0};
         // alignas(64) double jz_vals[vl] = {0};
 
         // double xrhocells[numcell][8] = {0.};
         // double yrhocells[numcell][8] = {0.};
         // double zrhocells[numcell][8] = {0.};
         // auto xrhocells = std::make_unique<double[]>(numcell);
         // auto yrhocells = std::make_unique<double[]>(numcell);
         // auto zrhocells = std::make_unique<double[]>(numcell);
         // one roll x
         // uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
         // uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
         // uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
         // uint8_t xpattern[8]={0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF};
         // uint8_t ypattern[8]={0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF};
         // uint8_t zpattern[8]={0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF};
         // svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
         // svbool_t px = svcmpne_n_u64(svptrue_b64(), rmx_v, 0);
         // svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
         // svbool_t py = svcmpne_n_u64(svptrue_b64(), rmy_v, 0);
         // svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
         // svbool_t pz = svcmpne_n_u64(svptrue_b64(), rmz_v, 0);
         // svbool_t px = svld1(svptrue_b8(),&xpattern[0]);
         // svbool_t py = svld1(svptrue_b8(),&ypattern[0]);
         // svbool_t pz = svld1(svptrue_b8(),&zpattern[0]);
 
         // soa sx sy sz
         // double ssx[2]={0.};
         // double ssy[2]={0.};
         // double ssz[2]={0.};
 
         for (int iip = 0; iip < block_size; ++iip) {
             // svbool_t px=svcmpne(svptrue_b64(),);
             svetime[0]=rdtscv();
             svbool_t p = svptrue_b64();
             
             Vec sx0=Vec(sx_m[0][iip]);
             Vec sx1=Vec(sx_m[1][iip]);
             Vec sxv=svsel_f64(px,sx0,sx1);
             Vec sy0=Vec(sy_m[0][iip]);
             Vec sy1=Vec(sy_m[1][iip]);
             Vec syv=svsel_f64(py,sy0,sy1);
             Vec sz0=Vec(sz_m[0][iip]);
             Vec sz1=Vec(sz_m[1][iip]);
             Vec szv=svsel_f64(pz,sz0,sz1);
             // printf("Error 2! \n");
 
             Vec s = sxv*syv*szv;
             Vec wwx=s*wqx[iip];
             // double jxtemp[8];
             // wwx.Store(p,&jxtemp[0]);
             // for(int idx=0;idx<8;idx++){
             //     test[idx+8*(iip+block_id*block_size)]=jxtemp[idx];
             // }
 
             Vec jy_v=s*wqy[iip];
             Vec jz_v=s*wqz[iip];
 
             long xoffset = xoffsets[iip];
             Vec jx_v = Vec::Load(p,&xrhocells[8*xoffset]);
             jx_v+=wwx;
             // printf("iip:%d, numPts: %ld, offsetx: %ld \n",iip, numcell, xoffset);
             jx_v.Store(p,&xrhocells[8*xoffset]);
             
             // double jxtemp[8];
             // jx_v.Store(p,&jxtemp[0]);
             // test[iip+block_id*block_size]=jxtemp[0];
 
             long yoffset = yoffsets[iip];
             Vec wwy = Vec::Load(p,&yrhocells[yoffset]);
             jy_v+=wwy;
             jy_v.Store(p,&yrhocells[yoffset]);
 
             long zoffset = zoffsets[iip];
             Vec wwz = Vec::Load(p,&zrhocells[zoffset]);
             jz_v+=wwz;
             jz_v.Store(p,&zrhocells[zoffset]);
             svetime[1]=rdtscv();
             cale_time+=(svetime[1]-svetime[0]);
         }
         // amrex::Abort("stop test!");
     }                     
     // TODO: reduction needs  to modify out of this func
     // ix iy iz in numcell
     // this can be SME
     // for(int idx=0;idx<108;idx++){
     //     printf(" %lf \n",xrhocells[idx]);
     // }
     // return;
     // amrex::Abort("xrhocells ERROR!");
     // long nx=len.x+1;
     // long nxy=nx*(len.y+1);
     long nx=xjstride;
     long nxy=xkstride;
     long moff[8] = {0, 1, nx, nx+1, nxy, nxy+1, nx+nxy, nx+nxy+1};
     for (int iz = 0; iz <= len.z; ++iz) {
         for (int iy = 0; iy <= len.y; ++iy) { 
             // scalar mode
             // const int vec_len = std::min(vl, static_cast<int>(len.x - ix+1));
             // for(int ix = 0; ix <= len.x; ix++){
             //     long j = lo.x + ix;
             //     long k = lo.y + iy;
             //     long l = lo.z + iz;
             //     long jxoffset = j - jx_arr.begin.x + 
             //         (k - jx_arr.begin.y) * xjstride + 
             //         (l - jx_arr.begin.z) * xkstride;
             //     long xoffset = 8*(ix + iy * xjstride + iz * xkstride);
             //     // if(8*jxoffset==xoffset){
             //     //     printf("jxoffset %d xoffset %d \n",jxoffset,xoffset);
             //     // }
             //     jx_arr.p[jxoffset+moff[0]]+=xrhocells[0+xoffset];
             //     jx_arr.p[jxoffset+moff[1]]+=xrhocells[1+xoffset];
             //     jx_arr.p[jxoffset+moff[2]]+=xrhocells[2+xoffset];
             //     jx_arr.p[jxoffset+moff[3]]+=xrhocells[3+xoffset];
             //     jx_arr.p[jxoffset+moff[4]]+=xrhocells[4+xoffset];
             //     jx_arr.p[jxoffset+moff[5]]+=xrhocells[5+xoffset];
             //     jx_arr.p[jxoffset+moff[6]]+=xrhocells[6+xoffset];
             //     jx_arr.p[jxoffset+moff[7]]+=xrhocells[7+xoffset];
             //     // if(iy==3 && iz==2){
             //     //     printf("rhocell %lf %lf %lf %lf \n",xrhocells[0+xoffset],xrhocells[1+xoffset]
             //     //             ,xrhocells[2+xoffset],xrhocells[3+xoffset]);
             //     // }
             // }
             for (int ix = 0; ix <= len.x; ix+=vl) {
                 svetime[0]=rdtscv();
 
                 // vector
                 svbool_t p=svwhilele_b64(ix,len.x);
                 // long j = lo.x + ix;
                 // long k = lo.y + iy;
                 // long l = lo.z + iz;
                 // x
                 // uint64_t irhox = 8*(ix + iy * xjstride + iz * xkstride);
                 // svuint64_t rhox_index = svindex_u64(0, 8ULL);
                 // long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                 svuint64_t rho_index = svindex_u64(0ULL, 8ULL);
                 long xoffset=ix + iy * xjstride + iz * xkstride;
                 long jxoffset=xoffset;
                 long irhox=8*xoffset;
                 Vec jx0=Vec::Load(p,&jx_arr.p[jxoffset+moff[0]]);
                 svfloat64_t rhox0=svld1_gather_u64index_f64(p,&xrhocells[0+irhox],rho_index);
                 jx0+=rhox0;
                 jx0.Store(p,&jx_arr.p[jxoffset+moff[0]]);
 
                 Vec jx1=Vec::Load(p,&jx_arr.p[jxoffset+moff[1]]);
                 svfloat64_t rhox1=svld1_gather_u64index_f64(p,&xrhocells[1+irhox],rho_index);
                 jx1+=rhox1;
                 jx1.Store(p,&jx_arr.p[jxoffset+moff[1]]);
 
                 Vec jx2=Vec::Load(p,&jx_arr.p[jxoffset+moff[2]]);
                 svfloat64_t rhox2=svld1_gather_u64index_f64(p,&xrhocells[2+irhox],rho_index);
                 jx2+=rhox2;
                 jx2.Store(p,&jx_arr.p[jxoffset+moff[2]]);
 
                 Vec jx3=Vec::Load(p,&jx_arr.p[jxoffset+moff[3]]);
                 svfloat64_t rhox3=svld1_gather_u64index_f64(p,&xrhocells[3+irhox],rho_index);
                 jx3+=rhox3;
                 jx3.Store(p,&jx_arr.p[jxoffset+moff[3]]);
 
                 Vec jx4=Vec::Load(p,&jx_arr.p[jxoffset+moff[4]]);
                 svfloat64_t rhox4=svld1_gather_u64index_f64(p,&xrhocells[4+irhox],rho_index);
                 jx4+=rhox4;
                 jx4.Store(p,&jx_arr.p[jxoffset+moff[4]]);
 
                 Vec jx5=Vec::Load(p,&jx_arr.p[jxoffset+moff[5]]);
                 svfloat64_t rhox5=svld1_gather_u64index_f64(p,&xrhocells[5+irhox],rho_index);
                 jx5+=rhox5;
                 jx5.Store(p,&jx_arr.p[jxoffset+moff[5]]);
 
                 Vec jx6=Vec::Load(p,&jx_arr.p[jxoffset+moff[6]]);
                 svfloat64_t rhox6=svld1_gather_u64index_f64(p,&xrhocells[6+irhox],rho_index);
                 jx6+=rhox6;
                 jx6.Store(p,&jx_arr.p[jxoffset+moff[6]]);
 
                 Vec jx7=Vec::Load(p,&jx_arr.p[jxoffset+moff[7]]);
                 svfloat64_t rhox7=svld1_gather_u64index_f64(p,&xrhocells[7+irhox],rho_index);
                 jx7+=rhox7;
                 jx7.Store(p,&jx_arr.p[jxoffset+moff[7]]);
                 
                 // y
                 // uint64_t irhoy = ix + iy * yjstride + iz * ykstride;
                 // svuint64_t rhoy_index = svindex_u64(irhoy, 8ULL);
                 // long jyoffset = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
                 long yoffset = ix + iy * yjstride + iz * ykstride;
                 long jyoffset=yoffset;
                 long irhoy=8*yoffset;
                 Vec jy0=Vec::Load(p,&jy_arr.p[jyoffset+moff[0]]);
                 svfloat64_t rhoy0=svld1_gather_u64index_f64(p,&yrhocells[0+irhoy],rho_index);
                 jy0+=rhoy0;
                 jy0.Store(p,&jy_arr.p[jyoffset+moff[0]]);
 
                 Vec jy1=Vec::Load(p,&jy_arr.p[jyoffset+moff[1]]);
                 svfloat64_t rhoy1=svld1_gather_u64index_f64(p,&yrhocells[1+irhoy],rho_index);
                 jy1+=rhoy1;
                 jy1.Store(p,&jy_arr.p[jyoffset+moff[1]]);
 
                 Vec jy2=Vec::Load(p,&jy_arr.p[jyoffset+moff[2]]);
                 svfloat64_t rhoy2=svld1_gather_u64index_f64(p,&yrhocells[2+irhoy],rho_index);
                 jy2+=rhoy2;
                 jy2.Store(p,&jy_arr.p[jyoffset+moff[2]]);
 
                 Vec jy3=Vec::Load(p,&jy_arr.p[jyoffset+moff[3]]);
                 svfloat64_t rhoy3=svld1_gather_u64index_f64(p,&yrhocells[3+irhoy],rho_index);
                 jy3+=rhoy3;
                 jy3.Store(p,&jy_arr.p[jyoffset+moff[3]]);
 
                 Vec jy4=Vec::Load(p,&jy_arr.p[jyoffset+moff[4]]);
                 svfloat64_t rhoy4=svld1_gather_u64index_f64(p,&yrhocells[4+irhoy],rho_index);
                 jy4+=rhoy4;
                 jy4.Store(p,&jy_arr.p[jyoffset+moff[4]]);
 
                 Vec jy5=Vec::Load(p,&jy_arr.p[jyoffset+moff[5]]);
                 svfloat64_t rhoy5=svld1_gather_u64index_f64(p,&yrhocells[5+irhoy],rho_index);
                 jy5+=rhoy5;
                 jy5.Store(p,&jy_arr.p[jyoffset+moff[5]]);
 
                 Vec jy6=Vec::Load(p,&jy_arr.p[jyoffset+moff[6]]);
                 svfloat64_t rhoy6=svld1_gather_u64index_f64(p,&yrhocells[6+irhoy],rho_index);
                 jy6+=rhoy6;
                 jy6.Store(p,&jy_arr.p[jyoffset+moff[6]]);
 
                 Vec jy7=Vec::Load(p,&jy_arr.p[jyoffset+moff[7]]);
                 svfloat64_t rhoy7=svld1_gather_u64index_f64(p,&yrhocells[7+irhoy],rho_index);
                 jy7+=rhoy7;
                 jy7.Store(p,&jy_arr.p[jyoffset+moff[7]]);
 
                 // z
                 // uint64_t irhoz = ix + iy * zjstride + iz * zkstride;
                 // svuint64_t rhoz_index = svindex_u64(irhoz, 8ULL);
                 // long jzoffset = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
                 long zoffset = ix + iy * zjstride + iz * zkstride;
                 long jzoffset=zoffset;
                 long irhoz=8*zoffset;
                 Vec jz0=Vec::Load(p,&jz_arr.p[jzoffset+moff[0]]);
                 svfloat64_t rhoz0=svld1_gather_u64index_f64(p,&zrhocells[0+irhoz],rho_index);
                 jz0+=rhoz0;
                 jz0.Store(p,&jz_arr.p[jzoffset+moff[0]]);
 
                 Vec jz1=Vec::Load(p,&jz_arr.p[jzoffset+moff[1]]);
                 svfloat64_t rhoz1=svld1_gather_u64index_f64(p,&zrhocells[1+irhoz],rho_index);
                 jz1+=rhoz1;
                 jz1.Store(p,&jz_arr.p[jzoffset+moff[1]]);
 
                 Vec jz2=Vec::Load(p,&jz_arr.p[jzoffset+moff[2]]);
                 svfloat64_t rhoz2=svld1_gather_u64index_f64(p,&zrhocells[2+irhoz],rho_index);
                 jz2+=rhoz2;
                 jz2.Store(p,&jz_arr.p[jzoffset+moff[2]]);
 
                 Vec jz3=Vec::Load(p,&jz_arr.p[jzoffset+moff[3]]);
                 svfloat64_t rhoz3=svld1_gather_u64index_f64(p,&zrhocells[3+irhoz],rho_index);
                 jz3+=rhoz3;
                 jz3.Store(p,&jz_arr.p[jzoffset+moff[3]]);
 
                 Vec jz4=Vec::Load(p,&jz_arr.p[jzoffset+moff[4]]);
                 svfloat64_t rhoz4=svld1_gather_u64index_f64(p,&zrhocells[4+irhoz],rho_index);
                 jz4+=rhoz4;
                 jz4.Store(p,&jz_arr.p[jzoffset+moff[4]]);
 
                 Vec jz5=Vec::Load(p,&jz_arr.p[jzoffset+moff[5]]);
                 svfloat64_t rhoz5=svld1_gather_u64index_f64(p,&zrhocells[5+irhoz],rho_index);
                 jz5+=rhoz5;
                 jz5.Store(p,&jz_arr.p[jzoffset+moff[5]]);
 
                 Vec jz6=Vec::Load(p,&jz_arr.p[jzoffset+moff[6]]);
                 svfloat64_t rhoz6=svld1_gather_u64index_f64(p,&zrhocells[6+irhoz],rho_index);
                 jz6+=rhoz6;
                 jz6.Store(p,&jz_arr.p[jzoffset+moff[6]]);
 
                 Vec jz7=Vec::Load(p,&jz_arr.p[jzoffset+moff[7]]);
                 svfloat64_t rhoz7=svld1_gather_u64index_f64(p,&zrhocells[7+irhoz],rho_index);
                 jz7+=rhoz7;
                 jz7.Store(p,&jz_arr.p[jzoffset+moff[7]]);
 
                 svetime[1]=rdtscv();
                 reduce_time+=(svetime[1]-svetime[0]);
             }
         }
     }
     auto total_stop=high_resolution_clock::now();
     duration<double> total_elapse = total_stop-total_start;
     total_time = total_elapse.count();
     // total_time[1]=rdtscv();
     // total_time[2]=(total_time[1]-total_time[0]);
     printf("SVE No Sort: total time: %lf s, precompute: %ld, cale_time: %ld, reduce_time: %ld \n\n",
                         total_time,     precompute,     cale_time,     reduce_time);
     // for(int idx=0;idx<108;idx++){
     //     long j = lo.x + idx;
     //     long k = lo.y +12;
     //     long l = lo.z ;
     //     long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
 
     //     printf("jx %lf \n",jx_arr.p[jxoffset]);
     //     printf("rhocell %lf \n",xrhocells[jxoffset]);
     // }
     // return;
 
 }
 
 // no block divide
 template <int depos_order>
 void doDepositionShapeN_sve2 (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Dim3 hi,
                          amrex::Dim3 len,
                          amrex::Real q,
                          std::vector<double>& test,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     using namespace std::chrono;
     using namespace amrex::literals;
     double total_time=0;
     // auto total_start=high_resolution_clock::now();
     // uint64_t total_time[3]={0};
     uint64_t precompute=0;
     uint64_t cale_time=0;
     uint64_t reduce_time=0;
     uint64_t svetime[2]={0};
     // total_time[0]=rdtscv();
     // Whether ion_lev is a null pointer (do_ionization=0) or a real pointer
     // (do_ionization=1)
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z;
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
 
     constexpr int nshapes = depos_order + 1;
     const int block_size=256;
     long n_blocks=np_to_deposit/block_size;
     int vl=svcntd();
 
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
 
     auto compute_shape_factor_v2 = [](double* sx[], Vec xmid, svbool_t p) {
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         sx0.Store(p, sx[0]);
         sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
     const long numcell = jx_fab.box().numPts();
 
     // auto xrhocells = std::make_unique<double[]>(8*numcell);
     // auto yrhocells = std::make_unique<double[]>(8*numcell);
     // auto zrhocells = std::make_unique<double[]>(8*numcell);
     std::vector<double> xrhocells(8*numcell,0.0);
     std::vector<double> yrhocells(8*numcell,0.0);
     std::vector<double> zrhocells(8*numcell,0.0);
     // one roll x
     uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
     uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
     uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
 
     svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
     svbool_t px = svcmpeq_n_u64(svptrue_b64(), rmx_v, 0);
     svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
     svbool_t py = svcmpeq_n_u64(svptrue_b64(), rmy_v, 0);
     svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
     svbool_t pz = svcmpeq_n_u64(svptrue_b64(), rmz_v, 0);
 
     // #pragma omp parallel for
     // for(int block_id=0;block_id<n_blocks;block_id++){
     // std::vector<double> sx_cell(nshapes * np_to_deposit, 0.0);
     // std::vector<double> sy_cell(nshapes * np_to_deposit, 0.0);
     // std::vector<double> sz_cell(nshapes * np_to_deposit, 0.0);
     // std::vector<int64_t> j_cell(8, 0);
     // std::vector<double> xmidt(8, 0);
     // std::vector<int> k_cell(np_to_deposit, 0);
     // std::vector<int> l_cell(np_to_deposit, 0);
     std::vector<amrex::Real> wqx(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqy(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqz(np_to_deposit, 0.0);
     // std::vector<amrex::Real> vx(np_to_deposit, 0.0);
     // std::vector<amrex::Real> vy(np_to_deposit, 0.0);
     // std::vector<amrex::Real> vz(np_to_deposit, 0.0);
     // double sx_m[nshapes][np_to_deposit] = {0.};
     // double sy_m[nshapes][np_to_deposit] = {0.};
     // double sz_m[nshapes][np_to_deposit] = {0.};
     std::vector<std::vector<amrex::Real>> sx_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
     std::vector<std::vector<amrex::Real>> sy_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
     std::vector<std::vector<amrex::Real>> sz_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
 
 
     alignas(64) long xoffsets[np_to_deposit];
     alignas(64) long yoffsets[np_to_deposit];
     alignas(64) long zoffsets[np_to_deposit];
     // alignas(64) long base_offset= lo.x - jx_arr.begin.x + (lo.y - jx_arr.begin.y) * xjstride + (lo.z - jx_arr.begin.z) * xkstride;
     // Vec j = lo.x + j_cell[ip];
     // Vec k = lo.y + k_cell[ip];
     // Vec l = lo.z + l_cell[ip];
     // Vec xoffsets_v = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
     // xoffsets_v.Store(p,&xICELL[iip]);
 
     for(long ip=0;ip<np_to_deposit;ip+=vl){
         // svetime[0]=rdtscv();
 
         // 计算基本物理量
         svbool_t p=svwhilele_b64(ip,np_to_deposit);
         // Inverse of Lorentz factor gamma
         Vec uxp_v=Vec::Load(p,&uxp[ip]);
         Vec uyp_v=Vec::Load(p,&uyp[ip]);
         Vec uzp_v=Vec::Load(p,&uzp[ip]);
         Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                     + uyp_v * uyp_v * clightsq
                                     + uzp_v * uzp_v * clightsq).Sqrt();
         // Product of particle charges and weights
         Vec wp_v=Vec::Load(p,&wp[ip]);
         Vec wq_v = q * wp_v;
 
         // Current particle positions (in physical units)
         Vec xp = Vec::Load(p, &mx[ip]);
         Vec yp = Vec::Load(p, &my[ip]);
         Vec zp = Vec::Load(p, &mz[ip]);
 
         // Particle velocities
         Vec vx_v = uxp_v * gaminv;
         Vec vy_v = uyp_v * gaminv;
         Vec vz_v = uzp_v * gaminv;
 
         // if (do_ionization) wq *= ion_lev[ip];
         Vec wqx_v = wq_v * invvol * vx_v;
         Vec wqy_v = wq_v * invvol * vy_v;
         Vec wqz_v = wq_v * invvol * vz_v;
 
         wqx_v.Store(p, &wqx[ip]);
         wqy_v.Store(p, &wqy[ip]);
         wqz_v.Store(p, &wqz[ip]);
 
         // Vec xp = Vec::Load(p, &mx[ip]);
         // Vec yp = Vec::Load(p, &my[ip]);
         // Vec zp = Vec::Load(p, &mz[ip]);
 
         Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x;
         Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y;
         Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z;
         // Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x - 0.5;
         // Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y - 0.5;
         // Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z - 0.5;
 
         // intVec j_cellv;
         // intVec k_cellv;
         // intVec l_cellv;
 
         double* sx_temp[nshapes] = {&sx_m[0][ip], &sx_m[1][ip]};
         intVec j_cellv = compute_shape_factor_v2( sx_temp, xmid, p);
         double* sy_temp[nshapes] = {&sy_m[0][ip], &sy_m[1][ip]};
         intVec k_cellv = compute_shape_factor_v2( sy_temp, ymid, p);
         double* sz_temp[nshapes] = {&sz_m[0][ip], &sz_m[1][ip]};
         intVec l_cellv = compute_shape_factor_v2( sz_temp, zmid, p);
 
         // intVec j = lo.x + j_cellv;
         // intVec k = lo.y + k_cellv;
         // intVec l = lo.z + l_cellv;
 
         // intVec xoffsets_v = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
         // intVec yoffsets_v = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
         // intVec zoffsets_v = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
         intVec xoffsets_v = j_cellv + (k_cellv) * xjstride + (l_cellv) * xkstride;
         intVec yoffsets_v = j_cellv + (k_cellv) * yjstride + (l_cellv) * ykstride;
         intVec zoffsets_v = j_cellv + (k_cellv) * zjstride + (l_cellv) * zkstride;
         xoffsets_v.Store(p,&xoffsets[ip]);
         yoffsets_v.Store(p,&yoffsets[ip]);
         zoffsets_v.Store(p,&zoffsets[ip]);
         // j_cellv.Store(p, &test[ip]);
         // xmid.Store(p, &xmidt[0]);
         // for (int i=0;i<8;i++){
         //     int tt=ip+i;
         //     printf("ip: %d, lo.x %d, jx_arr.begin.x, %d, jx_arr.begin.y, %d,jx_arr.begin.z, %d, xjstride: %d, xkstride: %d xoffsets[ip] : %d \n", 
         //             tt,   lo.x , jx_arr.begin.x, jx_arr.begin.y,jx_arr.begin.z, xjstride, xkstride,xoffsets[tt] );
             // printf("j_cell %d: %ld , xmid %f \n",i,j_cell[i], xmidt[i]);
         // }
         // svetime[1]=rdtscv();
         // precompute+=(svetime[1]-svetime[0]);
 
         
     }
     // alignas(64) double jx_vals[vl] = {0};
     // alignas(64) double jy_vals[vl] = {0};
     // alignas(64) double jz_vals[vl] = {0};
 
     // double xrhocells[numcell][8] = {0.};
     // double yrhocells[numcell][8] = {0.};
     // double zrhocells[numcell][8] = {0.};
     // auto xrhocells = std::make_unique<double[]>(numcell);
     // auto yrhocells = std::make_unique<double[]>(numcell);
     // auto zrhocells = std::make_unique<double[]>(numcell);
     // one roll x
     // uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
     // uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
     // uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
     // uint8_t xpattern[8]={0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF};
     // uint8_t ypattern[8]={0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF};
     // uint8_t zpattern[8]={0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF};
     // svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
     // svbool_t px = svcmpne_n_u64(svptrue_b64(), rmx_v, 0);
     // svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
     // svbool_t py = svcmpne_n_u64(svptrue_b64(), rmy_v, 0);
     // svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
     // svbool_t pz = svcmpne_n_u64(svptrue_b64(), rmz_v, 0);
     // svbool_t px = svld1(svptrue_b8(),&xpattern[0]);
     // svbool_t py = svld1(svptrue_b8(),&ypattern[0]);
     // svbool_t pz = svld1(svptrue_b8(),&zpattern[0]);
 
     // soa sx sy sz
     // double ssx[2]={0.};
     // double ssy[2]={0.};
     // double ssz[2]={0.};
 
     for (long ip = 0; ip < np_to_deposit; ++ip) {
         // svbool_t px=svcmpne(svptrue_b64(),);
         // svetime[0]=rdtscv();
         svbool_t p = svptrue_b64();
         
         Vec sx0=Vec(sx_m[0][ip]);
         Vec sx1=Vec(sx_m[1][ip]);
         Vec sxv=svsel_f64(px,sx0,sx1);
         Vec sy0=Vec(sy_m[0][ip]);
         Vec sy1=Vec(sy_m[1][ip]);
         Vec syv=svsel_f64(py,sy0,sy1);
         Vec sz0=Vec(sz_m[0][ip]);
         Vec sz1=Vec(sz_m[1][ip]);
         Vec szv=svsel_f64(pz,sz0,sz1);
         // printf("Error 2! \n");
 
         Vec s = sxv*syv*szv;
         Vec wwx=s*wqx[ip];
         // double jxtemp[8];
         // wwx.Store(p,&jxtemp[0]);
         // for(int idx=0;idx<8;idx++){
         //     test[idx+8*(ip+block_id*np_to_deposit)]=jxtemp[idx];
         // }
 
         Vec wwy=s*wqy[ip];
         Vec wwz=s*wqz[ip];
 
         long xoffset = xoffsets[ip];
         Vec jx_v = Vec::Load(p,&xrhocells[8*xoffset]);
         jx_v+=wwx;
         // printf("ip:%d, numPts: %ld, offsetx: %ld \n",ip, numcell, xoffset);
         jx_v.Store(p,&xrhocells[8*xoffset]);
         
         // double jxtemp[8];
         // jx_v.Store(p,&jxtemp[0]);
         // test[ip+block_id*np_to_deposit]=jxtemp[0];
 
         long yoffset = yoffsets[ip];
         Vec jy_v = Vec::Load(p,&yrhocells[yoffset]);
         jy_v+=wwy;
         jy_v.Store(p,&yrhocells[yoffset]);
 
         long zoffset = zoffsets[ip];
         Vec jz_v = Vec::Load(p,&zrhocells[zoffset]);
         jz_v+=wwz;
         jz_v.Store(p,&zrhocells[zoffset]);
         // svetime[1]=rdtscv();
         // cale_time+=(svetime[1]-svetime[0]);
     }
     // amrex::Abort("stop test!");
 // }                     
 // TODO: reduction needs  to modify out of this func
     // ix iy iz in numcell
     // this can be SME
     // for(int idx=0;idx<108;idx++){
     //     printf(" %lf \n",xrhocells[idx]);
     // }
     // return;
     // amrex::Abort("xrhocells ERROR!");
     // long nx=len.x+1;
     // long nxy=nx*(len.y+1);
     long nx=xjstride;
     long nxy=xkstride;
     long moff[8] = {0, 1, nx, nx+1, nxy, nxy+1, nx+nxy, nx+nxy+1};
     for (int iz = 0; iz <= len.z; ++iz) {
         for (int iy = 0; iy <= len.y; ++iy) { 
             // scalar mode
             // const int vec_len = std::min(vl, static_cast<int>(len.x - ix+1));
             // for(int ix = 0; ix <= len.x; ix++){
             //     long j = lo.x + ix;
             //     long k = lo.y + iy;
             //     long l = lo.z + iz;
             //     long jxoffset = j - jx_arr.begin.x + 
             //         (k - jx_arr.begin.y) * xjstride + 
             //         (l - jx_arr.begin.z) * xkstride;
             //     long xoffset = 8*(ix + iy * xjstride + iz * xkstride);
             //     // if(8*jxoffset==xoffset){
             //     //     printf("jxoffset %d xoffset %d \n",jxoffset,xoffset);
             //     // }
             //     jx_arr.p[jxoffset+moff[0]]+=xrhocells[0+xoffset];
             //     jx_arr.p[jxoffset+moff[1]]+=xrhocells[1+xoffset];
             //     jx_arr.p[jxoffset+moff[2]]+=xrhocells[2+xoffset];
             //     jx_arr.p[jxoffset+moff[3]]+=xrhocells[3+xoffset];
             //     jx_arr.p[jxoffset+moff[4]]+=xrhocells[4+xoffset];
             //     jx_arr.p[jxoffset+moff[5]]+=xrhocells[5+xoffset];
             //     jx_arr.p[jxoffset+moff[6]]+=xrhocells[6+xoffset];
             //     jx_arr.p[jxoffset+moff[7]]+=xrhocells[7+xoffset];
             //     // if(iy==3 && iz==2){
             //     //     printf("rhocell %lf %lf %lf %lf \n",xrhocells[0+xoffset],xrhocells[1+xoffset]
             //     //             ,xrhocells[2+xoffset],xrhocells[3+xoffset]);
             //     // }
             // }
             for (int ix = 0; ix <= len.x; ix+=vl) {
                 // svetime[0]=rdtscv();
 
                 // vector
                 svbool_t p=svwhilele_b64(ix,len.x);
                 // long j = lo.x + ix;
                 // long k = lo.y + iy;
                 // long l = lo.z + iz;
                 // x
                 // uint64_t irhox = 8*(ix + iy * xjstride + iz * xkstride);
                 // svuint64_t rhox_index = svindex_u64(0, 8ULL);
                 // long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                 svuint64_t rho_index = svindex_u64(0ULL, 8ULL);
                 long xoffset=ix + iy * xjstride + iz * xkstride;
                 long jxoffset=xoffset;
                 long irhox=8*xoffset;
                 Vec jx0=Vec::Load(p,&jx_arr.p[jxoffset+moff[0]]);
                 svfloat64_t rhox0=svld1_gather_u64index_f64(p,&xrhocells[0+irhox],rho_index);
                 jx0+=rhox0;
                 jx0.Store(p,&jx_arr.p[jxoffset+moff[0]]);
 
                 Vec jx1=Vec::Load(p,&jx_arr.p[jxoffset+moff[1]]);
                 svfloat64_t rhox1=svld1_gather_u64index_f64(p,&xrhocells[1+irhox],rho_index);
                 jx1+=rhox1;
                 jx1.Store(p,&jx_arr.p[jxoffset+moff[1]]);
 
                 Vec jx2=Vec::Load(p,&jx_arr.p[jxoffset+moff[2]]);
                 svfloat64_t rhox2=svld1_gather_u64index_f64(p,&xrhocells[2+irhox],rho_index);
                 jx2+=rhox2;
                 jx2.Store(p,&jx_arr.p[jxoffset+moff[2]]);
 
                 Vec jx3=Vec::Load(p,&jx_arr.p[jxoffset+moff[3]]);
                 svfloat64_t rhox3=svld1_gather_u64index_f64(p,&xrhocells[3+irhox],rho_index);
                 jx3+=rhox3;
                 jx3.Store(p,&jx_arr.p[jxoffset+moff[3]]);
 
                 Vec jx4=Vec::Load(p,&jx_arr.p[jxoffset+moff[4]]);
                 svfloat64_t rhox4=svld1_gather_u64index_f64(p,&xrhocells[4+irhox],rho_index);
                 jx4+=rhox4;
                 jx4.Store(p,&jx_arr.p[jxoffset+moff[4]]);
 
                 Vec jx5=Vec::Load(p,&jx_arr.p[jxoffset+moff[5]]);
                 svfloat64_t rhox5=svld1_gather_u64index_f64(p,&xrhocells[5+irhox],rho_index);
                 jx5+=rhox5;
                 jx5.Store(p,&jx_arr.p[jxoffset+moff[5]]);
 
                 Vec jx6=Vec::Load(p,&jx_arr.p[jxoffset+moff[6]]);
                 svfloat64_t rhox6=svld1_gather_u64index_f64(p,&xrhocells[6+irhox],rho_index);
                 jx6+=rhox6;
                 jx6.Store(p,&jx_arr.p[jxoffset+moff[6]]);
 
                 Vec jx7=Vec::Load(p,&jx_arr.p[jxoffset+moff[7]]);
                 svfloat64_t rhox7=svld1_gather_u64index_f64(p,&xrhocells[7+irhox],rho_index);
                 jx7+=rhox7;
                 jx7.Store(p,&jx_arr.p[jxoffset+moff[7]]);
                 
                 // y
                 // uint64_t irhoy = ix + iy * yjstride + iz * ykstride;
                 // svuint64_t rhoy_index = svindex_u64(irhoy, 8ULL);
                 // long jyoffset = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
                 long yoffset = ix + iy * yjstride + iz * ykstride;
                 long jyoffset=yoffset;
                 long irhoy=8*yoffset;
                 Vec jy0=Vec::Load(p,&jy_arr.p[jyoffset+moff[0]]);
                 svfloat64_t rhoy0=svld1_gather_u64index_f64(p,&yrhocells[0+irhoy],rho_index);
                 jy0+=rhoy0;
                 jy0.Store(p,&jy_arr.p[jyoffset+moff[0]]);
 
                 Vec jy1=Vec::Load(p,&jy_arr.p[jyoffset+moff[1]]);
                 svfloat64_t rhoy1=svld1_gather_u64index_f64(p,&yrhocells[1+irhoy],rho_index);
                 jy1+=rhoy1;
                 jy1.Store(p,&jy_arr.p[jyoffset+moff[1]]);
 
                 Vec jy2=Vec::Load(p,&jy_arr.p[jyoffset+moff[2]]);
                 svfloat64_t rhoy2=svld1_gather_u64index_f64(p,&yrhocells[2+irhoy],rho_index);
                 jy2+=rhoy2;
                 jy2.Store(p,&jy_arr.p[jyoffset+moff[2]]);
 
                 Vec jy3=Vec::Load(p,&jy_arr.p[jyoffset+moff[3]]);
                 svfloat64_t rhoy3=svld1_gather_u64index_f64(p,&yrhocells[3+irhoy],rho_index);
                 jy3+=rhoy3;
                 jy3.Store(p,&jy_arr.p[jyoffset+moff[3]]);
 
                 Vec jy4=Vec::Load(p,&jy_arr.p[jyoffset+moff[4]]);
                 svfloat64_t rhoy4=svld1_gather_u64index_f64(p,&yrhocells[4+irhoy],rho_index);
                 jy4+=rhoy4;
                 jy4.Store(p,&jy_arr.p[jyoffset+moff[4]]);
 
                 Vec jy5=Vec::Load(p,&jy_arr.p[jyoffset+moff[5]]);
                 svfloat64_t rhoy5=svld1_gather_u64index_f64(p,&yrhocells[5+irhoy],rho_index);
                 jy5+=rhoy5;
                 jy5.Store(p,&jy_arr.p[jyoffset+moff[5]]);
 
                 Vec jy6=Vec::Load(p,&jy_arr.p[jyoffset+moff[6]]);
                 svfloat64_t rhoy6=svld1_gather_u64index_f64(p,&yrhocells[6+irhoy],rho_index);
                 jy6+=rhoy6;
                 jy6.Store(p,&jy_arr.p[jyoffset+moff[6]]);
 
                 Vec jy7=Vec::Load(p,&jy_arr.p[jyoffset+moff[7]]);
                 svfloat64_t rhoy7=svld1_gather_u64index_f64(p,&yrhocells[7+irhoy],rho_index);
                 jy7+=rhoy7;
                 jy7.Store(p,&jy_arr.p[jyoffset+moff[7]]);
 
                 // z
                 // uint64_t irhoz = ix + iy * zjstride + iz * zkstride;
                 // svuint64_t rhoz_index = svindex_u64(irhoz, 8ULL);
                 // long jzoffset = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
                 long zoffset = ix + iy * zjstride + iz * zkstride;
                 long jzoffset=zoffset;
                 long irhoz=8*zoffset;
                 Vec jz0=Vec::Load(p,&jz_arr.p[jzoffset+moff[0]]);
                 svfloat64_t rhoz0=svld1_gather_u64index_f64(p,&zrhocells[0+irhoz],rho_index);
                 jz0+=rhoz0;
                 jz0.Store(p,&jz_arr.p[jzoffset+moff[0]]);
 
                 Vec jz1=Vec::Load(p,&jz_arr.p[jzoffset+moff[1]]);
                 svfloat64_t rhoz1=svld1_gather_u64index_f64(p,&zrhocells[1+irhoz],rho_index);
                 jz1+=rhoz1;
                 jz1.Store(p,&jz_arr.p[jzoffset+moff[1]]);
 
                 Vec jz2=Vec::Load(p,&jz_arr.p[jzoffset+moff[2]]);
                 svfloat64_t rhoz2=svld1_gather_u64index_f64(p,&zrhocells[2+irhoz],rho_index);
                 jz2+=rhoz2;
                 jz2.Store(p,&jz_arr.p[jzoffset+moff[2]]);
 
                 Vec jz3=Vec::Load(p,&jz_arr.p[jzoffset+moff[3]]);
                 svfloat64_t rhoz3=svld1_gather_u64index_f64(p,&zrhocells[3+irhoz],rho_index);
                 jz3+=rhoz3;
                 jz3.Store(p,&jz_arr.p[jzoffset+moff[3]]);
 
                 Vec jz4=Vec::Load(p,&jz_arr.p[jzoffset+moff[4]]);
                 svfloat64_t rhoz4=svld1_gather_u64index_f64(p,&zrhocells[4+irhoz],rho_index);
                 jz4+=rhoz4;
                 jz4.Store(p,&jz_arr.p[jzoffset+moff[4]]);
 
                 Vec jz5=Vec::Load(p,&jz_arr.p[jzoffset+moff[5]]);
                 svfloat64_t rhoz5=svld1_gather_u64index_f64(p,&zrhocells[5+irhoz],rho_index);
                 jz5+=rhoz5;
                 jz5.Store(p,&jz_arr.p[jzoffset+moff[5]]);
 
                 Vec jz6=Vec::Load(p,&jz_arr.p[jzoffset+moff[6]]);
                 svfloat64_t rhoz6=svld1_gather_u64index_f64(p,&zrhocells[6+irhoz],rho_index);
                 jz6+=rhoz6;
                 jz6.Store(p,&jz_arr.p[jzoffset+moff[6]]);
 
                 Vec jz7=Vec::Load(p,&jz_arr.p[jzoffset+moff[7]]);
                 svfloat64_t rhoz7=svld1_gather_u64index_f64(p,&zrhocells[7+irhoz],rho_index);
                 jz7+=rhoz7;
                 jz7.Store(p,&jz_arr.p[jzoffset+moff[7]]);
 
                 // svetime[1]=rdtscv();
                 // reduce_time+=(svetime[1]-svetime[0]);
             }
         }
     }
     // auto total_stop=high_resolution_clock::now();
     // duration<double> total_elapse = total_stop-total_start;
     // total_time = total_elapse.count();
     // // total_time[1]=rdtscv();
     // // total_time[2]=(total_time[1]-total_time[0]);
     // printf(" \n SVE No Sort: total time: %lf s, precompute: %ld, cale_time: %ld, reduce_time: %ld \n\n",
     //                     total_time,     precompute,     cale_time,     reduce_time);
     // for(int idx=0;idx<108;idx++){
     //     long j = lo.x + idx;
     //     long k = lo.y +12;
     //     long l = lo.z ;
     //     long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
 
     //     printf("jx %lf \n",jx_arr.p[jxoffset]);
     //     printf("rhocell %lf \n",xrhocells[jxoffset]);
     // }
     // return;
 
 }
 
 // depos_order = 1
 // sort method data is not real, ERROR
 template <int depos_order>
 void doDepositionShapeN_sve_sort (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Dim3 hi,
                          amrex::Dim3 len,
                          amrex::Real q,
                          std::vector<double>& test,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     uint64_t total_time[3]={0};
     uint64_t precompute=0;
     uint64_t cale_time=0;
     uint64_t reduce_time=0;
     uint64_t svetime[2]={0};
     using namespace amrex::literals;
     total_time[0]=rdtscv();
 
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z; 
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
 
     constexpr int nshapes = depos_order + 1;
     const int block_size=256;
     long n_blocks=np_to_deposit/block_size;
     int vl=svcntd();
 
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
 
     auto compute_shape_factor_v2 = [](double* sx[], Vec xmid, svbool_t p) {
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         sx0.Store(p, sx[0]);
         sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
     const long numcell = jx_fab.box().numPts();
 
     auto xrhocells = std::make_unique<double[]>(8*numcell);
     auto yrhocells = std::make_unique<double[]>(8*numcell);
     auto zrhocells = std::make_unique<double[]>(8*numcell);
     // one roll x
     uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
     uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
     uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
     long nx=len.x;
     long nxy=len.x*len.y;
     long moff[8] = {0, 1, nx, nx+1, nxy, nxy+1, nx+nxy, nx+nxy+1};
     svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
     svbool_t px = svcmpne_n_u64(svptrue_b64(), rmx_v, 0);
     svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
     svbool_t py = svcmpne_n_u64(svptrue_b64(), rmy_v, 0);
     svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
     svbool_t pz = svcmpne_n_u64(svptrue_b64(), rmz_v, 0);
 
     // #pragma omp parallel for
     for(int block_id=0;block_id<n_blocks;block_id++){
 
         std::vector<amrex::Real> wqx(np_to_deposit, 0.0);
         std::vector<amrex::Real> wqy(np_to_deposit, 0.0);
         std::vector<amrex::Real> wqz(np_to_deposit, 0.0);
         double sx_m[nshapes][np_to_deposit] = {0.};
         double sy_m[nshapes][np_to_deposit] = {0.};
         double sz_m[nshapes][np_to_deposit] = {0.};
 
         alignas(64) long xoffsets[np_to_deposit];
         alignas(64) long yoffsets[np_to_deposit];
         alignas(64) long zoffsets[np_to_deposit];
 
         for(int iip=0;iip<np_to_deposit;iip+=vl){
             svetime[0]=rdtscv();
 
             long ip=iip+block_id*np_to_deposit;
             // 计算基本物理量
             svbool_t p_ip=svwhilele_b64(ip,np_to_deposit);
             // Inverse of Lorentz factor gamma
             Vec uxp_v=Vec::Load(p_ip,&uxp[ip]);
             Vec uyp_v=Vec::Load(p_ip,&uyp[ip]);
             Vec uzp_v=Vec::Load(p_ip,&uzp[ip]);
             Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                         + uyp_v * uyp_v * clightsq
                                         + uzp_v * uzp_v * clightsq).Sqrt();
             // Product of particle charges and weights
             Vec wp_v=Vec::Load(p_ip,&wp[ip]);
             Vec wq_v = q * wp_v;
 
             // Current particle positions (in physical units)
             Vec xp = Vec::Load(p_ip, &mx[ip]);
             Vec yp = Vec::Load(p_ip, &my[ip]);
             Vec zp = Vec::Load(p_ip, &mz[ip]);
 
             // Particle velocities
             Vec vx_v = uxp_v * gaminv;
             Vec vy_v = uyp_v * gaminv;
             Vec vz_v = uzp_v * gaminv;
 
             // if (do_ionization) wq *= ion_lev[ip];
             Vec wqx_v = wq_v * invvol * vx_v;
             Vec wqy_v = wq_v * invvol * vy_v;
             Vec wqz_v = wq_v * invvol * vz_v;
 
             wqx_v.Store(p_ip, &wqx[iip]);
             wqy_v.Store(p_ip, &wqy[iip]);
             wqz_v.Store(p_ip, &wqz[iip]);
 
             Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x - 0.5;
             Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y - 0.5;
             Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z - 0.5;
 
             double* sx_temp[nshapes] = {&sx_m[0][iip], &sx_m[1][iip]};
             intVec j_cellv = compute_shape_factor_v2( sx_temp, xmid, p_ip);
             double* sy_temp[nshapes] = {&sy_m[0][iip], &sy_m[1][iip]};
             intVec k_cellv = compute_shape_factor_v2( sy_temp, ymid, p_ip);
             double* sz_temp[nshapes] = {&sz_m[0][iip], &sz_m[1][iip]};
             intVec l_cellv = compute_shape_factor_v2( sz_temp, zmid, p_ip);
             // TODO USE jkl cell to SORT
             intVec xoffsets_v = j_cellv + (k_cellv) * xjstride + (l_cellv) * xkstride;
             intVec yoffsets_v = j_cellv + (k_cellv) * yjstride + (l_cellv) * ykstride;
             intVec zoffsets_v = j_cellv + (k_cellv) * zjstride + (l_cellv) * zkstride;
             xoffsets_v.Store(p_ip,&xoffsets[iip]);
             yoffsets_v.Store(p_ip,&yoffsets[iip]);
             zoffsets_v.Store(p_ip,&zoffsets[iip]);
             svetime[1]=rdtscv();
             precompute+=(svetime[1]-svetime[0]);
             
         }
         
         int partnum=128;
         
         for (long iip = 0; iip < np_to_deposit/partnum; iip+=partnum) {
             svetime[0]=rdtscv();
             // svbool_t px=svcmpne(svptrue_b64(),);
             svbool_t p = svptrue_b64();
                      
             long xoffset = xoffsets[iip];
             Vec wwx = Vec::Load(p,&xrhocells[xoffset]);
             long yoffset = yoffsets[iip];
             Vec wwy = Vec::Load(p,&yrhocells[yoffset]);
             long zoffset = zoffsets[iip];
             Vec wwz = Vec::Load(p,&zrhocells[zoffset]);
 
             for(int ipar=0;ipar<partnum;ipar++){
                 int iip_p=iip+ipar;
                 Vec sx0=Vec(sx_m[0][iip_p]);
                 Vec sx1=Vec(sx_m[1][iip_p]);
                 Vec sxv=svsel_f64(px,sx0,sx1);
                 Vec sy0=Vec(sy_m[0][iip_p]);
                 Vec sy1=Vec(sy_m[1][iip_p]);
                 Vec syv=svsel_f64(py,sy0,sy1);
                 Vec sz0=Vec(sz_m[0][iip_p]);
                 Vec sz1=Vec(sz_m[1][iip_p]);
                 Vec szv=svsel_f64(pz,sz0,sz1);
                 // printf("Error 2! \n");
                 Vec s = sxv*syv*szv;
                 Vec jx_v=s*wqx[iip_p];
                 wwx+=jx_v;                
                 Vec jy_v=s*wqy[iip_p];
                 wwy+=jy_v;              
                 Vec jz_v=s*wqz[iip_p];
                 wwz+=jz_v;
             }
 
             // long xoffset = xoffsets[iip];
             // Vec wwx = Vec::Load(p,&xrhocells[xoffset]);
             // jx_v+=wwx;
             // printf("iip:%d, numPts: %ld, offsetx: %ld \n",iip, numcell, xoffset);
             wwx.Store(p,&xrhocells[xoffset]);
 
             // long yoffset = yoffsets[iip];
             // Vec wwy = Vec::Load(p,&yrhocells[yoffset]);
             // jy_v+=wwy;
             wwy.Store(p,&yrhocells[yoffset]);
 
             // long zoffset = zoffsets[iip];
             // Vec wwz = Vec::Load(p,&zrhocells[zoffset]);
             // jz_v+=wwz;
             wwz.Store(p,&zrhocells[zoffset]);
             svetime[1]=rdtscv();
             cale_time+=(svetime[1]-svetime[0]);
         }
         // amrex::Abort("stop test!");
     }                     
     // TODO: reduction needs  to modify out of this func
     // ix iy iz in numcell
     // this can be SME
     for (int iz = 0; iz <= len.z; ++iz) {
         for (int iy = 0; iy <= len.y; ++iy) { 
             for (int ix = 0; ix <= len.x; ix+=vl) {
                 // scalar mode
                 // long j = lo.x + ix;
                 // long k = lo.y + iy;
                 // long l = lo.z + iz;
                 // long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                 // long xoffset = ix + iy * xjstride + iz * xkstride;
                 // jx_arr.p[jxoffset+moff[0]]+=xrhocells[0+xoffset];
                 // jx_arr.p[jxoffset+moff[1]]+=xrhocells[1+xoffset];
                 // jx_arr.p[jxoffset+moff[2]]+=xrhocells[2+xoffset];
                 // jx_arr.p[jxoffset+moff[3]]+=xrhocells[3+xoffset];
                 // jx_arr.p[jxoffset+moff[4]]+=xrhocells[4+xoffset];
                 // jx_arr.p[jxoffset+moff[5]]+=xrhocells[5+xoffset];
                 // jx_arr.p[jxoffset+moff[6]]+=xrhocells[6+xoffset];
                 // jx_arr.p[jxoffset+moff[7]]+=xrhocells[7+xoffset];
                 svetime[0]=rdtscv();
 
                 // vector
                 svbool_t p=svwhilele_b64(ix,len.x);
                 long j = lo.x + ix;
                 long k = lo.y + iy;
                 long l = lo.z + iz;
                 // x
                 uint64_t irhox = ix + iy * xjstride + iz * xkstride;
                 svuint64_t rhox_index = svindex_u64(irhox, 8ULL);
                 long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                 Vec jx0=Vec::Load(p,&jx_arr.p[jxoffset+moff[0]]);
                 svfloat64_t rhox0=svld1_gather_u64index_f64(p,&xrhocells[0+irhox],rhox_index);
                 jx0+=rhox0;
                 jx0.Store(p,&jx_arr.p[jxoffset+moff[0]]);
 
                 Vec jx1=Vec::Load(p,&jx_arr.p[jxoffset+moff[1]]);
                 svfloat64_t rhox1=svld1_gather_u64index_f64(p,&xrhocells[1+irhox],rhox_index);
                 jx1+=rhox1;
                 jx1.Store(p,&jx_arr.p[jxoffset+moff[1]]);
 
                 Vec jx2=Vec::Load(p,&jx_arr.p[jxoffset+moff[2]]);
                 svfloat64_t rhox2=svld1_gather_u64index_f64(p,&xrhocells[2+irhox],rhox_index);
                 jx2+=rhox2;
                 jx2.Store(p,&jx_arr.p[jxoffset+moff[2]]);
 
                 Vec jx3=Vec::Load(p,&jx_arr.p[jxoffset+moff[3]]);
                 svfloat64_t rhox3=svld1_gather_u64index_f64(p,&xrhocells[3+irhox],rhox_index);
                 jx3+=rhox3;
                 jx3.Store(p,&jx_arr.p[jxoffset+moff[3]]);
 
                 Vec jx4=Vec::Load(p,&jx_arr.p[jxoffset+moff[4]]);
                 svfloat64_t rhox4=svld1_gather_u64index_f64(p,&xrhocells[4+irhox],rhox_index);
                 jx4+=rhox4;
                 jx4.Store(p,&jx_arr.p[jxoffset+moff[4]]);
 
                 Vec jx5=Vec::Load(p,&jx_arr.p[jxoffset+moff[5]]);
                 svfloat64_t rhox5=svld1_gather_u64index_f64(p,&xrhocells[5+irhox],rhox_index);
                 jx5+=rhox5;
                 jx5.Store(p,&jx_arr.p[jxoffset+moff[5]]);
 
                 Vec jx6=Vec::Load(p,&jx_arr.p[jxoffset+moff[6]]);
                 svfloat64_t rhox6=svld1_gather_u64index_f64(p,&xrhocells[6+irhox],rhox_index);
                 jx6+=rhox6;
                 jx6.Store(p,&jx_arr.p[jxoffset+moff[6]]);
 
                 Vec jx7=Vec::Load(p,&jx_arr.p[jxoffset+moff[7]]);
                 svfloat64_t rhox7=svld1_gather_u64index_f64(p,&xrhocells[7+irhox],rhox_index);
                 jx7+=rhox7;
                 jx7.Store(p,&jx_arr.p[jxoffset+moff[7]]);
                 
                 // y
                 uint64_t irhoy = ix + iy * yjstride + iz * ykstride;
                 svuint64_t rhoy_index = svindex_u64(irhoy, 8ULL);
                 long jyoffset = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
                 Vec jy0=Vec::Load(p,&jy_arr.p[jyoffset+moff[0]]);
                 svfloat64_t rhoy0=svld1_gather_u64index_f64(p,&yrhocells[0+irhoy],rhoy_index);
                 jy0+=rhoy0;
                 jy0.Store(p,&jy_arr.p[jyoffset+moff[0]]);
 
                 Vec jy1=Vec::Load(p,&jy_arr.p[jyoffset+moff[1]]);
                 svfloat64_t rhoy1=svld1_gather_u64index_f64(p,&yrhocells[1+irhoy],rhoy_index);
                 jy1+=rhoy1;
                 jy1.Store(p,&jy_arr.p[jyoffset+moff[1]]);
 
                 Vec jy2=Vec::Load(p,&jy_arr.p[jyoffset+moff[2]]);
                 svfloat64_t rhoy2=svld1_gather_u64index_f64(p,&yrhocells[2+irhoy],rhoy_index);
                 jy2+=rhoy2;
                 jy2.Store(p,&jy_arr.p[jyoffset+moff[2]]);
 
                 Vec jy3=Vec::Load(p,&jy_arr.p[jyoffset+moff[3]]);
                 svfloat64_t rhoy3=svld1_gather_u64index_f64(p,&yrhocells[3+irhoy],rhoy_index);
                 jy3+=rhoy3;
                 jy3.Store(p,&jy_arr.p[jyoffset+moff[3]]);
 
                 Vec jy4=Vec::Load(p,&jy_arr.p[jyoffset+moff[4]]);
                 svfloat64_t rhoy4=svld1_gather_u64index_f64(p,&yrhocells[4+irhoy],rhoy_index);
                 jy4+=rhoy4;
                 jy4.Store(p,&jy_arr.p[jyoffset+moff[4]]);
 
                 Vec jy5=Vec::Load(p,&jy_arr.p[jyoffset+moff[5]]);
                 svfloat64_t rhoy5=svld1_gather_u64index_f64(p,&yrhocells[5+irhoy],rhoy_index);
                 jy5+=rhoy5;
                 jy5.Store(p,&jy_arr.p[jyoffset+moff[5]]);
 
                 Vec jy6=Vec::Load(p,&jy_arr.p[jyoffset+moff[6]]);
                 svfloat64_t rhoy6=svld1_gather_u64index_f64(p,&yrhocells[6+irhoy],rhoy_index);
                 jy6+=rhoy6;
                 jy6.Store(p,&jy_arr.p[jyoffset+moff[6]]);
 
                 Vec jy7=Vec::Load(p,&jy_arr.p[jyoffset+moff[7]]);
                 svfloat64_t rhoy7=svld1_gather_u64index_f64(p,&yrhocells[7+irhoy],rhoy_index);
                 jy7+=rhoy7;
                 jy7.Store(p,&jy_arr.p[jyoffset+moff[7]]);
 
                 // z
                 uint64_t irhoz = ix + iy * zjstride + iz * zkstride;
                 svuint64_t rhoz_index = svindex_u64(irhoz, 8ULL);
                 long jzoffset = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
                 Vec jz0=Vec::Load(p,&jz_arr.p[jzoffset+moff[0]]);
                 svfloat64_t rhoz0=svld1_gather_u64index_f64(p,&zrhocells[0+irhoz],rhoz_index);
                 jz0+=rhoz0;
                 jz0.Store(p,&jz_arr.p[jzoffset+moff[0]]);
 
                 Vec jz1=Vec::Load(p,&jz_arr.p[jzoffset+moff[1]]);
                 svfloat64_t rhoz1=svld1_gather_u64index_f64(p,&zrhocells[1+irhoz],rhoz_index);
                 jz1+=rhoz1;
                 jz1.Store(p,&jz_arr.p[jzoffset+moff[1]]);
 
                 Vec jz2=Vec::Load(p,&jz_arr.p[jzoffset+moff[2]]);
                 svfloat64_t rhoz2=svld1_gather_u64index_f64(p,&zrhocells[2+irhoz],rhoz_index);
                 jz2+=rhoz2;
                 jz2.Store(p,&jz_arr.p[jzoffset+moff[2]]);
 
                 Vec jz3=Vec::Load(p,&jz_arr.p[jzoffset+moff[3]]);
                 svfloat64_t rhoz3=svld1_gather_u64index_f64(p,&zrhocells[3+irhoz],rhoz_index);
                 jz3+=rhoz3;
                 jz3.Store(p,&jz_arr.p[jzoffset+moff[3]]);
 
                 Vec jz4=Vec::Load(p,&jz_arr.p[jzoffset+moff[4]]);
                 svfloat64_t rhoz4=svld1_gather_u64index_f64(p,&zrhocells[4+irhoz],rhoz_index);
                 jz4+=rhoz4;
                 jz4.Store(p,&jz_arr.p[jzoffset+moff[4]]);
 
                 Vec jz5=Vec::Load(p,&jz_arr.p[jzoffset+moff[5]]);
                 svfloat64_t rhoz5=svld1_gather_u64index_f64(p,&zrhocells[5+irhoz],rhoz_index);
                 jz5+=rhoz5;
                 jz5.Store(p,&jz_arr.p[jzoffset+moff[5]]);
 
                 Vec jz6=Vec::Load(p,&jz_arr.p[jzoffset+moff[6]]);
                 svfloat64_t rhoz6=svld1_gather_u64index_f64(p,&zrhocells[6+irhoz],rhoz_index);
                 jz6+=rhoz6;
                 jz6.Store(p,&jz_arr.p[jzoffset+moff[6]]);
 
                 Vec jz7=Vec::Load(p,&jz_arr.p[jzoffset+moff[7]]);
                 svfloat64_t rhoz7=svld1_gather_u64index_f64(p,&zrhocells[7+irhoz],rhoz_index);
                 jz7+=rhoz7;
                 jz7.Store(p,&jz_arr.p[jzoffset+moff[7]]);
 
                 // svetime[1]=rdtscv();
                 // reduce_time+=(svetime[1]-svetime[0]);
             }
         }
     }
     // total_time[1]=rdtscv();
     // total_time[2]=(total_time[1]-total_time[0]);
     // printf("total time: %d, precompute: %d, cale_time: %d, reduce_time: %d \n",
     //         total_time,     precompute,     cale_time,     reduce_time);
 
 }
 
 // 添加了真的粒子分桶排序功能
 template <int depos_order>
 void doDepositionShapeN_sve_sort_real (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Dim3 hi,
                          amrex::Dim3 len,
                          amrex::Real q,
                          std::vector<double>& test,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     // uint64_t total_time[3]={0};
     using namespace std::chrono;
     using namespace amrex::literals;
     double total_time=0;
     // auto total_start=high_resolution_clock::now();
     uint64_t precompute=0;
     uint64_t cale_time=0;
     uint64_t sort_time=0;
         uint64_t count_time=0;
         uint64_t presum_time=0;
         uint64_t binlist_time=0;
     uint64_t reduce_time=0;
     uint64_t svetime[3]={0};
     uint64_t branch_time=0;
     
     // total_time[0]=rdtscv();
     
 
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z; 
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
 
     constexpr int nshapes = depos_order + 1;
     // constexpr int nshapes = 2;
     int vl=svcntd();
 
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
 
     auto compute_shape_factor_v2 = [](double* sx[], Vec xmid, svbool_t p) {
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         sx0.Store(p, sx[0]);
         sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
     const long numcell = jx_fab.box().numPts();
     const long xnumcell = jx_fab.box().numPts();
     // printf("xnumcell %d %d %d \n",xnumcell,xjstride,xkstride);
     // const long ynumcell = jy_fab.box().numPts();
     // printf("ynumcell %d \n",ynumcell);
     // const long znumcell = jz_fab.box().numPts();
     // printf("znumcell %d \n",znumcell);
 
     auto xrhocells = std::make_unique<double[]>(8*numcell);
     auto yrhocells = std::make_unique<double[]>(8*numcell);
     auto zrhocells = std::make_unique<double[]>(8*numcell);
     // one roll x
     uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
     uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
     uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
     long nx=xjstride;
     long nxy=xkstride;
     long moff[8] = {0, 1, nx, nx+1, nxy, nxy+1, nx+nxy, nx+nxy+1};
     svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
     svbool_t px = svcmpeq_n_u64(svptrue_b64(), rmx_v, 0);
     svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
     svbool_t py = svcmpeq_n_u64(svptrue_b64(), rmy_v, 0);
     svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
     svbool_t pz = svcmpeq_n_u64(svptrue_b64(), rmz_v, 0);
 
     std::vector<amrex::Real> wqx(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqy(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqz(np_to_deposit, 0.0);
 
     // double sx_m[nshapes][np_to_deposit] = {0.};
     // double sy_m[nshapes][np_to_deposit] = {0.};
     // double sz_m[nshapes][np_to_deposit] = {0.};
     std::vector<std::vector<amrex::Real>> sx_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
     std::vector<std::vector<amrex::Real>> sy_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
     std::vector<std::vector<amrex::Real>> sz_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
 
     // some place dont have particle
     alignas(64) long xoffsets[np_to_deposit]; 
     // alignas(64) long yoffsets[np_to_deposit];
     // alignas(64) long zoffsets[np_to_deposit];
     std::vector<long> xcount(numcell,0);
     // std::vector<long> ycount(numcell,0);
     // std::vector<long> zcount(numcell,0);
     // printf("before vl \n");
     // std::vector<long> xcount_tmp(np_to_deposit,0);
     
 
     for(long ip=0;ip<np_to_deposit;ip+=vl){
         // svetime[0]=rdtscv();
 
         // 计算基本物理量
         svbool_t p=svwhilele_b64(ip,np_to_deposit);
         // Inverse of Lorentz factor gamma
         Vec uxp_v=Vec::Load(p,&uxp[ip]);
         Vec uyp_v=Vec::Load(p,&uyp[ip]);
         Vec uzp_v=Vec::Load(p,&uzp[ip]);
         Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                     + uyp_v * uyp_v * clightsq
                                     + uzp_v * uzp_v * clightsq).Sqrt();
         // Product of particle charges and weights
         Vec wp_v=Vec::Load(p,&wp[ip]);
         Vec wq_v = q * wp_v;
 
         // Current particle positions (in physical units)
         Vec xp = Vec::Load(p, &mx[ip]);
         Vec yp = Vec::Load(p, &my[ip]);
         Vec zp = Vec::Load(p, &mz[ip]);
 
         // Particle velocities
         Vec vx_v = uxp_v * gaminv;
         Vec vy_v = uyp_v * gaminv;
         Vec vz_v = uzp_v * gaminv;
 
         // if (do_ionization) wq *= ion_lev[ip];
         Vec wqx_v = wq_v * invvol * vx_v;
         Vec wqy_v = wq_v * invvol * vy_v;
         Vec wqz_v = wq_v * invvol * vz_v;
 
         wqx_v.Store(p, &wqx[ip]);
         wqy_v.Store(p, &wqy[ip]);
         wqz_v.Store(p, &wqz[ip]);
 
         // Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x - 0.5;
         // Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y - 0.5;
         // Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z - 0.5;
         Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x;
         Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y;
         Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z;
 
         double* sx_temp[nshapes] = {&sx_m[0][ip], &sx_m[1][ip]};
         intVec j_cellv = compute_shape_factor_v2( sx_temp, xmid, p);
         // j_cellv.Store(p, &test[ip]);
         // for (int i=0;i<8;i++){
         //     int tt=ip+i;
         //     // printf("iip: %d, lo.x %d, jx_arr.begin.x, %d, jx_arr.begin.y, %d,jx_arr.begin.z, %d, xjstride: %d, xkstride: %d xoffsets[iip] : %d \n", 
         //     //         tt,   lo.x , jx_arr.begin.x, jx_arr.begin.y,jx_arr.begin.z, xjstride, xkstride,xoffsets[tt] );
         //     // printf("j_cell %d: %ld , xmid %f \n",i,j_cell[i], xmidt[i]);
         // }
         double* sy_temp[nshapes] = {&sy_m[0][ip], &sy_m[1][ip]};
         intVec k_cellv = compute_shape_factor_v2( sy_temp, ymid, p);
         double* sz_temp[nshapes] = {&sz_m[0][ip], &sz_m[1][ip]};
         intVec l_cellv = compute_shape_factor_v2( sz_temp, zmid, p); 
 
         intVec xoffsets_v = j_cellv + k_cellv * xjstride + l_cellv * xkstride;
         // intVec yoffsets_v = j_cellv + k_cellv * yjstride + l_cellv * ykstride;
         // intVec zoffsets_v = j_cellv + k_cellv * zjstride + l_cellv * zkstride;
 
         xoffsets_v.Store(p,&xoffsets[ip]);
         // yoffsets_v.Store(p,&yoffsets[ip]);
         // zoffsets_v.Store(p,&zoffsets[ip]);
 
         // 原子操作，不可避免
         // const int vec_len = std::min(vl, static_cast<int>(np_to_deposit-ip));
         // svetime[2]=rdtscv();
         // for(int off=0;off<vec_len;off++){
         //     xcount[xoffsets[ip+off]]++;
         //     // ycount[yoffsets[ip+off]]++;
         //     // zcount[zoffsets[ip+off]]++;
         // }
         // svetime[1]=rdtscv();
         // count_time+=(svetime[1]-svetime[2]);
 
         // printf("after STORE\n");
         // svetime[1]=rdtscv();
         // precompute+=(svetime[1]-svetime[0]); 
         // printf("after SAVE\n");
     }
     // svetime[0]=rdtscv();
     for(long ip=0;ip<np_to_deposit;ip++){
         xcount[xoffsets[ip]]++;
     }
     // svetime[1]=rdtscv();
     // count_time+=(svetime[1]-svetime[0]);
 
     std::vector<int> xpresum(numcell+1,0);
     // std::vector<int> ypresum(numcell+1,0);
     // std::vector<int> zpresum(numcell+1,0);
     // svetime[0]=rdtscv();
     for(int c=1;c<=numcell;c++){
         xpresum[c]=xpresum[c-1]+xcount[c-1];
         // ypresum[c]=ypresum[c-1]+ycount[c-1];
         // zpresum[c]=zpresum[c-1]+zcount[c-1];
     }
     // svetime[1]=rdtscv();
     // presum_time+=(svetime[1]-svetime[0]);
     // printf("np_to_deposit %d sum %d xpresum[%d] %d  \n",np_to_deposit,sum1,numcell,xpresum[numcell]);
     // amrex::Abort("END 2!");
 
     // int xbinList[np_to_deposit]={-1};
     std::vector<int> xbinList(np_to_deposit,-1);
     // std::vector<int> ybinList(np_to_deposit,-1);
     // std::vector<int> zbinList(np_to_deposit,-1);
     // std::vector<int> xcurrentPos=xpresum;
     // svetime[0]=rdtscv();
     for(int ip=0;ip<np_to_deposit;ip++){
         long xoffset = xoffsets[ip];
         // long yoffset = yoffsets[ip];
         // long zoffset = zoffsets[ip];
         xbinList[xpresum[xoffset]]=ip;
         xpresum[xoffset]++;
         // ybinList[ypresum[yoffset]]=ip;
         // zbinList[zpresum[zoffset]]=ip;
         // ypresum[yoffset]++;
         // zpresum[zoffset]++;
     }
     // svetime[1]=rdtscv();
     // binlist_time+=(svetime[1]-svetime[0]);
     // sort_time+=(count_time+binlist_time+presum_time);
     // amrex::Abort("stop 2!");
     // printf("stop 2\n");
     // for(int ip=0;ip<np_to_deposit;ip++){
     //     if(xbinList[ip]!=ybinList[ip]   \
     //         ||xbinList[ip]!=zbinList[ip] \
     //         ||ybinList[ip]!=zbinList[ip]){
     //         printf("\nxbinList[%d] %d \n",ip,xbinList[ip]);
     //         printf("ybinList[%d] %d \n",ip,ybinList[ip]);
     //         printf("zbinList[%d] %d \n",ip,zbinList[ip]);
     //     }
     // }
     // amrex::Abort("END 2!");
 
     for(int c=1;c<=numcell;c++){
         // svetime[0]=rdtscv();
         
         int start = xpresum[c-1];
         int end = xpresum[c];
         if(start==end){
             // svetime[1]=rdtscv();
             // branch_time+=(svetime[1]-svetime[0]);
             continue;
         }
         // svetime[1]=rdtscv();
         // branch_time+=(svetime[1]-svetime[0]);
         svbool_t p = svptrue_b64();
         Vec wwx = Vec::Load(p,&xrhocells[8*c]);
         Vec wwy = Vec::Load(p,&yrhocells[8*c]);
         Vec wwz = Vec::Load(p,&zrhocells[8*c]);
         for(int idx=start;idx<end;idx++){
             int ip=xbinList[idx];
             // printf("ip %d sx_m[0] %lf sx_m[1] %lf \n",
             //             ip,   sx_m[0][ip],  sx_m[1][ip]);
             Vec sx0=Vec(sx_m[0][ip]);
             Vec sx1=Vec(sx_m[1][ip]);
             Vec sxv=svsel_f64(px,sx0,sx1);
             Vec sy0=Vec(sy_m[0][ip]);
             Vec sy1=Vec(sy_m[1][ip]);
             Vec syv=svsel_f64(py,sy0,sy1);
             Vec sz0=Vec(sz_m[0][ip]);
             Vec sz1=Vec(sz_m[1][ip]);
             Vec szv=svsel_f64(pz,sz0,sz1);
             // printf("Error 2! \n");
             Vec s = sxv*syv*szv;
             Vec jx_v=s*wqx[ip];
             // jx_v.Store(p,&test[ip*8]);
             wwx+=jx_v;
             Vec jy_v=s*wqy[ip];
             wwy+=jy_v;              
             Vec jz_v=s*wqz[ip];
             wwz+=jz_v;
         }
         wwx.Store(p,&xrhocells[8*c]);
         // test[c]=xrhocells[8*c]
         wwy.Store(p,&yrhocells[8*c]);
         wwz.Store(p,&zrhocells[8*c]);
         // svetime[1]=rdtscv();
         // cale_time+=(svetime[1]-svetime[0]);
     }
     
                    
     // TODO: reduction needs  to modify out of this func
     // ix iy iz in numcell
     // this can be SME
     for (int iz = 0; iz <= len.z; ++iz) {
         for (int iy = 0; iy <= len.y; ++iy) { 
             // scalar mode
             // for(int ix = 0; ix <= len.x; ix++){
             //     long j = lo.x + ix;
             //     long k = lo.y + iy;
             //     long l = lo.z + iz;
             //     // long jxoffset = j - jx_arr.begin.x + 
             //     //     (k - jx_arr.begin.y) * xjstride + 
             //     //     (l - jx_arr.begin.z) * xkstride;
             //     long jxoffset = ix + iy * xjstride + iz * xkstride;
             //     long xoffset = 8*(ix + iy * xjstride + iz * xkstride);
             //     // if(8*jxoffset==xoffset){
             //     //     printf("jxoffset %d xoffset %d \n",jxoffset,xoffset);
             //     // }
             //     jx_arr.p[jxoffset+moff[0]]+=xrhocells[0+xoffset];
             //     jx_arr.p[jxoffset+moff[1]]+=xrhocells[1+xoffset];
             //     jx_arr.p[jxoffset+moff[2]]+=xrhocells[2+xoffset];
             //     jx_arr.p[jxoffset+moff[3]]+=xrhocells[3+xoffset];
             //     jx_arr.p[jxoffset+moff[4]]+=xrhocells[4+xoffset];
             //     jx_arr.p[jxoffset+moff[5]]+=xrhocells[5+xoffset];
             //     jx_arr.p[jxoffset+moff[6]]+=xrhocells[6+xoffset];
             //     jx_arr.p[jxoffset+moff[7]]+=xrhocells[7+xoffset];
             //     // if(iy==3 && iz==2){
             //     //     printf("rhocell %lf %lf %lf %lf \n",xrhocells[0+xoffset],xrhocells[1+xoffset]
             //     //             ,xrhocells[2+xoffset],xrhocells[3+xoffset]);
             //     // }
             // }
             for (int ix = 0; ix <= len.x; ix+=vl) {
                 // svetime[0]=rdtscv();
 
                 // vector
                 svbool_t p=svwhilele_b64(ix,len.x);
                 // long j = lo.x + ix;
                 // long k = lo.y + iy;
                 // long l = lo.z + iz;
                 // x
                 // uint64_t irhox = 8*(ix + iy * xjstride + iz * xkstride);
                 // svuint64_t rhox_index = svindex_u64(0, 8ULL);
                 // long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                 svuint64_t rho_index = svindex_u64(0ULL, 8ULL);
                 long xoffset=ix + iy * xjstride + iz * xkstride;
                 long jxoffset=xoffset;
                 long irhox=8*xoffset;
                 Vec jx0=Vec::Load(p,&jx_arr.p[jxoffset+moff[0]]);
                 svfloat64_t rhox0=svld1_gather_u64index_f64(p,&xrhocells[0+irhox],rho_index);
                 jx0+=rhox0;
                 jx0.Store(p,&jx_arr.p[jxoffset+moff[0]]);
 
                 Vec jx1=Vec::Load(p,&jx_arr.p[jxoffset+moff[1]]);
                 svfloat64_t rhox1=svld1_gather_u64index_f64(p,&xrhocells[1+irhox],rho_index);
                 jx1+=rhox1;
                 jx1.Store(p,&jx_arr.p[jxoffset+moff[1]]);
 
                 Vec jx2=Vec::Load(p,&jx_arr.p[jxoffset+moff[2]]);
                 svfloat64_t rhox2=svld1_gather_u64index_f64(p,&xrhocells[2+irhox],rho_index);
                 jx2+=rhox2;
                 jx2.Store(p,&jx_arr.p[jxoffset+moff[2]]);
 
                 Vec jx3=Vec::Load(p,&jx_arr.p[jxoffset+moff[3]]);
                 svfloat64_t rhox3=svld1_gather_u64index_f64(p,&xrhocells[3+irhox],rho_index);
                 jx3+=rhox3;
                 jx3.Store(p,&jx_arr.p[jxoffset+moff[3]]);
 
                 Vec jx4=Vec::Load(p,&jx_arr.p[jxoffset+moff[4]]);
                 svfloat64_t rhox4=svld1_gather_u64index_f64(p,&xrhocells[4+irhox],rho_index);
                 jx4+=rhox4;
                 jx4.Store(p,&jx_arr.p[jxoffset+moff[4]]);
 
                 Vec jx5=Vec::Load(p,&jx_arr.p[jxoffset+moff[5]]);
                 svfloat64_t rhox5=svld1_gather_u64index_f64(p,&xrhocells[5+irhox],rho_index);
                 jx5+=rhox5;
                 jx5.Store(p,&jx_arr.p[jxoffset+moff[5]]);
 
                 Vec jx6=Vec::Load(p,&jx_arr.p[jxoffset+moff[6]]);
                 svfloat64_t rhox6=svld1_gather_u64index_f64(p,&xrhocells[6+irhox],rho_index);
                 jx6+=rhox6;
                 jx6.Store(p,&jx_arr.p[jxoffset+moff[6]]);
 
                 Vec jx7=Vec::Load(p,&jx_arr.p[jxoffset+moff[7]]);
                 svfloat64_t rhox7=svld1_gather_u64index_f64(p,&xrhocells[7+irhox],rho_index);
                 jx7+=rhox7;
                 jx7.Store(p,&jx_arr.p[jxoffset+moff[7]]);
                 
                 // y
                 // uint64_t irhoy = ix + iy * yjstride + iz * ykstride;
                 // svuint64_t rhoy_index = svindex_u64(irhoy, 8ULL);
                 // long jyoffset = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
                 long yoffset = ix + iy * yjstride + iz * ykstride;
                 long jyoffset=yoffset;
                 long irhoy=8*yoffset;
                 Vec jy0=Vec::Load(p,&jy_arr.p[jyoffset+moff[0]]);
                 svfloat64_t rhoy0=svld1_gather_u64index_f64(p,&yrhocells[0+irhoy],rho_index);
                 jy0+=rhoy0;
                 jy0.Store(p,&jy_arr.p[jyoffset+moff[0]]);
 
                 Vec jy1=Vec::Load(p,&jy_arr.p[jyoffset+moff[1]]);
                 svfloat64_t rhoy1=svld1_gather_u64index_f64(p,&yrhocells[1+irhoy],rho_index);
                 jy1+=rhoy1;
                 jy1.Store(p,&jy_arr.p[jyoffset+moff[1]]);
 
                 Vec jy2=Vec::Load(p,&jy_arr.p[jyoffset+moff[2]]);
                 svfloat64_t rhoy2=svld1_gather_u64index_f64(p,&yrhocells[2+irhoy],rho_index);
                 jy2+=rhoy2;
                 jy2.Store(p,&jy_arr.p[jyoffset+moff[2]]);
 
                 Vec jy3=Vec::Load(p,&jy_arr.p[jyoffset+moff[3]]);
                 svfloat64_t rhoy3=svld1_gather_u64index_f64(p,&yrhocells[3+irhoy],rho_index);
                 jy3+=rhoy3;
                 jy3.Store(p,&jy_arr.p[jyoffset+moff[3]]);
 
                 Vec jy4=Vec::Load(p,&jy_arr.p[jyoffset+moff[4]]);
                 svfloat64_t rhoy4=svld1_gather_u64index_f64(p,&yrhocells[4+irhoy],rho_index);
                 jy4+=rhoy4;
                 jy4.Store(p,&jy_arr.p[jyoffset+moff[4]]);
 
                 Vec jy5=Vec::Load(p,&jy_arr.p[jyoffset+moff[5]]);
                 svfloat64_t rhoy5=svld1_gather_u64index_f64(p,&yrhocells[5+irhoy],rho_index);
                 jy5+=rhoy5;
                 jy5.Store(p,&jy_arr.p[jyoffset+moff[5]]);
 
                 Vec jy6=Vec::Load(p,&jy_arr.p[jyoffset+moff[6]]);
                 svfloat64_t rhoy6=svld1_gather_u64index_f64(p,&yrhocells[6+irhoy],rho_index);
                 jy6+=rhoy6;
                 jy6.Store(p,&jy_arr.p[jyoffset+moff[6]]);
 
                 Vec jy7=Vec::Load(p,&jy_arr.p[jyoffset+moff[7]]);
                 svfloat64_t rhoy7=svld1_gather_u64index_f64(p,&yrhocells[7+irhoy],rho_index);
                 jy7+=rhoy7;
                 jy7.Store(p,&jy_arr.p[jyoffset+moff[7]]);
 
                 // z
                 // uint64_t irhoz = ix + iy * zjstride + iz * zkstride;
                 // svuint64_t rhoz_index = svindex_u64(irhoz, 8ULL);
                 // long jzoffset = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
                 long zoffset = ix + iy * zjstride + iz * zkstride;
                 long jzoffset=zoffset;
                 long irhoz=8*zoffset;
                 Vec jz0=Vec::Load(p,&jz_arr.p[jzoffset+moff[0]]);
                 svfloat64_t rhoz0=svld1_gather_u64index_f64(p,&zrhocells[0+irhoz],rho_index);
                 jz0+=rhoz0;
                 jz0.Store(p,&jz_arr.p[jzoffset+moff[0]]);
 
                 Vec jz1=Vec::Load(p,&jz_arr.p[jzoffset+moff[1]]);
                 svfloat64_t rhoz1=svld1_gather_u64index_f64(p,&zrhocells[1+irhoz],rho_index);
                 jz1+=rhoz1;
                 jz1.Store(p,&jz_arr.p[jzoffset+moff[1]]);
 
                 Vec jz2=Vec::Load(p,&jz_arr.p[jzoffset+moff[2]]);
                 svfloat64_t rhoz2=svld1_gather_u64index_f64(p,&zrhocells[2+irhoz],rho_index);
                 jz2+=rhoz2;
                 jz2.Store(p,&jz_arr.p[jzoffset+moff[2]]);
 
                 Vec jz3=Vec::Load(p,&jz_arr.p[jzoffset+moff[3]]);
                 svfloat64_t rhoz3=svld1_gather_u64index_f64(p,&zrhocells[3+irhoz],rho_index);
                 jz3+=rhoz3;
                 jz3.Store(p,&jz_arr.p[jzoffset+moff[3]]);
 
                 Vec jz4=Vec::Load(p,&jz_arr.p[jzoffset+moff[4]]);
                 svfloat64_t rhoz4=svld1_gather_u64index_f64(p,&zrhocells[4+irhoz],rho_index);
                 jz4+=rhoz4;
                 jz4.Store(p,&jz_arr.p[jzoffset+moff[4]]);
 
                 Vec jz5=Vec::Load(p,&jz_arr.p[jzoffset+moff[5]]);
                 svfloat64_t rhoz5=svld1_gather_u64index_f64(p,&zrhocells[5+irhoz],rho_index);
                 jz5+=rhoz5;
                 jz5.Store(p,&jz_arr.p[jzoffset+moff[5]]);
 
                 Vec jz6=Vec::Load(p,&jz_arr.p[jzoffset+moff[6]]);
                 svfloat64_t rhoz6=svld1_gather_u64index_f64(p,&zrhocells[6+irhoz],rho_index);
                 jz6+=rhoz6;
                 jz6.Store(p,&jz_arr.p[jzoffset+moff[6]]);
 
                 Vec jz7=Vec::Load(p,&jz_arr.p[jzoffset+moff[7]]);
                 svfloat64_t rhoz7=svld1_gather_u64index_f64(p,&zrhocells[7+irhoz],rho_index);
                 jz7+=rhoz7;
                 jz7.Store(p,&jz_arr.p[jzoffset+moff[7]]);
 
                 // svetime[1]=rdtscv();
                 // reduce_time+=(svetime[1]-svetime[0]);
             }
         }
     }
     // auto total_stop=high_resolution_clock::now();
     // duration<double> total_elapse = total_stop-total_start;
     // total_time = total_elapse.count();
     // printf("\n SVE noblock Sort: total time: %lf s, precompute: %ld, sort_time %ld cale_time: %ld, reduce_time: %ld \n",
     //     total_time,     precompute,   sort_time,  cale_time,     reduce_time);
     // printf("\t noblock Sort: %ld, Count: %ld, Presum %ld binlist: %ld, Branch: %ld \n",
     //         sort_time,      count_time,   presum_time,  binlist_time, branch_time);
 
     // total_time[1]=rdtscv();
     // total_time[2]=(total_time[1]-total_time[0]);
     // printf("total time: %d, precompute: %d, cale_time: %d, reduce_time: %d \n",
     //         total_time,     precompute,     cale_time,     reduce_time);
     // amrex::Abort("END!");
 
 }
 
 // 分桶加分块
 template <int depos_order>
 void doDepositionShapeN_sve_sort_real2 (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Dim3 hi,
                          amrex::Dim3 len,
                          amrex::Real q,
                          std::vector<double>& test,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     // uint64_t total_time[3]={0};
     using namespace std::chrono;
     using namespace amrex::literals;
     double total_time=0;
     // auto total_start=high_resolution_clock::now();
     uint64_t precompute=0;
     uint64_t cale_time=0;
     uint64_t sort_time=0;
         uint64_t count_time=0;
         uint64_t presum_time=0;
         uint64_t binlist_time=0;
     uint64_t reduce_time=0;
     uint64_t svetime[3]={0};
     uint64_t branch_time=0;
     
     
     
 
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z; 
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
 
     constexpr int nshapes = depos_order + 1;
     const int block_size=256;
     int n_blocks=np_to_deposit/block_size;
     int vl=svcntd();
 
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
 
     auto compute_shape_factor_v2 = [](double* sx[], Vec xmid, svbool_t p) {
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         sx0.Store(p, sx[0]);
         sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
     const long numcell = jx_fab.box().numPts();
     // const long xnumcell = jx_fab.box().numPts();
 
     // auto xrhocells = std::make_unique<double[]>(8*numcell);
     // auto yrhocells = std::make_unique<double[]>(8*numcell);
     // auto zrhocells = std::make_unique<double[]>(8*numcell);
     std::vector<double> xrhocells(8*numcell,0.0);
     std::vector<double> yrhocells(8*numcell,0.0);
     std::vector<double> zrhocells(8*numcell,0.0);
     // one roll x
     uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
     uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
     uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
     long nx=xjstride;
     long nxy=xkstride;
     long moff[8] = {0, 1, nx, nx+1, nxy, nxy+1, nx+nxy, nx+nxy+1};
     svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
     svbool_t px = svcmpeq_n_u64(svptrue_b64(), rmx_v, 0);
     svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
     svbool_t py = svcmpeq_n_u64(svptrue_b64(), rmy_v, 0);
     svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
     svbool_t pz = svcmpeq_n_u64(svptrue_b64(), rmz_v, 0);
 
     std::vector<long> xcount(numcell,0);
     std::vector<int> xpresum(numcell+1,0);
     std::vector<int> xbinList(np_to_deposit,-1);
     
     std::vector<amrex::Real> wqx(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqy(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqz(np_to_deposit, 0.0);
 
     std::vector<std::vector<amrex::Real>> sx_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
     std::vector<std::vector<amrex::Real>> sy_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
     std::vector<std::vector<amrex::Real>> sz_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
 
     // some place dont have particle
     alignas(64) long xoffsets[np_to_deposit];
     
     for(int block_id=0;block_id<n_blocks;block_id++){
         alignas(64) long block_ip=block_id*block_size;
          
         const int loop_size = std::min(block_size, static_cast<int>(np_to_deposit-block_ip));
         for(int iip=0;iip<loop_size;iip+=vl){
             // svetime[0]=rdtscv();
             long ip=iip+block_ip;
 
             // 计算基本物理量
             svbool_t p=svwhilele_b64(ip,np_to_deposit);
             // Inverse of Lorentz factor gamma
             Vec uxp_v=Vec::Load(p,&uxp[ip]);
             Vec uyp_v=Vec::Load(p,&uyp[ip]);
             Vec uzp_v=Vec::Load(p,&uzp[ip]);
             Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                         + uyp_v * uyp_v * clightsq
                                         + uzp_v * uzp_v * clightsq).Sqrt();
             // Product of particle charges and weights
             Vec wp_v=Vec::Load(p,&wp[ip]);
             Vec wq_v = q * wp_v;
 
             // Current particle positions (in physical units)
             Vec xp = Vec::Load(p, &mx[ip]);
             Vec yp = Vec::Load(p, &my[ip]);
             Vec zp = Vec::Load(p, &mz[ip]);
 
             // Particle velocities
             Vec vx_v = uxp_v * gaminv;
             Vec vy_v = uyp_v * gaminv;
             Vec vz_v = uzp_v * gaminv;
 
             // if (do_ionization) wq *= ion_lev[iip];
             Vec wqx_v = wq_v * invvol * vx_v;
             Vec wqy_v = wq_v * invvol * vy_v;
             Vec wqz_v = wq_v * invvol * vz_v;
 
             wqx_v.Store(p, &wqx[ip]);
             wqy_v.Store(p, &wqy[ip]);
             wqz_v.Store(p, &wqz[ip]);
 
             // Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x - 0.5;
             // Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y - 0.5;
             // Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z - 0.5;
             Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x;
             Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y;
             Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z;
 
             double* sx_temp[nshapes] = {&sx_m[0][ip], &sx_m[1][ip]};
             intVec j_cellv = compute_shape_factor_v2( sx_temp, xmid, p);
             double* sy_temp[nshapes] = {&sy_m[0][ip], &sy_m[1][ip]};
             intVec k_cellv = compute_shape_factor_v2( sy_temp, ymid, p);
             double* sz_temp[nshapes] = {&sz_m[0][ip], &sz_m[1][ip]};
             intVec l_cellv = compute_shape_factor_v2( sz_temp, zmid, p); 
 
             intVec xoffsets_v = j_cellv + k_cellv * xjstride + l_cellv * xkstride;
 
             xoffsets_v.Store(p,&xoffsets[ip]);
 
             // svetime[1]=rdtscv();
             // precompute+=(svetime[1]-svetime[0]); 
         }
     }
     // count
     // svetime[0]=rdtscv();
     // std::vector<long> xcount_tmp(numcell,0);
     for(int block_id=0;block_id<n_blocks;block_id++){
         alignas(64) long block_ip=block_id*block_size;
         const int loop_size = std::min(block_size, static_cast<int>(np_to_deposit-block_ip));
         // std::fill(xcount_tmp.begin(),xcount_tmp.end(),0);
         // if(!xcount_tmp.empty()){
         //     std::memset(xcount_tmp.data(),0,numcell*sizeof(long));
         // }
         for(int iip=0;iip<loop_size;iip++){
             long ip=iip+block_ip;
             // long ip=iip+block_ip;
             xcount[xoffsets[ip]]++;
         }
         // can sve
         // for(int c=0;c<numcell;c++){
         //     xcount[c]+=xcount_tmp[c];
         // }
     }
     // svetime[1]=rdtscv();
     // count_time+=(svetime[1]-svetime[0]);
     // presum
     // svetime[0]=rdtscv();
     for(int c=1;c<=numcell;c++){
         xpresum[c]=xpresum[c-1]+xcount[c-1];
     }
     // svetime[1]=rdtscv();
     // presum_time+=(svetime[1]-svetime[0]);
     // divide bin
     // svetime[0]=rdtscv();
     for(int block_id=0;block_id<n_blocks;block_id++){
         alignas(64) long block_ip=block_id*block_size;
         const int loop_size = std::min(block_size, static_cast<int>(np_to_deposit-block_ip));
         for(int iip=0;iip<loop_size;iip++){
             long ip=iip+block_ip;
             int xoffset = xoffsets[ip];
             // long ip=ip+block_ip;
             xbinList[xpresum[xoffset]]=ip;
             xpresum[xoffset]++;
         }
     }
     // svetime[1]=rdtscv();
     // binlist_time+=(svetime[1]-svetime[0]);
     // sort_time+=(count_time+binlist_time+presum_time);
     // calculate
     for(int c=1;c<=numcell;c++){
         // svetime[0]=rdtscv();
         
         int start = xpresum[c-1];
         int end = xpresum[c];
         if(start==end){
             // svetime[1]=rdtscv();
             // branch_time+=(svetime[1]-svetime[0]);
             continue;
         }
         // svetime[1]=rdtscv();
         // branch_time+=(svetime[1]-svetime[0]);
         svbool_t p = svptrue_b64();
         Vec wwx = Vec::Load(p,&xrhocells[8*c]);
         Vec wwy = Vec::Load(p,&yrhocells[8*c]);
         Vec wwz = Vec::Load(p,&zrhocells[8*c]);
         for(int idx=start;idx<end;idx++){
             alignas(64) long ip=xbinList[idx];
             printf("ip %d sx_m[0] %lf sx_m[1] %lf \n",
                         ip,   sx_m[0][ip],  sx_m[1][ip]);
             Vec sx0=Vec(sx_m[0][ip]);
             Vec sx1=Vec(sx_m[1][ip]);
             Vec sxv=svsel_f64(px,sx0,sx1);
             Vec sy0=Vec(sy_m[0][ip]);
             Vec sy1=Vec(sy_m[1][ip]);
             Vec syv=svsel_f64(py,sy0,sy1);
             Vec sz0=Vec(sz_m[0][ip]);
             Vec sz1=Vec(sz_m[1][ip]);
             Vec szv=svsel_f64(pz,sz0,sz1);
             // printf("Error 2! \n");
             Vec s = sxv*syv*szv;
             Vec jx_v=s*wqx[ip];
             jx_v.Store(p,&test[ip*8]);
             wwx+=jx_v;
             Vec jy_v=s*wqy[ip];
             wwy+=jy_v;              
             Vec jz_v=s*wqz[ip];
             wwz+=jz_v;
         }
        
         wwx.Store(p,&xrhocells[8*c]);
         // test[c]=xrhocells[8*c]
         wwy.Store(p,&yrhocells[8*c]);
         wwz.Store(p,&zrhocells[8*c]);
         // svetime[1]=rdtscv();
         // cale_time+=(svetime[1]-svetime[0]);
     }
     
                    
     // TODO: reduction needs  to modify out of this func
     // ix iy iz in numcell
     // this can be SME
     int errcount=0;
     for (int iz = 0; iz <= len.z; ++iz) {
         for (int iy = 0; iy <= len.y; ++iy) { 
             for (int ix = 0; ix <= len.x; ix+=vl) {
                 // svetime[0]=rdtscv();
 
                 // vector
                 svbool_t p=svwhilele_b64(ix,len.x);
                 // long j = lo.x + ix;
                 // long k = lo.y + iy;
                 // long l = lo.z + iz;
                 // x
                 // uint64_t irhox = 8*(ix + iy * xjstride + iz * xkstride);
                 // svuint64_t rhox_index = svindex_u64(0, 8ULL);
                 // long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                 svuint64_t rho_index = svindex_u64(0ULL, 8ULL);
                 long xoffset=ix + iy * xjstride + iz * xkstride;
                 long jxoffset=xoffset;
                 long irhox=8*xoffset;
                 Vec jx0=Vec::Load(p,&jx_arr.p[jxoffset+moff[0]]);
                 svfloat64_t rhox0=svld1_gather_u64index_f64(p,&xrhocells[0+irhox],rho_index);
                 jx0+=rhox0;
                 jx0.Store(p,&jx_arr.p[jxoffset+moff[0]]);
 
                 Vec jx1=Vec::Load(p,&jx_arr.p[jxoffset+moff[1]]);
                 svfloat64_t rhox1=svld1_gather_u64index_f64(p,&xrhocells[1+irhox],rho_index);
                 jx1+=rhox1;
                 jx1.Store(p,&jx_arr.p[jxoffset+moff[1]]);
 
                 Vec jx2=Vec::Load(p,&jx_arr.p[jxoffset+moff[2]]);
                 svfloat64_t rhox2=svld1_gather_u64index_f64(p,&xrhocells[2+irhox],rho_index);
                 jx2+=rhox2;
                 jx2.Store(p,&jx_arr.p[jxoffset+moff[2]]);
 
                 Vec jx3=Vec::Load(p,&jx_arr.p[jxoffset+moff[3]]);
                 svfloat64_t rhox3=svld1_gather_u64index_f64(p,&xrhocells[3+irhox],rho_index);
                 jx3+=rhox3;
                 jx3.Store(p,&jx_arr.p[jxoffset+moff[3]]);
 
                 Vec jx4=Vec::Load(p,&jx_arr.p[jxoffset+moff[4]]);
                 svfloat64_t rhox4=svld1_gather_u64index_f64(p,&xrhocells[4+irhox],rho_index);
                 jx4+=rhox4;
                 jx4.Store(p,&jx_arr.p[jxoffset+moff[4]]);
 
                 Vec jx5=Vec::Load(p,&jx_arr.p[jxoffset+moff[5]]);
                 svfloat64_t rhox5=svld1_gather_u64index_f64(p,&xrhocells[5+irhox],rho_index);
                 jx5+=rhox5;
                 jx5.Store(p,&jx_arr.p[jxoffset+moff[5]]);
 
                 Vec jx6=Vec::Load(p,&jx_arr.p[jxoffset+moff[6]]);
                 svfloat64_t rhox6=svld1_gather_u64index_f64(p,&xrhocells[6+irhox],rho_index);
                 jx6+=rhox6;
                 jx6.Store(p,&jx_arr.p[jxoffset+moff[6]]);
 
                 Vec jx7=Vec::Load(p,&jx_arr.p[jxoffset+moff[7]]);
                 svfloat64_t rhox7=svld1_gather_u64index_f64(p,&xrhocells[7+irhox],rho_index);
                 jx7+=rhox7;
                 jx7.Store(p,&jx_arr.p[jxoffset+moff[7]]);
                 for(int ii=0;ii<8;ii++){
                     double jxorg=jx_arr.p[ii+jxoffset+moff[0]];
                     if(jxorg>1e-2){
                         // printf("jxoffset %ld jxoffset1 %ld \n",jxoffset+moff[idx],jxoffset1+moff[idx]);
                         printf("ix %d iy %d iz %d: jxorg %lf \n",
                             ix,  iy,   iz,  jxorg );
                         errcount++;
                         if(errcount>10){
                             // printf("%d %d %d %d \n",len.x,len.y,len.z,jx_fab.box().numPts());
                             // amrex::Abort("ERROR 10 ! jxorg and jxsve");
                         }
                     }
                 }
                 
                 // y
                 // uint64_t irhoy = ix + iy * yjstride + iz * ykstride;
                 // svuint64_t rhoy_index = svindex_u64(irhoy, 8ULL);
                 // long jyoffset = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
                 long yoffset = ix + iy * yjstride + iz * ykstride;
                 long jyoffset=yoffset;
                 long irhoy=8*yoffset;
                 Vec jy0=Vec::Load(p,&jy_arr.p[jyoffset+moff[0]]);
                 svfloat64_t rhoy0=svld1_gather_u64index_f64(p,&yrhocells[0+irhoy],rho_index);
                 jy0+=rhoy0;
                 jy0.Store(p,&jy_arr.p[jyoffset+moff[0]]);
 
                 Vec jy1=Vec::Load(p,&jy_arr.p[jyoffset+moff[1]]);
                 svfloat64_t rhoy1=svld1_gather_u64index_f64(p,&yrhocells[1+irhoy],rho_index);
                 jy1+=rhoy1;
                 jy1.Store(p,&jy_arr.p[jyoffset+moff[1]]);
 
                 Vec jy2=Vec::Load(p,&jy_arr.p[jyoffset+moff[2]]);
                 svfloat64_t rhoy2=svld1_gather_u64index_f64(p,&yrhocells[2+irhoy],rho_index);
                 jy2+=rhoy2;
                 jy2.Store(p,&jy_arr.p[jyoffset+moff[2]]);
 
                 Vec jy3=Vec::Load(p,&jy_arr.p[jyoffset+moff[3]]);
                 svfloat64_t rhoy3=svld1_gather_u64index_f64(p,&yrhocells[3+irhoy],rho_index);
                 jy3+=rhoy3;
                 jy3.Store(p,&jy_arr.p[jyoffset+moff[3]]);
 
                 Vec jy4=Vec::Load(p,&jy_arr.p[jyoffset+moff[4]]);
                 svfloat64_t rhoy4=svld1_gather_u64index_f64(p,&yrhocells[4+irhoy],rho_index);
                 jy4+=rhoy4;
                 jy4.Store(p,&jy_arr.p[jyoffset+moff[4]]);
 
                 Vec jy5=Vec::Load(p,&jy_arr.p[jyoffset+moff[5]]);
                 svfloat64_t rhoy5=svld1_gather_u64index_f64(p,&yrhocells[5+irhoy],rho_index);
                 jy5+=rhoy5;
                 jy5.Store(p,&jy_arr.p[jyoffset+moff[5]]);
 
                 Vec jy6=Vec::Load(p,&jy_arr.p[jyoffset+moff[6]]);
                 svfloat64_t rhoy6=svld1_gather_u64index_f64(p,&yrhocells[6+irhoy],rho_index);
                 jy6+=rhoy6;
                 jy6.Store(p,&jy_arr.p[jyoffset+moff[6]]);
 
                 Vec jy7=Vec::Load(p,&jy_arr.p[jyoffset+moff[7]]);
                 svfloat64_t rhoy7=svld1_gather_u64index_f64(p,&yrhocells[7+irhoy],rho_index);
                 jy7+=rhoy7;
                 jy7.Store(p,&jy_arr.p[jyoffset+moff[7]]);
 
                 // z
                 // uint64_t irhoz = ix + iy * zjstride + iz * zkstride;
                 // svuint64_t rhoz_index = svindex_u64(irhoz, 8ULL);
                 // long jzoffset = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
                 long zoffset = ix + iy * zjstride + iz * zkstride;
                 long jzoffset=zoffset;
                 long irhoz=8*zoffset;
                 Vec jz0=Vec::Load(p,&jz_arr.p[jzoffset+moff[0]]);
                 svfloat64_t rhoz0=svld1_gather_u64index_f64(p,&zrhocells[0+irhoz],rho_index);
                 jz0+=rhoz0;
                 jz0.Store(p,&jz_arr.p[jzoffset+moff[0]]);
 
                 Vec jz1=Vec::Load(p,&jz_arr.p[jzoffset+moff[1]]);
                 svfloat64_t rhoz1=svld1_gather_u64index_f64(p,&zrhocells[1+irhoz],rho_index);
                 jz1+=rhoz1;
                 jz1.Store(p,&jz_arr.p[jzoffset+moff[1]]);
 
                 Vec jz2=Vec::Load(p,&jz_arr.p[jzoffset+moff[2]]);
                 svfloat64_t rhoz2=svld1_gather_u64index_f64(p,&zrhocells[2+irhoz],rho_index);
                 jz2+=rhoz2;
                 jz2.Store(p,&jz_arr.p[jzoffset+moff[2]]);
 
                 Vec jz3=Vec::Load(p,&jz_arr.p[jzoffset+moff[3]]);
                 svfloat64_t rhoz3=svld1_gather_u64index_f64(p,&zrhocells[3+irhoz],rho_index);
                 jz3+=rhoz3;
                 jz3.Store(p,&jz_arr.p[jzoffset+moff[3]]);
 
                 Vec jz4=Vec::Load(p,&jz_arr.p[jzoffset+moff[4]]);
                 svfloat64_t rhoz4=svld1_gather_u64index_f64(p,&zrhocells[4+irhoz],rho_index);
                 jz4+=rhoz4;
                 jz4.Store(p,&jz_arr.p[jzoffset+moff[4]]);
 
                 Vec jz5=Vec::Load(p,&jz_arr.p[jzoffset+moff[5]]);
                 svfloat64_t rhoz5=svld1_gather_u64index_f64(p,&zrhocells[5+irhoz],rho_index);
                 jz5+=rhoz5;
                 jz5.Store(p,&jz_arr.p[jzoffset+moff[5]]);
 
                 Vec jz6=Vec::Load(p,&jz_arr.p[jzoffset+moff[6]]);
                 svfloat64_t rhoz6=svld1_gather_u64index_f64(p,&zrhocells[6+irhoz],rho_index);
                 jz6+=rhoz6;
                 jz6.Store(p,&jz_arr.p[jzoffset+moff[6]]);
 
                 Vec jz7=Vec::Load(p,&jz_arr.p[jzoffset+moff[7]]);
                 svfloat64_t rhoz7=svld1_gather_u64index_f64(p,&zrhocells[7+irhoz],rho_index);
                 jz7+=rhoz7;
                 jz7.Store(p,&jz_arr.p[jzoffset+moff[7]]);
 
                 // svetime[1]=rdtscv();
                 // reduce_time+=(svetime[1]-svetime[0]);
             }
         }
     }
     // auto total_stop=high_resolution_clock::now();
     // duration<double> total_elapse = total_stop-total_start;
     // total_time = total_elapse.count();
     // printf("SVE Sort: total time: %lf s, precompute: %ld, sort_time %ld cale_time: %ld, reduce_time: %ld \n",
     //     total_time,     precompute,   sort_time,  cale_time,     reduce_time);
     // printf("\t Sort: %ld, Count: %ld, Presum %ld binlist: %ld, Branch: %ld \n",
     //         sort_time,      count_time,   presum_time,  binlist_time, branch_time);
 
     // total_time[1]=rdtscv();
     // total_time[2]=(total_time[1]-total_time[0]);
     // printf("total time: %d, precompute: %d, cale_time: %d, reduce_time: %d \n",
     //         total_time,     precompute,     cale_time,     reduce_time);
     // amrex::Abort("END!");
 
 }
 
 
 // not rhocell but particle simd, paper 2
 // with  data reuse
 template <int depos_order>
 void doDepositionShapeN_sve_jtmp2 (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Dim3 hi,
                          amrex::Dim3 len,
                          amrex::Real q,
                          std::vector<double>& test,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     // uint64_t total_time[3]={0};
     using namespace std::chrono;
     using namespace amrex::literals;
     double total_time=0;
     // auto total_start=high_resolution_clock::now();
     uint64_t precompute=0;
     uint64_t cale_time=0;
     uint64_t sort_time=0;
         uint64_t count_time=0;
         uint64_t presum_time=0;
         uint64_t binlist_time=0;
     uint64_t reduce_time=0;
     uint64_t svetime[3]={0};
     uint64_t branch_time=0;
     
     // total_time[0]=rdtscv();
     
 
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z; 
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
 
     constexpr int nshapes = depos_order + 1;
     // constexpr int nshapes = 2;
     int vl=svcntd();
 
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
 
     auto compute_shape_factor_v2 = [](double* sx[], Vec xmid, svbool_t p) {
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         sx0.Store(p, sx[0]);
         sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
     const int numcell = jx_fab.box().numPts();
     const int xnumcell = jx_fab.box().numPts();
 
     auto xrhocells = std::make_unique<double[]>(8*numcell);
     auto yrhocells = std::make_unique<double[]>(8*numcell);
     auto zrhocells = std::make_unique<double[]>(8*numcell);
     // one roll x
     uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
     uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
     uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
     long nx=xjstride;
     long nxy=xkstride;
     long moff[8] = {0, 1, nx, nx+1, nxy, nxy+1, nx+nxy, nx+nxy+1};
     svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
     svbool_t px = svcmpeq_n_u64(svptrue_b64(), rmx_v, 0);
     svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
     svbool_t py = svcmpeq_n_u64(svptrue_b64(), rmy_v, 0);
     svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
     svbool_t pz = svcmpeq_n_u64(svptrue_b64(), rmz_v, 0);
 
     std::vector<amrex::Real> wqx(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqy(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqz(np_to_deposit, 0.0);
 
     std::vector<std::vector<amrex::Real>> sx_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
     std::vector<std::vector<amrex::Real>> sy_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
     std::vector<std::vector<amrex::Real>> sz_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
 
     // some place dont have particle
     alignas(64) long xoffsets[np_to_deposit]; 
     std::vector<long> xcount(numcell,0);    
 
     for(long ip=0;ip<np_to_deposit;ip+=vl){
         // svetime[0]=rdtscv();
 
         // 计算基本物理量
         svbool_t p=svwhilele_b64(ip,np_to_deposit);
         // Inverse of Lorentz factor gamma
         Vec uxp_v=Vec::Load(p,&uxp[ip]);
         Vec uyp_v=Vec::Load(p,&uyp[ip]);
         Vec uzp_v=Vec::Load(p,&uzp[ip]);
         Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                     + uyp_v * uyp_v * clightsq
                                     + uzp_v * uzp_v * clightsq).Sqrt();
         // Product of particle charges and weights
         Vec wp_v=Vec::Load(p,&wp[ip]);
         Vec wq_v = q * wp_v;
 
         // Current particle positions (in physical units)
         Vec xp = Vec::Load(p, &mx[ip]);
         Vec yp = Vec::Load(p, &my[ip]);
         Vec zp = Vec::Load(p, &mz[ip]);
 
         // Particle velocities
         Vec vx_v = uxp_v * gaminv;
         Vec vy_v = uyp_v * gaminv;
         Vec vz_v = uzp_v * gaminv;
 
         // if (do_ionization) wq *= ion_lev[ip];
         Vec wqx_v = wq_v * invvol * vx_v;
         Vec wqy_v = wq_v * invvol * vy_v;
         Vec wqz_v = wq_v * invvol * vz_v;
 
         wqx_v.Store(p, &wqx[ip]);
         wqy_v.Store(p, &wqy[ip]);
         wqz_v.Store(p, &wqz[ip]);
 
         Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x;
         Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y;
         Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z;
 
         double* sx_temp[nshapes] = {&sx_m[0][ip], &sx_m[1][ip]};
         intVec j_cellv = compute_shape_factor_v2( sx_temp, xmid, p);
         double* sy_temp[nshapes] = {&sy_m[0][ip], &sy_m[1][ip]};
         intVec k_cellv = compute_shape_factor_v2( sy_temp, ymid, p);
         double* sz_temp[nshapes] = {&sz_m[0][ip], &sz_m[1][ip]};
         intVec l_cellv = compute_shape_factor_v2( sz_temp, zmid, p); 
 
         intVec xoffsets_v = j_cellv + k_cellv * xjstride + l_cellv * xkstride;
 
         xoffsets_v.Store(p,&xoffsets[ip]);
     }
     // svetime[0]=rdtscv();
     for(long ip=0;ip<np_to_deposit;ip++){
         xcount[xoffsets[ip]]++;
     }
     // svetime[1]=rdtscv();
     // count_time+=(svetime[1]-svetime[0]);
 
     std::vector<long> xpresum(numcell+1,0);
     // svetime[0]=rdtscv();
     for(int c=1;c<=numcell;c++){
         xpresum[c]=xpresum[c-1]+xcount[c-1];
     }
     // svetime[1]=rdtscv();
     // presum_time+=(svetime[1]-svetime[0]);
 
     std::vector<long> xbinList(np_to_deposit,-1);
     // svetime[0]=rdtscv();
     for(int ip=0;ip<np_to_deposit;ip++){
         long xoffset = xoffsets[ip];
         xbinList[xpresum[xoffset]]=ip;
         xpresum[xoffset]++;
     }
     // svetime[1]=rdtscv();
     // binlist_time+=(svetime[1]-svetime[0]);
     // sort_time+=(count_time+binlist_time+presum_time);
     // for (int iz = 0; iz <= len.z; ++iz) {
     //     for (int iy = 0; iy <= len.y; ++iy) { 
     //         for (int ix = 0; ix <= len.x; ix+=vl) {
     //             svbool_t p=svwhilele_b64(ix,len.x);
     //             int c=ix + iy * xjstride + iz * xkstride;
     // int ls=1;
     for(int c=1;c<=numcell;c+=vl){
         svbool_t p0=svwhilele_b64(c,numcell);
         intVec start_v=intVec::Load(p0,&xpresum[c-1]);
         intVec end_v=intVec::Load(p0,&xpresum[c]);
         intVec offset_v=end_v-start_v;
         svbool_t p=svcmpgt_n_s64(p0,offset_v, 0);
         int max_np=svmaxv_s64(p,offset_v);
         // long tipp[8]={0};
         // ip_v.Store(p,&tipp[0]);
         // for(int idx=0;idx<8;idx++){
         //     if(tipp[idx]>0){
         //         ls++;
         //         printf("ls %d np %d ip %ld \n",ls,np_to_deposit, tipp[idx]);
         //     }
         // }
         // long ip0=xbinList[xpresum[c]];
         // printf("np %d in %d \n",np_to_deposit,ip0);
         // svbool_t p_ip=svwhilelt_b64(ip0,np_to_deposit);
         // TODO 如果ip空了，没粒子了，咋办，也就会从list中取到错误没粒子的ip，
         // 必须保证粒子ip取超了都是0
         for (int iz = 0; iz < nshapes; ++iz) {
             const std::vector<double>& sz=sz_m[iz];
             for (int iy = 0; iy < nshapes; ++iy) {
                 const std::vector<double>& sy=sy_m[iy];
                 for (int ix = 0; ix < nshapes; ++ix) {
                     intVec in_start_v=start_v;
                     intVec in_offset_v=offset_v;
                     svbool_t in_p=p;
                     int in_max_np=max_np;
 
                     int coffset=c+ix + iy * xjstride + iz * xkstride;
                     Vec jx_arr_v=Vec::Load(p,&jx_arr.p[coffset]);
                     Vec jy_arr_v=Vec::Load(p,&jy_arr.p[coffset]);
                     Vec jz_arr_v=Vec::Load(p,&jz_arr.p[coffset]);
                     while(in_max_np>0){
                         intVec ip_v=svld1_gather_s64index_s64(in_p,&xbinList[0],in_start_v);
 
                         const std::vector<double>& sx=sx_m[ix];
                         Vec sx_v=svld1_gather_s64index_f64(in_p,&sx[0],ip_v);
                         // long ipp[8]={0};
                         // ip_v.Store(in_p,&ipp[0]);
                         // double sxx[8]={-1};
                         // sx_v.Store(in_p,&sxx[0]);
                         // for(int idx=0;idx<8;idx++){
                         //     if(sxx[idx]>0&&ix == 0){
                         //         // printf("ip %ld sx %lf \n",ipp[idx],sxx[idx]);
                         //         test[ipp[idx]]=sxx[idx];
                         //     }
                         // }
                         Vec sy_v=svld1_gather_s64index_f64(in_p,&sy[0],ip_v);
                         Vec sz_v=svld1_gather_s64index_f64(in_p,&sz[0],ip_v);
                         Vec s = sx_v * sy_v * sz_v;
                         Vec wqx_v=svld1_gather_s64index_f64(in_p,&wqx[0],ip_v);
                         Vec wqy_v=svld1_gather_s64index_f64(in_p,&wqy[0],ip_v);
                         Vec wqz_v=svld1_gather_s64index_f64(in_p,&wqz[0],ip_v);
                         jx_arr_v+=s* wqx_v;
                         jy_arr_v+=s* wqy_v;
                         jz_arr_v+=s* wqz_v;
                         
                         in_max_np--;
                         in_offset_v = svsub_s64_x(in_p, in_offset_v, intVec(1));
                         in_p=svcmpgt_n_s64(in_p, in_offset_v, 0);
                         in_start_v = svadd_s64_x(in_p, in_start_v, intVec(1));
                     }
                     jx_arr_v.Store(p,&jx_arr.p[coffset]);
                     jy_arr_v.Store(p,&jy_arr.p[coffset]);
                     jz_arr_v.Store(p,&jz_arr.p[coffset]);
                 }
             }
         }
     }
 }
 
 // not rhocell but particle simd, paper 2
 // with data reuse and lenx leny lenz loop
 // NO USE
 template <int depos_order>
 void doDepositionShapeN_sortforip_sme (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Dim3 hi,
                          amrex::Dim3 len,
                          amrex::Real q,
                          std::vector<double>& test,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     // uint64_t total_time[3]={0};
     using namespace std::chrono;
     using namespace amrex::literals;
     double total_time=0;
     // auto total_start=high_resolution_clock::now();
     uint64_t precompute=0;
     uint64_t cale_time=0;
     uint64_t sort_time=0;
         uint64_t count_time=0;
         uint64_t presum_time=0;
         uint64_t binlist_time=0;
     uint64_t reduce_time=0;
     uint64_t svetime[3]={0};
     uint64_t branch_time=0;
     
     // total_time[0]=rdtscv();
     
 
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z; 
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
 
     constexpr int nshapes = depos_order + 1;
     // constexpr int nshapes = 2;
     int vl=svcntd();
 
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
 
     auto compute_shape_factor_v2 = [](double* sx[], Vec xmid, svbool_t p) {
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         sx0.Store(p, sx[0]);
         sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
     const int numcell = jx_fab.box().numPts();
     const int xnumcell = jx_fab.box().numPts();
 
     auto xrhocells = std::make_unique<double[]>(8*numcell);
     auto yrhocells = std::make_unique<double[]>(8*numcell);
     auto zrhocells = std::make_unique<double[]>(8*numcell);
     // one roll x
     uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
     uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
     uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
     long nx=xjstride;
     long nxy=xkstride;
     long moff[8] = {0, 1, nx, nx+1, nxy, nxy+1, nx+nxy, nx+nxy+1};
     svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
     svbool_t px = svcmpeq_n_u64(svptrue_b64(), rmx_v, 0);
     svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
     svbool_t py = svcmpeq_n_u64(svptrue_b64(), rmy_v, 0);
     svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
     svbool_t pz = svcmpeq_n_u64(svptrue_b64(), rmz_v, 0);
 
     std::vector<amrex::Real> wqx(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqy(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqz(np_to_deposit, 0.0);
 
     std::vector<std::vector<amrex::Real>> sx_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
     std::vector<std::vector<amrex::Real>> sy_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
     std::vector<std::vector<amrex::Real>> sz_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
 
     // some place dont have particle
     alignas(64) long xoffsets[np_to_deposit]; 
     std::vector<long> xcount(numcell,0);    
 
     for(long ip=0;ip<np_to_deposit;ip+=vl){
         // svetime[0]=rdtscv();
 
         // 计算基本物理量
         svbool_t p=svwhilele_b64(ip,np_to_deposit);
         // Inverse of Lorentz factor gamma
         Vec uxp_v=Vec::Load(p,&uxp[ip]);
         Vec uyp_v=Vec::Load(p,&uyp[ip]);
         Vec uzp_v=Vec::Load(p,&uzp[ip]);
         Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                     + uyp_v * uyp_v * clightsq
                                     + uzp_v * uzp_v * clightsq).Sqrt();
         // Product of particle charges and weights
         Vec wp_v=Vec::Load(p,&wp[ip]);
         Vec wq_v = q * wp_v;
 
         // Current particle positions (in physical units)
         Vec xp = Vec::Load(p, &mx[ip]);
         Vec yp = Vec::Load(p, &my[ip]);
         Vec zp = Vec::Load(p, &mz[ip]);
 
         // Particle velocities
         Vec vx_v = uxp_v * gaminv;
         Vec vy_v = uyp_v * gaminv;
         Vec vz_v = uzp_v * gaminv;
 
         // if (do_ionization) wq *= ion_lev[ip];
         Vec wqx_v = wq_v * invvol * vx_v;
         Vec wqy_v = wq_v * invvol * vy_v;
         Vec wqz_v = wq_v * invvol * vz_v;
 
         wqx_v.Store(p, &wqx[ip]);
         wqy_v.Store(p, &wqy[ip]);
         wqz_v.Store(p, &wqz[ip]);
 
         Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x;
         Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y;
         Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z;
 
         double* sx_temp[nshapes] = {&sx_m[0][ip], &sx_m[1][ip]};
         intVec j_cellv = compute_shape_factor_v2( sx_temp, xmid, p);
         double* sy_temp[nshapes] = {&sy_m[0][ip], &sy_m[1][ip]};
         intVec k_cellv = compute_shape_factor_v2( sy_temp, ymid, p);
         double* sz_temp[nshapes] = {&sz_m[0][ip], &sz_m[1][ip]};
         intVec l_cellv = compute_shape_factor_v2( sz_temp, zmid, p); 
 
         intVec xoffsets_v = j_cellv + k_cellv * xjstride + l_cellv * xkstride;
 
         xoffsets_v.Store(p,&xoffsets[ip]);
     }
     // svetime[0]=rdtscv();
     for(long ip=0;ip<np_to_deposit;ip++){
         xcount[xoffsets[ip]]++;
     }
     // svetime[1]=rdtscv();
     // count_time+=(svetime[1]-svetime[0]);
 
     std::vector<long> xpresum(numcell+1,0);
     // svetime[0]=rdtscv();
     for(int c=1;c<=numcell;c++){
         xpresum[c]=xpresum[c-1]+xcount[c-1];
     }
     // svetime[1]=rdtscv();
     // presum_time+=(svetime[1]-svetime[0]);
 
     std::vector<long> xbinList(np_to_deposit,-1);
     // svetime[0]=rdtscv();
     for(int ip=0;ip<np_to_deposit;ip++){
         long xoffset = xoffsets[ip];
         xbinList[xpresum[xoffset]]=ip;
         xpresum[xoffset]++;
     }
     // svetime[1]=rdtscv();
     // binlist_time+=(svetime[1]-svetime[0]);
     // sort_time+=(count_time+binlist_time+presum_time);
     // for (int iz = 0; iz <= len.z; ++iz) {
     //     for (int iy = 0; iy <= len.y; ++iy) { 
     //         for (int ix = 0; ix <= len.x; ix+=vl) {
     //             svbool_t p=svwhilele_b64(ix,len.x);
     //             int c=ix + iy * xjstride + iz * xkstride;
     // int ls=1;
     // for(int c=1;c<=numcell;c+=vl){
     // SME
     for (int iiz = 0; iiz <= len.z; ++iiz) {
         for (int iiy = 0; iiy <= len.y; ++iiy) { 
             for(int iix = 0; iix <= len.x; iix+=vl){
                 int c=iix + iiy* xjstride + iiz * xkstride+1;
                 svbool_t p0=svwhilele_b64(iix,len.x);
                 intVec start_v=intVec::Load(p0,&xpresum[c-1]);
                 intVec end_v=intVec::Load(p0,&xpresum[c]);
                 intVec offset_v=end_v-start_v;
                 svbool_t p=svcmpgt_n_s64(p0,offset_v, 0);
                 int max_np=svmaxv_s64(p,offset_v);
                 // long tipp[8]={0};
                 // ip_v.Store(p,&tipp[0]);
                 // for(int idx=0;idx<8;idx++){
                 //     if(tipp[idx]>0){
                 //         ls++;
                 //         printf("ls %d np %d ip %ld \n",ls,np_to_deposit, tipp[idx]);
                 //     }
                 // }
                 // long ip0=xbinList[xpresum[c]];
                 // printf("np %d in %d \n",np_to_deposit,ip0);
                 // svbool_t p_ip=svwhilelt_b64(ip0,np_to_deposit);
                 for (int iz = 0; iz < nshapes; ++iz) {
                     const std::vector<double>& sz=sz_m[iz];
                     for (int iy = 0; iy < nshapes; ++iy) {
                         const std::vector<double>& sy=sy_m[iy];
                         for (int ix = 0; ix < nshapes; ++ix) {
                             intVec in_start_v=start_v;
                             intVec in_offset_v=offset_v;
                             svbool_t in_p=p;
                             int in_max_np=max_np;
 
                             int coffset=c+ix + iy * xjstride + iz * xkstride;
                             Vec jx_arr_v=Vec::Load(p,&jx_arr.p[coffset]);
                             Vec jy_arr_v=Vec::Load(p,&jy_arr.p[coffset]);
                             Vec jz_arr_v=Vec::Load(p,&jz_arr.p[coffset]);
                             while(in_max_np>0){
                                 intVec ip_v=svld1_gather_s64index_s64(in_p,&xbinList[0],in_start_v);
 
                                 const std::vector<double>& sx=sx_m[ix];
                                 Vec sx_v=svld1_gather_s64index_f64(in_p,&sx[0],ip_v);
                                 // long ipp[8]={0};
                                 // ip_v.Store(in_p,&ipp[0]);
                                 // double sxx[8]={-1};
                                 // sx_v.Store(in_p,&sxx[0]);
                                 // for(int idx=0;idx<8;idx++){
                                 //     if(sxx[idx]>0&&ix == 0){
                                 //         // printf("ip %ld sx %lf \n",ipp[idx],sxx[idx]);
                                 //         test[ipp[idx]]=sxx[idx];
                                 //     }
                                 // }
                                 Vec sy_v=svld1_gather_s64index_f64(in_p,&sy[0],ip_v);
                                 Vec sz_v=svld1_gather_s64index_f64(in_p,&sz[0],ip_v);
                                 Vec s = sx_v * sy_v * sz_v;
                                 Vec wqx_v=svld1_gather_s64index_f64(in_p,&wqx[0],ip_v);
                                 Vec wqy_v=svld1_gather_s64index_f64(in_p,&wqy[0],ip_v);
                                 Vec wqz_v=svld1_gather_s64index_f64(in_p,&wqz[0],ip_v);
                                 jx_arr_v+=s* wqx_v;
                                 jy_arr_v+=s* wqy_v;
                                 jz_arr_v+=s* wqz_v;
                                 
                                 in_max_np--;
                                 in_offset_v = svsub_s64_x(in_p, in_offset_v, intVec(1));
                                 in_p=svcmpgt_n_s64(in_p, in_offset_v, 0);
                                 in_start_v = svadd_s64_x(in_p, in_start_v, intVec(1));
                             }
                             jx_arr_v.Store(p,&jx_arr.p[coffset]);
                             jy_arr_v.Store(p,&jy_arr.p[coffset]);
                             jz_arr_v.Store(p,&jz_arr.p[coffset]);
                         }
                     }
                 }
             }
         }
     }
 }
 
 
 template <int depos_order>
 __arm_new("za") inline void sort_real_sme_kernal(
     const long numcell,
     const std::vector<int>& xpresum,
     const std::vector<int>& xbinList,
     std::vector<amrex::Real>& xrhocells,
     std::vector<amrex::Real>& yrhocells,
     std::vector<amrex::Real>& zrhocells,
     std::vector<std::vector<amrex::Real>>& sx_m,
     std::vector<std::vector<amrex::Real>>& sy_m,
     std::vector<std::vector<amrex::Real>>& sz_m,
     std::vector<amrex::Real>& wqx,
     std::vector<amrex::Real>& wqy,
     std::vector<amrex::Real>& wqz,
     std::vector<double>& test, amrex::Dim3 len
 )__arm_streaming
 {
     using namespace amrex::literals;
     uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
     uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
     uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
     long nx=len.x;
     long nxy=len.x*len.y;
     long moff[8] = {0, 1, nx, nx+1, nxy, nxy+1, nx+nxy, nx+nxy+1};
     svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
     svbool_t px = svcmpeq_n_u64(svptrue_b64(), rmx_v, 0);
     svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
     svbool_t py = svcmpeq_n_u64(svptrue_b64(), rmy_v, 0);
     svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
     svbool_t pz = svcmpeq_n_u64(svptrue_b64(), rmz_v, 0);
 
     svbool_t p_4=svwhilelt_b64(0,4);
     svbool_t p_4_8=svbic_z(svptrue_b64(),svptrue_b64(),p_4);
     svbool_t p0=svwhilelt_b64(0,2);
     svbool_t p1=svbic_z(p_4,p_4, p0);
     svbool_t p = svptrue_b64();
     MVec vzero(0);
 
     for(int c=1;c<=numcell;c+=2){       
         // int start = xpresum[c-1];
         // int end = xpresum[c];
         int start0 = xpresum[c-1];
         int start1 = xpresum[c];
         int len_ip0=start1-start0;
         int len_ip1=xpresum[c+1]-start1;
         int len_max=std::max(len_ip0,len_ip1);
 
         if(len_max<=0){
             continue;
         }
         int len_min=std::min(len_ip0,len_ip1);
         // printf("c %d/%d len %d len_ip0 %d len_ip1 %d \n",c,numcell, len,len_ip0,len_ip1);
        
         svzero_za();
         //TODO use cell+=2, to do 2cells particles depo simultaneously
         // for(int idx=start;idx<end;idx++){
         for(int idx=0;idx<len_min;idx++){
             int idx0=start0+idx;
             int idx1=start1+idx;
             int ip0=xbinList[idx0];
             int ip1=xbinList[idx1];
 
             MVec sz_v=svdup_n_f64(0);
             MVec sz_1 = svld1(p0,&sz_m[ip0][0]);
             sz_1*=wqx[ip0];
             sz_v=svsel(p0,sz_1,sz_v);
             // svbool_t p1=svwhilelt_b64(2,4);
             MVec sz_2 = svld1(p1,&sz_m[ip1-1][0]);
             sz_2*=wqx[ip1];
             sz_v=svsel(p1,sz_2,sz_v);
 
             MVec vx1=MVec::Load(p0, &sx_m[ip0][0]);
             MVec vx2=MVec::Load(p0, &sx_m[ip1][0]);
             MVec vy1=MVec::Load(p0, &sy_m[ip0][0]);
             MVec vy2=MVec::Load(p0, &sy_m[ip1][0]);
 
             const uint64_t x_indices[8]={0,2,0,2,1,3,1,3};
             MVec vx_broadcast=svtbl(svzip1(vx1,vx2),svld1_u64(svptrue_b64(),x_indices));
             const uint64_t y_indices[8]={0,0,2,2,1,1,3,3};
             MVec vy_broadcast=svtbl(svzip1(vy1,vy2),svld1_u64(svptrue_b64(),y_indices));
 
             MVec sxsy_v=vx_broadcast*vy_broadcast;
             // svzero_za();
             svmopa_za64_m(0, p_4, svptrue_b64(), sz_v, sxsy_v);
 
             // MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,0);
             // MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,0,2);
             // double wx0[8];
             // wxsxsysz0.Store(svptrue_b64(),&wx0[0]);
             // test[ip0]=wx0[0];
             // double wx1[8];
             // wxsxsysz1.Store(svptrue_b64(),&wx1[0]);
             // test[ip1]=wx1[4];
             // printf("ip0 %d: wx0[1] %lf, ip1 %d: wx1[5] %lf \n",ip0,wx0[1],ip1,wx1[5]);
             
 
         }
         
         // // MVec sxsysz = svread_hor_za64_m(vzero,p_4,0,j);
 
         MVec wwx = MVec::Load(p,&xrhocells[8*c]);
         MVec wwy = MVec::Load(p,&yrhocells[8*c]);
         MVec wwz = MVec::Load(p,&zrhocells[8*c]);
         MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,0);
         MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4,0,1);
         MVec B=svext(wxsxsysz1,wxsxsysz1,4);
         MVec s=svsel(p_4,wxsxsysz0,B);
         wwx+=s;
         MVec wwx1 = MVec::Load(p,&xrhocells[8*(c+1)]);
         MVec wwy1 = MVec::Load(p,&yrhocells[8*(c+1)]);
         MVec wwz1 = MVec::Load(p,&zrhocells[8*(c+1)]);
         MVec wxsxsysz10 = svread_hor_za64_m(vzero,p_4,0,2);
         MVec wxsxsysz11 = svread_hor_za64_m(vzero,p_4,0,3);
         MVec B1=svext(wxsxsysz11,wxsxsysz11,4);
         MVec s1=svsel(p_4,wxsxsysz10,B1);
         wwx1+=s1;
 
         // wwx.Store(p,&xrhocells[8*c]);
         // // test[c]=xrhocells[8*c];
         // wwy.Store(p,&yrhocells[8*c]);
         // wwz.Store(p,&zrhocells[8*c]); 
         // for(int idx=0;idx<len;idx++){
         MVec wwx2;
         MVec wwy2;
         MVec wwz2;
         int start=0;
         if(len_ip0<len_ip1){
             start=start1+len_min;
             wwx.Store(p,&xrhocells[8*c]);
             wwx2=wwx1;
             wwy2=wwy1;
             wwz2=wwz1;
         }else if(len_ip0>len_ip1){
             start=start0+len_min;
             wwx1.Store(p,&xrhocells[8*(c+1)]);
             wwx2=wwx;
             wwy2=wwy;
             wwz2=wwz;
         }else{
             continue;
         }
         // int start=(len_ip0>len_ip1 ? (start0+len_min):(start1+len_min));
         int end=start+len_max;
         for(int idx=start;idx<end;idx++){
         // for(int idx=start;idx<end;idx++){
             alignas(64) long ip=xbinList[idx];
             // printf("ip %d sx_m[0] %lf sx_m[1] %lf \n",
             //             ip,   sx_m[0][ip],  sx_m[1][ip]);
             MVec sx0=MVec(sx_m[ip][0]);
             MVec sx1=MVec(sx_m[ip][1]);
             MVec sxv=svsel_f64(px,sx0,sx1);
             MVec sy0=MVec(sy_m[ip][0]);
             MVec sy1=MVec(sy_m[ip][1]);
             MVec syv=svsel_f64(py,sy0,sy1);
             MVec sz0=MVec(sz_m[ip][0]);
             MVec sz1=MVec(sz_m[ip][1]);
             MVec szv=svsel_f64(pz,sz0,sz1);
             // printf("Error 2! \n");
             MVec s = sxv*syv*szv;
             MVec jx_v=s*wqx[ip];
             double test1[8]={0.};
             jx_v.Store(p,&test1[0]);
             test[ip]=test1[0];
             wwx2+=jx_v;
             MVec jy_v=s*wqy[ip];
             wwy2+=jy_v;              
             MVec jz_v=s*wqz[ip];
             wwz2+=jz_v;
         }
         if(len_ip0<len_ip1){
             wwx2.Store(p,&xrhocells[8*c]);
             // test[c]=xrhocells[8*c]
             wwy2.Store(p,&yrhocells[8*c]);
             wwz2.Store(p,&zrhocells[8*c]);
     
 
         }else if(len_ip0>len_ip1){
             wwx2.Store(p,&xrhocells[8*(c+1)]);
             // test[c]=xrhocells[8*c]
             wwy2.Store(p,&yrhocells[8*(c+1)]);
             wwz2.Store(p,&zrhocells[8*(c+1)]);
     
         }
         // wwx2.Store(p,&xrhocells[8*c]);
         // // test[c]=xrhocells[8*c]
         // wwy2.Store(p,&yrhocells[8*c]);
         // wwz2.Store(p,&zrhocells[8*c]);
 
     }
     
 
     
 
 
 }
 
 // one cell sme
 template <int depos_order>
 __arm_new("za") inline void sort_real_sme_kernal_2(
     const long numcell,
     const std::vector<int>& xpresum,
     const std::vector<int>& xbinList,
     std::vector<amrex::Real>& xrhocells,
     std::vector<amrex::Real>& yrhocells,
     std::vector<amrex::Real>& zrhocells,
     std::vector<amrex::Real>& sx_m,
     std::vector<amrex::Real>& sy_m,
     std::vector<amrex::Real>& sz_m,
     std::vector<amrex::Real>& wqx,
     std::vector<amrex::Real>& wqy,
     std::vector<amrex::Real>& wqz,
     std::vector<long>& test
 )__arm_streaming
 {
     using namespace amrex::literals;
     svbool_t p_4=svwhilelt_b64(0,4);
     svbool_t p_4_8=svbic_z(svptrue_b64(),svptrue_b64(),p_4);
     svbool_t p0=svwhilelt_b64(0,2);
     svbool_t p1=svbic_z(p_4,p_4, p0);
     svbool_t p = svptrue_b64();
     MVec vzero(0);
 
     for(int c=1;c<=numcell;c++){
         
         int start = xpresum[c-1];
         int end = xpresum[c];
         if(start==end){
             // svetime[1]=rdtscv();
             // branch_time+=(svetime[1]-svetime[0]);
             continue;
         }
         // svetime[1]=rdtscv();
         // branch_time+=(svetime[1]-svetime[0]);
         // svbool_t p = svptrue_b64();
         // MVec wwx = MVec::Load(p,&xrhocells[8*c]);
         // MVec wwy = MVec::Load(p,&yrhocells[8*c]);
         // MVec wwz = MVec::Load(p,&zrhocells[8*c]);
         // const int end_len = std::min(2, static_cast<int>(end-start));
         svzero_za();
         const int end1 = end-(end - start)%2;
         for(int idx=start;idx<end1;idx+=2){
             // sx={x[0],x[1],x2[0],x2[1]}
             // sysz={y1[0]z1[0],y1[1]z1[0],y1[0]z1[1],y1[1]z1[1],y2[0]z2[0],y2[1]z2[0],y2[0]z2[1],y2[1]z2[1]}
             int ip=xbinList[idx];
             int ip1=xbinList[idx+1];
             // printf("ip %d lenin %d \n",ip,end1-start);
             
             // MVec sx_v=svdup_n_f64(0);
             // MVec sx_1 = svld1(p0,&sx_m[ip][0]);
             // sx_1*=wqx[ip];
             // sx_v=svsel(p0,sx_1,sx_v);
             // // svbool_t p1=svwhilelt_b64(2,4);
             // MVec sx_2 = svld1(p1,&sx_m[ip1-1][0]);
             // sx_2*=wqx[ip1];
             // sx_v=svsel(p1,sx_2,sx_v);
             //
             // MVec vy1=MVec::Load(p0, &sy_m[ip][0]);
             // MVec vy2=MVec::Load(p0, &sy_m[ip1][0]);
             // MVec vz1=MVec::Load(p0, &sz_m[ip][0]);
             // MVec vz2=MVec::Load(p0, &sz_m[ip1][0]);
             //
             // const uint64_t y_indices[8]={0,2,0,2,1,3,1,3};
             // MVec vy_broadcast=svtbl(svzip1(vy1,vy2),svld1_u64(svptrue_b64(),y_indices));
             // const uint64_t z_indices[8]={0,0,2,2,1,1,3,3};
             // MVec vz_broadcast=svtbl(svzip1(vz1,vz2),svld1_u64(svptrue_b64(),z_indices));
             //
             // MVec sysz_v=vy_broadcast*vz_broadcast;
             // // svzero_za();
             // svmopa_za64_m(0, p_4, svptrue_b64(), sx_v, sysz_v);
             
             MVec sz_xv=svdup_n_f64(0);
             MVec sz_yv=svdup_n_f64(0);
             MVec sz_zv=svdup_n_f64(0);
             MVec sz_x1 = svld1(p0,&sz_m[ip*2]);
             MVec sz_x2 = svld1(p1,&sz_m[(ip1-1)*2]);
             MVec sz_y1 = sz_x1; 
             MVec sz_y2 = sz_x2; 
             MVec sz_z1 = sz_x1;
             MVec sz_z2 = sz_x2;
             // svbool_t p1=svwhilelt_b64(2,4);
             sz_x1*=wqx[ip];
             sz_xv=svsel(p0,sz_x1,sz_xv);
             sz_x2*=wqx[ip1];
             sz_xv=svsel(p1,sz_x2,sz_xv);
             sz_y1*=wqy[ip];
             sz_yv=svsel(p0,sz_y1,sz_yv);
             sz_y2*=wqy[ip1];
             sz_yv=svsel(p1,sz_y2,sz_yv);
             sz_z1*=wqz[ip];
             sz_zv=svsel(p0,sz_z1,sz_zv);
             sz_z2*=wqz[ip1];
             sz_zv=svsel(p1,sz_z2,sz_zv);
             // double vvs[8];
             // sz_xv.Store(p,&vvs[0]);
             // test[ip]=vvs[0];
             // test[ip1]=vvs[2];
 
             // test[ip]=wqx[ip];
             // test[ip1]=wqx[ip1];
 
             MVec vx1=MVec::Load(p0, &sx_m[ip*2]);
             MVec vx2=MVec::Load(p0, &sx_m[ip1*2]);
             // double vvs[8];
             // vx1.Store(p0,&vvs[0]);
             // test[ip]=vvs[0];
             // vx2.Store(p0,&vvs[0]);
             // test[ip1]=vvs[0];
 
             MVec vy1=MVec::Load(p0, &sy_m[ip*2]);
             MVec vy2=MVec::Load(p0, &sy_m[ip1*2]);
 
             const uint64_t x_indices[8]={0,2,0,2,1,3,1,3};
             MVec vx_broadcast=svtbl(svzip1(vx1,vx2),svld1_u64(svptrue_b64(),x_indices));
             const uint64_t y_indices[8]={0,0,2,2,1,1,3,3};
             MVec vy_broadcast=svtbl(svzip1(vy1,vy2),svld1_u64(svptrue_b64(),y_indices));
 
             // double vx[8]={sx_m[ip][0],sx_m[ip][1],sx_m[ip][0],sx_m[ip][1],sx_m[ip1][0],sx_m[ip1][1],sx_m[ip1][0],sx_m[ip1][1]};
             // double vy[8]={sy_m[ip][0],sy_m[ip][0],sy_m[ip][1],sy_m[ip][1],sy_m[ip1][0],sy_m[ip1][0],sy_m[ip1][1],sy_m[ip1][1]};
             // vx_broadcast=MVec::Load(p,&vx[0]);
             // vy_broadcast=MVec::Load(p,&vy[0]);
             MVec sxsy_v=vx_broadcast*vy_broadcast;
             // double vvs[8];
             // sxsy_v.Store(p,&vvs[0]);
             // for(int ii=0;ii<4;ii++){
             //     test[4*ip +ii]=vvs[0+ii];
             //     test[4*ip1+ii]=vvs[4+ii];
             // }
             
 
             // svzero_za();
             svmopa_za64_m(0, p_4, svptrue_b64(), sz_xv, sxsy_v);
             svmopa_za64_m(1, p_4, svptrue_b64(), sz_yv, sxsy_v);
             svmopa_za64_m(2, p_4, svptrue_b64(), sz_zv, sxsy_v);
 
             // MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,0);
             // MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,0,2);
             // double wx0[8];
             // wxsxsysz0.Store(svptrue_b64(),&wx0[0]);
             // double wx1[8];
             // wxsxsysz1.Store(svptrue_b64(),&wx1[0]);
             // for(int ii=0;ii<4;ii++){
             //     test[8*ip+ii]=wx0[0+ii];
             //     test[8*ip1+ii]=wx1[4+ii];
             // }
             // wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,1);
             // wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,0,3);
             // wx0[8];
             // wxsxsysz0.Store(svptrue_b64(),&wx0[0]);
             // wx1[8];
             // wxsxsysz1.Store(svptrue_b64(),&wx1[0]);
             // for(int ii=0;ii<4;ii++){
             //     test[8*ip+4+ii]=wx0[0+ii];
             //     test[8*ip1+4+ii]=wx1[4+ii];
             // }
 
             // MVec wwx = MVec::Load(p,&xrhocells[8*c]);
             // double wx0[8];
             // double wx1[8];
             // double wy0[8];
             // double wy1[8];
             // double wz0[8];
             // double wz1[8];
             // MVec wxsxsyszx0 = svread_hor_za64_m(vzero,p,0,0);
             // MVec wxsxsyszx1 = svread_hor_za64_m(vzero,p,0,1);
             // MVec wxsxsyszy0 = svread_hor_za64_m(vzero,p,1,0);
             // MVec wxsxsyszy1 = svread_hor_za64_m(vzero,p,1,1);
             // MVec wxsxsyszz0 = svread_hor_za64_m(vzero,p,2,0);
             // MVec wxsxsyszz1 = svread_hor_za64_m(vzero,p,2,1);
             // wxsxsyszx0.Store(svptrue_b64(),&wx0[0]);
             // wxsxsyszx1.Store(svptrue_b64(),&wx1[0]);
             // wxsxsyszy0.Store(svptrue_b64(),&wy0[0]);
             // wxsxsyszy1.Store(svptrue_b64(),&wy1[0]);
             // wxsxsyszz0.Store(svptrue_b64(),&wz0[0]);
             // wxsxsyszz1.Store(svptrue_b64(),&wz1[0]);
             // // for(int ii=0;ii<4;ii++){
             // //     xrhocells[8*c+ii]+=wx0[0+ii];
             // //     xrhocells[8*c+ii+4]+=wx1[0+ii];
             // //     yrhocells[8*c+ii]+=wy0[0+ii];
             // //     yrhocells[8*c+ii+4]+=wy1[0+ii];
             // //     zrhocells[8*c+ii]+=wz0[0+ii];
             // //     zrhocells[8*c+ii+4]+=wz1[0+ii];
             // //     // test[8*ip+ii]=wx0[0+ii];
             // //     // test[8*ip+4+ii]=wx1[0+ii];
             // // }
             // MVec s=svsplice(p_4,wxsxsyszx0,wxsxsyszx1);
             // wwx+=s;
             // wxsxsyszx0 = svread_hor_za64_m(vzero,p,0,2);
             // wxsxsyszx1 = svread_hor_za64_m(vzero,p,0,3);
             // wxsxsyszy0 = svread_hor_za64_m(vzero,p,1,2);
             // wxsxsyszy1 = svread_hor_za64_m(vzero,p,1,3);
             // wxsxsyszz0 = svread_hor_za64_m(vzero,p,2,2);
             // wxsxsyszz1 = svread_hor_za64_m(vzero,p,2,3);
             // wxsxsyszx0.Store(svptrue_b64(),&wx0[0]);
             // wxsxsyszx1.Store(svptrue_b64(),&wx1[0]);
             // wxsxsyszy0.Store(svptrue_b64(),&wy0[0]);
             // wxsxsyszy1.Store(svptrue_b64(),&wy1[0]);
             // wxsxsyszz0.Store(svptrue_b64(),&wz0[0]);
             // wxsxsyszz1.Store(svptrue_b64(),&wz1[0]); 
             // // for(int ii=0;ii<4;ii++){
             // //     xrhocells[8*c+ii]+=wx0[4+ii];
             // //     xrhocells[8*c+ii+4]+=wx1[4+ii];
             // //     yrhocells[8*c+ii]+=wy0[4+ii];
             // //     yrhocells[8*c+ii+4]+=wy1[4+ii];
             // //     zrhocells[8*c+ii]+=wz0[4+ii];
             // //     zrhocells[8*c+ii+4]+=wz1[4+ii];
             // //     // test[8*ip1+0+ii]=wx0[4+ii];
             // //     // test[8*ip1+4+ii]=wx1[4+ii];
             // // }
             // MVec B=svext(wxsxsyszx1,wxsxsyszx1,4);
             // s=svext(wxsxsyszx0,B,4);
             // wwx+=s;
             // wwx.Store(p,&xrhocells[8*c]);
         }
 
         // svzero_za();
         if((end - start)%2==1){
             int ip=xbinList[end1+1];   
             printf("ip %d len %d \n",ip,end-start);
             MVec sz_v=svdup_n_f64(0);
             MVec sz_1 = svld1(p0,&sz_m[ip*2]);
             sz_1*=wqx[ip];
             sz_v=svsel(p0,sz_1,sz_v);
             // svbool_t p1=svwhilelt_b64(2,4);
             MVec vx1=MVec::Load(p0, &sx_m[ip*2]);
             MVec vy1=MVec::Load(p0, &sy_m[ip*2]);
             MVec sxsy_v=svsplice(p0,vx1,vy1);
             // svzero_za();
             svmopa_za64_m(0, p0, p_4, sz_v, sxsy_v);
         }
 
         MVec wwx = MVec::Load(p,&xrhocells[8*c]);
         MVec wwy = MVec::Load(p,&yrhocells[8*c]);
         MVec wwz = MVec::Load(p,&zrhocells[8*c]);
         MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,0);
         MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4,0,1);
         // svfloat64x2_t ss=svcreate2_f64(wxsxsysz0,wxsxsysz0);
         // MVec B=svext(wxsxsysz1,wxsxsysz1,4);
         // MVec s=svsel(p_4,wxsxsysz0,B);
         MVec s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
         wwx+=s;
         wxsxsysz0 = svread_hor_za64_m(vzero,p_4_8,0,2);
         wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,0,3);
         MVec B=svext(wxsxsysz1,wxsxsysz1,4);
         s=svext(wxsxsysz0,B,4);
         // B=svext(wxsxsysz1,wxsxsysz1,4);
         // s=svsel(p_4,wxsxsysz0,B);
         // s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
         wwx+=s;
         wwx.Store(p,&xrhocells[8*c]);
         // test[c]=xrhocells[8*c];
         wwy.Store(p,&yrhocells[8*c]);
         wwz.Store(p,&zrhocells[8*c]); 
     }
 
 
 }
 
 template <int depos_order>
 __arm_new("za")  void sort_real_sme_kernal_3(
     const long numcell,
     const std::vector<int>& xpresum,
     const std::vector<int>& xbinList,
     std::vector<amrex::Real>& xrhocells,
     std::vector<amrex::Real>& yrhocells,
     std::vector<amrex::Real>& zrhocells,
     std::vector<amrex::Real>& sx_m,
     std::vector<amrex::Real>& sy_m,
     std::vector<amrex::Real>& sz_m,
     std::vector<amrex::Real>& wqx,
     std::vector<amrex::Real>& wqy,
     std::vector<amrex::Real>& wqz
 )__arm_streaming
 {
     using namespace amrex::literals;
     svbool_t p_4=svwhilelt_b64(0,4);
     svbool_t p_4_8=svbic_z(svptrue_b64(),svptrue_b64(),p_4);
     svbool_t p0=svwhilelt_b64(0,2);
     svbool_t p1=svbic_z(p_4,p_4, p0);
     svbool_t p = svptrue_b64();
     MVec vzero(0);
 
     for(int c=1;c<=numcell;c++){
         
         int start = xpresum[c-1];
         int end = xpresum[c];
         if(start==end){
             // svetime[1]=rdtscv();
             // branch_time+=(svetime[1]-svetime[0]);
             continue;
         }
         // svetime[1]=rdtscv();
         // branch_time+=(svetime[1]-svetime[0]);
         // svbool_t p = svptrue_b64();
         // MVec wwx = MVec::Load(p,&xrhocells[8*c]);
         // MVec wwy = MVec::Load(p,&yrhocells[8*c]);
         // MVec wwz = MVec::Load(p,&zrhocells[8*c]);
         // const int end_len = std::min(2, static_cast<int>(end-start));
         svzero_za();
         const int end1 = end-(end - start)%2;
         for(int idx=start;idx<end1;idx+=2){
             // sx={x[0],x[1],x2[0],x2[1]}
             // sysz={y1[0]z1[0],y1[1]z1[0],y1[0]z1[1],y1[1]z1[1],y2[0]z2[0],y2[1]z2[0],y2[0]z2[1],y2[1]z2[1]}
             int ip=xbinList[idx];
             int ip1=xbinList[idx+1];
             // printf("ip %d lenin %d \n",ip,end1-start);
             
             // MVec sx_v=svdup_n_f64(0);
             // MVec sx_1 = svld1(p0,&sx_m[ip][0]);
             // sx_1*=wqx[ip];
             // sx_v=svsel(p0,sx_1,sx_v);
             // // svbool_t p1=svwhilelt_b64(2,4);
             // MVec sx_2 = svld1(p1,&sx_m[ip1-1][0]);
             // sx_2*=wqx[ip1];
             // sx_v=svsel(p1,sx_2,sx_v);
             //
             // MVec vy1=MVec::Load(p0, &sy_m[ip][0]);
             // MVec vy2=MVec::Load(p0, &sy_m[ip1][0]);
             // MVec vz1=MVec::Load(p0, &sz_m[ip][0]);
             // MVec vz2=MVec::Load(p0, &sz_m[ip1][0]);
             //
             // const uint64_t y_indices[8]={0,2,0,2,1,3,1,3};
             // MVec vy_broadcast=svtbl(svzip1(vy1,vy2),svld1_u64(svptrue_b64(),y_indices));
             // const uint64_t z_indices[8]={0,0,2,2,1,1,3,3};
             // MVec vz_broadcast=svtbl(svzip1(vz1,vz2),svld1_u64(svptrue_b64(),z_indices));
             //
             // MVec sysz_v=vy_broadcast*vz_broadcast;
             // // svzero_za();
             // svmopa_za64_m(0, p_4, svptrue_b64(), sx_v, sysz_v);
             
             MVec sz_xv=svdup_n_f64(0);
             MVec sz_yv=svdup_n_f64(0);
             MVec sz_zv=svdup_n_f64(0);
             MVec sz_x1 = svld1(p0,&sz_m[ip*2]);
             MVec sz_x2 = svld1(p1,&sz_m[(ip1-1)*2]);
             MVec sz_y1 = sz_x1; 
             MVec sz_y2 = sz_x2; 
             MVec sz_z1 = sz_x1;
             MVec sz_z2 = sz_x2;
             // svbool_t p1=svwhilelt_b64(2,4);
             sz_x1*=wqx[ip];
             sz_xv=svsel(p0,sz_x1,sz_xv);
             sz_x2*=wqx[ip1];
             sz_xv=svsel(p1,sz_x2,sz_xv);
             sz_y1*=wqy[ip];
             sz_yv=svsel(p0,sz_y1,sz_yv);
             sz_y2*=wqy[ip1];
             sz_yv=svsel(p1,sz_y2,sz_yv);
             sz_z1*=wqz[ip];
             sz_zv=svsel(p0,sz_z1,sz_zv);
             sz_z2*=wqz[ip1];
             sz_zv=svsel(p1,sz_z2,sz_zv);
             // double vvs[8];
             // sz_xv.Store(p,&vvs[0]);
             // test[ip]=vvs[0];
             // test[ip1]=vvs[2];
 
             // test[ip]=wqx[ip];
             // test[ip1]=wqx[ip1];
 
             MVec vx1=MVec::Load(p0, &sx_m[ip*2]);
             MVec vx2=MVec::Load(p0, &sx_m[ip1*2]);
             // double vvs[8];
             // vx1.Store(p0,&vvs[0]);
             // test[ip]=vvs[0];
             // vx2.Store(p0,&vvs[0]);
             // test[ip1]=vvs[0];
 
             MVec vy1=MVec::Load(p0, &sy_m[ip*2]);
             MVec vy2=MVec::Load(p0, &sy_m[ip1*2]);
 
             const uint64_t x_indices[8]={0,2,0,2,1,3,1,3};
             MVec vx_broadcast=svtbl(svzip1(vx1,vx2),svld1_u64(svptrue_b64(),x_indices));
             const uint64_t y_indices[8]={0,0,2,2,1,1,3,3};
             MVec vy_broadcast=svtbl(svzip1(vy1,vy2),svld1_u64(svptrue_b64(),y_indices));
 
             // double vx[8]={sx_m[ip][0],sx_m[ip][1],sx_m[ip][0],sx_m[ip][1],sx_m[ip1][0],sx_m[ip1][1],sx_m[ip1][0],sx_m[ip1][1]};
             // double vy[8]={sy_m[ip][0],sy_m[ip][0],sy_m[ip][1],sy_m[ip][1],sy_m[ip1][0],sy_m[ip1][0],sy_m[ip1][1],sy_m[ip1][1]};
             // vx_broadcast=MVec::Load(p,&vx[0]);
             // vy_broadcast=MVec::Load(p,&vy[0]);
             MVec sxsy_v=vx_broadcast*vy_broadcast;
             // double vvs[8];
             // sxsy_v.Store(p,&vvs[0]);
             // for(int ii=0;ii<4;ii++){
             //     test[4*ip +ii]=vvs[0+ii];
             //     test[4*ip1+ii]=vvs[4+ii];
             // }
             
 
             // svzero_za();
             svmopa_za64_m(0, p_4, svptrue_b64(), sz_xv, sxsy_v);
             svmopa_za64_m(1, p_4, svptrue_b64(), sz_yv, sxsy_v);
             svmopa_za64_m(2, p_4, svptrue_b64(), sz_zv, sxsy_v);
 
             // MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,0);
             // MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,0,2);
             // double wx0[8];
             // wxsxsysz0.Store(svptrue_b64(),&wx0[0]);
             // double wx1[8];
             // wxsxsysz1.Store(svptrue_b64(),&wx1[0]);
             // for(int ii=0;ii<4;ii++){
             //     test[8*ip+ii]=wx0[0+ii];
             //     test[8*ip1+ii]=wx1[4+ii];
             // }
             // wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,1);
             // wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,0,3);
             // wx0[8];
             // wxsxsysz0.Store(svptrue_b64(),&wx0[0]);
             // wx1[8];
             // wxsxsysz1.Store(svptrue_b64(),&wx1[0]);
             // for(int ii=0;ii<4;ii++){
             //     test[8*ip+4+ii]=wx0[0+ii];
             //     test[8*ip1+4+ii]=wx1[4+ii];
             // }
 
             // MVec wwx = MVec::Load(p,&xrhocells[8*c]);
             // double wx0[8];
             // double wx1[8];
             // double wy0[8];
             // double wy1[8];
             // double wz0[8];
             // double wz1[8];
             // MVec wxsxsyszx0 = svread_hor_za64_m(vzero,p,0,0);
             // MVec wxsxsyszx1 = svread_hor_za64_m(vzero,p,0,1);
             // MVec wxsxsyszy0 = svread_hor_za64_m(vzero,p,1,0);
             // MVec wxsxsyszy1 = svread_hor_za64_m(vzero,p,1,1);
             // MVec wxsxsyszz0 = svread_hor_za64_m(vzero,p,2,0);
             // MVec wxsxsyszz1 = svread_hor_za64_m(vzero,p,2,1);
             // wxsxsyszx0.Store(svptrue_b64(),&wx0[0]);
             // wxsxsyszx1.Store(svptrue_b64(),&wx1[0]);
             // wxsxsyszy0.Store(svptrue_b64(),&wy0[0]);
             // wxsxsyszy1.Store(svptrue_b64(),&wy1[0]);
             // wxsxsyszz0.Store(svptrue_b64(),&wz0[0]);
             // wxsxsyszz1.Store(svptrue_b64(),&wz1[0]);
             // // for(int ii=0;ii<4;ii++){
             // //     xrhocells[8*c+ii]+=wx0[0+ii];
             // //     xrhocells[8*c+ii+4]+=wx1[0+ii];
             // //     yrhocells[8*c+ii]+=wy0[0+ii];
             // //     yrhocells[8*c+ii+4]+=wy1[0+ii];
             // //     zrhocells[8*c+ii]+=wz0[0+ii];
             // //     zrhocells[8*c+ii+4]+=wz1[0+ii];
             // //     // test[8*ip+ii]=wx0[0+ii];
             // //     // test[8*ip+4+ii]=wx1[0+ii];
             // // }
             // MVec s=svsplice(p_4,wxsxsyszx0,wxsxsyszx1);
             // wwx+=s;
             // wxsxsyszx0 = svread_hor_za64_m(vzero,p,0,2);
             // wxsxsyszx1 = svread_hor_za64_m(vzero,p,0,3);
             // wxsxsyszy0 = svread_hor_za64_m(vzero,p,1,2);
             // wxsxsyszy1 = svread_hor_za64_m(vzero,p,1,3);
             // wxsxsyszz0 = svread_hor_za64_m(vzero,p,2,2);
             // wxsxsyszz1 = svread_hor_za64_m(vzero,p,2,3);
             // wxsxsyszx0.Store(svptrue_b64(),&wx0[0]);
             // wxsxsyszx1.Store(svptrue_b64(),&wx1[0]);
             // wxsxsyszy0.Store(svptrue_b64(),&wy0[0]);
             // wxsxsyszy1.Store(svptrue_b64(),&wy1[0]);
             // wxsxsyszz0.Store(svptrue_b64(),&wz0[0]);
             // wxsxsyszz1.Store(svptrue_b64(),&wz1[0]); 
             // // for(int ii=0;ii<4;ii++){
             // //     xrhocells[8*c+ii]+=wx0[4+ii];
             // //     xrhocells[8*c+ii+4]+=wx1[4+ii];
             // //     yrhocells[8*c+ii]+=wy0[4+ii];
             // //     yrhocells[8*c+ii+4]+=wy1[4+ii];
             // //     zrhocells[8*c+ii]+=wz0[4+ii];
             // //     zrhocells[8*c+ii+4]+=wz1[4+ii];
             // //     // test[8*ip1+0+ii]=wx0[4+ii];
             // //     // test[8*ip1+4+ii]=wx1[4+ii];
             // // }
             // MVec B=svext(wxsxsyszx1,wxsxsyszx1,4);
             // s=svext(wxsxsyszx0,B,4);
             // wwx+=s;
             // wwx.Store(p,&xrhocells[8*c]);
         }
 
         // svzero_za();
         if((end - start)%2==1){
             int ip=xbinList[end1];   
             // printf("ip %d len %d \n",ip,end-start);
             MVec sz_v=svdup_n_f64(0);
             MVec sz_x1 = svld1(p0,&sz_m[ip*2]);
             sz_x1*=wqx[ip];
             // MVec sz_1=sz_mm*wqx[ip];
             sz_v=svsel(p0,sz_x1,sz_v);
             // svbool_t p1=svwhilelt_b64(2,4);
             MVec vx1=MVec::Load(p0, &sx_m[ip*2]);
             MVec vy1=MVec::Load(p0, &sy_m[ip*2]);
             MVec sxsy_v=svsplice(p0,vx1,vx1)*svzip1(vy1,vy1);
             
             // MVec sxsy_v=vx_broadcast*vy_broadcast;
             // MVec sxsy_v=svsplice(p0,vx1,vy1);
             // svzero_za();
             svmopa_za64_m(0, p0, p_4, sz_v, sxsy_v);
         }
 
         MVec wwx = MVec::Load(p,&xrhocells[8*c]);
         MVec wwy = MVec::Load(p,&yrhocells[8*c]);
         MVec wwz = MVec::Load(p,&zrhocells[8*c]);
         MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,0);
         MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4,0,1);
         // svfloat64x2_t ss=svcreate2_f64(wxsxsysz0,wxsxsysz0);
         // MVec B=svext(wxsxsysz1,wxsxsysz1,4);
         // MVec s=svsel(p_4,wxsxsysz0,B);
         MVec s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
         wwx+=s;
         wxsxsysz0 = svread_hor_za64_m(vzero,p_4_8,0,2);
         wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,0,3);
         MVec B=svext(wxsxsysz1,wxsxsysz1,4);
         s=svext(wxsxsysz0,B,4);
         // B=svext(wxsxsysz1,wxsxsysz1,4);
         // s=svsel(p_4,wxsxsysz0,B);
         // s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
         wwx+=s;
         wwx.Store(p,&xrhocells[8*c]);
         // test[c]=xrhocells[8*c];
         wwy.Store(p,&yrhocells[8*c]);
         wwz.Store(p,&zrhocells[8*c]); 
     }
 
 
 }
 template <int depos_order>
 __arm_new("za")  void sort_real_sme_kernal_5(
     const long numcell,
     const std::vector<int>& xpresum,
     const std::vector<int>& xbinList,
     std::vector<amrex::Real>& xrhocells,
     std::vector<amrex::Real>& yrhocells,
     std::vector<amrex::Real>& zrhocells,
     std::vector<amrex::Real>& sx_m,
     std::vector<amrex::Real>& sy_m,
     std::vector<amrex::Real>& sz_m,
     std::vector<amrex::Real>& wqx,
     std::vector<amrex::Real>& wqy,
     std::vector<amrex::Real>& wqz,
     std::vector<amrex::Real>& testsxwq
 )__arm_streaming
 {
    using namespace amrex::literals;
    svbool_t p_4=svwhilelt_b64(0,4);
    svbool_t p_4_8=svbic_z(svptrue_b64(),svptrue_b64(),p_4);
    svbool_t p0=svwhilelt_b64(0,2);
    svbool_t p1=svbic_z(p_4,p_4, p0);
    svbool_t p = svptrue_b64();
    MVec vzero(0);

    for(int c=1;c<=numcell;c++){
        
        int start = xpresum[c-1];
        int end = xpresum[c];
        if(start==end){
            // svetime[1]=rdtscv();
            // branch_time+=(svetime[1]-svetime[0]);
            continue;
        }
        // svetime[1]=rdtscv();
        // branch_time+=(svetime[1]-svetime[0]);
        // svbool_t p = svptrue_b64();
        // MVec wwx = MVec::Load(p,&xrhocells[8*c]);
        // MVec wwy = MVec::Load(p,&yrhocells[8*c]);
        // MVec wwz = MVec::Load(p,&zrhocells[8*c]);
        // const int end_len = std::min(2, static_cast<int>(end-start));
        svzero_za();
        const int end1 = end-(end - start)%2;
        for(int idx=start;idx<end1;idx+=2){
            // sx={x[0],x[1],x2[0],x2[1]}
            // sysz={y1[0]z1[0],y1[1]z1[0],y1[0]z1[1],y1[1]z1[1],y2[0]z2[0],y2[1]z2[0],y2[0]z2[1],y2[1]z2[1]}
            int ip=xbinList[idx];
            int ip1=xbinList[idx+1];
            // printf("ip %d lenin %d \n",ip,end1-start);
            
            // MVec sx_v=svdup_n_f64(0);
            // MVec sx_1 = svld1(p0,&sx_m[ip][0]);
            // sx_1*=wqx[ip];
            // sx_v=svsel(p0,sx_1,sx_v);
            // // svbool_t p1=svwhilelt_b64(2,4);
            // MVec sx_2 = svld1(p1,&sx_m[ip1-1][0]);
            // sx_2*=wqx[ip1];
            // sx_v=svsel(p1,sx_2,sx_v);
            //
            // MVec vy1=MVec::Load(p0, &sy_m[ip][0]);
            // MVec vy2=MVec::Load(p0, &sy_m[ip1][0]);
            // MVec vz1=MVec::Load(p0, &sz_m[ip][0]);
            // MVec vz2=MVec::Load(p0, &sz_m[ip1][0]);
            //
            // const uint64_t y_indices[8]={0,2,0,2,1,3,1,3};
            // MVec vy_broadcast=svtbl(svzip1(vy1,vy2),svld1_u64(svptrue_b64(),y_indices));
            // const uint64_t z_indices[8]={0,0,2,2,1,1,3,3};
            // MVec vz_broadcast=svtbl(svzip1(vz1,vz2),svld1_u64(svptrue_b64(),z_indices));
            //
            // MVec sysz_v=vy_broadcast*vz_broadcast;
            // // svzero_za();
            // svmopa_za64_m(0, p_4, svptrue_b64(), sx_v, sysz_v);
             
            MVec sz_xv=svdup_n_f64(0);
            MVec sz_yv=svdup_n_f64(0);
            MVec sz_zv=svdup_n_f64(0);
            MVec sz_x1 = svld1(p0,&sz_m[ip*2]);
            // MVec sz_x2 = svld1(p1,&sz_m[(ip)*2]);
             MVec sz_x2 = svld1(p1,&sz_m[(ip1-1)*2]);
            MVec sz_y1 = sz_x1; 
            MVec sz_y2 = sz_x2; 
            MVec sz_z1 = sz_x1;
            MVec sz_z2 = sz_x2;
            MVec testsxwq_v=sz_x1*wqx[ip];
            // svfloat64_t testsxwq_v = svdup_f64(0.0);
            // testsxwq_v=svmul_f64_x(p, sz_x1, svdup_f64(wqx[ip]));
            // vzero=svdup_f64(0.0);
            MVec final_vector = svcompact_f64(p0, testsxwq_v);
            // svfloat64_t final_vector = svsel_f64(p0, testsxwq_v, vzero);
            // svst1_f64(p, &testsxwq[8*(ip)], final_vector);
            final_vector.Store(p,&testsxwq[8*(ip)]);
            // svbool_t p1=svwhilelt_b64(2,4);
            sz_x1*=wqx[ip];
            sz_xv=svsel(p0,sz_x1,sz_xv);
            //  sz_x1.Store(svptrue_b64(),&testsxwq[8*(ip)]);
            //  sz_xv.Store(p0,&testsxwq[2*(ip)]);

            testsxwq_v = svdup_f64(0.0);
            testsxwq_v=sz_x2*wqx[ip1];
            // testsxwq_v=svmul_f64_x(p, sz_x2, svdup_f64(wqx[ip1]));
            // vzero=svdup_f64(0.0);
            final_vector = svcompact_f64(p1, testsxwq_v);
            // svst1_f64(p, &testsxwq[8*(ip1)], final_vector);
            final_vector.Store(svptrue_b64(),&testsxwq[8*(ip1)]);
            sz_x2*=wqx[ip1];
            sz_xv=svsel(p1,sz_x2,sz_xv);
            //  sz_x2.Store(svptrue_b64(),&testsxwq[8*(ip1)]);
            //  sz_xv.Store(p1,&testsxwq[2*(ip1-1)]);
            sz_y1*=wqy[ip];
            sz_yv=svsel(p0,sz_y1,sz_yv);
            sz_y2*=wqy[ip1];
            sz_yv=svsel(p1,sz_y2,sz_yv);
            sz_z1*=wqz[ip];
            sz_zv=svsel(p0,sz_z1,sz_zv);
            sz_z2*=wqz[ip1];
            sz_zv=svsel(p1,sz_z2,sz_zv);
            // double vvs[8];
            // sz_xv.Store(p,&vvs[0]);
            // test[ip]=vvs[0];
            // test[ip1]=vvs[2];

            // test[ip]=wqx[ip];
            // test[ip1]=wqx[ip1];

            MVec vx1=MVec::Load(p0, &sx_m[ip*2]);
            MVec vx2=MVec::Load(p0, &sx_m[ip1*2]);
            // double vvs[8];
            // vx1.Store(p0,&vvs[0]);
            // test[ip]=vvs[0];
            // vx2.Store(p0,&vvs[0]);
            // test[ip1]=vvs[0];

            MVec vy1=MVec::Load(p0, &sy_m[ip*2]);
            MVec vy2=MVec::Load(p0, &sy_m[ip1*2]);

            const uint64_t x_indices[8]={0,2,0,2,1,3,1,3};
            MVec vx_broadcast=svtbl(svzip1(vx1,vx2),svld1_u64(svptrue_b64(),x_indices));
            const uint64_t y_indices[8]={0,0,2,2,1,1,3,3};
            MVec vy_broadcast=svtbl(svzip1(vy1,vy2),svld1_u64(svptrue_b64(),y_indices));

            // double vx[8]={sx_m[ip][0],sx_m[ip][1],sx_m[ip][0],sx_m[ip][1],sx_m[ip1][0],sx_m[ip1][1],sx_m[ip1][0],sx_m[ip1][1]};
            // double vy[8]={sy_m[ip][0],sy_m[ip][0],sy_m[ip][1],sy_m[ip][1],sy_m[ip1][0],sy_m[ip1][0],sy_m[ip1][1],sy_m[ip1][1]};
            // vx_broadcast=MVec::Load(p,&vx[0]);
            // vy_broadcast=MVec::Load(p,&vy[0]);
            MVec sxsy_v=vx_broadcast*vy_broadcast;
            // double vvs[8];
            // sxsy_v.Store(p,&vvs[0]);
            // for(int ii=0;ii<4;ii++){
            //     test[4*ip +ii]=vvs[0+ii];
            //     test[4*ip1+ii]=vvs[4+ii];
            // }
            

            // svzero_za();
            svmopa_za64_m(0, p_4, svptrue_b64(), sz_xv, sxsy_v);
            svmopa_za64_m(1, p_4, svptrue_b64(), sz_yv, sxsy_v);
            svmopa_za64_m(2, p_4, svptrue_b64(), sz_zv, sxsy_v);

            // MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,0);
            // MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,0,2);
            // double wx0[8];
            // wxsxsysz0.Store(svptrue_b64(),&wx0[0]);
            // double wx1[8];
            // wxsxsysz1.Store(svptrue_b64(),&wx1[0]);
            // for(int ii=0;ii<4;ii++){
            //     test[8*ip+ii]=wx0[0+ii];
            //     test[8*ip1+ii]=wx1[4+ii];
            // }
            // wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,1);
            // wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,0,3);
            // wx0[8];
            // wxsxsysz0.Store(svptrue_b64(),&wx0[0]);
            // wx1[8];
            // wxsxsysz1.Store(svptrue_b64(),&wx1[0]);
            // for(int ii=0;ii<4;ii++){
            //     test[8*ip+4+ii]=wx0[0+ii];
            //     test[8*ip1+4+ii]=wx1[4+ii];
            // }

            // MVec wwx = MVec::Load(p,&xrhocells[8*c]);
            // double wx0[8];
            // double wx1[8];
            // double wy0[8];
            // double wy1[8];
            // double wz0[8];
            // double wz1[8];
            // MVec wxsxsyszx0 = svread_hor_za64_m(vzero,p,0,0);
            // MVec wxsxsyszx1 = svread_hor_za64_m(vzero,p,0,1);
            // MVec wxsxsyszy0 = svread_hor_za64_m(vzero,p,1,0);
            // MVec wxsxsyszy1 = svread_hor_za64_m(vzero,p,1,1);
            // MVec wxsxsyszz0 = svread_hor_za64_m(vzero,p,2,0);
            // MVec wxsxsyszz1 = svread_hor_za64_m(vzero,p,2,1);
            // wxsxsyszx0.Store(svptrue_b64(),&wx0[0]);
            // wxsxsyszx1.Store(svptrue_b64(),&wx1[0]);
            // wxsxsyszy0.Store(svptrue_b64(),&wy0[0]);
            // wxsxsyszy1.Store(svptrue_b64(),&wy1[0]);
            // wxsxsyszz0.Store(svptrue_b64(),&wz0[0]);
            // wxsxsyszz1.Store(svptrue_b64(),&wz1[0]);
            // // for(int ii=0;ii<4;ii++){
            // //     xrhocells[8*c+ii]+=wx0[0+ii];
            // //     xrhocells[8*c+ii+4]+=wx1[0+ii];
            // //     yrhocells[8*c+ii]+=wy0[0+ii];
            // //     yrhocells[8*c+ii+4]+=wy1[0+ii];
            // //     zrhocells[8*c+ii]+=wz0[0+ii];
            // //     zrhocells[8*c+ii+4]+=wz1[0+ii];
            // //     // test[8*ip+ii]=wx0[0+ii];
            // //     // test[8*ip+4+ii]=wx1[0+ii];
            // // }
            // MVec s=svsplice(p_4,wxsxsyszx0,wxsxsyszx1);
            // wwx+=s;
            // wxsxsyszx0 = svread_hor_za64_m(vzero,p,0,2);
            // wxsxsyszx1 = svread_hor_za64_m(vzero,p,0,3);
            // wxsxsyszy0 = svread_hor_za64_m(vzero,p,1,2);
            // wxsxsyszy1 = svread_hor_za64_m(vzero,p,1,3);
            // wxsxsyszz0 = svread_hor_za64_m(vzero,p,2,2);
            // wxsxsyszz1 = svread_hor_za64_m(vzero,p,2,3);
            // wxsxsyszx0.Store(svptrue_b64(),&wx0[0]);
            // wxsxsyszx1.Store(svptrue_b64(),&wx1[0]);
            // wxsxsyszy0.Store(svptrue_b64(),&wy0[0]);
            // wxsxsyszy1.Store(svptrue_b64(),&wy1[0]);
            // wxsxsyszz0.Store(svptrue_b64(),&wz0[0]);
            // wxsxsyszz1.Store(svptrue_b64(),&wz1[0]); 
            // // for(int ii=0;ii<4;ii++){
            // //     xrhocells[8*c+ii]+=wx0[4+ii];
            // //     xrhocells[8*c+ii+4]+=wx1[4+ii];
            // //     yrhocells[8*c+ii]+=wy0[4+ii];
            // //     yrhocells[8*c+ii+4]+=wy1[4+ii];
            // //     zrhocells[8*c+ii]+=wz0[4+ii];
            // //     zrhocells[8*c+ii+4]+=wz1[4+ii];
            // //     // test[8*ip1+0+ii]=wx0[4+ii];
            // //     // test[8*ip1+4+ii]=wx1[4+ii];
            // // }
            // MVec B=svext(wxsxsyszx1,wxsxsyszx1,4);
            // s=svext(wxsxsyszx0,B,4);
            // wwx+=s;
            // wwx.Store(p,&xrhocells[8*c]);
        }
 
        // svzero_za();
        if((end - start)%2==1){
            int ip=xbinList[end1];   
            // printf("ip %d len %d \n",ip,end-start);
            MVec sz_v=svdup_n_f64(0);
            MVec sz_x1 = svld1(p0,&sz_m[ip*2]);

            MVec testsxwq_v = svdup_f64(0.0);
            testsxwq_v=sz_x1*wqx[ip];
            // testsxwq_v=svmul_f64_x(p, sz_x1, svdup_f64(wqx[ip]));
            // vzero=svdup_f64(0.0);
            // svfloat64_t final_vector = svcompact_f64(p0, testsxwq_v);
            // svst1_f64(p, &testsxwq[8*(ip)], final_vector);
            testsxwq_v.Store(p,&testsxwq[8*(ip)]);

            sz_x1*=wqx[ip];
            // MVec sz_1=sz_mm*wqx[ip];
            sz_v=svsel(p0,sz_x1,sz_v);
            //  sz_x1.Store(svptrue_b64(),&testsxwq[8*(ip)]);
            //  sz_v.Store(p0,&testsxwq[2*(ip)]);
             // svbool_t p1=svwhilelt_b64(2,4);
             MVec vx1=MVec::Load(p0, &sx_m[ip*2]);
             MVec vy1=MVec::Load(p0, &sy_m[ip*2]);
             MVec sxsy_v=svsplice(p0,vx1,vx1)*svzip1(vy1,vy1);
             
             // MVec sxsy_v=vx_broadcast*vy_broadcast;
             // MVec sxsy_v=svsplice(p0,vx1,vy1);
             // svzero_za();
             svmopa_za64_m(0, p0, p_4, sz_v, sxsy_v);
         }
 
         MVec wwx = MVec::Load(p,&xrhocells[8*c]);
         MVec wwy = MVec::Load(p,&yrhocells[8*c]);
         MVec wwz = MVec::Load(p,&zrhocells[8*c]);
         MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,0);
         MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4,0,1);
         // svfloat64x2_t ss=svcreate2_f64(wxsxsysz0,wxsxsysz0);
         // MVec B=svext(wxsxsysz1,wxsxsysz1,4);
         // MVec s=svsel(p_4,wxsxsysz0,B);
         MVec s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
         wwx+=s;
         wxsxsysz0 = svread_hor_za64_m(vzero,p_4_8,0,2);
         wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,0,3);
         MVec B=svext(wxsxsysz1,wxsxsysz1,4);
         s=svext(wxsxsysz0,B,4);
         // B=svext(wxsxsysz1,wxsxsysz1,4);
         // s=svsel(p_4,wxsxsysz0,B);
         // s=svsplice(p_4,wxsxsysz0,wxsxsysz1);
         wwx+=s;
         wwx.Store(p,&xrhocells[8*c]);
         // test[c]=xrhocells[8*c];
         wwy.Store(p,&yrhocells[8*c]);
         wwz.Store(p,&zrhocells[8*c]); 
     }
 
 
 }
 
 
 // back up of kernal
 template <int depos_order>
 __arm_new("za") inline void sort_real_sme_kernal_bak(
     const long numcell,
     const std::vector<int>& xpresum,
     const std::vector<int>& xbinList,
     std::vector<amrex::Real>& xrhocells,
     std::vector<amrex::Real>& yrhocells,
     std::vector<amrex::Real>& zrhocells,
     std::vector<std::vector<amrex::Real>>& sx_m,
     std::vector<std::vector<amrex::Real>>& sy_m,
     std::vector<std::vector<amrex::Real>>& sz_m,
     std::vector<amrex::Real>& wqx,
     std::vector<amrex::Real>& wqy,
     std::vector<amrex::Real>& wqz,
     std::vector<double>& test
 )__arm_streaming
 {
     using namespace amrex::literals;
     svbool_t p_4=svwhilelt_b64(0,4);
     svbool_t p_4_8=svbic_z(svptrue_b64(),svptrue_b64(),p_4);
     svbool_t p0=svwhilelt_b64(0,2);
     svbool_t p1=svbic_z(p_4,p_4, p0);
     svbool_t p = svptrue_b64();
     MVec vzero(0);
 
     for(int c=1;c<=numcell;c+=2){       
         int start = xpresum[c-1];
         int end = xpresum[c];
         if(start==end){
             continue;
         }
         svzero_za();
         //TODO use cell+=2, to do 2cells particles depo simultaneously
         for(int idx=start;idx<end;idx++){
             // sx={x[0],x[1],x2[0],x2[1]}
             // sysz={y1[0]z1[0],y1[1]z1[0],y1[0]z1[1],y1[1]z1[1],y2[0]z2[0],y2[1]z2[0],y2[0]z2[1],y2[1]z2[1]}
             int ip=xbinList[idx];
             int ip1=xbinList[idx+1];
 
             MVec sz_v=svdup_n_f64(0);
             MVec sz_1 = svld1(p0,&sz_m[ip][0]);
             sz_1*=wqx[ip];
             sz_v=svsel(p0,sz_1,sz_v);
             // svbool_t p1=svwhilelt_b64(2,4);
             MVec sz_2 = svld1(p1,&sz_m[ip1-1][0]);
             sz_2*=wqx[ip1];
             sz_v=svsel(p1,sz_2,sz_v);
 
             MVec vx1=MVec::Load(p0, &sx_m[ip][0]);
             MVec vx2=MVec::Load(p0, &sx_m[ip1][0]);
             MVec vy1=MVec::Load(p0, &sy_m[ip][0]);
             MVec vy2=MVec::Load(p0, &sy_m[ip1][0]);
 
             const uint64_t x_indices[8]={0,2,0,2,1,3,1,3};
             MVec vx_broadcast=svtbl(svzip1(vx1,vx2),svld1_u64(svptrue_b64(),x_indices));
             const uint64_t y_indices[8]={0,0,2,2,1,1,3,3};
             MVec vy_broadcast=svtbl(svzip1(vy1,vy2),svld1_u64(svptrue_b64(),y_indices));
 
             MVec sxsy_v=vx_broadcast*vy_broadcast;
             // svzero_za();
             svmopa_za64_m(0, p_4, svptrue_b64(), sz_v, sxsy_v);
 
             // MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,1);
             // MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,0,3);
             // double wx0[8];
             // wxsxsysz0.Store(svptrue_b64(),&wx0[0]);
             // test[ip]=wx0[1];
             // double wx1[8];
             // wxsxsysz1.Store(svptrue_b64(),&wx1[0]);
             // test[ip1]=wx1[5];
 
         }
         // MVec sxsysz = svread_hor_za64_m(vzero,p_4,0,j);
         // MVec wwx = MVec::Load(p,&xrhocells[8*c]);
         // MVec wwy = MVec::Load(p,&yrhocells[8*c]);
         // MVec wwz = MVec::Load(p,&zrhocells[8*c]);
         // MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,0);
         // MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4,0,1);
         // MVec B=svext(wxsxsysz1,wxsxsysz1,4);
         // MVec s=svsel(p_4,wxsxsysz0,B);
         // wwx+=s;
         // wwx.Store(p,&xrhocells[8*c]);
         // test[c]=xrhocells[8*c];
         // wwy.Store(p,&yrhocells[8*c]);
         // wwz.Store(p,&zrhocells[8*c]); 
     }
 
     // for(int c=1;c<=numcell;c++){
         
     //     int start = xpresum[c-1];
     //     int end = xpresum[c];
     //     if(start==end){
     //         // svetime[1]=rdtscv();
     //         // branch_time+=(svetime[1]-svetime[0]);
     //         continue;
     //     }
     //     // svetime[1]=rdtscv();
     //     // branch_time+=(svetime[1]-svetime[0]);
     //     // svbool_t p = svptrue_b64();
     //     // MVec wwx = MVec::Load(p,&xrhocells[8*c]);
     //     // MVec wwy = MVec::Load(p,&yrhocells[8*c]);
     //     // MVec wwz = MVec::Load(p,&zrhocells[8*c]);
     //     // const int end_len = std::min(2, static_cast<int>(end-start));
     //     svzero_za();
     //     //TODO use cell+=2, to do 2cells particles depo simultaneously
     //     for(int idx=start;idx<end;idx+=2){
     //         // sx={x[0],x[1],x2[0],x2[1]}
     //         // sysz={y1[0]z1[0],y1[1]z1[0],y1[0]z1[1],y1[1]z1[1],y2[0]z2[0],y2[1]z2[0],y2[0]z2[1],y2[1]z2[1]}
     //         int ip=xbinList[idx];
     //         int ip1=xbinList[idx+1];
     //         // MVec sx_v=svdup_n_f64(0);
     //         // MVec sx_1 = svld1(p0,&sx_m[ip][0]);
     //         // sx_1*=wqx[ip];
     //         // sx_v=svsel(p0,sx_1,sx_v);
     //         // // svbool_t p1=svwhilelt_b64(2,4);
     //         // MVec sx_2 = svld1(p1,&sx_m[ip1-1][0]);
     //         // sx_2*=wqx[ip1];
     //         // sx_v=svsel(p1,sx_2,sx_v);
 
     //         // MVec vy1=MVec::Load(p0, &sy_m[ip][0]);
     //         // MVec vy2=MVec::Load(p0, &sy_m[ip1][0]);
     //         // MVec vz1=MVec::Load(p0, &sz_m[ip][0]);
     //         // MVec vz2=MVec::Load(p0, &sz_m[ip1][0]);
 
     //         // const uint64_t y_indices[8]={0,2,0,2,1,3,1,3};
     //         // MVec vy_broadcast=svtbl(svzip1(vy1,vy2),svld1_u64(svptrue_b64(),y_indices));
     //         // const uint64_t z_indices[8]={0,0,2,2,1,1,3,3};
     //         // MVec vz_broadcast=svtbl(svzip1(vz1,vz2),svld1_u64(svptrue_b64(),z_indices));
 
     //         // MVec sysz_v=vy_broadcast*vz_broadcast;
     //         // // svzero_za();
     //         // svmopa_za64_m(0, p_4, svptrue_b64(), sx_v, sysz_v);
     //         MVec sz_v=svdup_n_f64(0);
     //         MVec sz_1 = svld1(p0,&sz_m[ip][0]);
     //         sz_1*=wqx[ip];
     //         sz_v=svsel(p0,sz_1,sz_v);
     //         // svbool_t p1=svwhilelt_b64(2,4);
     //         MVec sz_2 = svld1(p1,&sz_m[ip1-1][0]);
     //         sz_2*=wqx[ip1];
     //         sz_v=svsel(p1,sz_2,sz_v);
 
     //         MVec vx1=MVec::Load(p0, &sx_m[ip][0]);
     //         MVec vx2=MVec::Load(p0, &sx_m[ip1][0]);
     //         MVec vy1=MVec::Load(p0, &sy_m[ip][0]);
     //         MVec vy2=MVec::Load(p0, &sy_m[ip1][0]);
 
     //         const uint64_t x_indices[8]={0,2,0,2,1,3,1,3};
     //         MVec vx_broadcast=svtbl(svzip1(vx1,vx2),svld1_u64(svptrue_b64(),x_indices));
     //         const uint64_t y_indices[8]={0,0,2,2,1,1,3,3};
     //         MVec vy_broadcast=svtbl(svzip1(vy1,vy2),svld1_u64(svptrue_b64(),y_indices));
 
     //         MVec sxsy_v=vx_broadcast*vy_broadcast;
     //         svzero_za();
     //         svmopa_za64_m(0, p_4, svptrue_b64(), sz_v, sxsy_v);
 
 
 
 
 
     //         // MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,1);
     //         // MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4_8,0,3);
     //         // double wx0[8];
     //         // wxsxsysz0.Store(svptrue_b64(),&wx0[0]);
     //         // test[ip]=wx0[1];
     //         // double wx1[8];
     //         // wxsxsysz1.Store(svptrue_b64(),&wx1[0]);
     //         // test[ip1]=wx1[5];
 
     //         MVec wwx = MVec::Load(p,&xrhocells[8*c]);
     //         MVec wwy = MVec::Load(p,&yrhocells[8*c]);
     //         MVec wwz = MVec::Load(p,&zrhocells[8*c]);
     //         MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,0);
     //         MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4,0,1);
     //         MVec B=svext(wxsxsysz1,wxsxsysz1,4);
     //         MVec s=svsel(p_4,wxsxsysz0,B);
     //         wwx+=s;
     //         wwx.Store(p,&xrhocells[8*c]);
     //         test[c]=xrhocells[8*c];
     //         wwy.Store(p,&yrhocells[8*c]);
     //         wwz.Store(p,&zrhocells[8*c]); 
     //     }
     //     // MVec sxsysz = svread_hor_za64_m(vzero,p_4,0,j);
     //     // MVec wwx = MVec::Load(p,&xrhocells[8*c]);
     //     // MVec wwy = MVec::Load(p,&yrhocells[8*c]);
     //     // MVec wwz = MVec::Load(p,&zrhocells[8*c]);
     //     // MVec wxsxsysz0 = svread_hor_za64_m(vzero,p_4,0,0);
     //     // MVec wxsxsysz1 = svread_hor_za64_m(vzero,p_4,0,1);
     //     // MVec B=svext(wxsxsysz1,wxsxsysz1,4);
     //     // MVec s=svsel(p_4,wxsxsysz0,B);
     //     // wwx+=s;
     //     // wwx.Store(p,&xrhocells[8*c]);
     //     // test[c]=xrhocells[8*c];
     //     // wwy.Store(p,&yrhocells[8*c]);
     //     // wwz.Store(p,&zrhocells[8*c]); 
     // }
 
 
 }
 
 // 添加了真的粒子分桶排序功能
 // 把最基本的排序sort版本实现了先，这不是stencilsme
 template <int depos_order>
 void doDepositionShapeN_sve_sort_real_sme (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Dim3 hi,
                          amrex::Dim3 len,
                          amrex::Real q,
                          std::vector<int>& test,
                          std::vector<double>& test0,std::vector<double>& test1,
                          ParticleTileType& ptile, const amrex::Box& box,
                          std::vector<amrex::Real>& test_rhocells,
                          std::vector<amrex::Real>& test_sxwq,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     // uint64_t total_time[3]={0};
     using namespace std::chrono;
     using namespace amrex::literals;
     double total_time=0;
     // auto total_start=high_resolution_clock::now();
     uint64_t precompute=0;
     uint64_t cale_time=0;
     uint64_t sort_time=0;
         uint64_t count_time=0;
         uint64_t presum_time=0;
         uint64_t binlist_time=0;
     uint64_t reduce_time=0;
     uint64_t svetime[3]={0};
     uint64_t branch_time=0;
     
     // total_time[0]=rdtscv();
     
 
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z; 
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
 
     constexpr int nshapes = depos_order + 1;
     // constexpr int nshapes = 2;
     int vl=svcntd();
 
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
 
     auto compute_shape_factor_v2 = [](std::vector<double>* sx, Vec xmid, svbool_t p) {
         const svuint64_t sx_index = svindex_u64(0ULL, 2ULL);
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         svst1_scatter_index(p,&sx[0][0],sx_index,sx0);
         svst1_scatter_index(p,&sx[0][1],sx_index,sx1);
         // sx0.Store(p, sx[0]);
         // sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
     auto compute_shape_factor_v1 = [](double* sx, Vec xmid, svbool_t p) {
         const svuint64_t sx_index = svindex_u64(0, 2);
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // double test[8];
         // xint.Store(p,&test[0]);
         // for(int ii=0;ii<8;ii++){
         //     // printf("ii %d xind %f \n",ii,test[ii]);
         //     sx[ii][0]=1.0-test[ii];
         //     sx[ii][1]=test[ii];
         // }
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         // double sx00[8];
         // double sx01[8];
         // sx0.Store(p,&sx00[0]);
         // sx1.Store(p,&sx01[0]);
         // for(int ii=0;ii<8;ii++){
         //     // printf("ii %d xind %f \n",ii,test[ii]);
         //     sx[ii][0]=sx00[ii];
         //     sx[ii][1]=sx01[ii];
         // }
         svst1_scatter_index(p,&sx[0],sx_index,sx0);
         svst1_scatter_index(p,&sx[1],sx_index,sx1);
         // sx0.Store(p, sx[0]);
         // sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
     const long numcell = jx_fab.box().numPts();
     const long xnumcell = jx_fab.box().numPts();
     // printf("xnumcell %d %d %d \n",xnumcell,xjstride,xkstride);
     // const long ynumcell = jy_fab.box().numPts();
     // printf("ynumcell %d \n",ynumcell);
     // const long znumcell = jz_fab.box().numPts();
     // printf("znumcell %d \n",znumcell);
 
     // auto xrhocells = std::make_unique<double[]>(8*numcell);
     // auto yrhocells = std::make_unique<double[]>(8*numcell);
     // auto zrhocells = std::make_unique<double[]>(8*numcell);
     std::vector<amrex::Real> xrhocells(8*numcell, 0.0);
     std::vector<amrex::Real> yrhocells(8*numcell, 0.0);
     std::vector<amrex::Real> zrhocells(8*numcell, 0.0);
     // one roll x
     uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
     uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
     uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
     long nx=xjstride;
     long nxy=xkstride;
     long moff[8] = {0, 1, nx, nx+1, nxy, nxy+1, nx+nxy, nx+nxy+1};
     svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
     svbool_t px = svcmpeq_n_u64(svptrue_b64(), rmx_v, 0);
     svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
     svbool_t py = svcmpeq_n_u64(svptrue_b64(), rmy_v, 0);
     svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
     svbool_t pz = svcmpeq_n_u64(svptrue_b64(), rmz_v, 0);
 
     std::vector<amrex::Real> wqx(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqy(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqz(np_to_deposit, 0.0);
 
     // double sx_m[nshapes][np_to_deposit] = {0.};
     // double sy_m[nshapes][np_to_deposit] = {0.};
     // double sz_m[nshapes][np_to_deposit] = {0.};
     // std::vector<std::vector<amrex::Real>> sx_m(np_to_deposit,std::vector<amrex::Real>(nshapes, 0.));
     // std::vector<std::vector<amrex::Real>> sy_m(np_to_deposit,std::vector<amrex::Real>(nshapes, 0.));
     // std::vector<std::vector<amrex::Real>> sz_m(np_to_deposit,std::vector<amrex::Real>(nshapes, 0.));
     std::vector<amrex::Real> sx_m(np_to_deposit*nshapes, 0.);
     std::vector<amrex::Real> sy_m(np_to_deposit*nshapes, 0.);
     std::vector<amrex::Real> sz_m(np_to_deposit*nshapes, 0.);
     // std::vector<std::vector<amrex::Real>> sx_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
     // std::vector<std::vector<amrex::Real>> sy_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
     // std::vector<std::vector<amrex::Real>> sz_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
 
     // some place dont have particle
     alignas(64) long xoffsets[np_to_deposit]; 
     // alignas(64) long yoffsets[np_to_deposit];
     // alignas(64) long zoffsets[np_to_deposit];
     std::vector<long> xcount(numcell,0);
     // std::vector<long> ycount(numcell,0);
     // std::vector<long> zcount(numcell,0);
     // printf("before vl \n");
     // std::vector<long> xcount_tmp(np_to_deposit,0);
     
 
     for(long ip=0;ip<np_to_deposit;ip+=vl){
         // svetime[0]=rdtscv();
 
         // 计算基本物理量
         svbool_t p=svwhilele_b64(ip,np_to_deposit);
         // Inverse of Lorentz factor gamma
         Vec uxp_v=Vec::Load(p,&uxp[ip]);
         Vec uyp_v=Vec::Load(p,&uyp[ip]);
         Vec uzp_v=Vec::Load(p,&uzp[ip]);
         Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                     + uyp_v * uyp_v * clightsq
                                     + uzp_v * uzp_v * clightsq).Sqrt();
         // Product of particle charges and weights
         Vec wp_v=Vec::Load(p,&wp[ip]);
         Vec wq_v = q * wp_v;
 
         // Current particle positions (in physical units)
         Vec xp = Vec::Load(p, &mx[ip]);
         Vec yp = Vec::Load(p, &my[ip]);
         Vec zp = Vec::Load(p, &mz[ip]);
 
         // Particle velocities
         Vec vx_v = uxp_v * gaminv;
         Vec vy_v = uyp_v * gaminv;
         Vec vz_v = uzp_v * gaminv;
 
         // if (do_ionization) wq *= ion_lev[ip];
         Vec wqx_v = wq_v * invvol * vx_v;
         Vec wqy_v = wq_v * invvol * vy_v;
         Vec wqz_v = wq_v * invvol * vz_v;
 
         wqx_v.Store(p, &wqx[ip]);
         wqy_v.Store(p, &wqy[ip]);
         wqz_v.Store(p, &wqz[ip]);
 
         // Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x - 0.5;
         // Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y - 0.5;
         // Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z - 0.5;
         Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x;
         Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y;
         Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z;
         // xmid.Store(p, &test0[ip]);
         // double* sx_temp[nshapes] = {&sx_m[0][ip], &sx_m[1][ip]};
         intVec j_cellv = compute_shape_factor_v1( &sx_m[ip*2], xmid, p);
         // j_cellv.Store(p, &test[ip]);
         // for (int i=0;i<8;i++){
         //     int tt=ip+i;
         //     test0[tt]=sx_m[tt][1];
         //     // printf("iip: %d, lo.x %d, jx_arr.begin.x, %d, jx_arr.begin.y, %d,jx_arr.begin.z, %d, xjstride: %d, xkstride: %d xoffsets[iip] : %d \n", 
         //     //         tt,   lo.x , jx_arr.begin.x, jx_arr.begin.y,jx_arr.begin.z, xjstride, xkstride,xoffsets[tt] );
         //     // printf("j_cell %d: %ld , xmid %f \n",i,j_cell[i], xmidt[i]);
         // }
         // double* sy_temp[nshapes] = {&sy_m[0][ip], &sy_m[1][ip]};
         intVec k_cellv = compute_shape_factor_v1( &sy_m[ip*2], ymid, p);
         // double* sz_temp[nshapes] = {&sz_m[0][ip], &sz_m[1][ip]};
         intVec l_cellv = compute_shape_factor_v1( &sz_m[ip*2], zmid, p); 
 
         intVec xoffsets_v = j_cellv + k_cellv * xjstride + l_cellv * xkstride;
         // intVec yoffsets_v = j_cellv + k_cellv * yjstride + l_cellv * ykstride;
         // intVec zoffsets_v = j_cellv + k_cellv * zjstride + l_cellv * zkstride;
 
         xoffsets_v.Store(p,&xoffsets[ip]);
         // yoffsets_v.Store(p,&yoffsets[ip]);
         // zoffsets_v.Store(p,&zoffsets[ip]);
 
         // 原子操作，不可避免
         // const int vec_len = std::min(vl, static_cast<int>(np_to_deposit-ip));
         // svetime[2]=rdtscv();
         // for(int off=0;off<vec_len;off++){
         //     xcount[xoffsets[ip+off]]++;
         //     // ycount[yoffsets[ip+off]]++;
         //     // zcount[zoffsets[ip+off]]++;
         // }
         // svetime[1]=rdtscv();
         // count_time+=(svetime[1]-svetime[2]);
 
         // printf("after STORE\n");
         // svetime[1]=rdtscv();
         // precompute+=(svetime[1]-svetime[0]); 
         // printf("after SAVE\n");
     }
     // svetime[0]=rdtscv();
     for(long ip=0;ip<np_to_deposit;ip++){
        if(test0[2*ip]!=sz_m[2*ip]){
            printf("szm[%d] ERROR %f! org %f szm %f \n",
                ip,sz_m[2*ip]-test0[2*ip],sz_m[2*ip],test0[2*ip]);
            // amrex::Abort("wqx");
         }
    }
     if(test0!=sz_m){
        printf("szm ERROR!\n");
        amrex::Abort("szm");
     }
     if(test1!=wqx){
        printf("wqx ERROR!\n");
        amrex::Abort("wqx");
     }
     for(long ip=0;ip<np_to_deposit;ip++){
        if(test1[ip]!=wqx[ip]){
            printf("wqx ERROR!\n");
            amrex::Abort("wqx");
         }
    }
     for(long ip=0;ip<np_to_deposit;ip++){
         xcount[xoffsets[ip]]++;
     }
     // svetime[1]=rdtscv();
     // count_time+=(svetime[1]-svetime[0]);
 
     std::vector<int> xpresum(numcell+1,0);
     // std::vector<int> ypresum(numcell+1,0);
     // std::vector<int> zpresum(numcell+1,0);
     // svetime[0]=rdtscv();
     for(int c=1;c<=numcell;c++){
         xpresum[c]=xpresum[c-1]+xcount[c-1];
         // ypresum[c]=ypresum[c-1]+ycount[c-1];
         // zpresum[c]=zpresum[c-1]+zcount[c-1];
     }
     // svetime[1]=rdtscv();
     // presum_time+=(svetime[1]-svetime[0]);
     // printf("np_to_deposit %d sum %d xpresum[%d] %d  \n",np_to_deposit,sum1,numcell,xpresum[numcell]);
     // amrex::Abort("END 2!");
 
     // int xbinList[np_to_deposit]={-1};
     std::vector<int> xbinList(np_to_deposit,-1);
     // std::vector<int> ybinList(np_to_deposit,-1);
     // std::vector<int> zbinList(np_to_deposit,-1);
     // std::vector<int> xcurrentPos=xpresum;
     // svetime[0]=rdtscv();
     for(int ip=0;ip<np_to_deposit;ip++){
         long xoffset = xoffsets[ip];
         // long yoffset = yoffsets[ip];
         // long zoffset = zoffsets[ip];
         xbinList[xpresum[xoffset]]=ip;
         xpresum[xoffset]++;
         // ybinList[ypresum[yoffset]]=ip;
         // zbinList[zpresum[zoffset]]=ip;
         // ypresum[yoffset]++;
         // zpresum[zoffset]++;
     }
 
 #if 0
     long bx = 2, by = 2, bz = 2;
     amrex::IntVect box_shape = box.length();
     // amrex::Print() << "Box shape: " << box_shape << std::endl;
     long nnx = len.x;
     long nny = len.y;
     long nnxny = nnx*nny;
     const int testcells = ptile.m_bin_offsets.size();
     std::vector<int> testcount(testcells);
     std::vector<int> pid_to_bin_map=ptile.m_pid_to_bin_map;
     for(int ip=0;ip<np_to_deposit;ip++){
         testcount[pid_to_bin_map[ip]]++;
         // testcount[test1[ip]]++;
     }
 
     for (int iz = 0; iz < len.z; ++iz) {
         for (int iy = 0; iy < len.y; ++iy) {       
             for (int ix = 0; ix < len.x; ix++) {
                 int c1=ix + iy * xjstride + iz * xkstride;
                 int c2=(ix) + (iy) * nnx + (iz) * nnxny;
                 if(testcount[c2]!=xcount[c1])
                 {
                     printf("x %d y %d z %d\n",ix,iy,iz);
                     printf("True xcount[%d] %d sme newbin[%d] %d \n",c1,xcount[c1],c2,testcount[c2]);
                     amrex::Abort("newbin LEN FALSE!!");
                 }
                 if(ptile.m_bin_lengths[c2]!=xcount[c1])
                 {
                     printf("x %d y %d z %d\n",ix,iy,iz);
                     printf("True xcount[%d] %d sme m_bin_lengths[%d] %d \n",c1,xcount[c1],c2,ptile.m_bin_lengths[c2]);
                     amrex::Abort("m_bin_lengths LEN FALSE!!");
                 }
 
             }
         }
     }
     // std::vector<int> ipv1;
     // std::vector<int> ipv2;
     // std::vector<int> ipv1(np_to_deposit);
     // std::vector<int> ipv2(np_to_deposit);
 
     int len1=0;
     int len2=0;
     int err=0;
     for (int iz = 0; iz < len.z; ++iz) {
         for (int iy = 0; iy < len.y; ++iy) {       
             for (int ix = 0; ix < len.x; ix++) {
                 int c1=ix + iy * xjstride + iz * xkstride;
                 // std::vector<int> ipv1(10,0);
                 // std::vector<int> ipv2(10,0);
                 std::vector<int> ipv1;
                 std::vector<int> ipv2;
                 int start = xpresum[c1-1];
                 int end = xpresum[c1];
                 len1=end-start;
                 if(len1==0){
                     // continue;
                 }else{
                     int ii=0;
                     for(int idx=start;idx<end;idx++){
                         // ipv1[ii]=xbinList[idx];
                         ipv1.push_back(static_cast<int>(xbinList[idx]));
                         ii++;
                     }
                     // len1=ii;
                 }
                 
                 int c2=(ix) + (iy) * nnx + (iz) * nnxny;
                 // if (ptile.m_bin_length[c2] == 0) continue;
                 // if(c2<=0) continue;
                 start = test0[c2];
                 end = test0[c2+1];
                 int ii=0;
                 len2=0;
                 for (int idx = start; idx < end; idx++) {
                     if (test[idx] == INVALID_PARTICLE_ID) {
                         // idx++;
                         continue;
                     } else{
                         // ipv2[ii] = test[idx];
                         ipv2.push_back(static_cast<int>(test[idx]));
                         ii++;
                     }
                     len2=ii;
                 }
                 if(len1!=len2)
                 // if(ipv1.size()!=ipv2.size() && len1!=len2)
                 {
                     printf("x %d y %d z %d\n",ix,iy,iz);
                     printf("True len[%d] %d(%d) sme len[%d] %d(%d) \n",c1,ipv1.size(),len1,c2,ipv2.size(),len2);
                     // amrex::Abort("ipv LEN FALSE!!");
                     int lenip=std::max(ipv2.size(),static_cast<unsigned long>(end-start));
                     for(int i =0;i<lenip;i++){
                         printf("LEN: ip1 %d, ip2 %d \n",ipv1[i],test[start+i]);
                     }
                 }
                 std::sort(ipv1.begin(),ipv1.end());
                 std::sort(ipv2.begin(),ipv2.end());
                 if(std::equal(ipv1.begin(),ipv1.end(),ipv2.begin())){
                 }
                 else{
                     for(int i =0;i<ipv1.size();i++){
                         printf("ip1 %d, ip2 %d \n",ipv1[i],ipv2[i]);
                         err++;
                     }
                 // }
                 // if(ipv1==ipv2){
                     // printf("True len %d sme len %d \n",len1,len2);
                     // amrex::Abort("ipv1 != ipv2!!");
                 }
                 if(err>10) amrex::Abort("ERROR ipv1!=ipv2   !!!!!");
             }
         }
     }
 
 #endif
 
 #if 0
     long bx = 2, by = 2, bz = 2;
     amrex::IntVect box_shape = box.length();
     // amrex::Print() << "Box shape: " << box_shape << std::endl;
     long nnx = box_shape[0];
     long nny = box_shape[1];
     long nnxny = nnx*nny;
     const int testcells = ptile.m_bin_offsets.size();
     std::vector<int> testcount(testcells);
     
     for(int ip=0;ip<np_to_deposit;ip++){
         testcount[test1[ip]]++;
     }
 
     for (int iz = 2; iz < len.z-2; ++iz) {
         for (int iy = 2; iy < len.y-2; ++iy) {       
             for (int ix = 2; ix < len.x-2; ix++) {
                 int c1=ix + iy * xjstride + iz * xkstride;
                 int c2=(ix-bx) + (iy-by) * nnx + (iz-bz) * nnxny;
                 if(testcount[c2]!=xcount[c1])
                 {
                     printf("x %d y %d z %d\n",ix,iy,iz);
                     printf("True xcount[%d] %d sme newbin[%d] %d \n",xcount[c1],c1,testcount[c2],c2);
                     amrex::Abort("newbin LEN FALSE!!");
                 }
                 if(ptile.m_bin_lengths[c2]!=xcount[c1])
                 {
                     printf("x %d y %d z %d\n",ix,iy,iz);
                     printf("True xcount[%d] %d sme m_bin_lengths[%d] %d \n",xcount[c1],c1,ptile.m_bin_lengths[c2],c2);
                     amrex::Abort("m_bin_lengths LEN FALSE!!");
                 }
 
             }
         }
     }
     // std::vector<int> ipv1;
     // std::vector<int> ipv2;
     // std::vector<int> ipv1(np_to_deposit);
     // std::vector<int> ipv2(np_to_deposit);
     int len1=0;
     int len2=0;
     for (int iz = 2; iz < len.z-2; ++iz) {
         for (int iy = 2; iy < len.y-2; ++iy) {       
             for (int ix = 2; ix < len.x-2; ix++) {
                 int c1=ix + iy * xjstride + iz * xkstride;
                 std::vector<int> ipv1;
                 std::vector<int> ipv2;
                 int start = xpresum[c1-1];
                 int end = xpresum[c1];
                 len1=end-start;
                 if(len1==0){
                     // continue;
                 }else{
                     // int ii=0;
                     for(int idx=start;idx<end;idx+=1){
                         // ipv1[ii]=xbinList[idx];
                         ipv1.push_back(static_cast<int>(xbinList[idx]));
                         // ii++;
                     }
                     // len1=ii;
                 }
                 
                 int c2=(ix-2) + (iy-2) * nnx + (iz-2) * nnxny;
                 // if (ptile.m_bin_length[c2] == 0) continue;
                 // if(c2<=0) continue;
                 start = test0[c2];
                 end = test0[c2+1];
                 int ii=0;
                 for (int idx = start; idx < end; idx++) {
                     if (test[idx] == INVALID_PARTICLE_ID) {
                         // idx++;
                         continue;
                     } else{
                         // ipv2[ii] = test[idx];
                         ipv2.push_back(static_cast<int>(test[idx]));
                         ii++;
                     }
                     len2=ii;
                 }
                 // if(len1!=len2)
                 if(ipv1.size()!=ipv2.size())
                 {
                     printf("x %d y %d z %d\n",ix,iy,iz);
                     printf("True len[%d] %d sme len[%d] %d \n",c1,ipv1.size(),c2,ipv2.size());
                     amrex::Abort("ipv LEN FALSE!!");
                 }
                 if(std::equal(ipv1.begin(),ipv1.end(),ipv2.begin())){
                 }
                 else{
                     for(int i =0;i<ipv1.size();i++){
                         printf("ip1 %d, ip2 %d \n",ipv1[i],ipv2[i]);
                     }
                 // }
                 // if(ipv1==ipv2){
                     // printf("True len %d sme len %d \n",len1,len2);
                     amrex::Abort("ipv1 != ipv2!!");
                 }
             }
         }
     }
 #endif
 
     // // std::vector<int> ipv1(np_to_deposit);
     // // std::vector<int> ipv2(np_to_deposit);
     // int len1=0;
     // int len2=0;
     // for (int iz = 0; iz <= len.z; ++iz) {
     //     for (int iy = 0; iy <= len.y; ++iy) {       
     //         for (int ix = 0; ix <= len.x; ix++) {
     //             int c1=ix + iy * xjstride + iz * xkstride+1;
                 
     //             int start = xpresum[c1-1];
     //             int end = xpresum[c1];
     //             if(start==end){
     //                 continue;
     //             }
                 
     //             int ii=0;
     //             for(int idx=start;idx<end;idx+=1){
     //                 // ipv1[ii]=xbinList[idx];
     //                 ipv1.push_back(static_cast<int>(xbinList[idx]));
     //                 ii++;
     //             }
     //             len1=ii;
     //         }
     //     }
     // }
     // for (int iz = 2; iz < len.z-2; ++iz) {
     //     for (int iy = 2; iy < len.y-2; ++iy) {       
     //         for (int ix = 2; ix < len.x-2; ix++) {
     // //             testcells
     //         // for(int c2=0;c2<testcells;c2++){
     //             int c2=(ix-bx) + (iy-by) * xjstride + (iz-bz) * xkstride;
     //             if(c2<=0) continue;
     //             int start = test0[c2];
     //             int end = test0[c2+1];
     //             int ii=0;
     //             for (int idx = start; idx < end; idx++) {
     //                 if (test[idx] == INVALID_PARTICLE_ID) {
     //                     // idx++;
     //                     continue;
     //                 } else{
     //                     // ipv2[ii] = test[idx];
     //                     ipv2.push_back(static_cast<int>(test[idx]));
     //                     ii++;
     //                 }
     //                 len2=ii;
     //             }
     //         }
     //     }
     // }
     
     // // if(len1!=len2)
     // if(ipv1.size()!=ipv2.size())
     // {
     //     printf("True len %d sme len %d \n",ipv1.size(),ipv2.size());
     //     amrex::Abort("LEN FALSE!!");
     // }
     // // if(std::equal(ipv1.begin(),ipv1.end(),ipv2.begin())){
     // if(ipv1!=ipv2){
     //     // printf("True len %d sme len %d \n",len1,len2);
     //     amrex::Abort("ipv1 != ipv2!!");
     // }
     
     // svetime[1]=rdtscv();
     // binlist_time+=(svetime[1]-svetime[0]);
     // sort_time+=(count_time+binlist_time+presum_time);
     // sort_real_sme_kernal_2<1>(numcell,xpresum,xbinList,
     //                         xrhocells,yrhocells,zrhocells,
     //                         sx_m,sy_m,sz_m,
     //                         wqx,wqy,wqz,test0);
     // sort_real_sme_kernal_3<1>(numcell,xpresum,xbinList,
     //                         xrhocells,yrhocells,zrhocells,
     //                         sx_m,sy_m,sz_m,
     //                         wqx,wqy,wqz);
     std::vector<amrex::Real> testsxwq(8*np_to_deposit, 0.0);
    //  std::vector<amrex::Real> testsxwq(2*np_to_deposit, 0.0);
     sort_real_sme_kernal_5<1>(numcell,xpresum,xbinList,
                             xrhocells,yrhocells,zrhocells,
                             sx_m,sy_m,sz_m,
                             wqx,wqy,wqz,testsxwq);
 
     
 
 #if 1
    int err2=0;
    // printf("Checking testsxwq.......\n");
    // for(int ii=0;ii<np_to_deposit;ii++){
    //     // if(test_sxwq[2*ii]!=0){
    //     if(testsxwq[2*ii]!=test_sxwq[2*ii]){
    //         printf("\n");
    //         printf("[1]Err %f testsxwq[%d][1] cell %d org %lf, sme %lf \n"
    //             ,testsxwq[2*ii]-test_sxwq[2*ii],ii, ptile.m_pid_to_bin_map[ii],testsxwq[2*ii],test_sxwq[2*ii]);
    //         printf("\t --szm ERR %f! org szm %lf sme szm %lf\n"
    //             ,sz_m[2*ii]-test0[2*ii],sz_m[2*ii],test0[2*ii]);
    //         err2++;
    //     }
    //     if(testsxwq[2*ii+1]!=test_sxwq[2*ii+1]){
    //         printf("[2]Err %f testsxwq[%d][2] org %lf, sme %lf \n"
    //             ,testsxwq[2*ii+1]-test_sxwq[2*ii+1],ii, ptile.m_pid_to_bin_map[ii],testsxwq[2*ii+1],test_sxwq[2*ii+1]);
    //         printf("\t --wqx ERR %f! org wqx %lf sme wqx %lf\n"
    //             ,wqx[ii]-test1[ii],wqx[ii],test1[ii]);
    //         printf("\n");
    //         err2++;
    //     }
    // }
    // if(err2>=200) amrex::Abort("testsxwq ERR>200");
    printf("Checking testsxwq 1.......\n");
    for(int ii=0;ii<np_to_deposit;ii++){
        // if(test_sxwq[2*ii]!=0){
        // for(int idx=4;idx<8;idx++){
        for(int idx=0;idx<8;idx++){
            // if(testsxwq[8*ii+idx]!=0){
            if(testsxwq[8*ii+idx]!=test_sxwq[8*ii+idx]){
                printf("\n");
                printf("Err[%d] %f testsxwq[%d][%d] cell %d org %lf, sme %lf \n"
                    ,ii,testsxwq[8*ii+idx]-test_sxwq[8*ii+idx],ii,idx,
                    ptile.m_pid_to_bin_map[ii],testsxwq[8*ii+idx],test_sxwq[8*ii+idx]);
                err2++;
                printf("\t --szm ERR %f! org szm0 %lf sme szm0 %lf\n"
                    ,sz_m[2*ii]-test0[2*ii],sz_m[2*ii],test0[2*ii]);
                printf("\t --szm ERR %f! org szm1 %lf sme szm1 %lf\n"
                    ,sz_m[2*ii+1]-test0[2*ii+1],sz_m[2*ii+1],test0[2*ii+1]);
                printf("\t --wqx ERR %f! org wqx %lf sme wqx %lf\n"
                            ,wqx[ii]-test1[ii],wqx[ii],test1[ii]);
                printf("\t --TRUE wqx*sz0= %f! wqx*sz1= %f!\n"
                            ,wqx[ii]*sz_m[2*ii],wqx[ii]*sz_m[2*ii+1]);
            }
            // if(testsxwq[2*ii+1]!=test_sxwq[2*ii+1]){
            //     printf("[2]Err %f testsxwq[%d][2] org %lf, sme %lf \n"
            //         ,testsxwq[2*ii+1]-test_sxwq[2*ii+1],ii, ptile.m_pid_to_bin_map[ii],testsxwq[2*ii+1],test_sxwq[2*ii+1]);
            //     
            //     printf("\n");
            //     err2++;
            // }
            // // 添加这行代码来检查实际的向量长度
            // size_t vl = svcntd(); // 获取double元素的向量长度
            // printf("Vector length: %zu doubles\n", vl);
        }
    }
    if(err2>=200) amrex::Abort("testsxwq ERR>200");
    printf("testsxwq Check!\n");
    long bx = 2, by = 2, bz = 2;
    amrex::IntVect box_shape = box.length();
    // amrex::Print() << "Box shape: " << box_shape << std::endl;
    long nnx = len.x;
    long nny = len.y;
    long nnxny = nnx*nny;
    const int testcells = ptile.m_bin_offsets.size();   
    int err=0; 
    int err1=0; 
    auto& local_index = ptile.m_local_index;
    auto& bin_offsets = ptile.m_bin_offsets;
    auto& bin_length = ptile.m_bin_lengths;
    // const long numcell = ptile.m_bin_offsets.size()-1;
    // const long numcell = jx_fab.box().numPts();
    auto& pid_to_bin_map = ptile.m_pid_to_bin_map;
    auto& free_slot = ptile.m_free_slots;
    int len1=0;
    int len2=0;
    for (int iz = 0; iz < len.z; ++iz) {
        for (int iy = 0; iy < len.y; ++iy) {       
            for (int ix = 0; ix < len.x; ix++) {

                int c1=ix + iy * xjstride + iz * xkstride;
                std::vector<int> ipv1;
                std::vector<int> ipv2;
                int start = xpresum[c1-1];
                int end = xpresum[c1];
                len1=end-start;
                if(len1==0){
                }else{
                    int ii=0;
                    for(int idx=start;idx<end;idx++){
                        // ipv1[ii]=xbinList[idx];
                        ipv1.push_back(static_cast<int>(xbinList[idx]));
                        ii++;
                    }
                    // len1=ii;
                }
                int old_bin=(ix) + (iy) * nnx + (iz) * nnxny+1;
                len2=bin_length[old_bin-1];
                if (bin_length[old_bin-1] == 0) continue;
                start = bin_offsets[old_bin-1];
                end = bin_offsets[old_bin];
                int first_idx=-1;
                for(int i=start;i<end;i++){
                    if (local_index[i] == INVALID_PARTICLE_ID) {
                        // idx1++;
                        continue;
                    } 
                    if(first_idx<0){
                        first_idx=i;
                    }else{
                        int idx1 = first_idx;
                        int idx2=i;
                        int ip1 = local_index[idx1];
                        ipv2.push_back(ip1);
                        int ip2 = local_index[idx2];
                        ipv2.push_back(ip2);
                        first_idx=-1;
                    }
                }
                if(first_idx>=0){
                    int ip1 = local_index[first_idx];
                    ipv2.push_back(ip1);
                }
                if(len1!=len2)
                // if(ipv1.size()!=ipv2.size() && len1!=len2)
                {
                    printf("x %d y %d z %d\n",ix,iy,iz);
                    printf("True len[%d] %d(%d) sme len[%d] %d(%d) \n",c1,ipv1.size(),len1,old_bin-1,ipv2.size(),len2);
                    // amrex::Abort("ipv LEN FALSE!!");
                    int lenip=std::max(ipv2.size(),static_cast<unsigned long>(end-start));
                    for(int i =0;i<lenip;i++){
                        printf("LEN: ip1 %d, ip2 %d \n",ipv1[i],test[start+i]);
                    }
                }
                std::sort(ipv1.begin(),ipv1.end());
                std::sort(ipv2.begin(),ipv2.end());
                if(std::equal(ipv1.begin(),ipv1.end(),ipv2.begin())){
                }
                else{
                    for(int i =0;i<ipv1.size();i++){
                        printf("ip1 %d, ip2 %d \n",ipv1[i],ipv2[i]);
                        err++;
                    }
                // }
                // if(ipv1==ipv2){
                    // printf("True len %d sme len %d \n",len1,len2);
                    // amrex::Abort("ipv1 != ipv2!!");
                }
                if(err>10) amrex::Abort("ERROR ipv1!=ipv2   !!!!!");




                
                // int c1=ix + iy * xjstride + iz * xkstride-1;
                c1=ix + iy * xjstride + iz * xkstride-1;
                int c2=(ix) + (iy) * nnx + (iz) * nnxny;
                bool flag=false;
                for(int ii=0;ii<8;ii++){
                    double t1=xrhocells[8*c1+ii];
                    double t2=test_rhocells[8*c2+ii];
                    if(t1!=t2){
                        printf("x %d y %d z %d c1 %d c2 %d :\n", 
                            ix,iy,iz,c1,c2);
                        printf("TRUE rho %lf SME rho %lf, err %lf\n",
                            t1,t2,t1-t2);
                        flag=true;
                        err1++;
                    }
                }
                // if(flag) amrex::Abort("Rhocell ERROR!!");
                if(err1>10) amrex::Abort("Rhocell ERROR!!");
            }
        }
    }
    // amrex::Abort("Rhocell ERROR!!");
 #endif
    // sort_real_sme_kernal<1>(numcell,xpresum,xbinList,
    //                         xrhocells,yrhocells,zrhocells,
    //                         sx_m,sy_m,sz_m,
    //                         wqx,wqy,wqz,test,len);
    // amrex::Abort("stop");
    // svbool_t p_4=svwhilelt_b64(0,4);
    // svbool_t p0=svwhilelt_b64(0,2);
    // svbool_t p1=svbic_z(p_4,p_4, p0);
    // for(int c=1;c<=numcell;c++){
    //     // svetime[0]=rdtscv();
    //
    //     int start = xpresum[c-1];
    //     int end = xpresum[c];
    //     if(start==end){
    //         // svetime[1]=rdtscv();
    //         // branch_time+=(svetime[1]-svetime[0]);
    //         continue;
    //     }
    //     // svetime[1]=rdtscv();
    //     // branch_time+=(svetime[1]-svetime[0]);
    //     svbool_t p = svptrue_b64();
    //     Vec wwx = Vec::Load(p,&xrhocells[8*c]);
    //     Vec wwy = Vec::Load(p,&yrhocells[8*c]);
    //     Vec wwz = Vec::Load(p,&zrhocells[8*c]);
    //     // const int end_len = std::min(2, static_cast<int>(end-start));
    //     //TODO use cell+=2, to do 2cells particles depo simultaneously
    //     for(int idx=start;idx<end;idx+=2){
    //         // sx={x[0],x[1],x2[0],x2[1]}
    //         // sysz={y1[0]z1[0],y1[1]z1[0],y1[0]z1[1],y1[1]z1[1],y2[0]z2[0],y2[1]z2[0],y2[0]z2[1],y2[1]z2[1]}
    //         int ip=xbinList[idx];
    //         int ip1=xbinList[idx+1];
    //         Vec sx_v=svdup_n_f64(0);
    //         Vec sx_1 = svld1(p0,&sx_m[ip][0]);
    //         sx_v=svsel(p0,sx_1,sx_v);
    //         // svbool_t p1=svwhilelt_b64(2,4);
    //         Vec sx_2 = svld1(p1,&sx_m[ip1-1][0]);
    //         sx_v=svsel(p1,sx_2,sx_v);
    //
    //         // svbool_t p1=svbic_z(svptrue_b64(),p_4, p0);
    //         // sx_v = svld1(p1,&sx_m[ip+1][0]);
    //         // sx_v.Load(p0,&sx_m[ip][0]);
    //         // sx_v.Load(p1,&sx_m[ip+1][0]);
    //
    //         // svbool_t p_4=svwhilelt_b64(0,4);
    //         // double sxx[8];
    //         // sx_v.Store(svptrue_b64(),&sxx[0]);
    //         // printf("ip %d sxx %lf sx_m %lf \n",ip,sxx[0],sx_m[ip][0]);
    //         // printf("ip %d sxx %lf sx_m %lf \n\n",ip1,sxx[2],sx_m[ip1][0]);
    //         // for (int i=0;i<2;i++){
    //         //     int tt=xbinList[idx+i];
    //         //     // test[tt]=sxx[i];
    //         //     printf("ip %d sxx %lf \n",tt,sxx[2*i]);
    //         //     // printf("ip %d sxm %lf \n",tt,sx_m[tt][0]);
    //         // }
    //         // amrex::Abort("test");
    //         // for (int i=0;i<4;i++){
    //         //     printf("sxx %lf \n",sxx[i]);
    //         // }
    //
    //         Vec vy1=Vec::Load(p0, &sy_m[ip][0]);
    //         Vec vy2=Vec::Load(p0, &sy_m[ip1][0]);
    //         Vec vz1=Vec::Load(p0, &sz_m[ip][0]);
    //         Vec vz2=Vec::Load(p0, &sz_m[ip1][0]);
    //
    //         const uint64_t y_indices[8]={0,1,0,1,2,3,2,3};
    //         Vec vy_broadcast=svtbl(svzip1(vy1,vy2),svld1_u64(svptrue_b64(),y_indices));
    //         const uint64_t z_indices[8]={0,0,1,1,2,2,3,3};
    //         Vec vz_broadcast=svtbl(svzip1(vz1,vz2),svld1_u64(svptrue_b64(),z_indices));
    //
    //         Vec sysz_v=vy_broadcast*vz_broadcast;





    //         // printf("ip %d sx_m[0] %lf sx_m[1] %lf \n",
    //         //             ip,   sx_m[0][ip],  sx_m[1][ip]);
    //         // Vec sx0=Vec(sx_m[0][ip]);
    //         // Vec sx1=Vec(sx_m[1][ip]);
    //         // Vec sxv=svsel_f64(px,sx0,sx1);
    //         // Vec sy0=Vec(sy_m[0][ip]);
    //         // Vec sy1=Vec(sy_m[1][ip]);
    //         // Vec syv=svsel_f64(py,sy0,sy1);
    //         // Vec sz0=Vec(sz_m[0][ip]);
    //         // Vec sz1=Vec(sz_m[1][ip]);
    //         // Vec szv=svsel_f64(pz,sz0,sz1);
    //         // // printf("Error 2! \n");
    //         // Vec s = sxv*syv*szv;
    //         // Vec jx_v=s*wqx[ip];
    //         // // jx_v.Store(p,&test[ip*8]);
    //         // wwx+=jx_v;
    //         // Vec jy_v=s*wqy[ip];
    //         // wwy+=jy_v;              
    //         // Vec jz_v=s*wqz[ip];
    //         // wwz+=jz_v;
    //     }
    //     wwx.Store(p,&xrhocells[8*c]);
    //     // test[c]=xrhocells[8*c]
    //     wwy.Store(p,&yrhocells[8*c]);
    //     wwz.Store(p,&zrhocells[8*c]);
    //     // svetime[1]=rdtscv();
    //     // cale_time+=(svetime[1]-svetime[0]);
    // }
    
    // amrex::Abort("test");              
    // TODO: reduction needs  to modify out of this func
    // ix iy iz in numcell
    // this can be SME
    int errcount=0;
    for (int iz = 0; iz <= len.z; ++iz) {
        for (int iy = 0; iy <= len.y; ++iy) { 
            // scalar mode
            // for(int ix = 0; ix <= len.x; ix++){
            //     long j = lo.x + ix;
            //     long k = lo.y + iy;
            //     long l = lo.z + iz;
            //     // long jxoffset = j - jx_arr.begin.x + 
            //     //     (k - jx_arr.begin.y) * xjstride + 
            //     //     (l - jx_arr.begin.z) * xkstride;
            //     long jxoffset = ix + iy * xjstride + iz * xkstride;
            //     long xoffset = 8*(ix + iy * xjstride + iz * xkstride);
            //     // if(8*jxoffset==xoffset){
            //     //     printf("jxoffset %d xoffset %d \n",jxoffset,xoffset);
            //     // }
            //     jx_arr.p[jxoffset+moff[0]]+=xrhocells[0+xoffset];
            //     jx_arr.p[jxoffset+moff[1]]+=xrhocells[1+xoffset];
            //     jx_arr.p[jxoffset+moff[2]]+=xrhocells[2+xoffset];
            //     jx_arr.p[jxoffset+moff[3]]+=xrhocells[3+xoffset];
            //     jx_arr.p[jxoffset+moff[4]]+=xrhocells[4+xoffset];
            //     jx_arr.p[jxoffset+moff[5]]+=xrhocells[5+xoffset];
            //     jx_arr.p[jxoffset+moff[6]]+=xrhocells[6+xoffset];
            //     jx_arr.p[jxoffset+moff[7]]+=xrhocells[7+xoffset];
            //     // if(iy==3 && iz==2){
            //     //     printf("rhocell %lf %lf %lf %lf \n",xrhocells[0+xoffset],xrhocells[1+xoffset]
            //     //             ,xrhocells[2+xoffset],xrhocells[3+xoffset]);
            //     // }
            //     // double jxorg=jx_arr.p[jxoffset+moff[0]];
            //     // if(jxorg>1e-2){
            //     //     // printf("jxoffset %ld jxoffset1 %ld \n",jxoffset+moff[idx],jxoffset1+moff[idx]);
            //     //     printf("ix %d iy %d iz %d: jxorg %lf \n",
            //     //                 ix,  iy,   iz,  jxorg );
            //     //     errcount++;
            //     //     if(errcount>10){
            //     //         // printf("%d %d %d %d \n",len.x,len.y,len.z,jx_fab.box().numPts());
            //     //         // amrex::Abort("ERROR 10 ! jxorg and jxsve");
            //     //     }
            //     // }
            // }
            
            for (int ix = 0; ix <= len.x; ix+=vl) {
                // svetime[0]=rdtscv();

                // vector
                svbool_t p=svwhilele_b64(ix,len.x);
                // long j = lo.x + ix;
                // long k = lo.y + iy;
                // long l = lo.z + iz;
                // x
                // uint64_t irhox = 8*(ix + iy * xjstride + iz * xkstride);
                // svuint64_t rhox_index = svindex_u64(0, 8ULL);
                // long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                svuint64_t rho_index = svindex_u64(0ULL, 8ULL);
                long xoffset=ix + iy * xjstride + iz * xkstride;
                long jxoffset=xoffset;
                long irhox=8*xoffset;
                Vec jx0=Vec::Load(p,&jx_arr.p[jxoffset+moff[0]]);
                svfloat64_t rhox0=svld1_gather_u64index_f64(p,&xrhocells[0+irhox],rho_index);
                jx0+=rhox0;
                jx0.Store(p,&jx_arr.p[jxoffset+moff[0]]);

                Vec jx1=Vec::Load(p,&jx_arr.p[jxoffset+moff[1]]);
                svfloat64_t rhox1=svld1_gather_u64index_f64(p,&xrhocells[1+irhox],rho_index);
                jx1+=rhox1;
                jx1.Store(p,&jx_arr.p[jxoffset+moff[1]]);

                Vec jx2=Vec::Load(p,&jx_arr.p[jxoffset+moff[2]]);
                svfloat64_t rhox2=svld1_gather_u64index_f64(p,&xrhocells[2+irhox],rho_index);
                jx2+=rhox2;
                jx2.Store(p,&jx_arr.p[jxoffset+moff[2]]);

                Vec jx3=Vec::Load(p,&jx_arr.p[jxoffset+moff[3]]);
                svfloat64_t rhox3=svld1_gather_u64index_f64(p,&xrhocells[3+irhox],rho_index);
                jx3+=rhox3;
                jx3.Store(p,&jx_arr.p[jxoffset+moff[3]]);

                Vec jx4=Vec::Load(p,&jx_arr.p[jxoffset+moff[4]]);
                svfloat64_t rhox4=svld1_gather_u64index_f64(p,&xrhocells[4+irhox],rho_index);
                jx4+=rhox4;
                jx4.Store(p,&jx_arr.p[jxoffset+moff[4]]);

                Vec jx5=Vec::Load(p,&jx_arr.p[jxoffset+moff[5]]);
                svfloat64_t rhox5=svld1_gather_u64index_f64(p,&xrhocells[5+irhox],rho_index);
                jx5+=rhox5;
                jx5.Store(p,&jx_arr.p[jxoffset+moff[5]]);

                Vec jx6=Vec::Load(p,&jx_arr.p[jxoffset+moff[6]]);
                svfloat64_t rhox6=svld1_gather_u64index_f64(p,&xrhocells[6+irhox],rho_index);
                jx6+=rhox6;
                jx6.Store(p,&jx_arr.p[jxoffset+moff[6]]);

                Vec jx7=Vec::Load(p,&jx_arr.p[jxoffset+moff[7]]);
                svfloat64_t rhox7=svld1_gather_u64index_f64(p,&xrhocells[7+irhox],rho_index);
                jx7+=rhox7;
                jx7.Store(p,&jx_arr.p[jxoffset+moff[7]]);
                
                // y
                // uint64_t irhoy = ix + iy * yjstride + iz * ykstride;
                // svuint64_t rhoy_index = svindex_u64(irhoy, 8ULL);
                // long jyoffset = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
                long yoffset = ix + iy * yjstride + iz * ykstride;
                long jyoffset=yoffset;
                long irhoy=8*yoffset;
                Vec jy0=Vec::Load(p,&jy_arr.p[jyoffset+moff[0]]);
                svfloat64_t rhoy0=svld1_gather_u64index_f64(p,&yrhocells[0+irhoy],rho_index);
                jy0+=rhoy0;
                jy0.Store(p,&jy_arr.p[jyoffset+moff[0]]);

                Vec jy1=Vec::Load(p,&jy_arr.p[jyoffset+moff[1]]);
                svfloat64_t rhoy1=svld1_gather_u64index_f64(p,&yrhocells[1+irhoy],rho_index);
                jy1+=rhoy1;
                jy1.Store(p,&jy_arr.p[jyoffset+moff[1]]);

                Vec jy2=Vec::Load(p,&jy_arr.p[jyoffset+moff[2]]);
                svfloat64_t rhoy2=svld1_gather_u64index_f64(p,&yrhocells[2+irhoy],rho_index);
                jy2+=rhoy2;
                jy2.Store(p,&jy_arr.p[jyoffset+moff[2]]);

                Vec jy3=Vec::Load(p,&jy_arr.p[jyoffset+moff[3]]);
                svfloat64_t rhoy3=svld1_gather_u64index_f64(p,&yrhocells[3+irhoy],rho_index);
                jy3+=rhoy3;
                jy3.Store(p,&jy_arr.p[jyoffset+moff[3]]);

                Vec jy4=Vec::Load(p,&jy_arr.p[jyoffset+moff[4]]);
                svfloat64_t rhoy4=svld1_gather_u64index_f64(p,&yrhocells[4+irhoy],rho_index);
                jy4+=rhoy4;
                jy4.Store(p,&jy_arr.p[jyoffset+moff[4]]);

                Vec jy5=Vec::Load(p,&jy_arr.p[jyoffset+moff[5]]);
                svfloat64_t rhoy5=svld1_gather_u64index_f64(p,&yrhocells[5+irhoy],rho_index);
                jy5+=rhoy5;
                jy5.Store(p,&jy_arr.p[jyoffset+moff[5]]);

                Vec jy6=Vec::Load(p,&jy_arr.p[jyoffset+moff[6]]);
                svfloat64_t rhoy6=svld1_gather_u64index_f64(p,&yrhocells[6+irhoy],rho_index);
                jy6+=rhoy6;
                jy6.Store(p,&jy_arr.p[jyoffset+moff[6]]);

                Vec jy7=Vec::Load(p,&jy_arr.p[jyoffset+moff[7]]);
                svfloat64_t rhoy7=svld1_gather_u64index_f64(p,&yrhocells[7+irhoy],rho_index);
                jy7+=rhoy7;
                jy7.Store(p,&jy_arr.p[jyoffset+moff[7]]);

                // z
                // uint64_t irhoz = ix + iy * zjstride + iz * zkstride;
                // svuint64_t rhoz_index = svindex_u64(irhoz, 8ULL);
                // long jzoffset = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
                long zoffset = ix + iy * zjstride + iz * zkstride;
                long jzoffset=zoffset;
                long irhoz=8*zoffset;
                Vec jz0=Vec::Load(p,&jz_arr.p[jzoffset+moff[0]]);
                svfloat64_t rhoz0=svld1_gather_u64index_f64(p,&zrhocells[0+irhoz],rho_index);
                jz0+=rhoz0;
                jz0.Store(p,&jz_arr.p[jzoffset+moff[0]]);

                Vec jz1=Vec::Load(p,&jz_arr.p[jzoffset+moff[1]]);
                svfloat64_t rhoz1=svld1_gather_u64index_f64(p,&zrhocells[1+irhoz],rho_index);
                jz1+=rhoz1;
                jz1.Store(p,&jz_arr.p[jzoffset+moff[1]]);

                Vec jz2=Vec::Load(p,&jz_arr.p[jzoffset+moff[2]]);
                svfloat64_t rhoz2=svld1_gather_u64index_f64(p,&zrhocells[2+irhoz],rho_index);
                jz2+=rhoz2;
                jz2.Store(p,&jz_arr.p[jzoffset+moff[2]]);

                Vec jz3=Vec::Load(p,&jz_arr.p[jzoffset+moff[3]]);
                svfloat64_t rhoz3=svld1_gather_u64index_f64(p,&zrhocells[3+irhoz],rho_index);
                jz3+=rhoz3;
                jz3.Store(p,&jz_arr.p[jzoffset+moff[3]]);

                Vec jz4=Vec::Load(p,&jz_arr.p[jzoffset+moff[4]]);
                svfloat64_t rhoz4=svld1_gather_u64index_f64(p,&zrhocells[4+irhoz],rho_index);
                jz4+=rhoz4;
                jz4.Store(p,&jz_arr.p[jzoffset+moff[4]]);

                Vec jz5=Vec::Load(p,&jz_arr.p[jzoffset+moff[5]]);
                svfloat64_t rhoz5=svld1_gather_u64index_f64(p,&zrhocells[5+irhoz],rho_index);
                jz5+=rhoz5;
                jz5.Store(p,&jz_arr.p[jzoffset+moff[5]]);

                Vec jz6=Vec::Load(p,&jz_arr.p[jzoffset+moff[6]]);
                svfloat64_t rhoz6=svld1_gather_u64index_f64(p,&zrhocells[6+irhoz],rho_index);
                jz6+=rhoz6;
                jz6.Store(p,&jz_arr.p[jzoffset+moff[6]]);

                Vec jz7=Vec::Load(p,&jz_arr.p[jzoffset+moff[7]]);
                svfloat64_t rhoz7=svld1_gather_u64index_f64(p,&zrhocells[7+irhoz],rho_index);
                jz7+=rhoz7;
                jz7.Store(p,&jz_arr.p[jzoffset+moff[7]]);

                // svetime[1]=rdtscv();
                // reduce_time+=(svetime[1]-svetime[0]);
            }
        }
    }
    
    // auto total_stop=high_resolution_clock::now();
    // duration<double> total_elapse = total_stop-total_start;
    // total_time = total_elapse.count();
    // printf("\n SVE noblock Sort: total time: %lf s, precompute: %ld, sort_time %ld cale_time: %ld, reduce_time: %ld \n",
    //     total_time,     precompute,   sort_time,  cale_time,     reduce_time);
    // printf("\t noblock Sort: %ld, Count: %ld, Presum %ld binlist: %ld, Branch: %ld \n",
    //         sort_time,      count_time,   presum_time,  binlist_time, branch_time);

    // total_time[1]=rdtscv();
    // total_time[2]=(total_time[1]-total_time[0]);
    // printf("total time: %d, precompute: %d, cale_time: %d, reduce_time: %d \n",
    //         total_time,     precompute,     cale_time,     reduce_time);
    // amrex::Abort("END!");
 
 }

 // 添加了真的粒子分桶排序功能
 // 把最基本的排序sort版本实现了先，这不是stencilsme
 template <int depos_order>
 void doDepositionShapeN_sort_test_order3 (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Dim3 hi,
                          amrex::Dim3 len,
                          amrex::Real q,
                          std::vector<int>& test,
                          std::vector<double>& test0,std::vector<double>& test1,
                          ParticleTileType& ptile, const amrex::Box& box,
                          std::vector<amrex::Real>& test_rhocells,
                          std::vector<amrex::Real>& test_sxwq,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     // uint64_t total_time[3]={0};
     using namespace std::chrono;
     using namespace amrex::literals;
     double total_time=0;
     // auto total_start=high_resolution_clock::now();
     uint64_t precompute=0;
     uint64_t cale_time=0;
     uint64_t sort_time=0;
         uint64_t count_time=0;
         uint64_t presum_time=0;
         uint64_t binlist_time=0;
     uint64_t reduce_time=0;
     uint64_t svetime[3]={0};
     uint64_t branch_time=0;
     
     // total_time[0]=rdtscv();
     
 
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z; 
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
 
     constexpr int nshapes = depos_order + 1;
     // constexpr int nshapes = 2;
     int vl=svcntd();
 
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
     auto compute_shape_factor_order3_v2 = [](double* sx, Vec xmid, svbool_t p, int np) {
        intVec i_newv = svcvt_s64_f64_z(p, xmid);

        Vec j = svrintz_x(p, xmid);
        Vec xint = xmid - j;
        Vec temp = 1.0 - xint;

        Vec sx0 = (1.0 / 6.0) * temp * temp * temp;
        sx0.Store(p, &sx[0*np]);
        Vec sx1 = (2.0 / 3.0) - xint * xint * (1.0 - xint * 0.5);
        sx1.Store(p, &sx[1*np]);
        Vec sx2 = (2.0 / 3.0) - temp * temp * (1.0 - 0.5 *temp);
        sx2.Store(p, &sx[2*np]);
        Vec sx3 = (1.0 / 6.0) * xint * xint * xint;
        sx3.Store(p, &sx[3*np]);

        return i_newv-1;
    };

    // 预计算网格步长
    const int xjstride = jx_arr.jstride;
    const int xkstride = jx_arr.kstride;
    // int nshapes=4;
    std::vector<amrex::Real> wqx(np_to_deposit);
    std::vector<amrex::Real> wqy(np_to_deposit);
    std::vector<amrex::Real> wqz(np_to_deposit);
    std::vector<amrex::Real> sx_mT(np_to_deposit*nshapes);
    std::vector<amrex::Real> sy_mT(np_to_deposit*nshapes);
    std::vector<amrex::Real> sz_mT(np_to_deposit*nshapes);

    long nnx = len.x;
    long nny = len.y;
    long nnxny = nnx*nny;
    alignas(64) int xoffsets[np_to_deposit]; 
    const long numcell = jx_fab.box().numPts();

    
    for(long ip=0;ip<np_to_deposit;ip+=vl){
        // svetime[0]=rdtscv();
        // 计算基本物理量
        svbool_t p=svwhilelt_b64(ip,np_to_deposit);

        // Inverse of Lorentz factor gamma
        Vec uxp_v=Vec::Load(p,&uxp[ip]);
        Vec uyp_v=Vec::Load(p,&uyp[ip]);
        Vec uzp_v=Vec::Load(p,&uzp[ip]);
        Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                    + uyp_v * uyp_v * clightsq
                                    + uzp_v * uzp_v * clightsq).Sqrt();
        // Product of particle charges and weights
        Vec wp_v=Vec::Load(p,&wp[ip]);
        Vec wq_v = q * wp_v;

        // Current particle positions (in physical units)
        Vec xp = Vec::Load(p, &mx[ip]);
        Vec yp = Vec::Load(p, &my[ip]);
        Vec zp = Vec::Load(p, &mz[ip]);

        // Particle velocities
        Vec vx_v = uxp_v * gaminv;
        Vec wqx_v = wq_v * invvol * vx_v;
        wqx_v.Store(p, &wqx[ip]);
        Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x;

        Vec vy_v = uyp_v * gaminv;
        Vec wqy_v = wq_v * invvol * vy_v;
        wqy_v.Store(p, &wqy[ip]);
        Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y;

        Vec vz_v = uzp_v * gaminv;
        Vec wqz_v = wq_v * invvol * vz_v;
        wqz_v.Store(p, &wqz[ip]);
        Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z;
        
        intVec j_cellv2 = compute_shape_factor_order3_v2( &sx_mT[ip], xmid, p,np_to_deposit);
        intVec k_cellv2 = compute_shape_factor_order3_v2( &sy_mT[ip], ymid, p,np_to_deposit);
        intVec l_cellv2 = compute_shape_factor_order3_v2( &sz_mT[ip], zmid, p,np_to_deposit); 
        intVec new_bin_v = (j_cellv2) + 
                (k_cellv2)* xjstride + 
                (l_cellv2) * xkstride;
        svst1w_s64(p, &xoffsets[ip], new_bin_v);
    }
    std::vector<long> xcount(numcell,0);
    for(long ip=0;ip<np_to_deposit;ip++){
        xcount[xoffsets[ip]]++;
    }
    std::vector<int> xpresum(numcell+1,0);
    for(int c=1;c<=numcell;c++){
        xpresum[c]=xpresum[c-1]+xcount[c-1];
    }
    std::vector<int> xbinList(np_to_deposit,-1);
    for(int ip=0;ip<np_to_deposit;ip++){
        long xoffset = xoffsets[ip];
        xbinList[xpresum[xoffset]]=ip;
        xpresum[xoffset]++;
    }
 
#if 1
    long bx = 2, by = 2, bz = 2;
    amrex::IntVect box_shape = box.length();
    // amrex::Print() << "Box shape: " << box_shape << std::endl;
    // long nnx = len.x;
    // long nny = len.y;
    // long nnxny = nnx*nny;

    const int testcells = ptile.m_bin_offsets.size()+1;
    std::vector<int> testcount(testcells);
    auto& pid_to_bin_map=ptile.m_pid_to_bin_map_hbm;
    for(int ip=0;ip<np_to_deposit;ip++){
        // printf("pid_to_bin_map[%d]=%d/%d,testcount[%d]=%d/%d++ \n",
        //     ip,pid_to_bin_map[ip],pid_to_bin_map.size(),
        //     pid_to_bin_map[ip],testcount[pid_to_bin_map[ip]],
        //     testcount.size()
        // );
        testcount[pid_to_bin_map[ip]]++;
        // testcount[test1[ip]]++;
    }

    for (int iz = 0; iz < len.z; ++iz) {
        for (int iy = 0; iy < len.y; ++iy) {       
            for (int ix = 0; ix < len.x; ix++) {
                int c1=ix + iy * xjstride + iz * xkstride;
                int c2=(ix) + (iy) * nnx + (iz) * nnxny;
                if(testcount[c2]!=xcount[c1])
                {
                    printf("x %d y %d z %d\n",ix,iy,iz);
                    printf("True xcount[%d] %d sme newbin[%d] %d \n",c1,xcount[c1],c2,testcount[c2]);
                    amrex::Abort("newbin LEN FALSE!!");
                }
                if(ptile.m_bin_lengths[c2]!=xcount[c1])
                {
                    printf("x %d y %d z %d\n",ix,iy,iz);
                    printf("True xcount[%d] %d sme m_bin_lengths[%d] %d \n",c1,xcount[c1],c2,ptile.m_bin_lengths[c2]);
                    amrex::Abort("m_bin_lengths LEN FALSE!!");
                }

            }
        }
    }
    // std::vector<int> ipv1;
    // std::vector<int> ipv2;
    // std::vector<int> ipv1(np_to_deposit);
    // std::vector<int> ipv2(np_to_deposit);

    int len1=0;
    int len2=0;
    int err=0;
    for (int iz = 0; iz < len.z; ++iz) {
        for (int iy = 0; iy < len.y; ++iy) {       
            for (int ix = 1; ix < len.x; ix++) {
                int c1=ix + iy * xjstride + iz * xkstride;
                // std::vector<int> ipv1(10,0);
                // std::vector<int> ipv2(10,0);
                std::vector<int> ipv1;
                std::vector<int> ipv2;
                int start = xpresum[c1-1];
                int end = xpresum[c1];
                len1=end-start;
                if(len1==0){
                    // continue;
                }else{
                    // int ii=0;
                    for(int idx=start;idx<end;idx++){
                        // ipv1[ii]=xbinList[idx];
                        ipv1.push_back(static_cast<int>(xbinList[idx]));
                        // ii++;
                    }
                    // len1=ii;
                }
                
                int c2=(ix) + (iy) * nnx + (iz) * nnxny;
                // if (ptile.m_bin_length[c2] == 0) continue;
                // if(c2<=0) continue;
                start = ptile.m_bin_offsets[c2];
                end = start+ptile.m_bin_lengths[c2];
                int ii=0;
                len2=ptile.m_bin_lengths[c2];
                for (int idx = start; idx < end; idx++) {
                
                    ipv2.push_back(static_cast<int>(
                        ptile.m_local_index_hbm[idx]));
                    // ii++;
                
                    // len2=ii;
                }
                if(len1!=len2)
                // if(ipv1.size()!=ipv2.size() && len1!=len2)
                {
                    printf("x %d y %d z %d\n",ix,iy,iz);
                    printf("True len[%d] %d(%d) sme len[%d] %d(%d) \n",
                        c1,ipv1.size(),len1,c2,ipv2.size(),len2);
                    // amrex::Abort("ipv LEN FALSE!!");
                    int lenip=std::max(ipv2.size(),
                        static_cast<unsigned long>(end-start));
                    for(int i =0;i<lenip;i++){
                        printf("LEN: ip1 %d, ip2 %d \n",
                            ipv1[i],test[start+i]);
                    }
                }
                std::sort(ipv1.begin(),ipv1.end());
                std::sort(ipv2.begin(),ipv2.end());
                // if(std::equal(ipv1.begin(),ipv1.end(),ipv2.begin())){
                // }
                // else{
                #if 0
                if(ipv1.size()>0)
                    printf("============ IP1 ==============\n");
                for(int i =0;i<ipv1.size();i++){
                    printf("ip1 %d \n",ipv1[i]);
                    // err++;
                }
                if(ipv2.size()>0)
                    printf("============ IP2 ==============\n");
                for(int i =0;i<ipv2.size();i++){
                    printf("ip2 %d \n",ipv2[i]);
                    // err++;
                }
                #endif
                for(int i =0;i<std::min(ipv1.size(),ipv2.size());i++){
                    if(ipv1[i]!=ipv2[i]) err++;
                }
                // }
                // if(ipv1==ipv2){
                    // printf("True len %d sme len %d \n",len1,len2);
                    // amrex::Abort("ipv1 != ipv2!!");
                // }
                if(err>10) amrex::Abort("ERROR ipv1!=ipv2   !!!!!");
            }
        }
    }
    return;
#endif
 
#if 0
    long bx = 2, by = 2, bz = 2;
    amrex::IntVect box_shape = box.length();
    // amrex::Print() << "Box shape: " << box_shape << std::endl;
    long nnx = box_shape[0];
    long nny = box_shape[1];
    long nnxny = nnx*nny;
    const int testcells = ptile.m_bin_offsets.size();
    std::vector<int> testcount(testcells);
    
    for(int ip=0;ip<np_to_deposit;ip++){
        testcount[test1[ip]]++;
    }

    for (int iz = 2; iz < len.z-2; ++iz) {
        for (int iy = 2; iy < len.y-2; ++iy) {       
            for (int ix = 2; ix < len.x-2; ix++) {
                int c1=ix + iy * xjstride + iz * xkstride;
                int c2=(ix-bx) + (iy-by) * nnx + (iz-bz) * nnxny;
                if(testcount[c2]!=xcount[c1])
                {
                    printf("x %d y %d z %d\n",ix,iy,iz);
                    printf("True xcount[%d] %d sme newbin[%d] %d \n",xcount[c1],c1,testcount[c2],c2);
                    amrex::Abort("newbin LEN FALSE!!");
                }
                if(ptile.m_bin_lengths[c2]!=xcount[c1])
                {
                    printf("x %d y %d z %d\n",ix,iy,iz);
                    printf("True xcount[%d] %d sme m_bin_lengths[%d] %d \n",xcount[c1],c1,ptile.m_bin_lengths[c2],c2);
                    amrex::Abort("m_bin_lengths LEN FALSE!!");
                }

            }
        }
    }
    // std::vector<int> ipv1;
    // std::vector<int> ipv2;
    // std::vector<int> ipv1(np_to_deposit);
    // std::vector<int> ipv2(np_to_deposit);
    int len1=0;
    int len2=0;
    for (int iz = 0; iz < len.z; ++iz) {
        for (int iy = 0; iy < len.y; ++iy) {       
            for (int ix = 0; ix < len.x; ix++) {
                int c1=ix + iy * xjstride + iz * xkstride;
                std::vector<int> ipv1;
                std::vector<int> ipv2;
                int start = xpresum[c1-1];
                int end = xpresum[c1];
                len1=end-start;
                if(len1==0){
                    // continue;
                }else{
                    // int ii=0;
                    for(int idx=start;idx<end;idx+=1){
                        // ipv1[ii]=xbinList[idx];
                        ipv1.push_back(static_cast<int>(xbinList[idx]));
                        // ii++;
                    }
                    // len1=ii;
                }
                
                int c2=(ix-2) + (iy-2) * nnx + (iz-2) * nnxny;
                // if (ptile.m_bin_length[c2] == 0) continue;
                // if(c2<=0) continue;
                start = test0[c2];
                end = test0[c2+1];
                int ii=0;
                for (int idx = start; idx < end; idx++) {
                    if (test[idx] == INVALID_PARTICLE_ID) {
                        // idx++;
                        continue;
                    } else{
                        // ipv2[ii] = test[idx];
                        ipv2.push_back(static_cast<int>(test[idx]));
                        ii++;
                    }
                    len2=ii;
                }
                // if(len1!=len2)
                if(ipv1.size()!=ipv2.size())
                {
                    printf("x %d y %d z %d\n",ix,iy,iz);
                    printf("True len[%d] %d sme len[%d] %d \n",c1,ipv1.size(),c2,ipv2.size());
                    amrex::Abort("ipv LEN FALSE!!");
                }
                if(std::equal(ipv1.begin(),ipv1.end(),ipv2.begin())){
                }
                else{
                    for(int i =0;i<ipv1.size();i++){
                        printf("ip1 %d, ip2 %d \n",ipv1[i],ipv2[i]);
                    }
                // }
                // if(ipv1==ipv2){
                    // printf("True len %d sme len %d \n",len1,len2);
                    amrex::Abort("ipv1 != ipv2!!");
                }
            }
        }
    }
    return;
#endif
 
     // // std::vector<int> ipv1(np_to_deposit);
     // // std::vector<int> ipv2(np_to_deposit);
     // int len1=0;
     // int len2=0;
     // for (int iz = 0; iz <= len.z; ++iz) {
     //     for (int iy = 0; iy <= len.y; ++iy) {       
     //         for (int ix = 0; ix <= len.x; ix++) {
     //             int c1=ix + iy * xjstride + iz * xkstride+1;
                 
     //             int start = xpresum[c1-1];
     //             int end = xpresum[c1];
     //             if(start==end){
     //                 continue;
     //             }
                 
     //             int ii=0;
     //             for(int idx=start;idx<end;idx+=1){
     //                 // ipv1[ii]=xbinList[idx];
     //                 ipv1.push_back(static_cast<int>(xbinList[idx]));
     //                 ii++;
     //             }
     //             len1=ii;
     //         }
     //     }
     // }
     // for (int iz = 2; iz < len.z-2; ++iz) {
     //     for (int iy = 2; iy < len.y-2; ++iy) {       
     //         for (int ix = 2; ix < len.x-2; ix++) {
     // //             testcells
     //         // for(int c2=0;c2<testcells;c2++){
     //             int c2=(ix-bx) + (iy-by) * xjstride + (iz-bz) * xkstride;
     //             if(c2<=0) continue;
     //             int start = test0[c2];
     //             int end = test0[c2+1];
     //             int ii=0;
     //             for (int idx = start; idx < end; idx++) {
     //                 if (test[idx] == INVALID_PARTICLE_ID) {
     //                     // idx++;
     //                     continue;
     //                 } else{
     //                     // ipv2[ii] = test[idx];
     //                     ipv2.push_back(static_cast<int>(test[idx]));
     //                     ii++;
     //                 }
     //                 len2=ii;
     //             }
     //         }
     //     }
     // }
     
     // // if(len1!=len2)
     // if(ipv1.size()!=ipv2.size())
     // {
     //     printf("True len %d sme len %d \n",ipv1.size(),ipv2.size());
     //     amrex::Abort("LEN FALSE!!");
     // }
     // // if(std::equal(ipv1.begin(),ipv1.end(),ipv2.begin())){
     // if(ipv1!=ipv2){
     //     // printf("True len %d sme len %d \n",len1,len2);
     //     amrex::Abort("ipv1 != ipv2!!");
     // }
     
     // svetime[1]=rdtscv();
     // binlist_time+=(svetime[1]-svetime[0]);
     // sort_time+=(count_time+binlist_time+presum_time);
     // sort_real_sme_kernal_2<1>(numcell,xpresum,xbinList,
     //                         xrhocells,yrhocells,zrhocells,
     //                         sx_m,sy_m,sz_m,
     //                         wqx,wqy,wqz,test0);
     // sort_real_sme_kernal_3<1>(numcell,xpresum,xbinList,
     //                         xrhocells,yrhocells,zrhocells,
     //                         sx_m,sy_m,sz_m,
     //                         wqx,wqy,wqz);
     std::vector<amrex::Real> testsxwq(8*np_to_deposit, 0.0);
    //  std::vector<amrex::Real> testsxwq(2*np_to_deposit, 0.0);
    //  sort_real_sme_kernal_5<1>(numcell,xpresum,xbinList,
    //                          xrhocells,yrhocells,zrhocells,
    //                          sx_m,sy_m,sz_m,
    //                          wqx,wqy,wqz,testsxwq);
 
     
 
 #if 0
    int err2=0;
    // printf("Checking testsxwq.......\n");
    // for(int ii=0;ii<np_to_deposit;ii++){
    //     // if(test_sxwq[2*ii]!=0){
    //     if(testsxwq[2*ii]!=test_sxwq[2*ii]){
    //         printf("\n");
    //         printf("[1]Err %f testsxwq[%d][1] cell %d org %lf, sme %lf \n"
    //             ,testsxwq[2*ii]-test_sxwq[2*ii],ii, ptile.m_pid_to_bin_map[ii],testsxwq[2*ii],test_sxwq[2*ii]);
    //         printf("\t --szm ERR %f! org szm %lf sme szm %lf\n"
    //             ,sz_m[2*ii]-test0[2*ii],sz_m[2*ii],test0[2*ii]);
    //         err2++;
    //     }
    //     if(testsxwq[2*ii+1]!=test_sxwq[2*ii+1]){
    //         printf("[2]Err %f testsxwq[%d][2] org %lf, sme %lf \n"
    //             ,testsxwq[2*ii+1]-test_sxwq[2*ii+1],ii, ptile.m_pid_to_bin_map[ii],testsxwq[2*ii+1],test_sxwq[2*ii+1]);
    //         printf("\t --wqx ERR %f! org wqx %lf sme wqx %lf\n"
    //             ,wqx[ii]-test1[ii],wqx[ii],test1[ii]);
    //         printf("\n");
    //         err2++;
    //     }
    // }
    // if(err2>=200) amrex::Abort("testsxwq ERR>200");
    printf("Checking testsxwq 1.......\n");
    for(int ii=0;ii<np_to_deposit;ii++){
        // if(test_sxwq[2*ii]!=0){
        // for(int idx=4;idx<8;idx++){
        for(int idx=0;idx<8;idx++){
            // if(testsxwq[8*ii+idx]!=0){
            if(testsxwq[8*ii+idx]!=test_sxwq[8*ii+idx]){
                printf("\n");
                printf("Err[%d] %f testsxwq[%d][%d] cell %d org %lf, sme %lf \n"
                    ,ii,testsxwq[8*ii+idx]-test_sxwq[8*ii+idx],ii,idx,
                    ptile.m_pid_to_bin_map[ii],testsxwq[8*ii+idx],test_sxwq[8*ii+idx]);
                err2++;
                printf("\t --szm ERR %f! org szm0 %lf sme szm0 %lf\n"
                    ,sz_m[2*ii]-test0[2*ii],sz_m[2*ii],test0[2*ii]);
                printf("\t --szm ERR %f! org szm1 %lf sme szm1 %lf\n"
                    ,sz_m[2*ii+1]-test0[2*ii+1],sz_m[2*ii+1],test0[2*ii+1]);
                printf("\t --wqx ERR %f! org wqx %lf sme wqx %lf\n"
                            ,wqx[ii]-test1[ii],wqx[ii],test1[ii]);
                printf("\t --TRUE wqx*sz0= %f! wqx*sz1= %f!\n"
                            ,wqx[ii]*sz_m[2*ii],wqx[ii]*sz_m[2*ii+1]);
            }
            // if(testsxwq[2*ii+1]!=test_sxwq[2*ii+1]){
            //     printf("[2]Err %f testsxwq[%d][2] org %lf, sme %lf \n"
            //         ,testsxwq[2*ii+1]-test_sxwq[2*ii+1],ii, ptile.m_pid_to_bin_map[ii],testsxwq[2*ii+1],test_sxwq[2*ii+1]);
            //     
            //     printf("\n");
            //     err2++;
            // }
            // // 添加这行代码来检查实际的向量长度
            // size_t vl = svcntd(); // 获取double元素的向量长度
            // printf("Vector length: %zu doubles\n", vl);
        }
    }
    if(err2>=200) amrex::Abort("testsxwq ERR>200");
    printf("testsxwq Check!\n");
    long bx = 2, by = 2, bz = 2;
    amrex::IntVect box_shape = box.length();
    // amrex::Print() << "Box shape: " << box_shape << std::endl;
    long nnx = len.x;
    long nny = len.y;
    long nnxny = nnx*nny;
    const int testcells = ptile.m_bin_offsets.size();   
    int err=0; 
    int err1=0; 
    auto& local_index = ptile.m_local_index;
    auto& bin_offsets = ptile.m_bin_offsets;
    auto& bin_length = ptile.m_bin_lengths;
    // const long numcell = ptile.m_bin_offsets.size()-1;
    // const long numcell = jx_fab.box().numPts();
    auto& pid_to_bin_map = ptile.m_pid_to_bin_map;
    auto& free_slot = ptile.m_free_slots;
    int len1=0;
    int len2=0;
    for (int iz = 0; iz < len.z; ++iz) {
        for (int iy = 0; iy < len.y; ++iy) {       
            for (int ix = 0; ix < len.x; ix++) {

                int c1=ix + iy * xjstride + iz * xkstride;
                std::vector<int> ipv1;
                std::vector<int> ipv2;
                int start = xpresum[c1-1];
                int end = xpresum[c1];
                len1=end-start;
                if(len1==0){
                }else{
                    int ii=0;
                    for(int idx=start;idx<end;idx++){
                        // ipv1[ii]=xbinList[idx];
                        ipv1.push_back(static_cast<int>(xbinList[idx]));
                        ii++;
                    }
                    // len1=ii;
                }
                int old_bin=(ix) + (iy) * nnx + (iz) * nnxny+1;
                len2=bin_length[old_bin-1];
                if (bin_length[old_bin-1] == 0) continue;
                start = bin_offsets[old_bin-1];
                end = bin_offsets[old_bin];
                int first_idx=-1;
                for(int i=start;i<end;i++){
                    if (local_index[i] == INVALID_PARTICLE_ID) {
                        // idx1++;
                        continue;
                    } 
                    if(first_idx<0){
                        first_idx=i;
                    }else{
                        int idx1 = first_idx;
                        int idx2=i;
                        int ip1 = local_index[idx1];
                        ipv2.push_back(ip1);
                        int ip2 = local_index[idx2];
                        ipv2.push_back(ip2);
                        first_idx=-1;
                    }
                }
                if(first_idx>=0){
                    int ip1 = local_index[first_idx];
                    ipv2.push_back(ip1);
                }
                if(len1!=len2)
                // if(ipv1.size()!=ipv2.size() && len1!=len2)
                {
                    printf("x %d y %d z %d\n",ix,iy,iz);
                    printf("True len[%d] %d(%d) sme len[%d] %d(%d) \n",c1,ipv1.size(),len1,old_bin-1,ipv2.size(),len2);
                    // amrex::Abort("ipv LEN FALSE!!");
                    int lenip=std::max(ipv2.size(),static_cast<unsigned long>(end-start));
                    for(int i =0;i<lenip;i++){
                        printf("LEN: ip1 %d, ip2 %d \n",ipv1[i],test[start+i]);
                    }
                }
                std::sort(ipv1.begin(),ipv1.end());
                std::sort(ipv2.begin(),ipv2.end());
                if(std::equal(ipv1.begin(),ipv1.end(),ipv2.begin())){
                }
                else{
                    for(int i =0;i<ipv1.size();i++){
                        printf("ip1 %d, ip2 %d \n",ipv1[i],ipv2[i]);
                        err++;
                    }
                // }
                // if(ipv1==ipv2){
                    // printf("True len %d sme len %d \n",len1,len2);
                    // amrex::Abort("ipv1 != ipv2!!");
                }
                if(err>10) amrex::Abort("ERROR ipv1!=ipv2   !!!!!");




                
                // int c1=ix + iy * xjstride + iz * xkstride-1;
                c1=ix + iy * xjstride + iz * xkstride-1;
                int c2=(ix) + (iy) * nnx + (iz) * nnxny;
                bool flag=false;
                for(int ii=0;ii<8;ii++){
                    double t1=xrhocells[8*c1+ii];
                    double t2=test_rhocells[8*c2+ii];
                    if(t1!=t2){
                        printf("x %d y %d z %d c1 %d c2 %d :\n", 
                            ix,iy,iz,c1,c2);
                        printf("TRUE rho %lf SME rho %lf, err %lf\n",
                            t1,t2,t1-t2);
                        flag=true;
                        err1++;
                    }
                }
                // if(flag) amrex::Abort("Rhocell ERROR!!");
                if(err1>10) amrex::Abort("Rhocell ERROR!!");
            }
        }
    }
    // amrex::Abort("Rhocell ERROR!!");
 #endif
    // sort_real_sme_kernal<1>(numcell,xpresum,xbinList,
    //                         xrhocells,yrhocells,zrhocells,
    //                         sx_m,sy_m,sz_m,
    //                         wqx,wqy,wqz,test,len);
    // amrex::Abort("stop");
    // svbool_t p_4=svwhilelt_b64(0,4);
    // svbool_t p0=svwhilelt_b64(0,2);
    // svbool_t p1=svbic_z(p_4,p_4, p0);
    // for(int c=1;c<=numcell;c++){
    //     // svetime[0]=rdtscv();
    //
    //     int start = xpresum[c-1];
    //     int end = xpresum[c];
    //     if(start==end){
    //         // svetime[1]=rdtscv();
    //         // branch_time+=(svetime[1]-svetime[0]);
    //         continue;
    //     }
    //     // svetime[1]=rdtscv();
    //     // branch_time+=(svetime[1]-svetime[0]);
    //     svbool_t p = svptrue_b64();
    //     Vec wwx = Vec::Load(p,&xrhocells[8*c]);
    //     Vec wwy = Vec::Load(p,&yrhocells[8*c]);
    //     Vec wwz = Vec::Load(p,&zrhocells[8*c]);
    //     // const int end_len = std::min(2, static_cast<int>(end-start));
    //     //TODO use cell+=2, to do 2cells particles depo simultaneously
    //     for(int idx=start;idx<end;idx+=2){
    //         // sx={x[0],x[1],x2[0],x2[1]}
    //         // sysz={y1[0]z1[0],y1[1]z1[0],y1[0]z1[1],y1[1]z1[1],y2[0]z2[0],y2[1]z2[0],y2[0]z2[1],y2[1]z2[1]}
    //         int ip=xbinList[idx];
    //         int ip1=xbinList[idx+1];
    //         Vec sx_v=svdup_n_f64(0);
    //         Vec sx_1 = svld1(p0,&sx_m[ip][0]);
    //         sx_v=svsel(p0,sx_1,sx_v);
    //         // svbool_t p1=svwhilelt_b64(2,4);
    //         Vec sx_2 = svld1(p1,&sx_m[ip1-1][0]);
    //         sx_v=svsel(p1,sx_2,sx_v);
    //
    //         // svbool_t p1=svbic_z(svptrue_b64(),p_4, p0);
    //         // sx_v = svld1(p1,&sx_m[ip+1][0]);
    //         // sx_v.Load(p0,&sx_m[ip][0]);
    //         // sx_v.Load(p1,&sx_m[ip+1][0]);
    //
    //         // svbool_t p_4=svwhilelt_b64(0,4);
    //         // double sxx[8];
    //         // sx_v.Store(svptrue_b64(),&sxx[0]);
    //         // printf("ip %d sxx %lf sx_m %lf \n",ip,sxx[0],sx_m[ip][0]);
    //         // printf("ip %d sxx %lf sx_m %lf \n\n",ip1,sxx[2],sx_m[ip1][0]);
    //         // for (int i=0;i<2;i++){
    //         //     int tt=xbinList[idx+i];
    //         //     // test[tt]=sxx[i];
    //         //     printf("ip %d sxx %lf \n",tt,sxx[2*i]);
    //         //     // printf("ip %d sxm %lf \n",tt,sx_m[tt][0]);
    //         // }
    //         // amrex::Abort("test");
    //         // for (int i=0;i<4;i++){
    //         //     printf("sxx %lf \n",sxx[i]);
    //         // }
    //
    //         Vec vy1=Vec::Load(p0, &sy_m[ip][0]);
    //         Vec vy2=Vec::Load(p0, &sy_m[ip1][0]);
    //         Vec vz1=Vec::Load(p0, &sz_m[ip][0]);
    //         Vec vz2=Vec::Load(p0, &sz_m[ip1][0]);
    //
    //         const uint64_t y_indices[8]={0,1,0,1,2,3,2,3};
    //         Vec vy_broadcast=svtbl(svzip1(vy1,vy2),svld1_u64(svptrue_b64(),y_indices));
    //         const uint64_t z_indices[8]={0,0,1,1,2,2,3,3};
    //         Vec vz_broadcast=svtbl(svzip1(vz1,vz2),svld1_u64(svptrue_b64(),z_indices));
    //
    //         Vec sysz_v=vy_broadcast*vz_broadcast;





    //         // printf("ip %d sx_m[0] %lf sx_m[1] %lf \n",
    //         //             ip,   sx_m[0][ip],  sx_m[1][ip]);
    //         // Vec sx0=Vec(sx_m[0][ip]);
    //         // Vec sx1=Vec(sx_m[1][ip]);
    //         // Vec sxv=svsel_f64(px,sx0,sx1);
    //         // Vec sy0=Vec(sy_m[0][ip]);
    //         // Vec sy1=Vec(sy_m[1][ip]);
    //         // Vec syv=svsel_f64(py,sy0,sy1);
    //         // Vec sz0=Vec(sz_m[0][ip]);
    //         // Vec sz1=Vec(sz_m[1][ip]);
    //         // Vec szv=svsel_f64(pz,sz0,sz1);
    //         // // printf("Error 2! \n");
    //         // Vec s = sxv*syv*szv;
    //         // Vec jx_v=s*wqx[ip];
    //         // // jx_v.Store(p,&test[ip*8]);
    //         // wwx+=jx_v;
    //         // Vec jy_v=s*wqy[ip];
    //         // wwy+=jy_v;              
    //         // Vec jz_v=s*wqz[ip];
    //         // wwz+=jz_v;
    //     }
    //     wwx.Store(p,&xrhocells[8*c]);
    //     // test[c]=xrhocells[8*c]
    //     wwy.Store(p,&yrhocells[8*c]);
    //     wwz.Store(p,&zrhocells[8*c]);
    //     // svetime[1]=rdtscv();
    //     // cale_time+=(svetime[1]-svetime[0]);
    // }
    
    // amrex::Abort("test");              
    // TODO: reduction needs  to modify out of this func
    // ix iy iz in numcell
    // this can be SME
    #if 0
    int errcount=0;
    for (int iz = 0; iz <= len.z; ++iz) {
        for (int iy = 0; iy <= len.y; ++iy) { 
            // scalar mode
            // for(int ix = 0; ix <= len.x; ix++){
            //     long j = lo.x + ix;
            //     long k = lo.y + iy;
            //     long l = lo.z + iz;
            //     // long jxoffset = j - jx_arr.begin.x + 
            //     //     (k - jx_arr.begin.y) * xjstride + 
            //     //     (l - jx_arr.begin.z) * xkstride;
            //     long jxoffset = ix + iy * xjstride + iz * xkstride;
            //     long xoffset = 8*(ix + iy * xjstride + iz * xkstride);
            //     // if(8*jxoffset==xoffset){
            //     //     printf("jxoffset %d xoffset %d \n",jxoffset,xoffset);
            //     // }
            //     jx_arr.p[jxoffset+moff[0]]+=xrhocells[0+xoffset];
            //     jx_arr.p[jxoffset+moff[1]]+=xrhocells[1+xoffset];
            //     jx_arr.p[jxoffset+moff[2]]+=xrhocells[2+xoffset];
            //     jx_arr.p[jxoffset+moff[3]]+=xrhocells[3+xoffset];
            //     jx_arr.p[jxoffset+moff[4]]+=xrhocells[4+xoffset];
            //     jx_arr.p[jxoffset+moff[5]]+=xrhocells[5+xoffset];
            //     jx_arr.p[jxoffset+moff[6]]+=xrhocells[6+xoffset];
            //     jx_arr.p[jxoffset+moff[7]]+=xrhocells[7+xoffset];
            //     // if(iy==3 && iz==2){
            //     //     printf("rhocell %lf %lf %lf %lf \n",xrhocells[0+xoffset],xrhocells[1+xoffset]
            //     //             ,xrhocells[2+xoffset],xrhocells[3+xoffset]);
            //     // }
            //     // double jxorg=jx_arr.p[jxoffset+moff[0]];
            //     // if(jxorg>1e-2){
            //     //     // printf("jxoffset %ld jxoffset1 %ld \n",jxoffset+moff[idx],jxoffset1+moff[idx]);
            //     //     printf("ix %d iy %d iz %d: jxorg %lf \n",
            //     //                 ix,  iy,   iz,  jxorg );
            //     //     errcount++;
            //     //     if(errcount>10){
            //     //         // printf("%d %d %d %d \n",len.x,len.y,len.z,jx_fab.box().numPts());
            //     //         // amrex::Abort("ERROR 10 ! jxorg and jxsve");
            //     //     }
            //     // }
            // }
            
            for (int ix = 0; ix <= len.x; ix+=vl) {
                // svetime[0]=rdtscv();

                // vector
                svbool_t p=svwhilele_b64(ix,len.x);
                // long j = lo.x + ix;
                // long k = lo.y + iy;
                // long l = lo.z + iz;
                // x
                // uint64_t irhox = 8*(ix + iy * xjstride + iz * xkstride);
                // svuint64_t rhox_index = svindex_u64(0, 8ULL);
                // long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                svuint64_t rho_index = svindex_u64(0ULL, 8ULL);
                long xoffset=ix + iy * xjstride + iz * xkstride;
                long jxoffset=xoffset;
                long irhox=8*xoffset;
                Vec jx0=Vec::Load(p,&jx_arr.p[jxoffset+moff[0]]);
                svfloat64_t rhox0=svld1_gather_u64index_f64(p,&xrhocells[0+irhox],rho_index);
                jx0+=rhox0;
                jx0.Store(p,&jx_arr.p[jxoffset+moff[0]]);

                Vec jx1=Vec::Load(p,&jx_arr.p[jxoffset+moff[1]]);
                svfloat64_t rhox1=svld1_gather_u64index_f64(p,&xrhocells[1+irhox],rho_index);
                jx1+=rhox1;
                jx1.Store(p,&jx_arr.p[jxoffset+moff[1]]);

                Vec jx2=Vec::Load(p,&jx_arr.p[jxoffset+moff[2]]);
                svfloat64_t rhox2=svld1_gather_u64index_f64(p,&xrhocells[2+irhox],rho_index);
                jx2+=rhox2;
                jx2.Store(p,&jx_arr.p[jxoffset+moff[2]]);

                Vec jx3=Vec::Load(p,&jx_arr.p[jxoffset+moff[3]]);
                svfloat64_t rhox3=svld1_gather_u64index_f64(p,&xrhocells[3+irhox],rho_index);
                jx3+=rhox3;
                jx3.Store(p,&jx_arr.p[jxoffset+moff[3]]);

                Vec jx4=Vec::Load(p,&jx_arr.p[jxoffset+moff[4]]);
                svfloat64_t rhox4=svld1_gather_u64index_f64(p,&xrhocells[4+irhox],rho_index);
                jx4+=rhox4;
                jx4.Store(p,&jx_arr.p[jxoffset+moff[4]]);

                Vec jx5=Vec::Load(p,&jx_arr.p[jxoffset+moff[5]]);
                svfloat64_t rhox5=svld1_gather_u64index_f64(p,&xrhocells[5+irhox],rho_index);
                jx5+=rhox5;
                jx5.Store(p,&jx_arr.p[jxoffset+moff[5]]);

                Vec jx6=Vec::Load(p,&jx_arr.p[jxoffset+moff[6]]);
                svfloat64_t rhox6=svld1_gather_u64index_f64(p,&xrhocells[6+irhox],rho_index);
                jx6+=rhox6;
                jx6.Store(p,&jx_arr.p[jxoffset+moff[6]]);

                Vec jx7=Vec::Load(p,&jx_arr.p[jxoffset+moff[7]]);
                svfloat64_t rhox7=svld1_gather_u64index_f64(p,&xrhocells[7+irhox],rho_index);
                jx7+=rhox7;
                jx7.Store(p,&jx_arr.p[jxoffset+moff[7]]);
                
                // y
                // uint64_t irhoy = ix + iy * yjstride + iz * ykstride;
                // svuint64_t rhoy_index = svindex_u64(irhoy, 8ULL);
                // long jyoffset = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
                long yoffset = ix + iy * yjstride + iz * ykstride;
                long jyoffset=yoffset;
                long irhoy=8*yoffset;
                Vec jy0=Vec::Load(p,&jy_arr.p[jyoffset+moff[0]]);
                svfloat64_t rhoy0=svld1_gather_u64index_f64(p,&yrhocells[0+irhoy],rho_index);
                jy0+=rhoy0;
                jy0.Store(p,&jy_arr.p[jyoffset+moff[0]]);

                Vec jy1=Vec::Load(p,&jy_arr.p[jyoffset+moff[1]]);
                svfloat64_t rhoy1=svld1_gather_u64index_f64(p,&yrhocells[1+irhoy],rho_index);
                jy1+=rhoy1;
                jy1.Store(p,&jy_arr.p[jyoffset+moff[1]]);

                Vec jy2=Vec::Load(p,&jy_arr.p[jyoffset+moff[2]]);
                svfloat64_t rhoy2=svld1_gather_u64index_f64(p,&yrhocells[2+irhoy],rho_index);
                jy2+=rhoy2;
                jy2.Store(p,&jy_arr.p[jyoffset+moff[2]]);

                Vec jy3=Vec::Load(p,&jy_arr.p[jyoffset+moff[3]]);
                svfloat64_t rhoy3=svld1_gather_u64index_f64(p,&yrhocells[3+irhoy],rho_index);
                jy3+=rhoy3;
                jy3.Store(p,&jy_arr.p[jyoffset+moff[3]]);

                Vec jy4=Vec::Load(p,&jy_arr.p[jyoffset+moff[4]]);
                svfloat64_t rhoy4=svld1_gather_u64index_f64(p,&yrhocells[4+irhoy],rho_index);
                jy4+=rhoy4;
                jy4.Store(p,&jy_arr.p[jyoffset+moff[4]]);

                Vec jy5=Vec::Load(p,&jy_arr.p[jyoffset+moff[5]]);
                svfloat64_t rhoy5=svld1_gather_u64index_f64(p,&yrhocells[5+irhoy],rho_index);
                jy5+=rhoy5;
                jy5.Store(p,&jy_arr.p[jyoffset+moff[5]]);

                Vec jy6=Vec::Load(p,&jy_arr.p[jyoffset+moff[6]]);
                svfloat64_t rhoy6=svld1_gather_u64index_f64(p,&yrhocells[6+irhoy],rho_index);
                jy6+=rhoy6;
                jy6.Store(p,&jy_arr.p[jyoffset+moff[6]]);

                Vec jy7=Vec::Load(p,&jy_arr.p[jyoffset+moff[7]]);
                svfloat64_t rhoy7=svld1_gather_u64index_f64(p,&yrhocells[7+irhoy],rho_index);
                jy7+=rhoy7;
                jy7.Store(p,&jy_arr.p[jyoffset+moff[7]]);

                // z
                // uint64_t irhoz = ix + iy * zjstride + iz * zkstride;
                // svuint64_t rhoz_index = svindex_u64(irhoz, 8ULL);
                // long jzoffset = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
                long zoffset = ix + iy * zjstride + iz * zkstride;
                long jzoffset=zoffset;
                long irhoz=8*zoffset;
                Vec jz0=Vec::Load(p,&jz_arr.p[jzoffset+moff[0]]);
                svfloat64_t rhoz0=svld1_gather_u64index_f64(p,&zrhocells[0+irhoz],rho_index);
                jz0+=rhoz0;
                jz0.Store(p,&jz_arr.p[jzoffset+moff[0]]);

                Vec jz1=Vec::Load(p,&jz_arr.p[jzoffset+moff[1]]);
                svfloat64_t rhoz1=svld1_gather_u64index_f64(p,&zrhocells[1+irhoz],rho_index);
                jz1+=rhoz1;
                jz1.Store(p,&jz_arr.p[jzoffset+moff[1]]);

                Vec jz2=Vec::Load(p,&jz_arr.p[jzoffset+moff[2]]);
                svfloat64_t rhoz2=svld1_gather_u64index_f64(p,&zrhocells[2+irhoz],rho_index);
                jz2+=rhoz2;
                jz2.Store(p,&jz_arr.p[jzoffset+moff[2]]);

                Vec jz3=Vec::Load(p,&jz_arr.p[jzoffset+moff[3]]);
                svfloat64_t rhoz3=svld1_gather_u64index_f64(p,&zrhocells[3+irhoz],rho_index);
                jz3+=rhoz3;
                jz3.Store(p,&jz_arr.p[jzoffset+moff[3]]);

                Vec jz4=Vec::Load(p,&jz_arr.p[jzoffset+moff[4]]);
                svfloat64_t rhoz4=svld1_gather_u64index_f64(p,&zrhocells[4+irhoz],rho_index);
                jz4+=rhoz4;
                jz4.Store(p,&jz_arr.p[jzoffset+moff[4]]);

                Vec jz5=Vec::Load(p,&jz_arr.p[jzoffset+moff[5]]);
                svfloat64_t rhoz5=svld1_gather_u64index_f64(p,&zrhocells[5+irhoz],rho_index);
                jz5+=rhoz5;
                jz5.Store(p,&jz_arr.p[jzoffset+moff[5]]);

                Vec jz6=Vec::Load(p,&jz_arr.p[jzoffset+moff[6]]);
                svfloat64_t rhoz6=svld1_gather_u64index_f64(p,&zrhocells[6+irhoz],rho_index);
                jz6+=rhoz6;
                jz6.Store(p,&jz_arr.p[jzoffset+moff[6]]);

                Vec jz7=Vec::Load(p,&jz_arr.p[jzoffset+moff[7]]);
                svfloat64_t rhoz7=svld1_gather_u64index_f64(p,&zrhocells[7+irhoz],rho_index);
                jz7+=rhoz7;
                jz7.Store(p,&jz_arr.p[jzoffset+moff[7]]);

                // svetime[1]=rdtscv();
                // reduce_time+=(svetime[1]-svetime[0]);
            }
        }
    }
    #endif
    // auto total_stop=high_resolution_clock::now();
    // duration<double> total_elapse = total_stop-total_start;
    // total_time = total_elapse.count();
    // printf("\n SVE noblock Sort: total time: %lf s, precompute: %ld, sort_time %ld cale_time: %ld, reduce_time: %ld \n",
    //     total_time,     precompute,   sort_time,  cale_time,     reduce_time);
    // printf("\t noblock Sort: %ld, Count: %ld, Presum %ld binlist: %ld, Branch: %ld \n",
    //         sort_time,      count_time,   presum_time,  binlist_time, branch_time);

    // total_time[1]=rdtscv();
    // total_time[2]=(total_time[1]-total_time[0]);
    // printf("total time: %d, precompute: %d, cale_time: %d, reduce_time: %d \n",
    //         total_time,     precompute,     cale_time,     reduce_time);
    // amrex::Abort("END!");
 
 }
 
 template <int depos_order>
 void doDepositionShapeN_sve_sort_real_sme_bak515 (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Dim3 hi,
                          amrex::Dim3 len,
                          amrex::Real q,
                          std::vector<long>& test,
                          std::vector<long>& test0,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     // uint64_t total_time[3]={0};
     using namespace std::chrono;
     using namespace amrex::literals;
     double total_time=0;
     // auto total_start=high_resolution_clock::now();
     uint64_t precompute=0;
     uint64_t cale_time=0;
     uint64_t sort_time=0;
         uint64_t count_time=0;
         uint64_t presum_time=0;
         uint64_t binlist_time=0;
     uint64_t reduce_time=0;
     uint64_t svetime[3]={0};
     uint64_t branch_time=0;
     
     // total_time[0]=rdtscv();
     
 
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z; 
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
 
     constexpr int nshapes = depos_order + 1;
     // constexpr int nshapes = 2;
     int vl=svcntd();
 
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
 
     auto compute_shape_factor_v2 = [](std::vector<double>* sx, Vec xmid, svbool_t p) {
         const svuint64_t sx_index = svindex_u64(0ULL, 2ULL);
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         svst1_scatter_index(p,&sx[0][0],sx_index,sx0);
         svst1_scatter_index(p,&sx[0][1],sx_index,sx1);
         // sx0.Store(p, sx[0]);
         // sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
     auto compute_shape_factor_v1 = [](double* sx, Vec xmid, svbool_t p) {
         const svuint64_t sx_index = svindex_u64(0, 2);
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // double test[8];
         // xint.Store(p,&test[0]);
         // for(int ii=0;ii<8;ii++){
         //     // printf("ii %d xind %f \n",ii,test[ii]);
         //     sx[ii][0]=1.0-test[ii];
         //     sx[ii][1]=test[ii];
         // }
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         // double sx00[8];
         // double sx01[8];
         // sx0.Store(p,&sx00[0]);
         // sx1.Store(p,&sx01[0]);
         // for(int ii=0;ii<8;ii++){
         //     // printf("ii %d xind %f \n",ii,test[ii]);
         //     sx[ii][0]=sx00[ii];
         //     sx[ii][1]=sx01[ii];
         // }
         svst1_scatter_index(p,&sx[0],sx_index,sx0);
         svst1_scatter_index(p,&sx[1],sx_index,sx1);
         // sx0.Store(p, sx[0]);
         // sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
     const long numcell = jx_fab.box().numPts();
     const long xnumcell = jx_fab.box().numPts();
     // printf("xnumcell %d %d %d \n",xnumcell,xjstride,xkstride);
     // const long ynumcell = jy_fab.box().numPts();
     // printf("ynumcell %d \n",ynumcell);
     // const long znumcell = jz_fab.box().numPts();
     // printf("znumcell %d \n",znumcell);
 
     // auto xrhocells = std::make_unique<double[]>(8*numcell);
     // auto yrhocells = std::make_unique<double[]>(8*numcell);
     // auto zrhocells = std::make_unique<double[]>(8*numcell);
     std::vector<amrex::Real> xrhocells(8*numcell, 0.0);
     std::vector<amrex::Real> yrhocells(8*numcell, 0.0);
     std::vector<amrex::Real> zrhocells(8*numcell, 0.0);
     // one roll x
     uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
     uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
     uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
     long nx=xjstride;
     long nxy=xkstride;
     long moff[8] = {0, 1, nx, nx+1, nxy, nxy+1, nx+nxy, nx+nxy+1};
     svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
     svbool_t px = svcmpeq_n_u64(svptrue_b64(), rmx_v, 0);
     svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
     svbool_t py = svcmpeq_n_u64(svptrue_b64(), rmy_v, 0);
     svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
     svbool_t pz = svcmpeq_n_u64(svptrue_b64(), rmz_v, 0);
 
     std::vector<amrex::Real> wqx(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqy(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqz(np_to_deposit, 0.0);
 
     // double sx_m[nshapes][np_to_deposit] = {0.};
     // double sy_m[nshapes][np_to_deposit] = {0.};
     // double sz_m[nshapes][np_to_deposit] = {0.};
     // std::vector<std::vector<amrex::Real>> sx_m(np_to_deposit,std::vector<amrex::Real>(nshapes, 0.));
     // std::vector<std::vector<amrex::Real>> sy_m(np_to_deposit,std::vector<amrex::Real>(nshapes, 0.));
     // std::vector<std::vector<amrex::Real>> sz_m(np_to_deposit,std::vector<amrex::Real>(nshapes, 0.));
     std::vector<amrex::Real> sx_m(np_to_deposit*nshapes, 0.);
     std::vector<amrex::Real> sy_m(np_to_deposit*nshapes, 0.);
     std::vector<amrex::Real> sz_m(np_to_deposit*nshapes, 0.);
     // std::vector<std::vector<amrex::Real>> sx_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
     // std::vector<std::vector<amrex::Real>> sy_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
     // std::vector<std::vector<amrex::Real>> sz_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
 
     // some place dont have particle
     alignas(64) long xoffsets[np_to_deposit]; 
     // alignas(64) long yoffsets[np_to_deposit];
     // alignas(64) long zoffsets[np_to_deposit];
     std::vector<long> xcount(numcell,0);
     // std::vector<long> ycount(numcell,0);
     // std::vector<long> zcount(numcell,0);
     // printf("before vl \n");
     // std::vector<long> xcount_tmp(np_to_deposit,0);
     
 
     for(long ip=0;ip<np_to_deposit;ip+=vl){
         // svetime[0]=rdtscv();
 
         // 计算基本物理量
         svbool_t p=svwhilele_b64(ip,np_to_deposit);
         // Inverse of Lorentz factor gamma
         Vec uxp_v=Vec::Load(p,&uxp[ip]);
         Vec uyp_v=Vec::Load(p,&uyp[ip]);
         Vec uzp_v=Vec::Load(p,&uzp[ip]);
         Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                     + uyp_v * uyp_v * clightsq
                                     + uzp_v * uzp_v * clightsq).Sqrt();
         // Product of particle charges and weights
         Vec wp_v=Vec::Load(p,&wp[ip]);
         Vec wq_v = q * wp_v;
 
         // Current particle positions (in physical units)
         Vec xp = Vec::Load(p, &mx[ip]);
         Vec yp = Vec::Load(p, &my[ip]);
         Vec zp = Vec::Load(p, &mz[ip]);
 
         // Particle velocities
         Vec vx_v = uxp_v * gaminv;
         Vec vy_v = uyp_v * gaminv;
         Vec vz_v = uzp_v * gaminv;
 
         // if (do_ionization) wq *= ion_lev[ip];
         Vec wqx_v = wq_v * invvol * vx_v;
         Vec wqy_v = wq_v * invvol * vy_v;
         Vec wqz_v = wq_v * invvol * vz_v;
 
         wqx_v.Store(p, &wqx[ip]);
         wqy_v.Store(p, &wqy[ip]);
         wqz_v.Store(p, &wqz[ip]);
 
         // Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x - 0.5;
         // Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y - 0.5;
         // Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z - 0.5;
         Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x;
         Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y;
         Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z;
         // xmid.Store(p, &test0[ip]);
         // double* sx_temp[nshapes] = {&sx_m[0][ip], &sx_m[1][ip]};
         intVec j_cellv = compute_shape_factor_v1( &sx_m[ip*2], xmid, p);
         // j_cellv.Store(p, &test[ip]);
         // for (int i=0;i<8;i++){
         //     int tt=ip+i;
         //     test0[tt]=sx_m[tt][1];
         //     // printf("iip: %d, lo.x %d, jx_arr.begin.x, %d, jx_arr.begin.y, %d,jx_arr.begin.z, %d, xjstride: %d, xkstride: %d xoffsets[iip] : %d \n", 
         //     //         tt,   lo.x , jx_arr.begin.x, jx_arr.begin.y,jx_arr.begin.z, xjstride, xkstride,xoffsets[tt] );
         //     // printf("j_cell %d: %ld , xmid %f \n",i,j_cell[i], xmidt[i]);
         // }
         // double* sy_temp[nshapes] = {&sy_m[0][ip], &sy_m[1][ip]};
         intVec k_cellv = compute_shape_factor_v1( &sy_m[ip*2], ymid, p);
         // double* sz_temp[nshapes] = {&sz_m[0][ip], &sz_m[1][ip]};
         intVec l_cellv = compute_shape_factor_v1( &sz_m[ip*2], zmid, p); 
 
         intVec xoffsets_v = j_cellv + k_cellv * xjstride + l_cellv * xkstride;
         // intVec yoffsets_v = j_cellv + k_cellv * yjstride + l_cellv * ykstride;
         // intVec zoffsets_v = j_cellv + k_cellv * zjstride + l_cellv * zkstride;
 
         xoffsets_v.Store(p,&xoffsets[ip]);
         // yoffsets_v.Store(p,&yoffsets[ip]);
         // zoffsets_v.Store(p,&zoffsets[ip]);
 
         // 原子操作，不可避免
         // const int vec_len = std::min(vl, static_cast<int>(np_to_deposit-ip));
         // svetime[2]=rdtscv();
         // for(int off=0;off<vec_len;off++){
         //     xcount[xoffsets[ip+off]]++;
         //     // ycount[yoffsets[ip+off]]++;
         //     // zcount[zoffsets[ip+off]]++;
         // }
         // svetime[1]=rdtscv();
         // count_time+=(svetime[1]-svetime[2]);
 
         // printf("after STORE\n");
         // svetime[1]=rdtscv();
         // precompute+=(svetime[1]-svetime[0]); 
         // printf("after SAVE\n");
     }
     // svetime[0]=rdtscv();
     for(long ip=0;ip<np_to_deposit;ip++){
         xcount[xoffsets[ip]]++;
     }
     // svetime[1]=rdtscv();
     // count_time+=(svetime[1]-svetime[0]);
 
     std::vector<int> xpresum(numcell+1,0);
     // std::vector<int> ypresum(numcell+1,0);
     // std::vector<int> zpresum(numcell+1,0);
     // svetime[0]=rdtscv();
     for(int c=1;c<=numcell;c++){
         xpresum[c]=xpresum[c-1]+xcount[c-1];
         // ypresum[c]=ypresum[c-1]+ycount[c-1];
         // zpresum[c]=zpresum[c-1]+zcount[c-1];
     }
     // svetime[1]=rdtscv();
     // presum_time+=(svetime[1]-svetime[0]);
     // printf("np_to_deposit %d sum %d xpresum[%d] %d  \n",np_to_deposit,sum1,numcell,xpresum[numcell]);
     // amrex::Abort("END 2!");
 
     // int xbinList[np_to_deposit]={-1};
     std::vector<int> xbinList(np_to_deposit,-1);
     // std::vector<int> ybinList(np_to_deposit,-1);
     // std::vector<int> zbinList(np_to_deposit,-1);
     // std::vector<int> xcurrentPos=xpresum;
     // svetime[0]=rdtscv();
     for(int ip=0;ip<np_to_deposit;ip++){
         long xoffset = xoffsets[ip];
         // long yoffset = yoffsets[ip];
         // long zoffset = zoffsets[ip];
         xbinList[xpresum[xoffset]]=ip;
         xpresum[xoffset]++;
         // ybinList[ypresum[yoffset]]=ip;
         // zbinList[zpresum[zoffset]]=ip;
         // ypresum[yoffset]++;
         // zpresum[zoffset]++;
     }
 
     // svetime[1]=rdtscv();
     // binlist_time+=(svetime[1]-svetime[0]);
     // sort_time+=(count_time+binlist_time+presum_time);
     sort_real_sme_kernal_2<1>(numcell,xpresum,xbinList,
                             xrhocells,yrhocells,zrhocells,
                             sx_m,sy_m,sz_m,
                             wqx,wqy,wqz,test0);
     // sort_real_sme_kernal<1>(numcell,xpresum,xbinList,
     //                         xrhocells,yrhocells,zrhocells,
     //                         sx_m,sy_m,sz_m,
     //                         wqx,wqy,wqz,test,len);
     // amrex::Abort("stop");
     // svbool_t p_4=svwhilelt_b64(0,4);
     // svbool_t p0=svwhilelt_b64(0,2);
     // svbool_t p1=svbic_z(p_4,p_4, p0);
     // for(int c=1;c<=numcell;c++){
     //     // svetime[0]=rdtscv();
     //
     //     int start = xpresum[c-1];
     //     int end = xpresum[c];
     //     if(start==end){
     //         // svetime[1]=rdtscv();
     //         // branch_time+=(svetime[1]-svetime[0]);
     //         continue;
     //     }
     //     // svetime[1]=rdtscv();
     //     // branch_time+=(svetime[1]-svetime[0]);
     //     svbool_t p = svptrue_b64();
     //     Vec wwx = Vec::Load(p,&xrhocells[8*c]);
     //     Vec wwy = Vec::Load(p,&yrhocells[8*c]);
     //     Vec wwz = Vec::Load(p,&zrhocells[8*c]);
     //     // const int end_len = std::min(2, static_cast<int>(end-start));
     //     //TODO use cell+=2, to do 2cells particles depo simultaneously
     //     for(int idx=start;idx<end;idx+=2){
     //         // sx={x[0],x[1],x2[0],x2[1]}
     //         // sysz={y1[0]z1[0],y1[1]z1[0],y1[0]z1[1],y1[1]z1[1],y2[0]z2[0],y2[1]z2[0],y2[0]z2[1],y2[1]z2[1]}
     //         int ip=xbinList[idx];
     //         int ip1=xbinList[idx+1];
     //         Vec sx_v=svdup_n_f64(0);
     //         Vec sx_1 = svld1(p0,&sx_m[ip][0]);
     //         sx_v=svsel(p0,sx_1,sx_v);
     //         // svbool_t p1=svwhilelt_b64(2,4);
     //         Vec sx_2 = svld1(p1,&sx_m[ip1-1][0]);
     //         sx_v=svsel(p1,sx_2,sx_v);
     //
     //         // svbool_t p1=svbic_z(svptrue_b64(),p_4, p0);
     //         // sx_v = svld1(p1,&sx_m[ip+1][0]);
     //         // sx_v.Load(p0,&sx_m[ip][0]);
     //         // sx_v.Load(p1,&sx_m[ip+1][0]);
     //
     //         // svbool_t p_4=svwhilelt_b64(0,4);
     //         // double sxx[8];
     //         // sx_v.Store(svptrue_b64(),&sxx[0]);
     //         // printf("ip %d sxx %lf sx_m %lf \n",ip,sxx[0],sx_m[ip][0]);
     //         // printf("ip %d sxx %lf sx_m %lf \n\n",ip1,sxx[2],sx_m[ip1][0]);
     //         // for (int i=0;i<2;i++){
     //         //     int tt=xbinList[idx+i];
     //         //     // test[tt]=sxx[i];
     //         //     printf("ip %d sxx %lf \n",tt,sxx[2*i]);
     //         //     // printf("ip %d sxm %lf \n",tt,sx_m[tt][0]);
     //         // }
     //         // amrex::Abort("test");
     //         // for (int i=0;i<4;i++){
     //         //     printf("sxx %lf \n",sxx[i]);
     //         // }
     //
     //         Vec vy1=Vec::Load(p0, &sy_m[ip][0]);
     //         Vec vy2=Vec::Load(p0, &sy_m[ip1][0]);
     //         Vec vz1=Vec::Load(p0, &sz_m[ip][0]);
     //         Vec vz2=Vec::Load(p0, &sz_m[ip1][0]);
     //
     //         const uint64_t y_indices[8]={0,1,0,1,2,3,2,3};
     //         Vec vy_broadcast=svtbl(svzip1(vy1,vy2),svld1_u64(svptrue_b64(),y_indices));
     //         const uint64_t z_indices[8]={0,0,1,1,2,2,3,3};
     //         Vec vz_broadcast=svtbl(svzip1(vz1,vz2),svld1_u64(svptrue_b64(),z_indices));
     //
     //         Vec sysz_v=vy_broadcast*vz_broadcast;
 
 
 
 
 
     //         // printf("ip %d sx_m[0] %lf sx_m[1] %lf \n",
     //         //             ip,   sx_m[0][ip],  sx_m[1][ip]);
     //         // Vec sx0=Vec(sx_m[0][ip]);
     //         // Vec sx1=Vec(sx_m[1][ip]);
     //         // Vec sxv=svsel_f64(px,sx0,sx1);
     //         // Vec sy0=Vec(sy_m[0][ip]);
     //         // Vec sy1=Vec(sy_m[1][ip]);
     //         // Vec syv=svsel_f64(py,sy0,sy1);
     //         // Vec sz0=Vec(sz_m[0][ip]);
     //         // Vec sz1=Vec(sz_m[1][ip]);
     //         // Vec szv=svsel_f64(pz,sz0,sz1);
     //         // // printf("Error 2! \n");
     //         // Vec s = sxv*syv*szv;
     //         // Vec jx_v=s*wqx[ip];
     //         // // jx_v.Store(p,&test[ip*8]);
     //         // wwx+=jx_v;
     //         // Vec jy_v=s*wqy[ip];
     //         // wwy+=jy_v;              
     //         // Vec jz_v=s*wqz[ip];
     //         // wwz+=jz_v;
     //     }
     //     wwx.Store(p,&xrhocells[8*c]);
     //     // test[c]=xrhocells[8*c]
     //     wwy.Store(p,&yrhocells[8*c]);
     //     wwz.Store(p,&zrhocells[8*c]);
     //     // svetime[1]=rdtscv();
     //     // cale_time+=(svetime[1]-svetime[0]);
     // }
     
     // amrex::Abort("test");              
     // TODO: reduction needs  to modify out of this func
     // ix iy iz in numcell
     // this can be SME
     int errcount=0;
     for (int iz = 0; iz <= len.z; ++iz) {
         for (int iy = 0; iy <= len.y; ++iy) { 
             // scalar mode
             // for(int ix = 0; ix <= len.x; ix++){
             //     long j = lo.x + ix;
             //     long k = lo.y + iy;
             //     long l = lo.z + iz;
             //     // long jxoffset = j - jx_arr.begin.x + 
             //     //     (k - jx_arr.begin.y) * xjstride + 
             //     //     (l - jx_arr.begin.z) * xkstride;
             //     long jxoffset = ix + iy * xjstride + iz * xkstride;
             //     long xoffset = 8*(ix + iy * xjstride + iz * xkstride);
             //     // if(8*jxoffset==xoffset){
             //     //     printf("jxoffset %d xoffset %d \n",jxoffset,xoffset);
             //     // }
             //     jx_arr.p[jxoffset+moff[0]]+=xrhocells[0+xoffset];
             //     jx_arr.p[jxoffset+moff[1]]+=xrhocells[1+xoffset];
             //     jx_arr.p[jxoffset+moff[2]]+=xrhocells[2+xoffset];
             //     jx_arr.p[jxoffset+moff[3]]+=xrhocells[3+xoffset];
             //     jx_arr.p[jxoffset+moff[4]]+=xrhocells[4+xoffset];
             //     jx_arr.p[jxoffset+moff[5]]+=xrhocells[5+xoffset];
             //     jx_arr.p[jxoffset+moff[6]]+=xrhocells[6+xoffset];
             //     jx_arr.p[jxoffset+moff[7]]+=xrhocells[7+xoffset];
             //     // if(iy==3 && iz==2){
             //     //     printf("rhocell %lf %lf %lf %lf \n",xrhocells[0+xoffset],xrhocells[1+xoffset]
             //     //             ,xrhocells[2+xoffset],xrhocells[3+xoffset]);
             //     // }
             //     // double jxorg=jx_arr.p[jxoffset+moff[0]];
             //     // if(jxorg>1e-2){
             //     //     // printf("jxoffset %ld jxoffset1 %ld \n",jxoffset+moff[idx],jxoffset1+moff[idx]);
             //     //     printf("ix %d iy %d iz %d: jxorg %lf \n",
             //     //                 ix,  iy,   iz,  jxorg );
             //     //     errcount++;
             //     //     if(errcount>10){
             //     //         // printf("%d %d %d %d \n",len.x,len.y,len.z,jx_fab.box().numPts());
             //     //         // amrex::Abort("ERROR 10 ! jxorg and jxsve");
             //     //     }
             //     // }
             // }
             
             for (int ix = 0; ix <= len.x; ix+=vl) {
                 // svetime[0]=rdtscv();
 
                 // vector
                 svbool_t p=svwhilele_b64(ix,len.x);
                 // long j = lo.x + ix;
                 // long k = lo.y + iy;
                 // long l = lo.z + iz;
                 // x
                 // uint64_t irhox = 8*(ix + iy * xjstride + iz * xkstride);
                 // svuint64_t rhox_index = svindex_u64(0, 8ULL);
                 // long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                 svuint64_t rho_index = svindex_u64(0ULL, 8ULL);
                 long xoffset=ix + iy * xjstride + iz * xkstride;
                 long jxoffset=xoffset;
                 long irhox=8*xoffset;
                 Vec jx0=Vec::Load(p,&jx_arr.p[jxoffset+moff[0]]);
                 svfloat64_t rhox0=svld1_gather_u64index_f64(p,&xrhocells[0+irhox],rho_index);
                 jx0+=rhox0;
                 jx0.Store(p,&jx_arr.p[jxoffset+moff[0]]);
 
                 Vec jx1=Vec::Load(p,&jx_arr.p[jxoffset+moff[1]]);
                 svfloat64_t rhox1=svld1_gather_u64index_f64(p,&xrhocells[1+irhox],rho_index);
                 jx1+=rhox1;
                 jx1.Store(p,&jx_arr.p[jxoffset+moff[1]]);
 
                 Vec jx2=Vec::Load(p,&jx_arr.p[jxoffset+moff[2]]);
                 svfloat64_t rhox2=svld1_gather_u64index_f64(p,&xrhocells[2+irhox],rho_index);
                 jx2+=rhox2;
                 jx2.Store(p,&jx_arr.p[jxoffset+moff[2]]);
 
                 Vec jx3=Vec::Load(p,&jx_arr.p[jxoffset+moff[3]]);
                 svfloat64_t rhox3=svld1_gather_u64index_f64(p,&xrhocells[3+irhox],rho_index);
                 jx3+=rhox3;
                 jx3.Store(p,&jx_arr.p[jxoffset+moff[3]]);
 
                 Vec jx4=Vec::Load(p,&jx_arr.p[jxoffset+moff[4]]);
                 svfloat64_t rhox4=svld1_gather_u64index_f64(p,&xrhocells[4+irhox],rho_index);
                 jx4+=rhox4;
                 jx4.Store(p,&jx_arr.p[jxoffset+moff[4]]);
 
                 Vec jx5=Vec::Load(p,&jx_arr.p[jxoffset+moff[5]]);
                 svfloat64_t rhox5=svld1_gather_u64index_f64(p,&xrhocells[5+irhox],rho_index);
                 jx5+=rhox5;
                 jx5.Store(p,&jx_arr.p[jxoffset+moff[5]]);
 
                 Vec jx6=Vec::Load(p,&jx_arr.p[jxoffset+moff[6]]);
                 svfloat64_t rhox6=svld1_gather_u64index_f64(p,&xrhocells[6+irhox],rho_index);
                 jx6+=rhox6;
                 jx6.Store(p,&jx_arr.p[jxoffset+moff[6]]);
 
                 Vec jx7=Vec::Load(p,&jx_arr.p[jxoffset+moff[7]]);
                 svfloat64_t rhox7=svld1_gather_u64index_f64(p,&xrhocells[7+irhox],rho_index);
                 jx7+=rhox7;
                 jx7.Store(p,&jx_arr.p[jxoffset+moff[7]]);
                 
                 // y
                 // uint64_t irhoy = ix + iy * yjstride + iz * ykstride;
                 // svuint64_t rhoy_index = svindex_u64(irhoy, 8ULL);
                 // long jyoffset = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
                 long yoffset = ix + iy * yjstride + iz * ykstride;
                 long jyoffset=yoffset;
                 long irhoy=8*yoffset;
                 Vec jy0=Vec::Load(p,&jy_arr.p[jyoffset+moff[0]]);
                 svfloat64_t rhoy0=svld1_gather_u64index_f64(p,&yrhocells[0+irhoy],rho_index);
                 jy0+=rhoy0;
                 jy0.Store(p,&jy_arr.p[jyoffset+moff[0]]);
 
                 Vec jy1=Vec::Load(p,&jy_arr.p[jyoffset+moff[1]]);
                 svfloat64_t rhoy1=svld1_gather_u64index_f64(p,&yrhocells[1+irhoy],rho_index);
                 jy1+=rhoy1;
                 jy1.Store(p,&jy_arr.p[jyoffset+moff[1]]);
 
                 Vec jy2=Vec::Load(p,&jy_arr.p[jyoffset+moff[2]]);
                 svfloat64_t rhoy2=svld1_gather_u64index_f64(p,&yrhocells[2+irhoy],rho_index);
                 jy2+=rhoy2;
                 jy2.Store(p,&jy_arr.p[jyoffset+moff[2]]);
 
                 Vec jy3=Vec::Load(p,&jy_arr.p[jyoffset+moff[3]]);
                 svfloat64_t rhoy3=svld1_gather_u64index_f64(p,&yrhocells[3+irhoy],rho_index);
                 jy3+=rhoy3;
                 jy3.Store(p,&jy_arr.p[jyoffset+moff[3]]);
 
                 Vec jy4=Vec::Load(p,&jy_arr.p[jyoffset+moff[4]]);
                 svfloat64_t rhoy4=svld1_gather_u64index_f64(p,&yrhocells[4+irhoy],rho_index);
                 jy4+=rhoy4;
                 jy4.Store(p,&jy_arr.p[jyoffset+moff[4]]);
 
                 Vec jy5=Vec::Load(p,&jy_arr.p[jyoffset+moff[5]]);
                 svfloat64_t rhoy5=svld1_gather_u64index_f64(p,&yrhocells[5+irhoy],rho_index);
                 jy5+=rhoy5;
                 jy5.Store(p,&jy_arr.p[jyoffset+moff[5]]);
 
                 Vec jy6=Vec::Load(p,&jy_arr.p[jyoffset+moff[6]]);
                 svfloat64_t rhoy6=svld1_gather_u64index_f64(p,&yrhocells[6+irhoy],rho_index);
                 jy6+=rhoy6;
                 jy6.Store(p,&jy_arr.p[jyoffset+moff[6]]);
 
                 Vec jy7=Vec::Load(p,&jy_arr.p[jyoffset+moff[7]]);
                 svfloat64_t rhoy7=svld1_gather_u64index_f64(p,&yrhocells[7+irhoy],rho_index);
                 jy7+=rhoy7;
                 jy7.Store(p,&jy_arr.p[jyoffset+moff[7]]);
 
                 // z
                 // uint64_t irhoz = ix + iy * zjstride + iz * zkstride;
                 // svuint64_t rhoz_index = svindex_u64(irhoz, 8ULL);
                 // long jzoffset = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
                 long zoffset = ix + iy * zjstride + iz * zkstride;
                 long jzoffset=zoffset;
                 long irhoz=8*zoffset;
                 Vec jz0=Vec::Load(p,&jz_arr.p[jzoffset+moff[0]]);
                 svfloat64_t rhoz0=svld1_gather_u64index_f64(p,&zrhocells[0+irhoz],rho_index);
                 jz0+=rhoz0;
                 jz0.Store(p,&jz_arr.p[jzoffset+moff[0]]);
 
                 Vec jz1=Vec::Load(p,&jz_arr.p[jzoffset+moff[1]]);
                 svfloat64_t rhoz1=svld1_gather_u64index_f64(p,&zrhocells[1+irhoz],rho_index);
                 jz1+=rhoz1;
                 jz1.Store(p,&jz_arr.p[jzoffset+moff[1]]);
 
                 Vec jz2=Vec::Load(p,&jz_arr.p[jzoffset+moff[2]]);
                 svfloat64_t rhoz2=svld1_gather_u64index_f64(p,&zrhocells[2+irhoz],rho_index);
                 jz2+=rhoz2;
                 jz2.Store(p,&jz_arr.p[jzoffset+moff[2]]);
 
                 Vec jz3=Vec::Load(p,&jz_arr.p[jzoffset+moff[3]]);
                 svfloat64_t rhoz3=svld1_gather_u64index_f64(p,&zrhocells[3+irhoz],rho_index);
                 jz3+=rhoz3;
                 jz3.Store(p,&jz_arr.p[jzoffset+moff[3]]);
 
                 Vec jz4=Vec::Load(p,&jz_arr.p[jzoffset+moff[4]]);
                 svfloat64_t rhoz4=svld1_gather_u64index_f64(p,&zrhocells[4+irhoz],rho_index);
                 jz4+=rhoz4;
                 jz4.Store(p,&jz_arr.p[jzoffset+moff[4]]);
 
                 Vec jz5=Vec::Load(p,&jz_arr.p[jzoffset+moff[5]]);
                 svfloat64_t rhoz5=svld1_gather_u64index_f64(p,&zrhocells[5+irhoz],rho_index);
                 jz5+=rhoz5;
                 jz5.Store(p,&jz_arr.p[jzoffset+moff[5]]);
 
                 Vec jz6=Vec::Load(p,&jz_arr.p[jzoffset+moff[6]]);
                 svfloat64_t rhoz6=svld1_gather_u64index_f64(p,&zrhocells[6+irhoz],rho_index);
                 jz6+=rhoz6;
                 jz6.Store(p,&jz_arr.p[jzoffset+moff[6]]);
 
                 Vec jz7=Vec::Load(p,&jz_arr.p[jzoffset+moff[7]]);
                 svfloat64_t rhoz7=svld1_gather_u64index_f64(p,&zrhocells[7+irhoz],rho_index);
                 jz7+=rhoz7;
                 jz7.Store(p,&jz_arr.p[jzoffset+moff[7]]);
 
                 // svetime[1]=rdtscv();
                 // reduce_time+=(svetime[1]-svetime[0]);
             }
         }
     }
     
     // auto total_stop=high_resolution_clock::now();
     // duration<double> total_elapse = total_stop-total_start;
     // total_time = total_elapse.count();
     // printf("\n SVE noblock Sort: total time: %lf s, precompute: %ld, sort_time %ld cale_time: %ld, reduce_time: %ld \n",
     //     total_time,     precompute,   sort_time,  cale_time,     reduce_time);
     // printf("\t noblock Sort: %ld, Count: %ld, Presum %ld binlist: %ld, Branch: %ld \n",
     //         sort_time,      count_time,   presum_time,  binlist_time, branch_time);
 
     // total_time[1]=rdtscv();
     // total_time[2]=(total_time[1]-total_time[0]);
     // printf("total time: %d, precompute: %d, cale_time: %d, reduce_time: %d \n",
     //         total_time,     precompute,     cale_time,     reduce_time);
     // amrex::Abort("END!");
 
 }
 
 
 // not rhocell but particle simd, paper 2
 // with  no data reuse
 template <int depos_order>
 void doDepositionShapeN_sve_jtmp (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Dim3 hi,
                          amrex::Dim3 len,
                          amrex::Real q,
                          std::vector<double>& test,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     // uint64_t total_time[3]={0};
     using namespace std::chrono;
     using namespace amrex::literals;
     double total_time=0;
     // auto total_start=high_resolution_clock::now();
     uint64_t precompute=0;
     uint64_t cale_time=0;
     uint64_t sort_time=0;
         uint64_t count_time=0;
         uint64_t presum_time=0;
         uint64_t binlist_time=0;
     uint64_t reduce_time=0;
     uint64_t svetime[3]={0};
     uint64_t branch_time=0;
     
     // total_time[0]=rdtscv();
     
 
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z; 
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
 
     constexpr int nshapes = depos_order + 1;
     // constexpr int nshapes = 2;
     int vl=svcntd();
 
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
 
     auto compute_shape_factor_v2 = [](double* sx[], Vec xmid, svbool_t p) {
         intVec i_newv = svcvt_s64_f64_z(p, xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         sx0.Store(p, sx[0]);
         sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         return i_newv;
     };
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
     const int numcell = jx_fab.box().numPts();
     const int xnumcell = jx_fab.box().numPts();
 
     auto xrhocells = std::make_unique<double[]>(8*numcell);
     auto yrhocells = std::make_unique<double[]>(8*numcell);
     auto zrhocells = std::make_unique<double[]>(8*numcell);
     // one roll x
     uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
     uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
     uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
     long nx=xjstride;
     long nxy=xkstride;
     long moff[8] = {0, 1, nx, nx+1, nxy, nxy+1, nx+nxy, nx+nxy+1};
     svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
     svbool_t px = svcmpeq_n_u64(svptrue_b64(), rmx_v, 0);
     svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
     svbool_t py = svcmpeq_n_u64(svptrue_b64(), rmy_v, 0);
     svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
     svbool_t pz = svcmpeq_n_u64(svptrue_b64(), rmz_v, 0);
 
     std::vector<amrex::Real> wqx(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqy(np_to_deposit, 0.0);
     std::vector<amrex::Real> wqz(np_to_deposit, 0.0);
 
     std::vector<std::vector<amrex::Real>> sx_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
     std::vector<std::vector<amrex::Real>> sy_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
     std::vector<std::vector<amrex::Real>> sz_m(nshapes,std::vector<amrex::Real>(np_to_deposit, 0.));
 
     // some place dont have particle
     alignas(64) long xoffsets[np_to_deposit]; 
     std::vector<long> xcount(numcell,0);    
 
     for(long ip=0;ip<np_to_deposit;ip+=vl){
         // svetime[0]=rdtscv();
 
         // 计算基本物理量
         svbool_t p=svwhilele_b64(ip,np_to_deposit);
         // Inverse of Lorentz factor gamma
         Vec uxp_v=Vec::Load(p,&uxp[ip]);
         Vec uyp_v=Vec::Load(p,&uyp[ip]);
         Vec uzp_v=Vec::Load(p,&uzp[ip]);
         Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                     + uyp_v * uyp_v * clightsq
                                     + uzp_v * uzp_v * clightsq).Sqrt();
         // Product of particle charges and weights
         Vec wp_v=Vec::Load(p,&wp[ip]);
         Vec wq_v = q * wp_v;
 
         // Current particle positions (in physical units)
         Vec xp = Vec::Load(p, &mx[ip]);
         Vec yp = Vec::Load(p, &my[ip]);
         Vec zp = Vec::Load(p, &mz[ip]);
 
         // Particle velocities
         Vec vx_v = uxp_v * gaminv;
         Vec vy_v = uyp_v * gaminv;
         Vec vz_v = uzp_v * gaminv;
 
         // if (do_ionization) wq *= ion_lev[ip];
         Vec wqx_v = wq_v * invvol * vx_v;
         Vec wqy_v = wq_v * invvol * vy_v;
         Vec wqz_v = wq_v * invvol * vz_v;
 
         wqx_v.Store(p, &wqx[ip]);
         wqy_v.Store(p, &wqy[ip]);
         wqz_v.Store(p, &wqz[ip]);
 
         Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x;
         Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y;
         Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z;
 
         double* sx_temp[nshapes] = {&sx_m[0][ip], &sx_m[1][ip]};
         intVec j_cellv = compute_shape_factor_v2( sx_temp, xmid, p);
         double* sy_temp[nshapes] = {&sy_m[0][ip], &sy_m[1][ip]};
         intVec k_cellv = compute_shape_factor_v2( sy_temp, ymid, p);
         double* sz_temp[nshapes] = {&sz_m[0][ip], &sz_m[1][ip]};
         intVec l_cellv = compute_shape_factor_v2( sz_temp, zmid, p); 
 
         intVec xoffsets_v = j_cellv + k_cellv * xjstride + l_cellv * xkstride;
 
         xoffsets_v.Store(p,&xoffsets[ip]);
     }
     // svetime[0]=rdtscv();
     for(long ip=0;ip<np_to_deposit;ip++){
         xcount[xoffsets[ip]]++;
     }
     // svetime[1]=rdtscv();
     // count_time+=(svetime[1]-svetime[0]);
 
     std::vector<long> xpresum(numcell+1,0);
     // svetime[0]=rdtscv();
     for(int c=1;c<=numcell;c++){
         xpresum[c]=xpresum[c-1]+xcount[c-1];
     }
     // svetime[1]=rdtscv();
     // presum_time+=(svetime[1]-svetime[0]);
 
     std::vector<long> xbinList(np_to_deposit,-1);
     // svetime[0]=rdtscv();
     for(int ip=0;ip<np_to_deposit;ip++){
         long xoffset = xoffsets[ip];
         xbinList[xpresum[xoffset]]=ip;
         xpresum[xoffset]++;
     }
     // svetime[1]=rdtscv();
     // binlist_time+=(svetime[1]-svetime[0]);
     // sort_time+=(count_time+binlist_time+presum_time);
     // for (int iz = 0; iz <= len.z; ++iz) {
     //     for (int iy = 0; iy <= len.y; ++iy) { 
     //         for (int ix = 0; ix <= len.x; ix+=vl) {
     //             svbool_t p=svwhilele_b64(ix,len.x);
     //             int c=ix + iy * xjstride + iz * xkstride;
     // int ls=1;
     // printf("tile x %d, tile y %d, tile z %d \n", len.x,len.y,len.z);
     for(int c=1;c<=numcell;c+=vl){
         svbool_t p0=svwhilele_b64(c,numcell);
         intVec start_v=intVec::Load(p0,&xpresum[c-1]);
         intVec end_v=intVec::Load(p0,&xpresum[c]);
         intVec offset_v=end_v-start_v;
         svbool_t p=svcmpgt_n_s64(p0,offset_v, 0);
         int max_np=svmaxv_s64(p,offset_v);
         // long tipp[8]={0};
         // ip_v.Store(p,&tipp[0]);
         // for(int idx=0;idx<8;idx++){
         //     if(tipp[idx]>0){
         //         ls++;
         //         printf("ls %d np %d ip %ld \n",ls,np_to_deposit, tipp[idx]);
         //     }
         // }
         // long ip0=xbinList[xpresum[c]];
         // printf("np %d in %d \n",np_to_deposit,ip0);
         // svbool_t p_ip=svwhilelt_b64(ip0,np_to_deposit);
         for(int c=1;c<=numcell;c+=vl){
             svbool_t p0=svwhilele_b64(c,numcell);
             intVec start_v=intVec::Load(p0,&xpresum[c-1]);
             intVec end_v=intVec::Load(p0,&xpresum[c]);
             intVec offset_v=end_v-start_v;
             svbool_t p=svcmpgt_n_s64(p0,offset_v, 0);
             int max_np=svmaxv_s64(p,offset_v);
             while(max_np>0){
                 intVec ip_v=svld1_gather_s64index_s64(p,&xbinList[0],start_v);
                 // long tipp[8]={0};
                 // ip_v.Store(p,&tipp[0]);
                 // for(int idx=0;idx<8;idx++){
                 //     if(tipp[idx]>0){
                 //         ls++;
                 //         printf("ls %d np %d ip %ld \n",ls,np_to_deposit, tipp[idx]);
                 //     }
                 // }
     
                 // long ip0=xbinList[xpresum[c]];
                 // printf("np %d in %d \n",np_to_deposit,ip0);
                 // svbool_t p_ip=svwhilelt_b64(ip0,np_to_deposit);
                 for (int iz = 0; iz < nshapes; ++iz) {
                     const std::vector<double>& sz=sz_m[iz];
                     for (int iy = 0; iy < nshapes; ++iy) {
                         const std::vector<double>& sy=sy_m[iy];
                         for (int ix = 0; ix < nshapes; ++ix) {
                             int coffset=c+ix + iy * xjstride + iz * xkstride;
                             Vec jx_arr_v=Vec::Load(p,&jx_arr.p[coffset]);
                             Vec jy_arr_v=Vec::Load(p,&jy_arr.p[coffset]);
                             Vec jz_arr_v=Vec::Load(p,&jz_arr.p[coffset]);
     
                             const std::vector<double>& sx=sx_m[ix];
                             Vec sx_v=svld1_gather_s64index_f64(p,&sx[0],ip_v);
                             // long ipp[8]={0};
                             // ip_v.Store(p,&ipp[0]);
                             // double sxx[8]={-1};
                             // sx_v.Store(p,&sxx[0]);
                             // for(int idx=0;idx<8;idx++){
                             //     if(sxx[idx]>0&&ix == 0){
                             //         // printf("ip %ld sx %lf \n",ipp[idx],sxx[idx]);
                             //         test[ipp[idx]]=sxx[idx];
                             //     }
                             // }
                             Vec sy_v=svld1_gather_s64index_f64(p,&sy[0],ip_v);
                             Vec sz_v=svld1_gather_s64index_f64(p,&sz[0],ip_v);
                             Vec s = sx_v * sy_v * sz_v;
                             Vec wqx_v=svld1_gather_s64index_f64(p,&wqx[0],ip_v);
                             Vec wqy_v=svld1_gather_s64index_f64(p,&wqy[0],ip_v);
                             Vec wqz_v=svld1_gather_s64index_f64(p,&wqz[0],ip_v);
                             jx_arr_v+=s* wqx_v;
                             jy_arr_v+=s* wqy_v;
                             jz_arr_v+=s* wqz_v;
                             
                             jx_arr_v.Store(p,&jx_arr.p[coffset]);
                             jy_arr_v.Store(p,&jy_arr.p[coffset]);
                             jz_arr_v.Store(p,&jz_arr.p[coffset]);
                         }
                     }
                 }
                 max_np--;
                 offset_v = svsub_s64_x(p, offset_v, intVec(1));
                 p=svcmpgt_n_s64(p, offset_v, 0);
                 start_v = svadd_s64_x(p, start_v, intVec(1));
             }
         }
     }
 }


 template <int depos_order>
 void doDepositionShapeN_test_order3_special(const GetParticlePosition<PIdx> &GetPosition,
                                            const amrex::ParticleReal *const wp,
                                            const amrex::ParticleReal *const uxp,
                                            const amrex::ParticleReal *const uyp,
                                            const amrex::ParticleReal *const uzp,
                                            const int *ion_lev,
                                            amrex::FArrayBox &jx_fab,
                                            amrex::FArrayBox &jy_fab,
                                            amrex::FArrayBox &jz_fab,
                                            long np_to_deposit,
                                            amrex::Real relative_time,
                                            const amrex::XDim3 &dinv,
                                            const amrex::XDim3 &xyzmin,
                                            amrex::Dim3 lo,
                                            amrex::Dim3 hi,
                                            amrex::Dim3 len,
                                            amrex::Real q,
                                            WarpXParticleContainer::ParticleTileType &ptile, const amrex::Box &box,
                                            [[maybe_unused]] int n_rz_azimuthal_modes)
 {
     // 数据预处理开始======================================================
     // uint64_t total_time[3]={0};
     using namespace std::chrono;
     using namespace amrex::literals;
     // WARPX_PROFILE_REGION("USERDEFINE:doDepositionShapeN_pura_sme_1");
     // WARPX_PROFILE("[1]USERDEFINE:warpxDEPO::doDepositionShapeN_pura_sme_1");
     // WARPX_PROFILE_VAR_NS("doDepositionShapeN_pura_sme:dataPreprocessing", dataPreprocessing);
     // WARPX_PROFILE_VAR_NS("doDepositionShapeN_pura_sme:dataReduce", dataReduce);
     // WARPX_PROFILE_VAR_NS("doDepositionShapeN_pura_sme:sort_3d_sme_kernal", sme_kernal);
    //  WARPX_PROFILE("[0] USER org()");
    //  WARPX_PROFILE_VAR_NS("[1] USER org_pre", bl_sort);
    //  WARPX_PROFILE_VAR_NS("[2] USER org_cmp&sav", bl_sme);
     // WARPX_PROFILE_VAR_NS("[3] USER org_post", bl_post);
     
     // WARPX_PROFILE_VAR_START(dataPreprocessing);
    //  WARPX_PROFILE_VAR_START(bl_sort);
    uint64_t total_time[3]={0};
    // double total_time=0;
    // auto total_start=high_resolution_clock::now();
    uint64_t precompute=0;
    uint64_t precompute1[2]={0};
    uint64_t cal_time=0;
    uint64_t sort_time=0;
        uint64_t presort=0;
        uint64_t insert=0;
        uint64_t borrow=0;
        uint64_t rebuildtime=0;
    uint64_t reduce_time=0;
    uint64_t svetime[3]={0};
    uint64_t svetime1[3]={0};
 
     // WARPX_PROFILE_VAR_START(dataPreprocessing);
     total_time[0]=rdtscv();
     
     constexpr int nshape = depos_order + 1;
     std::vector<amrex::Real> wqx(np_to_deposit, 0.0_rt), wqy(np_to_deposit, 0.0_rt), wqz(np_to_deposit, 0.0_rt);
     std::vector<amrex::Real> sx_m(nshape * np_to_deposit, 0);
     std::vector<amrex::Real> sy_m(nshape * np_to_deposit, 0);
     std::vector<amrex::Real> sz_m(nshape * np_to_deposit, 0);
     std::vector<amrex::Real> jm(np_to_deposit, 0);
     std::vector<amrex::Real> km(np_to_deposit, 0);
     std::vector<amrex::Real> lm(np_to_deposit, 0);

     svetime[0]=rdtscv();
     amrex::Array4<amrex::Real> const &jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const &jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const &jz_arr = jz_fab.array();
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
    //  long nx = xjstride;
    //  long nxy = xkstride;
    //  long moff[8] = {0, 1, nx, nx + 1, nxy, nxy + 1, nx + nxy, nx + nxy + 1};
 
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x * dinv.y * dinv.z;
 
     const amrex::Real clightsq = 1.0_rt / PhysConst::c / PhysConst::c;
 
     const long numcell = jx_fab.box().numPts();
 
     amrex::IntVect const jx_type = jx_fab.box().type();
     amrex::IntVect const jy_type = jy_fab.box().type();
     amrex::IntVect const jz_type = jz_fab.box().type();
    //  int nshape = 1+depos_order;
 
     
 
    //  int j_m=-1;
    //  int k_m=-1;
    //  int l_m=-1;
     alignas(64) std::vector<int> newbin(np_to_deposit,-1);
 
     // std::vector<std::vector<amrex::Real>> sz_jx(np_to_deposit, std::vector<amrex::Real>(depos_order + 1, 0.0_rt));
     // std::vector<int> l_jx(np_to_deposit, 0), l_jy(np_to_deposit, 0), l_jz(np_to_deposit, 0);
     svetime[1]=rdtscv();
     precompute1[0]+=(svetime[1]-svetime[0]);

     svetime[0]=rdtscv();
     #pragma omp simd
     for (int ip = 0; ip < np_to_deposit; ip++)
     {
         // for(int ip=ptile.m_num_particles;ip<np_to_deposit;ip++){
         amrex::ParticleReal xp, yp, zp;
         GetPosition(ip, xp, yp, zp);
 
         // --- Get particle quantities
         const amrex::Real gaminv = 1.0_rt / std::sqrt(1.0_rt + uxp[ip] * uxp[ip] * clightsq + uyp[ip] * uyp[ip] * clightsq + uzp[ip] * uzp[ip] * clightsq);
         const amrex::Real vx = uxp[ip] * gaminv;
         const amrex::Real vy = uyp[ip] * gaminv;
         const amrex::Real vz = uzp[ip] * gaminv;
 
         amrex::Real wq = q * wp[ip];
         if (do_ionization)
         {
             wq *= ion_lev[ip];
         }
 
         constexpr int NODE = amrex::IndexType::NODE;
         constexpr int CELL = amrex::IndexType::CELL;
 
         // wqx, wqy wqz are particle current in each direction
         wqx[ip] = wq * invvol * vx;
         wqy[ip] = wq * invvol * vy;
         wqz[ip] = wq * invvol * vz;
 
         // --- Compute shape factors
         Compute_shape_factor<depos_order> const compute_shape_factor;
 
         // const auto j = static_cast<int>(xmid);
         // x direction
         // Get particle position after 1/2 push back in position
         // Keep these double to avoid bug in single precision
 
         const double xmid = ((xp - xyzmin.x) + relative_time * vx) * dinv.x;
 
         double sx_node[depos_order + 1] = {0.};
         double sx_cell[depos_order + 1] = {0.};
         int j_node = 0;
         int j_cell = 0;
         if (jx_type[0] == NODE || jy_type[0] == NODE || jz_type[0] == NODE)
         {
             j_node = compute_shape_factor(sx_node, xmid);
         }
         if (jx_type[0] == CELL || jy_type[0] == CELL || jz_type[0] == CELL)
         {
             j_cell = compute_shape_factor(sx_cell, xmid - 0.5);
         }
 
         // amrex::Real sx_jx[depos_order + 1] = {0._rt};
         // amrex::Real sx_jy[depos_order + 1] = {0._rt};
         // amrex::Real sx_jz[depos_order + 1] = {0._rt};
         for (int ix = 0; ix <= depos_order; ix++)
         {
             // sx_jx[ip][ix] = ((jx_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
             // sx_jy[ip][ix] = ((jy_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
             // sx_jz[ip][ix] = ((jz_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
             sx_m[ip * nshape + ix] = ((jx_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
         }
 
         // int const j_jx = ((jx_type[0] == NODE) ? j_node : j_cell);
         // j_jx[ip] = ((jx_type[0] == NODE) ? j_node : j_cell);
         // j_jy[ip] = ((jy_type[0] == NODE) ? j_node : j_cell);
         // j_jz[ip] = ((jz_type[0] == NODE) ? j_node : j_cell);
         // j_m[ip] = ((jz_type[0] == NODE) ? j_node : j_cell);
         jm[ip] = ((jz_type[0] == NODE) ? j_node : j_cell);
 
         // y direction
         // Keep these double to avoid bug in single precision
         const double ymid = ((yp - xyzmin.y) + relative_time * vy) * dinv.y;
         double sy_node[depos_order + 1] = {0.};
         double sy_cell[depos_order + 1] = {0.};
         int k_node = 0;
         int k_cell = 0;
         if (jx_type[1] == NODE || jy_type[1] == NODE || jz_type[1] == NODE)
         {
             k_node = compute_shape_factor(sy_node, ymid);
         }
         if (jx_type[1] == CELL || jy_type[1] == CELL || jz_type[1] == CELL)
         {
             k_cell = compute_shape_factor(sy_cell, ymid - 0.5);
         }
         // amrex::Real sy_jx[depos_order + 1] = {0._rt};
         // amrex::Real sy_jy[depos_order + 1] = {0._rt};
         // amrex::Real sy_jz[depos_order + 1] = {0._rt};
         for (int iy = 0; iy <= depos_order; iy++)
         {
             // sy_jx[ip][iy] = ((jx_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
             // sy_jy[ip][iy] = ((jy_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
             // sy_jz[ip][iy] = ((jz_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
             sy_m[ip * nshape + iy] = ((jx_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
         }
         // k_jx[ip] = ((jx_type[1] == NODE) ? k_node : k_cell);
         // k_jy[ip] = ((jy_type[1] == NODE) ? k_node : k_cell);
         // k_jz[ip] = ((jz_type[1] == NODE) ? k_node : k_cell);
         // k_m[ip] = ((jx_type[1] == NODE) ? k_node : k_cell);
         km[ip] = ((jx_type[1] == NODE) ? k_node : k_cell);
 
         // z direction
         // Keep these double to avoid bug in single precision
         constexpr int zdir = WARPX_ZINDEX;
         const double zmid = ((zp - xyzmin.z) + relative_time * vz) * dinv.z;
         double sz_node[depos_order + 1] = {0.};
         double sz_cell[depos_order + 1] = {0.};
         int l_node = 0;
         int l_cell = 0;
         if (jx_type[zdir] == NODE || jy_type[zdir] == NODE || jz_type[zdir] == NODE)
         {
             l_node = compute_shape_factor(sz_node, zmid);
         }
         if (jx_type[zdir] == CELL || jy_type[zdir] == CELL || jz_type[zdir] == CELL)
         {
             l_cell = compute_shape_factor(sz_cell, zmid - 0.5);
         }
         // amrex::Real sz_jx[depos_order + 1] = {0._rt};
         // amrex::Real sz_jy[depos_order + 1] = {0._rt};
         // amrex::Real sz_jz[depos_order + 1] = {0._rt};
         for (int iz = 0; iz <= depos_order; iz++)
         {
             // sz_jx[ip][iz] = ((jx_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
             // sz_jy[ip][iz] = ((jy_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
             // sz_jz[ip][iz] = ((jz_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
             sz_m[ip * nshape + iz] = ((jx_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
         }
         // l_jx[ip] = ((jx_type[zdir] == NODE) ? l_node : l_cell);
         // l_jy[ip] = ((jy_type[zdir] == NODE) ? l_node : l_cell);
         // l_jz[ip] = ((jz_type[zdir] == NODE) ? l_node : l_cell);
         // l_m[ip] = ((jz_type[zdir] == NODE) ? l_node : l_cell);
         lm[ip] = ((jz_type[zdir] == NODE) ? l_node : l_cell);
        //  newbin[ip]=j_m+k_m*xjstride+l_m*xkstride;
     }
     svetime[1]=rdtscv();
     precompute1[1]+=(svetime[1]-svetime[0]);
     precompute=(precompute1[1]+precompute1[0]); 
 
 
    //  WARPX_PROFILE_VAR_STOP(bl_sort);
    //  WARPX_PROFILE_VAR_START(bl_sme);
 
     amrex::IntVect box_shape = box.length();
 
     int nx_box = box_shape[0];
     int ny_box = box_shape[1];
     int nxny_box = nx_box * ny_box;
     std::vector<double> jx_t(numcell,0),jy_t(numcell,0),jz_t(numcell,0);

     svetime[0]=rdtscv();
     #pragma omp simd
     for (int ip = 0; ip < np_to_deposit; ip++){
        #pragma omp simd
         for (int iz=0; iz<=depos_order; iz++){
            #pragma omp simd
             for (int iy=0; iy<=depos_order; iy++){
                #pragma unroll
                 for (int ix=0; ix<=depos_order; ix++){
                    //  double sxsysz= sx_m[ip * 2 + ix]*sy_m[ip * 2 + iy]*sz_m[ip * 2 + iz];
                    //  long idx = ix + iy * xjstride + iz * xkstride;
                     // jx_t[idx]+=sxsysz*wqx[ip];
                     // jy_t[idx]+=sxsysz*wqy[ip];
                     // jz_t[idx]+=sxsysz*wqz[ip];
                    //  amrex::Gpu::Atomic::AddNoRet( &jx_arr.p[idx],sxsysz*wqx[ip]);
                    //  amrex::Gpu::Atomic::AddNoRet( &jy_arr.p[idx],sxsysz*wqy[ip]);
                    //  amrex::Gpu::Atomic::AddNoRet( &jz_arr.p[idx],sxsysz*wqz[ip]);
                    // svetime[0]=rdtscv();
                    // double jx=sx_m[ix+nshape*ip]*sy_m[iy+nshape*ip]*sz_m[iz+nshape*ip]*wqx[ip];
                    // double jy=sx_m[ix+nshape*ip]*sy_m[iy+nshape*ip]*sz_m[iz+nshape*ip]*wqy[ip];
                    // double jz=sx_m[ix+nshape*ip]*sy_m[iy+nshape*ip]*sz_m[iz+nshape*ip]*wqz[ip];
                    // svetime[1]=rdtscv();
                    // cal_time+=(svetime[1]-svetime[0]); 

                    // svetime[0]=rdtscv();
                    // amrex::Gpu::Atomic::AddNoRet(
                    //     &jx_arr(lo.x+jm[ip]+ix, lo.y+km[ip]+iy, lo.z+lm[ip]+iz),
                    //     jx);
                    // amrex::Gpu::Atomic::AddNoRet(
                    //     &jy_arr(lo.x+jm[ip]+ix, lo.y+km[ip]+iy, lo.z+lm[ip]+iz),
                    //     jy);
                    // amrex::Gpu::Atomic::AddNoRet(
                    //     &jz_arr(lo.x+jm[ip]+ix, lo.y+km[ip]+iy, lo.z+lm[ip]+iz),
                    //     jz);
                    // svetime[1]=rdtscv();
                    // reduce_time+=(svetime[1]-svetime[0]); 
                
                     amrex::Gpu::Atomic::AddNoRet(
                         &jx_arr(lo.x+jm[ip]+ix, lo.y+km[ip]+iy, lo.z+lm[ip]+iz),
                         sx_m[ix+2*ip]*sy_m[iy+2*ip]*sz_m[iz+2*ip]*wqx[ip]);
                    //  amrex::Gpu::Atomic::AddNoRet(
                    //      &jy_arr(lo.x+jm[ip]+ix, lo.y+km[ip]+iy, lo.z+lm[ip]+iz),
                    //      sx_m[ix+2*ip]*sy_m[iy+2*ip]*sz_m[iz+2*ip]*wqy[ip]);
                    //  amrex::Gpu::Atomic::AddNoRet(
                    //      &jz_arr(lo.x+jm[ip]+ix, lo.y+km[ip]+iy, lo.z+lm[ip]+iz),
                    //      sx_m[ix+2*ip]*sy_m[iy+2*ip]*sz_m[iz+2*ip]*wqz[ip]);
                     }
                 }
             }
         }
        svetime[1]=rdtscv();
        cal_time+=(svetime[1]-svetime[0]);

        total_time[1]=rdtscv();
        total_time[2]+=(total_time[1]-total_time[0]); 

        // int world_rank;
        // MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);
        // int tid = omp_get_thread_num();
        // if (world_rank == 0 && tid == 0) {
            printf("================ORG=================\n");
            printf("ORG Total:%llu \n",(unsigned long long)(cal_time+precompute));
            //  printf("ORG Total:%d \n",total_time[2]);
            printf("\t ORG precompute:%lu \n",precompute);
            printf("\t\t --precompute1:%lu \n",precompute1[0]);
            printf("\t\t --precompute2:%lu \n",precompute1[1]);
            printf("\t ORG cal_time+reduce_time:%lu \n\n",cal_time);
            //  printf("\t ORG reduce_time:%d \n\n",reduce_time);
        // }
    
        //  WARPX_PROFILE_VAR_STOP(bl_sme);
     // WARPX_PROFILE_VAR_STOP(dataReduce);
 
     // auto total_stop=high_resolution_clock::now();
 
 }
 

// test correctness
template <int depos_order>
void doDepositionShapeN_test_order3 (const GetParticlePosition<PIdx>& GetPosition,
                        const amrex::ParticleReal * const wp,
                        const amrex::ParticleReal * const uxp,
                        const amrex::ParticleReal * const uyp,
                        const amrex::ParticleReal * const uzp,
                        const int* ion_lev,
                        amrex::FArrayBox& jx_fab,
                        amrex::FArrayBox& jx_fab1,
                        amrex::FArrayBox& jy_fab,
                        amrex::FArrayBox& jz_fab,
                        long np_to_deposit,
                        amrex::Real relative_time,
                        const amrex::XDim3 & dinv,
                        const amrex::XDim3 & xyzmin,
                        amrex::Dim3 lo,
                        amrex::Dim3 hi,
                        amrex::Dim3 len,
                        amrex::Real q,
                        std::vector<int>& test,
                        std::vector<int>& testbin,
                        std::vector<double>& test_sxm,
                        std::vector<amrex::Real>& test_sxwq,
                        [[maybe_unused]]int n_rz_azimuthal_modes)
{
    using namespace amrex::literals;
    uint64_t total_time[3]={0};
    total_time[0]=rdtscv();

    // Whether ion_lev is a null pointer (do_ionization=0) or a real pointer
    // (do_ionization=1)
    const bool do_ionization = ion_lev;

    const amrex::Real invvol = dinv.x*dinv.y*dinv.z;

    const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;

    amrex::Array4<amrex::Real> const& jx_arr = jx_fab1.array();
    //jx is org, jx1 is sve
    amrex::Array4<amrex::Real> const& jx_arr1 = jx_fab.array();
    amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
    amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
    amrex::IntVect const jx_type = jx_fab.box().type();
    amrex::IntVect const jy_type = jy_fab.box().type();
    amrex::IntVect const jz_type = jz_fab.box().type();
    long nnx = len.x;
    long nny = len.y;
    long nnxny = nnx*nny;
    // printf("org len x %d y %d z %d xjstride %d xkstride %d\n",
    //     len.x,len.y,len.z,jx_arr1.jstride,jx_arr1.kstride);
    // Loop over particles and deposit into jx_fab, jy_fab and jz_fab
    //==================
    double errsxwqc=0;
    // double errsxwq=0;
    //==================
    amrex::ParallelFor(
        np_to_deposit,
        [=] AMREX_GPU_DEVICE (long ip) {
            amrex::ParticleReal xp, yp, zp;
            GetPosition(ip, xp, yp, zp);

            // --- Get particle quantities
            const amrex::Real gaminv = 1.0_rt/std::sqrt(1.0_rt + uxp[ip]*uxp[ip]*clightsq
                                                        + uyp[ip]*uyp[ip]*clightsq
                                                        + uzp[ip]*uzp[ip]*clightsq);
            const amrex::Real vx  = uxp[ip]*gaminv;
            const amrex::Real vy  = uyp[ip]*gaminv;
            const amrex::Real vz  = uzp[ip]*gaminv;

            amrex::Real wq  = q*wp[ip];
            if (do_ionization){
                wq *= ion_lev[ip];
            }

            // doDepositionShapeNKernel<depos_order>(xp, yp, zp, wq, vx, vy, vz, jx_arr, jy_arr, jz_arr,
            //                                       jx_type, jy_type, jz_type,
            //                                       relative_time, dinv, xyzmin,
            //                                       invvol, lo, n_rz_azimuthal_modes);

            constexpr int NODE = amrex::IndexType::NODE;
            constexpr int CELL = amrex::IndexType::CELL;
        
            // wqx, wqy wqz are particle current in each direction
        
            const amrex::Real wqx = wq*invvol*vx;
            // double err=wqx-test0[ip];
            // if(abs(err)>1e-3){
            //     printf("\nip %d wqx %lf simd %lf err %lf \n",ip,wqx,test0[ip],err);
            // }
            const amrex::Real wqy = wq*invvol*vy;
        
            const amrex::Real wqz = wq*invvol*vz;
        
            // --- Compute shape factors
            Compute_shape_factor< depos_order > const compute_shape_factor;
        
            const double xmid = ((xp - xyzmin.x) + relative_time*vx)*dinv.x;
            // j_j[xyz] leftmost grid point in x that the particle touches for the centering of each current
            // sx_j[xyz] shape factor along x for the centering of each current
            // There are only two possible centerings, node or cell centered, so at most only two shape factor
            // arrays will be needed.
            // Keep these double to avoid bug in single precision
            double sx_node[depos_order + 1] = {0.};
            double sx_cell[depos_order + 1] = {0.};
            int j_node = 0;
            int j_cell = 0;
            // jx_type[0] = CELL;
            // jy_type[0] = CELL;
            // jz_type[0] = CELL;
            // amrex::Print()<<jx_type[0]<<std::endl;
            if (jx_type[0] == NODE || jy_type[0] == NODE || jz_type[0] == NODE) {
                j_node = compute_shape_factor(sx_node, xmid);
            }
            if (jx_type[0] == CELL || jy_type[0] == CELL || jz_type[0] == CELL) {
                j_cell = compute_shape_factor(sx_cell, xmid - 0.5);
            }
            // double err=sx_node[0]-test0[ip];
            // // double err=xmid-test0[ip];
            // // int err=j_node-test[ip];
            // if(abs(err)>1e-3){
            //     // printf("\nip %d j_node %d simd %d err %d \n",ip,j_node,test[ip],err);
            //     // printf("\nip %d xmid %lf simd %lf err %lf \n",ip,xmid,test0[ip],err);
            //     printf("\nip %d sx_node %lf simd %lf err %lf \n",ip,sx_node[0],test0[ip],err);
            // }
            // for(int idx=0;idx<8;idx++){
            //     printf("j_node: sve %d org %d err %d \n", test[ip],j_node,test[ip]-j_node);
            // }
            // amrex::Abort("stop j_node");
            
        
            amrex::Real sx_jx[depos_order + 1] = {0._rt};
            amrex::Real sx_jy[depos_order + 1] = {0._rt};
            amrex::Real sx_jz[depos_order + 1] = {0._rt};
            for (int ix=0; ix<=depos_order; ix++)
            {
                sx_jx[ix] = ((jx_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
                sx_jy[ix] = ((jy_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
                sx_jz[ix] = ((jz_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
            }
        
            int const j_jx = ((jx_type[0] == NODE) ? j_node : j_cell);
            int const j_jy = ((jy_type[0] == NODE) ? j_node : j_cell);
            int const j_jz = ((jz_type[0] == NODE) ? j_node : j_cell);
            //========================
            #if 0
            int errc=0;
            for (int ix=0; ix<=depos_order; ix++)
            {
                double err=0;
                err=test_sxm[ip*4+ix]-sx_jx[ix];
                if(abs(err)>1e-3){
                    printf("SXM err %d: ip %d org %lf sve %lf err %lf \n",errc,ip,sx_jx[ix],test_sxm[ip*4+ix],err);
                    errc++;
                }
                if(errc>100){  
                    amrex::Abort("SXM ERR");
                }
            }
            #endif
            //=======================
        
        
            // y direction
            // Keep these double to avoid bug in single precision
            const double ymid = ((yp - xyzmin.y) + relative_time*vy)*dinv.y;
            double sy_node[depos_order + 1] = {0.};
            double sy_cell[depos_order + 1] = {0.};
            int k_node = 0;
            int k_cell = 0;
            if (jx_type[1] == NODE || jy_type[1] == NODE || jz_type[1] == NODE) {
                k_node = compute_shape_factor(sy_node, ymid);
            }
            if (jx_type[1] == CELL || jy_type[1] == CELL || jz_type[1] == CELL) {
                k_cell = compute_shape_factor(sy_cell, ymid - 0.5);
            }
            amrex::Real sy_jx[depos_order + 1] = {0._rt};
            amrex::Real sy_jy[depos_order + 1] = {0._rt};
            amrex::Real sy_jz[depos_order + 1] = {0._rt};
            for (int iy=0; iy<=depos_order; iy++)
            {
                sy_jx[iy] = ((jx_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
                sy_jy[iy] = ((jy_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
                sy_jz[iy] = ((jz_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
            }
            int const k_jx = ((jx_type[1] == NODE) ? k_node : k_cell);
            int const k_jy = ((jy_type[1] == NODE) ? k_node : k_cell);
            int const k_jz = ((jz_type[1] == NODE) ? k_node : k_cell);
        
        
            // z direction
            // Keep these double to avoid bug in single precision
            constexpr int zdir = WARPX_ZINDEX;
            const double zmid = ((zp - xyzmin.z) + relative_time*vz)*dinv.z;
            double sz_node[depos_order + 1] = {0.};
            double sz_cell[depos_order + 1] = {0.};
            int l_node = 0;
            int l_cell = 0;
            if (jx_type[zdir] == NODE || jy_type[zdir] == NODE || jz_type[zdir] == NODE) {
                l_node = compute_shape_factor(sz_node, zmid);
                // printf("\n ip %d NODE \n",ip);
                // if(jx_type[zdir] == NODE){
                //     printf("jx node\n");
                // }
                // if(jy_type[zdir] == NODE){
                //     printf("jy node\n");
                // }
                // if(jy_type[zdir] == NODE){
                //     printf("jz node\n");
                // }
            }
            if (jx_type[zdir] == CELL || jy_type[zdir] == CELL || jz_type[zdir] == CELL) {
                l_cell = compute_shape_factor(sz_cell, zmid - 0.5);
                printf("\n ip %d CELL \n",ip);
                if(jx_type[zdir] == CELL){
                    printf("jx cell\n");
                }
                if(jy_type[zdir] == CELL){
                    printf("jy cell\n");
                }
                if(jy_type[zdir] == CELL){
                    printf("jz cell\n");
                }
            }
            amrex::Real sz_jx[depos_order + 1] = {0._rt};
            amrex::Real sz_jy[depos_order + 1] = {0._rt};
            amrex::Real sz_jz[depos_order + 1] = {0._rt};
            for (int iz=0; iz<=depos_order; iz++)
            {
                sz_jx[iz] = ((jx_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
                sz_jy[iz] = ((jy_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
                sz_jz[iz] = ((jz_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
            }
            int const l_jx = ((jx_type[zdir] == NODE) ? l_node : l_cell);
            int const l_jy = ((jy_type[zdir] == NODE) ? l_node : l_cell);
            int const l_jz = ((jz_type[zdir] == NODE) ? l_node : l_cell);
            //==============================
            #if 0
            {
                double err=0;
                err=testbin[ip]-(j_jx+k_jx* nnx+l_jx* nnxny);
                if(abs(err)>1e-3){
                    printf("bin err %d: ip %d org %lf sve %lf err %lf \n",errc,ip,
                        (j_jx+k_jx* nnx+l_jx* nnxny),testbin[ip],err);
                    errc++;
                }
                if(errc>100){  
                    amrex::Abort("bin ERR");
                }
            }
            #endif
            //================================
            // double err=wqx*sz_node[0]-test0[ip];
            // // double err=xmid-test0[ip];
            // // int err=j_node-test[ip];
            // if(abs(err)>1e-3){
            //     // printf("\nip %d j_node %d simd %d err %d \n",ip,j_node,test[ip],err);
            //     // printf("\nip %d xmid %lf simd %lf err %lf \n",ip,xmid,test0[ip],err);
            //     printf("\nip %d sz_node %lf simd %lf err %lf \n",ip,wqx*sz_node[0],test0[ip],err);
            // }

            // Deposit current into jx_arr, jy_arr and jz_arr
            //==================================
            #if 0
            // double errsxwqc=0;
            double errsxwq=0;
            for (int ix=0; ix<=depos_order; ix++){
                for (int iz=0; iz<=1; iz++){
                    for (int iy=0; iy<=depos_order; iy++){
                        errsxwq=test_sxwq[ip*64+iy+iz*4+ix*8]-sx_jx[ix]*sy_jx[iy]*sz_jx[iz]*wqx;
                        if(abs(errsxwq)>1){
                            printf("sxwq[%d] err ix %d iy %d iz %d : org %lf sve %lf err %lf \n"
                                ,ip,ix,iy,iz,sx_jx[ix]*sy_jx[iy]*sz_jx[iz]*wqx
                                ,test_sxwq[ip*64+iy+iz*4+ix*8],errsxwq);
                            // errsxwqc++;
                        }
                        if(errsxwqc>100){  
                            amrex::Abort("sxwq ERR");
                        }
                    }
                }
            }
            for (int ix=0; ix<=depos_order; ix++){
                for (int iz=2; iz<=3; iz++){
                    for (int iy=0; iy<=depos_order; iy++){
                        // double errsxwqc=0;
                        // double errsxwq=0;
                        errsxwq=test_sxwq[ip*64+32+iy+(iz-2)*4+ix*8]-sx_jx[ix]*sy_jx[iy]*sz_jx[iz]*wqx;
                        if(abs(errsxwq)>1){
                            printf("sxwq[%d] err ix %d iy %d iz %d : org %lf sve %lf err %lf \n"
                                ,ip,ix,iy,iz,sx_jx[ix]*sy_jx[iy]*sz_jx[iz]*wqx
                                ,test_sxwq[ip*64+32+iy+(iz-2)*4+ix*8],errsxwq);
                            // errsxwqc++;
                        }
                        if(errsxwqc>100){  
                            amrex::Abort("sxwq ERR");
                        }
                    }
                }
            }
            #endif
            //==================================


            for (int iz=0; iz<=depos_order; iz++){
                for (int iy=0; iy<=depos_order; iy++){
                    for (int ix=0; ix<=depos_order; ix++){
                        double sxsysz=sx_jx[ix]*sy_jx[iy]*sz_jx[iz];
                        amrex::Gpu::Atomic::AddNoRet(
                            &jx_arr(lo.x+j_jx+ix, lo.y+k_jx+iy, lo.z+l_jx+iz),
                            sxsysz*wqx);
                        // amrex::Gpu::Atomic::AddNoRet(
                        //     &jy_arr(lo.x+j_jy+ix, lo.y+k_jy+iy, lo.z+l_jy+iz),
                        //     sxsysz*wqy);
                        // amrex::Gpu::Atomic::AddNoRet(
                        //     &jz_arr(lo.x+j_jz+ix, lo.y+k_jz+iy, lo.z+l_jz+iz),
                        //     sxsysz*wqz);
                        // amrex::Gpu::Atomic::AddNoRet(
                        //     &jx_arr(lo.x+j_jx+ix, lo.y+k_jx+iy, lo.z+l_jx+iz),
                        //     sx_jx[ix]*sy_jx[iy]*sz_jx[iz]*wqx);
                        // amrex::Gpu::Atomic::AddNoRet(
                        //     &jy_arr(lo.x+j_jy+ix, lo.y+k_jy+iy, lo.z+l_jy+iz),
                        //     sx_jy[ix]*sy_jy[iy]*sz_jy[iz]*wqy);
                        // amrex::Gpu::Atomic::AddNoRet(
                        //     &jz_arr(lo.x+j_jz+ix, lo.y+k_jz+iy, lo.z+l_jz+iz),
                        //     sx_jz[ix]*sy_jz[iy]*sz_jz[iz]*wqz);
                    }
                }
            }
        }
    );
#if 1
    // 这里是正确性校验，如果不开启可以做性能对比
    // long nx=len.x;
    // long nxy=len.x*len.y;
    // long moff[8] = {0, 1, nx, nx+1, nxy, nxy+1, nx+nxy, nx+nxy+1};
    const int xjstride = jx_arr.jstride;
    const int xkstride = jx_arr.kstride;
    const int xjstride1 = jx_arr1.jstride;
    const int xkstride1 = jx_arr1.kstride;
    // const int yjstride = jy_arr.jstride;
    // const int ykstride = jy_arr.kstride;
    // const int zjstride = jz_arr.jstride;
    // const int zkstride = jz_arr.kstride;
    int errcount=0;
    // printf("\n");
    // for(int idx=0;idx<108;idx++){
    //     long j = lo.x + idx;
    //     long k = lo.y +12;
    //     long l = lo.z ;
    //     long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;

    //     printf("%lf \n",jx_arr.p[jxoffset]);
    // }
    // amrex::Abort("xrhocells ERROR!");
    printf("========TESTING CORRECTNESS============\n");
    for (int iz = 0; iz <= len.z; ++iz) {
        for (int iy = 0; iy <= len.y; ++iy) { 
            for (int ix = 0; ix <= len.x; ++ix) {
                long j = lo.x + ix;
                long k = lo.y + iy;
                long l = lo.z + iz;
                long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                long jxoffset1 = j - jx_arr1.begin.x + (k - jx_arr1.begin.y) * xjstride1 + (l - jx_arr1.begin.z) * xkstride1;
                // long xoffset = ix + iy * xjstride + iz * xkstride;
                // for(int idx=0;idx<8;idx++){+moff[idx]
                    double jxorg=jx_arr.p[jxoffset];
                    double jxsve=jx_arr1.p[jxoffset1];
                    double err=jxsve-jxorg;
                    if(abs(err)>1){
                    // if(1){
                    // if(jxorg>1e-2){
                        // printf("jxoffset %ld jxoffset1 %ld \n",jxoffset+moff[idx],jxoffset1+moff[idx]);
                        printf("jxoffset %d ix %d iy %d iz %d: jxorg %lf jxsve %lf ERR %lf \n",
                            jxoffset,ix,  iy,   iz,       jxorg,    jxsve,   err );
                        errcount++;
                        if(errcount>30){
                            printf("%d %d %d %d \n",len.x,len.y,len.z,jx_fab.box().numPts());
                            amrex::Abort("222 ERROR 10 ! jxorg and jxsve");
                        }
                    }
                // }
            }
        }
    }
    // amrex::Abort("ERROR! jxorg and jxsve");
#endif
    total_time[1]=rdtscv();
    total_time[2]=total_time[1]-total_time[0];
    printf("ORG Total:%d \n\n",total_time[2]);
}
 
 
 
 // test correctness
 template <int depos_order>
 void doDepositionShapeN_test (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jx_fab1,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Dim3 hi,
                          amrex::Dim3 len,
                          amrex::Real q,
                          std::vector<int>& test,
                          std::vector<double>& test0,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     using namespace amrex::literals;
 
     // Whether ion_lev is a null pointer (do_ionization=0) or a real pointer
     // (do_ionization=1)
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z;
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab1.array();
     //jx is org, jx1 is sve
     amrex::Array4<amrex::Real> const& jx_arr1 = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
     amrex::IntVect const jx_type = jx_fab.box().type();
     amrex::IntVect const jy_type = jy_fab.box().type();
     amrex::IntVect const jz_type = jz_fab.box().type();
 
     // Loop over particles and deposit into jx_fab, jy_fab and jz_fab
     amrex::ParallelFor(
         np_to_deposit,
         [=] AMREX_GPU_DEVICE (long ip) {
             amrex::ParticleReal xp, yp, zp;
             GetPosition(ip, xp, yp, zp);
 
             // --- Get particle quantities
             const amrex::Real gaminv = 1.0_rt/std::sqrt(1.0_rt + uxp[ip]*uxp[ip]*clightsq
                                                         + uyp[ip]*uyp[ip]*clightsq
                                                         + uzp[ip]*uzp[ip]*clightsq);
             const amrex::Real vx  = uxp[ip]*gaminv;
             const amrex::Real vy  = uyp[ip]*gaminv;
             const amrex::Real vz  = uzp[ip]*gaminv;
 
             amrex::Real wq  = q*wp[ip];
             if (do_ionization){
                 wq *= ion_lev[ip];
             }
 
             // doDepositionShapeNKernel<depos_order>(xp, yp, zp, wq, vx, vy, vz, jx_arr, jy_arr, jz_arr,
             //                                       jx_type, jy_type, jz_type,
             //                                       relative_time, dinv, xyzmin,
             //                                       invvol, lo, n_rz_azimuthal_modes);
 
             constexpr int NODE = amrex::IndexType::NODE;
             constexpr int CELL = amrex::IndexType::CELL;
         
             // wqx, wqy wqz are particle current in each direction
         
             const amrex::Real wqx = wq*invvol*vx;
             // double err=wqx-test0[ip];
             // if(abs(err)>1e-3){
             //     printf("\nip %d wqx %lf simd %lf err %lf \n",ip,wqx,test0[ip],err);
             // }
             const amrex::Real wqy = wq*invvol*vy;
         
             const amrex::Real wqz = wq*invvol*vz;
         
             // --- Compute shape factors
             Compute_shape_factor< depos_order > const compute_shape_factor;
         
             const double xmid = ((xp - xyzmin.x) + relative_time*vx)*dinv.x;
             // j_j[xyz] leftmost grid point in x that the particle touches for the centering of each current
             // sx_j[xyz] shape factor along x for the centering of each current
             // There are only two possible centerings, node or cell centered, so at most only two shape factor
             // arrays will be needed.
             // Keep these double to avoid bug in single precision
             double sx_node[depos_order + 1] = {0.};
             double sx_cell[depos_order + 1] = {0.};
             int j_node = 0;
             int j_cell = 0;
             // jx_type[0] = CELL;
             // jy_type[0] = CELL;
             // jz_type[0] = CELL;
             // amrex::Print()<<jx_type[0]<<std::endl;
             if (jx_type[0] == NODE || jy_type[0] == NODE || jz_type[0] == NODE) {
                 j_node = compute_shape_factor(sx_node, xmid);
             }
             if (jx_type[0] == CELL || jy_type[0] == CELL || jz_type[0] == CELL) {
                 j_cell = compute_shape_factor(sx_cell, xmid - 0.5);
             }
             // double err=sx_node[0]-test0[ip];
             // // double err=xmid-test0[ip];
             // // int err=j_node-test[ip];
             // if(abs(err)>1e-3){
             //     // printf("\nip %d j_node %d simd %d err %d \n",ip,j_node,test[ip],err);
             //     // printf("\nip %d xmid %lf simd %lf err %lf \n",ip,xmid,test0[ip],err);
             //     printf("\nip %d sx_node %lf simd %lf err %lf \n",ip,sx_node[0],test0[ip],err);
             // }
             // for(int idx=0;idx<8;idx++){
             //     printf("j_node: sve %d org %d err %d \n", test[ip],j_node,test[ip]-j_node);
             // }
             // amrex::Abort("stop j_node");
             
         
             amrex::Real sx_jx[depos_order + 1] = {0._rt};
             amrex::Real sx_jy[depos_order + 1] = {0._rt};
             amrex::Real sx_jz[depos_order + 1] = {0._rt};
             for (int ix=0; ix<=depos_order; ix++)
             {
                 sx_jx[ix] = ((jx_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
                 sx_jy[ix] = ((jy_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
                 sx_jz[ix] = ((jz_type[0] == NODE) ? amrex::Real(sx_node[ix]) : amrex::Real(sx_cell[ix]));
             }
         
             int const j_jx = ((jx_type[0] == NODE) ? j_node : j_cell);
             int const j_jy = ((jy_type[0] == NODE) ? j_node : j_cell);
             int const j_jz = ((jz_type[0] == NODE) ? j_node : j_cell);
         
         
         
             // y direction
             // Keep these double to avoid bug in single precision
             const double ymid = ((yp - xyzmin.y) + relative_time*vy)*dinv.y;
             double sy_node[depos_order + 1] = {0.};
             double sy_cell[depos_order + 1] = {0.};
             int k_node = 0;
             int k_cell = 0;
             if (jx_type[1] == NODE || jy_type[1] == NODE || jz_type[1] == NODE) {
                 k_node = compute_shape_factor(sy_node, ymid);
             }
             if (jx_type[1] == CELL || jy_type[1] == CELL || jz_type[1] == CELL) {
                 k_cell = compute_shape_factor(sy_cell, ymid - 0.5);
             }
             amrex::Real sy_jx[depos_order + 1] = {0._rt};
             amrex::Real sy_jy[depos_order + 1] = {0._rt};
             amrex::Real sy_jz[depos_order + 1] = {0._rt};
             for (int iy=0; iy<=depos_order; iy++)
             {
                 sy_jx[iy] = ((jx_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
                 sy_jy[iy] = ((jy_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
                 sy_jz[iy] = ((jz_type[1] == NODE) ? amrex::Real(sy_node[iy]) : amrex::Real(sy_cell[iy]));
             }
             int const k_jx = ((jx_type[1] == NODE) ? k_node : k_cell);
             int const k_jy = ((jy_type[1] == NODE) ? k_node : k_cell);
             int const k_jz = ((jz_type[1] == NODE) ? k_node : k_cell);
         
         
             // z direction
             // Keep these double to avoid bug in single precision
             constexpr int zdir = WARPX_ZINDEX;
             const double zmid = ((zp - xyzmin.z) + relative_time*vz)*dinv.z;
             double sz_node[depos_order + 1] = {0.};
             double sz_cell[depos_order + 1] = {0.};
             int l_node = 0;
             int l_cell = 0;
             if (jx_type[zdir] == NODE || jy_type[zdir] == NODE || jz_type[zdir] == NODE) {
                 l_node = compute_shape_factor(sz_node, zmid);
                 // printf("\n ip %d NODE \n",ip);
                 // if(jx_type[zdir] == NODE){
                 //     printf("jx node\n");
                 // }
                 // if(jy_type[zdir] == NODE){
                 //     printf("jy node\n");
                 // }
                 // if(jy_type[zdir] == NODE){
                 //     printf("jz node\n");
                 // }
             }
             if (jx_type[zdir] == CELL || jy_type[zdir] == CELL || jz_type[zdir] == CELL) {
                 l_cell = compute_shape_factor(sz_cell, zmid - 0.5);
                 printf("\n ip %d CELL \n",ip);
                 if(jx_type[zdir] == CELL){
                     printf("jx cell\n");
                 }
                 if(jy_type[zdir] == CELL){
                     printf("jy cell\n");
                 }
                 if(jy_type[zdir] == CELL){
                     printf("jz cell\n");
                 }
             }
             amrex::Real sz_jx[depos_order + 1] = {0._rt};
             amrex::Real sz_jy[depos_order + 1] = {0._rt};
             amrex::Real sz_jz[depos_order + 1] = {0._rt};
             for (int iz=0; iz<=depos_order; iz++)
             {
                 sz_jx[iz] = ((jx_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
                 sz_jy[iz] = ((jy_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
                 sz_jz[iz] = ((jz_type[zdir] == NODE) ? amrex::Real(sz_node[iz]) : amrex::Real(sz_cell[iz]));
             }
             int const l_jx = ((jx_type[zdir] == NODE) ? l_node : l_cell);
             int const l_jy = ((jy_type[zdir] == NODE) ? l_node : l_cell);
             int const l_jz = ((jz_type[zdir] == NODE) ? l_node : l_cell);
         
             // double err=wqx*sz_node[0]-test0[ip];
             // // double err=xmid-test0[ip];
             // // int err=j_node-test[ip];
             // if(abs(err)>1e-3){
             //     // printf("\nip %d j_node %d simd %d err %d \n",ip,j_node,test[ip],err);
             //     // printf("\nip %d xmid %lf simd %lf err %lf \n",ip,xmid,test0[ip],err);
             //     printf("\nip %d sz_node %lf simd %lf err %lf \n",ip,wqx*sz_node[0],test0[ip],err);
             // }
 
             // Deposit current into jx_arr, jy_arr and jz_arr
         
             for (int iz=0; iz<=depos_order; iz++){
                 for (int iy=0; iy<=depos_order; iy++){
                     for (int ix=0; ix<=depos_order; ix++){
                         amrex::Gpu::Atomic::AddNoRet(
                             &jx_arr(lo.x+j_jx+ix, lo.y+k_jx+iy, lo.z+l_jx+iz),
                             sx_jx[ix]*sy_jx[iy]*sz_jx[iz]*wqx);
                         // if(iz==0 && iy==0 && ix==0){
                         //     int idx = ix+iy*2+iz*4;
                         //     double err=sx_jx[ix]*sy_jx[iy]*sz_jx[iz]*wqx-test[ip];
                         //     // double err=jx_arr(lo.x+j_jx+ix, lo.y+k_jx+iy, lo.z+l_jx+iz)-test[ip];
                         //     if(err>1e-3){
                         //         // printf("ip %d org %lf sve %lf err %lf \n", ip, 
                         //         //     jx_arr(lo.x+j_jx+ix, lo.y+k_jx+iy, lo.z+l_jx+iz),test[ip],err);
                         //         printf("ip %d org %lf sve %lf err %lf \n",
                         //             ip,sx_jx[ix]*sy_jx[iy]*sz_jx[iz]*wqx,test[ip],err);
                         //     }
                         // }
                         // int idx = ix+iy*2+iz*4;
                         // double err=sx_jx[ix]*sy_jx[iy]*sz_jx[iz]*wqx-test0[8*ip+idx];
                         // if(err>1e-3){
                         //     // printf("ip %d org %lf sve %lf err %lf \n", ip, 
                         //     //     jx_arr(lo.x+j_jx+ix, lo.y+k_jx+iy, lo.z+l_jx+iz),test[ip],err);
                         //     printf("ip %d org %lf sve %lf err %lf \n",
                         //         8*ip+idx,sx_jx[ix]*sy_jx[iy]*sz_jx[iz]*wqx,test0[idx],err);
                         // }
                         // if(iz==0){
                         //     int idx = ix+iy*2;
                         //     double err=sx_jx[ix]*sy_jx[iy]-test0[4*ip+idx];
                         //     if(err>1e-3){
                         //         // printf("ip %d org %lf sve %lf err %lf \n", ip, 
                         //         //     jx_arr(lo.x+j_jx+ix, lo.y+k_jx+iy, lo.z+l_jx+iz),test[ip],err);
                         //         printf("ip %d org %lf sve %lf err %lf \n",
                         //             4*ip+idx,sx_jx[ix]*sy_jx[iy],test0[4*ip+idx],err);
                         //     }
                         // }
                         amrex::Gpu::Atomic::AddNoRet(
                             &jy_arr(lo.x+j_jy+ix, lo.y+k_jy+iy, lo.z+l_jy+iz),
                             sx_jy[ix]*sy_jy[iy]*sz_jy[iz]*wqy);
                         amrex::Gpu::Atomic::AddNoRet(
                             &jz_arr(lo.x+j_jz+ix, lo.y+k_jz+iy, lo.z+l_jz+iz),
                             sx_jz[ix]*sy_jz[iy]*sz_jz[iz]*wqz);
                     }
                 }
             }
 
         }
     );
     long nx=len.x;
     long nxy=len.x*len.y;
     long moff[8] = {0, 1, nx, nx+1, nxy, nxy+1, nx+nxy, nx+nxy+1};
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int xjstride1 = jx_arr1.jstride;
     const int xkstride1 = jx_arr1.kstride;
     // const int yjstride = jy_arr.jstride;
     // const int ykstride = jy_arr.kstride;
     // const int zjstride = jz_arr.jstride;
     // const int zkstride = jz_arr.kstride;
     int errcount=0;
     // printf("\n");
     // for(int idx=0;idx<108;idx++){
     //     long j = lo.x + idx;
     //     long k = lo.y +12;
     //     long l = lo.z ;
     //     long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
 
     //     printf("%lf \n",jx_arr.p[jxoffset]);
     // }
     // amrex::Abort("xrhocells ERROR!");
     for (int iz = 0; iz <= len.z; ++iz) {
         for (int iy = 0; iy <= len.y; ++iy) { 
             for (int ix = 0; ix <= len.x; ++ix) {
                 long j = lo.x + ix;
                 long k = lo.y + iy;
                 long l = lo.z + iz;
                 long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                 long jxoffset1 = j - jx_arr1.begin.x + (k - jx_arr1.begin.y) * xjstride1 + (l - jx_arr1.begin.z) * xkstride1;
                 // long xoffset = ix + iy * xjstride + iz * xkstride;
                 // for(int idx=0;idx<8;idx++){+moff[idx]
                     double jxorg=jx_arr.p[jxoffset];
                     double jxsve=jx_arr1.p[jxoffset1];
                     double err=jxsve-jxorg;
                     if(abs(err)>1){
                     // if(1){
                     // if(jxorg>1e-2){
                         // printf("jxoffset %ld jxoffset1 %ld \n",jxoffset+moff[idx],jxoffset1+moff[idx]);
                         printf("111 ix %d iy %d iz %d: jxorg %lf jxsve %lf ERR %lf \n",
                             ix,  iy,   iz,       jxorg,    jxsve,   err );
                         errcount++;
                         if(errcount>30){
                             printf("%d %d %d %d \n",len.x,len.y,len.z,jx_fab.box().numPts());
                             amrex::Abort("222 ERROR 10 ! jxorg and jxsve");
                         }
                     }
                 // }
                 // amrex::Abort("ERROR! jxorg and jxsve");
             }
         }
     }
 
 }
 
 
 // only valid for tilesize 1 1 1
 template <int depos_order>
 void doDepositionShapeN_sve_sort2 (const GetParticlePosition<PIdx>& GetPosition,
                          const amrex::ParticleReal * const wp,
                          const amrex::ParticleReal * const uxp,
                          const amrex::ParticleReal * const uyp,
                          const amrex::ParticleReal * const uzp,
                          const int* ion_lev,
                          amrex::FArrayBox& jx_fab,
                          amrex::FArrayBox& jy_fab,
                          amrex::FArrayBox& jz_fab,
                          long np_to_deposit,
                          amrex::Real relative_time,
                          const amrex::XDim3 & dinv,
                          const amrex::XDim3 & xyzmin,
                          amrex::Dim3 lo,
                          amrex::Dim3 hi,
                          amrex::Dim3 len,
                          amrex::Real q,
                          [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     uint64_t total_time[3]={0};
     uint64_t precompute=0;
     uint64_t cale_time=0;
     uint64_t reduce_time=0;
     uint64_t svetime[2]={0};
     using namespace amrex::literals;
     total_time[0]=rdtscv();
 
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z; 
 
     const amrex::Real clightsq = 1.0_rt/PhysConst::c/PhysConst::c;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
 
     
     const int block_size=256;
     long n_blocks=np_to_deposit/block_size;
     int vl=svcntd();
 
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
 
     auto compute_shape_factor_v2 = [](double* sx[], int xmid, svbool_t p) {
         intVec i_newv(xmid);
         // Vec j = svrintz_x(p, xmid);
         Vec j = svcvt_f64_s64_z(p, i_newv);
         Vec xint = xmid - j;
         // Vec temp = 1.0 - xint;
         Vec sx0 = 1.0 - xint;
         Vec sx1 = xint;
         sx0.Store(p, sx[0]);
         sx1.Store(p, sx[1]);
         // i_newv=svcvt_s64_x(p,j);
         // svst1(p, i_new, i_newv);
         // return i_newv;
     };
 
     // 预计算网格步长
     const int xjstride = jx_arr.jstride;
     const int xkstride = jx_arr.kstride;
     const int yjstride = jy_arr.jstride;
     const int ykstride = jy_arr.kstride;
     const int zjstride = jz_arr.jstride;
     const int zkstride = jz_arr.kstride;
 
     const long numcell = jx_fab.box().numPts();
 
     auto xrhocells = std::make_unique<double[]>(8*numcell);
     auto yrhocells = std::make_unique<double[]>(8*numcell);
     auto zrhocells = std::make_unique<double[]>(8*numcell);
     // one roll x
     uint64_t rmx[8] = {0,1,0,1,0,1,0,1};
     uint64_t rmy[8] = {0,0,1,1,0,0,1,1};
     uint64_t rmz[8] = {0,0,0,0,1,1,1,1};
     long nx=len.x;
     long nxy=len.x*len.y;
     long moff[8] = {0, 1, nx, nx+1, nxy, nxy+1, nx+nxy, nx+nxy+1};
     svuint64_t rmx_v = svld1_u64(svptrue_b64(), rmx);
     svbool_t px = svcmpne_n_u64(svptrue_b64(), rmx_v, 0);
     svuint64_t rmy_v = svld1_u64(svptrue_b64(), rmy);
     svbool_t py = svcmpne_n_u64(svptrue_b64(), rmy_v, 0);
     svuint64_t rmz_v = svld1_u64(svptrue_b64(), rmz);
     svbool_t pz = svcmpne_n_u64(svptrue_b64(), rmz_v, 0);
 
     // #pragma omp parallel for
     // for(int block_id=0;block_id<n_blocks;block_id++){
         constexpr int nshapes = depos_order + 1;
         std::vector<amrex::Real> wqx(np_to_deposit, 0.0);
         std::vector<amrex::Real> wqy(np_to_deposit, 0.0);
         std::vector<amrex::Real> wqz(np_to_deposit, 0.0);
         std::vector<std::vector<amrex::Real>> sx_m(nshapes,std::vector<amrex::Real>(np_to_deposit));
         std::vector<std::vector<amrex::Real>> sy_m(nshapes,std::vector<amrex::Real>(np_to_deposit));
         std::vector<std::vector<amrex::Real>> sz_m(nshapes,std::vector<amrex::Real>(np_to_deposit));
         // double sx_m[nshapes][np_to_deposit] = {0.};
         // double sy_m[nshapes][np_to_deposit] = {0.};
         // double sz_m[nshapes][np_to_deposit] = {0.};
 
         alignas(64) long xoffsets[np_to_deposit];
         alignas(64) long yoffsets[np_to_deposit];
         alignas(64) long zoffsets[np_to_deposit];
 
         
         amrex::Real gaminv0 = 1.0_rt/std::sqrt(1.0_rt + uxp[0]*uxp[0]*clightsq
             + uyp[0]*uyp[0]*clightsq
             + uzp[0]*uzp[0]*clightsq);
         amrex::Real vx  = uxp[0]*gaminv0;
         amrex::Real vy  = uyp[0]*gaminv0;
         amrex::Real vz  = uzp[0]*gaminv0;
         amrex::Real xmid0 = ((mx[0] - xyzmin.x) + relative_time * vx) * dinv.x - 0.5;
         amrex::Real ymid0 = ((my[0] - xyzmin.y) + relative_time * vy) * dinv.y - 0.5;
         amrex::Real zmid0 = ((mz[0] - xyzmin.z) + relative_time * vz) * dinv.z - 0.5;
         int xmid= static_cast<int>(xmid0);
         int ymid= static_cast<int>(ymid0);
         int zmid= static_cast<int>(zmid0);
 
         for(long ip=0;ip<np_to_deposit;ip+=vl){
             svetime[0]=rdtscv();
 
             // long ip=iip+block_id*block_size;
             // 计算基本物理量
             svbool_t p_ip=svwhilele_b64(ip,np_to_deposit);
             // Inverse of Lorentz factor gamma
             Vec uxp_v=Vec::Load(p_ip,&uxp[ip]);
             Vec uyp_v=Vec::Load(p_ip,&uyp[ip]);
             Vec uzp_v=Vec::Load(p_ip,&uzp[ip]);
             Vec gaminv = 1._rt / (1._rt + uxp_v * uxp_v * clightsq
                                         + uyp_v * uyp_v * clightsq
                                         + uzp_v * uzp_v * clightsq).Sqrt();
             // Product of particle charges and weights
             Vec wp_v=Vec::Load(p_ip,&wp[ip]);
             Vec wq_v = q * wp_v;
 
             // Current particle positions (in physical units)
             Vec xp = Vec::Load(p_ip, &mx[ip]);
             Vec yp = Vec::Load(p_ip, &my[ip]);
             Vec zp = Vec::Load(p_ip, &mz[ip]);
 
             // Particle velocities
             Vec vx_v = uxp_v * gaminv;
             Vec vy_v = uyp_v * gaminv;
             Vec vz_v = uzp_v * gaminv;
 
             // if (do_ionization) wq *= ion_lev[ip];
             Vec wqx_v = wq_v * invvol * vx_v;
             Vec wqy_v = wq_v * invvol * vy_v;
             Vec wqz_v = wq_v * invvol * vz_v;
 
             wqx_v.Store(p_ip, &wqx[ip]);
             wqy_v.Store(p_ip, &wqy[ip]);
             wqz_v.Store(p_ip, &wqz[ip]);
 
             // Vec xmid = ((xp - xyzmin.x) + relative_time * vx_v) * dinv.x - 0.5;
             // Vec ymid = ((yp - xyzmin.y) + relative_time * vy_v) * dinv.y - 0.5;
             // Vec zmid = ((zp - xyzmin.z) + relative_time * vz_v) * dinv.z - 0.5;
 
             double* sx_temp[nshapes] = {&sx_m[0][ip], &sx_m[1][ip]};
             compute_shape_factor_v2( sx_temp, xmid, p_ip);
             double* sy_temp[nshapes] = {&sy_m[0][ip], &sy_m[1][ip]};
             compute_shape_factor_v2( sy_temp, ymid, p_ip);
             double* sz_temp[nshapes] = {&sz_m[0][ip], &sz_m[1][ip]};
             compute_shape_factor_v2( sz_temp, zmid, p_ip);
 
             // intVec xoffsets_v = j_cellv + (k_cellv) * xjstride + (l_cellv) * xkstride;
             // intVec yoffsets_v = j_cellv + (k_cellv) * yjstride + (l_cellv) * ykstride;
             // intVec zoffsets_v = j_cellv + (k_cellv) * zjstride + (l_cellv) * zkstride;
             // xoffsets_v.Store(p_ip,&xoffsets[iip]);
             // yoffsets_v.Store(p_ip,&yoffsets[iip]);
             // zoffsets_v.Store(p_ip,&zoffsets[iip]);
             svetime[1]=rdtscv();
             precompute+=(svetime[1]-svetime[0]);
             
         } 
         
         int partnum=16*8*8;
         svbool_t p_ip = svptrue_b64();
         // long xoffset = xoffsets[iip];
         Vec wwx = Vec::Load(p_ip,&xrhocells[0]);
         // long yoffset = yoffsets[iip];
         Vec wwy = Vec::Load(p_ip,&yrhocells[0]);
         // long zoffset = zoffsets[iip];
         Vec wwz = Vec::Load(p_ip,&zrhocells[0]);
         for (long ip = 0; ip < np_to_deposit; ip++) {
             svetime[0]=rdtscv();
             // svbool_t px=svcmpne(svptrue_b64(),);
             // svbool_t p_ip = svptrue_b64();
                      
 
             // for(int ipar=0;ipar<partnum;ipar++){
                 // int iip_p=iip+ipar;
                 Vec sx0=Vec(sx_m[0][ip]);
                 Vec sx1=Vec(sx_m[1][ip]);
                 Vec sxv=svsel_f64(px,sx0,sx1);
                 Vec sy0=Vec(sy_m[0][ip]);
                 Vec sy1=Vec(sy_m[1][ip]);
                 Vec syv=svsel_f64(py,sy0,sy1);
                 Vec sz0=Vec(sz_m[0][ip]);
                 Vec sz1=Vec(sz_m[1][ip]);
                 Vec szv=svsel_f64(pz,sz0,sz1);
                 // printf("Error 2! \n");
                 Vec s = sxv*syv*szv;
                 Vec jx_v=s*wqx[ip];
                 wwx+=jx_v;                
                 Vec jy_v=s*wqy[ip];
                 wwy+=jy_v;              
                 Vec jz_v=s*wqz[ip];
                 wwz+=jz_v;
             // }
 
             // long xoffset = xoffsets[iip];
             // Vec wwx = Vec::Load(p_ip,&xrhocells[xoffset]);
             // jx_v+=wwx;
             // printf("iip:%d, numPts: %ld, offsetx: %ld \n",iip, numcell, xoffset);
             wwx.Store(p_ip,&xrhocells[0]);
 
             // long yoffset = yoffsets[iip];
             // Vec wwy = Vec::Load(p_ip,&yrhocells[yoffset]);
             // jy_v+=wwy;
             wwy.Store(p_ip,&yrhocells[0]);
 
             // long zoffset = zoffsets[iip];
             // Vec wwz = Vec::Load(p_ip,&zrhocells[zoffset]);
             // jz_v+=wwz;
             wwz.Store(p_ip,&zrhocells[0]);
             svetime[1]=rdtscv();
             cale_time+=(svetime[1]-svetime[0]);
         }
         // amrex::Abort("stop test!");
     // }                     
     // TODO: reduction needs  to modify out of this func
     // ix iy iz in numcell
     // this can be SME
     for (int iz = 0; iz <= len.z; ++iz) {
         for (int iy = 0; iy <= len.y; ++iy) { 
             for (int ix = 0; ix <= len.x; ix+=vl) {
                 // scalar mode
                 // long j = lo.x + ix;
                 // long k = lo.y + iy;
                 // long l = lo.z + iz;
                 // long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                 // long xoffset = ix + iy * xjstride + iz * xkstride;
                 // jx_arr.p[jxoffset+moff[0]]+=xrhocells[0+xoffset];
                 // jx_arr.p[jxoffset+moff[1]]+=xrhocells[1+xoffset];
                 // jx_arr.p[jxoffset+moff[2]]+=xrhocells[2+xoffset];
                 // jx_arr.p[jxoffset+moff[3]]+=xrhocells[3+xoffset];
                 // jx_arr.p[jxoffset+moff[4]]+=xrhocells[4+xoffset];
                 // jx_arr.p[jxoffset+moff[5]]+=xrhocells[5+xoffset];
                 // jx_arr.p[jxoffset+moff[6]]+=xrhocells[6+xoffset];
                 // jx_arr.p[jxoffset+moff[7]]+=xrhocells[7+xoffset];
                 svetime[0]=rdtscv();
 
                 // vector
                 svbool_t p=svwhilele_b64(ix,len.x);
                 long j = lo.x + ix;
                 long k = lo.y + iy;
                 long l = lo.z + iz;
                 // x
                 uint64_t irhox = ix + iy * xjstride + iz * xkstride;
                 svuint64_t rhox_index = svindex_u64(irhox, 8ULL);
                 long jxoffset = j - jx_arr.begin.x + (k - jx_arr.begin.y) * xjstride + (l - jx_arr.begin.z) * xkstride;
                 Vec jx0=Vec::Load(p,&jx_arr.p[jxoffset+moff[0]]);
                 svfloat64_t rhox0=svld1_gather_u64index_f64(p,&xrhocells[0+irhox],rhox_index);
                 jx0+=rhox0;
                 jx0.Store(p,&jx_arr.p[jxoffset+moff[0]]);
 
                 Vec jx1=Vec::Load(p,&jx_arr.p[jxoffset+moff[1]]);
                 svfloat64_t rhox1=svld1_gather_u64index_f64(p,&xrhocells[1+irhox],rhox_index);
                 jx1+=rhox1;
                 jx1.Store(p,&jx_arr.p[jxoffset+moff[1]]);
 
                 Vec jx2=Vec::Load(p,&jx_arr.p[jxoffset+moff[2]]);
                 svfloat64_t rhox2=svld1_gather_u64index_f64(p,&xrhocells[2+irhox],rhox_index);
                 jx2+=rhox2;
                 jx2.Store(p,&jx_arr.p[jxoffset+moff[2]]);
 
                 Vec jx3=Vec::Load(p,&jx_arr.p[jxoffset+moff[3]]);
                 svfloat64_t rhox3=svld1_gather_u64index_f64(p,&xrhocells[3+irhox],rhox_index);
                 jx3+=rhox3;
                 jx3.Store(p,&jx_arr.p[jxoffset+moff[3]]);
 
                 Vec jx4=Vec::Load(p,&jx_arr.p[jxoffset+moff[4]]);
                 svfloat64_t rhox4=svld1_gather_u64index_f64(p,&xrhocells[4+irhox],rhox_index);
                 jx4+=rhox4;
                 jx4.Store(p,&jx_arr.p[jxoffset+moff[4]]);
 
                 Vec jx5=Vec::Load(p,&jx_arr.p[jxoffset+moff[5]]);
                 svfloat64_t rhox5=svld1_gather_u64index_f64(p,&xrhocells[5+irhox],rhox_index);
                 jx5+=rhox5;
                 jx5.Store(p,&jx_arr.p[jxoffset+moff[5]]);
 
                 Vec jx6=Vec::Load(p,&jx_arr.p[jxoffset+moff[6]]);
                 svfloat64_t rhox6=svld1_gather_u64index_f64(p,&xrhocells[6+irhox],rhox_index);
                 jx6+=rhox6;
                 jx6.Store(p,&jx_arr.p[jxoffset+moff[6]]);
 
                 Vec jx7=Vec::Load(p,&jx_arr.p[jxoffset+moff[7]]);
                 svfloat64_t rhox7=svld1_gather_u64index_f64(p,&xrhocells[7+irhox],rhox_index);
                 jx7+=rhox7;
                 jx7.Store(p,&jx_arr.p[jxoffset+moff[7]]);
                 
                 // y
                 uint64_t irhoy = ix + iy * yjstride + iz * ykstride;
                 svuint64_t rhoy_index = svindex_u64(irhoy, 8ULL);
                 long jyoffset = j - jy_arr.begin.x + (k - jy_arr.begin.y) * yjstride + (l - jy_arr.begin.z) * ykstride;
                 Vec jy0=Vec::Load(p,&jy_arr.p[jyoffset+moff[0]]);
                 svfloat64_t rhoy0=svld1_gather_u64index_f64(p,&yrhocells[0+irhoy],rhoy_index);
                 jy0+=rhoy0;
                 jy0.Store(p,&jy_arr.p[jyoffset+moff[0]]);
 
                 Vec jy1=Vec::Load(p,&jy_arr.p[jyoffset+moff[1]]);
                 svfloat64_t rhoy1=svld1_gather_u64index_f64(p,&yrhocells[1+irhoy],rhoy_index);
                 jy1+=rhoy1;
                 jy1.Store(p,&jy_arr.p[jyoffset+moff[1]]);
 
                 Vec jy2=Vec::Load(p,&jy_arr.p[jyoffset+moff[2]]);
                 svfloat64_t rhoy2=svld1_gather_u64index_f64(p,&yrhocells[2+irhoy],rhoy_index);
                 jy2+=rhoy2;
                 jy2.Store(p,&jy_arr.p[jyoffset+moff[2]]);
 
                 Vec jy3=Vec::Load(p,&jy_arr.p[jyoffset+moff[3]]);
                 svfloat64_t rhoy3=svld1_gather_u64index_f64(p,&yrhocells[3+irhoy],rhoy_index);
                 jy3+=rhoy3;
                 jy3.Store(p,&jy_arr.p[jyoffset+moff[3]]);
 
                 Vec jy4=Vec::Load(p,&jy_arr.p[jyoffset+moff[4]]);
                 svfloat64_t rhoy4=svld1_gather_u64index_f64(p,&yrhocells[4+irhoy],rhoy_index);
                 jy4+=rhoy4;
                 jy4.Store(p,&jy_arr.p[jyoffset+moff[4]]);
 
                 Vec jy5=Vec::Load(p,&jy_arr.p[jyoffset+moff[5]]);
                 svfloat64_t rhoy5=svld1_gather_u64index_f64(p,&yrhocells[5+irhoy],rhoy_index);
                 jy5+=rhoy5;
                 jy5.Store(p,&jy_arr.p[jyoffset+moff[5]]);
 
                 Vec jy6=Vec::Load(p,&jy_arr.p[jyoffset+moff[6]]);
                 svfloat64_t rhoy6=svld1_gather_u64index_f64(p,&yrhocells[6+irhoy],rhoy_index);
                 jy6+=rhoy6;
                 jy6.Store(p,&jy_arr.p[jyoffset+moff[6]]);
 
                 Vec jy7=Vec::Load(p,&jy_arr.p[jyoffset+moff[7]]);
                 svfloat64_t rhoy7=svld1_gather_u64index_f64(p,&yrhocells[7+irhoy],rhoy_index);
                 jy7+=rhoy7;
                 jy7.Store(p,&jy_arr.p[jyoffset+moff[7]]);
 
                 // z
                 uint64_t irhoz = ix + iy * zjstride + iz * zkstride;
                 svuint64_t rhoz_index = svindex_u64(irhoz, 8ULL);
                 long jzoffset = j - jz_arr.begin.x + (k - jz_arr.begin.y) * zjstride + (l - jz_arr.begin.z) * zkstride;
                 Vec jz0=Vec::Load(p,&jz_arr.p[jzoffset+moff[0]]);
                 svfloat64_t rhoz0=svld1_gather_u64index_f64(p,&zrhocells[0+irhoz],rhoz_index);
                 jz0+=rhoz0;
                 jz0.Store(p,&jz_arr.p[jzoffset+moff[0]]);
 
                 Vec jz1=Vec::Load(p,&jz_arr.p[jzoffset+moff[1]]);
                 svfloat64_t rhoz1=svld1_gather_u64index_f64(p,&zrhocells[1+irhoz],rhoz_index);
                 jz1+=rhoz1;
                 jz1.Store(p,&jz_arr.p[jzoffset+moff[1]]);
 
                 Vec jz2=Vec::Load(p,&jz_arr.p[jzoffset+moff[2]]);
                 svfloat64_t rhoz2=svld1_gather_u64index_f64(p,&zrhocells[2+irhoz],rhoz_index);
                 jz2+=rhoz2;
                 jz2.Store(p,&jz_arr.p[jzoffset+moff[2]]);
 
                 Vec jz3=Vec::Load(p,&jz_arr.p[jzoffset+moff[3]]);
                 svfloat64_t rhoz3=svld1_gather_u64index_f64(p,&zrhocells[3+irhoz],rhoz_index);
                 jz3+=rhoz3;
                 jz3.Store(p,&jz_arr.p[jzoffset+moff[3]]);
 
                 Vec jz4=Vec::Load(p,&jz_arr.p[jzoffset+moff[4]]);
                 svfloat64_t rhoz4=svld1_gather_u64index_f64(p,&zrhocells[4+irhoz],rhoz_index);
                 jz4+=rhoz4;
                 jz4.Store(p,&jz_arr.p[jzoffset+moff[4]]);
 
                 Vec jz5=Vec::Load(p,&jz_arr.p[jzoffset+moff[5]]);
                 svfloat64_t rhoz5=svld1_gather_u64index_f64(p,&zrhocells[5+irhoz],rhoz_index);
                 jz5+=rhoz5;
                 jz5.Store(p,&jz_arr.p[jzoffset+moff[5]]);
 
                 Vec jz6=Vec::Load(p,&jz_arr.p[jzoffset+moff[6]]);
                 svfloat64_t rhoz6=svld1_gather_u64index_f64(p,&zrhocells[6+irhoz],rhoz_index);
                 jz6+=rhoz6;
                 jz6.Store(p,&jz_arr.p[jzoffset+moff[6]]);
 
                 Vec jz7=Vec::Load(p,&jz_arr.p[jzoffset+moff[7]]);
                 svfloat64_t rhoz7=svld1_gather_u64index_f64(p,&zrhocells[7+irhoz],rhoz_index);
                 jz7+=rhoz7;
                 jz7.Store(p,&jz_arr.p[jzoffset+moff[7]]);
 
                 svetime[1]=rdtscv();
                 reduce_time+=(svetime[1]-svetime[0]);
             }
         }
     }
     total_time[1]=rdtscv();
     total_time[2]=(total_time[1]-total_time[0]);
     printf("total time: %d, precompute: %d, cale_time: %d, reduce_time: %d \n",
             total_time,     precompute,     cale_time,     reduce_time);
 
 }
 
 /**
  * \brief Direct current deposition for thread thread_num for the implicit scheme
  *        The only difference from doDepositionShapeN is in how the particle gamma
  *        is calculated.
  * \tparam depos_order deposition order
  * \param GetPosition  A functor for returning the particle position.
  * \param wp           Pointer to array of particle weights.
  * \param uxp_n,uyp_n,uzp_n  Pointer to arrays of particle momentum at time n.
  * \param uxp,uyp,uzp  Pointer to arrays of particle momentum at time n+1/2.
  * \param ion_lev      Pointer to array of particle ionization level. This is
                          required to have the charge of each macroparticle
                          since q is a scalar. For non-ionizable species,
                          ion_lev is a null pointer.
  * \param jx_fab,jy_fab,jz_fab FArrayBox of current density, either full array or tile.
  * \param np_to_deposit Number of particles for which current is deposited.
  * \param dinv         3D cell size inverse
  * \param xyzmin       Physical lower bounds of domain.
  * \param lo           Index lower bounds of domain.
  * \param q            species charge.
  * \param n_rz_azimuthal_modes Number of azimuthal modes when using RZ geometry.
  */
 template <int depos_order>
 void doDepositionShapeNImplicit(const GetParticlePosition<PIdx>& GetPosition,
                                 const amrex::ParticleReal * const wp,
                                 const amrex::ParticleReal * const uxp_n,
                                 const amrex::ParticleReal * const uyp_n,
                                 const amrex::ParticleReal * const uzp_n,
                                 const amrex::ParticleReal * const uxp,
                                 const amrex::ParticleReal * const uyp,
                                 const amrex::ParticleReal * const uzp,
                                 const int * const ion_lev,
                                 amrex::FArrayBox& jx_fab,
                                 amrex::FArrayBox& jy_fab,
                                 amrex::FArrayBox& jz_fab,
                                 const long np_to_deposit,
                                 const amrex::XDim3 & dinv,
                                 const amrex::XDim3 & xyzmin,
                                 const amrex::Dim3 lo,
                                 const amrex::Real q,
                                 [[maybe_unused]]const int n_rz_azimuthal_modes)
 {
     using namespace amrex::literals;
 
     // Whether ion_lev is a null pointer (do_ionization=0) or a real pointer
     // (do_ionization=1)
     const bool do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z;
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
     amrex::IntVect const jx_type = jx_fab.box().type();
     amrex::IntVect const jy_type = jy_fab.box().type();
     amrex::IntVect const jz_type = jz_fab.box().type();
 
     // Loop over particles and deposit into jx_fab, jy_fab and jz_fab
     amrex::ParallelFor(
             np_to_deposit,
             [=] AMREX_GPU_DEVICE (long ip) {
             amrex::ParticleReal xp, yp, zp;
             GetPosition(ip, xp, yp, zp);
 
             constexpr amrex::ParticleReal inv_c2 = 1._prt/(PhysConst::c*PhysConst::c);
 
             // Compute inverse Lorentz factor, the average of gamma at time levels n and n+1
             // The uxp,uyp,uzp are the velocities at time level n+1/2
             const amrex::ParticleReal uxp_np1 = 2._prt*uxp[ip] - uxp_n[ip];
             const amrex::ParticleReal uyp_np1 = 2._prt*uyp[ip] - uyp_n[ip];
             const amrex::ParticleReal uzp_np1 = 2._prt*uzp[ip] - uzp_n[ip];
             const amrex::ParticleReal gamma_n = std::sqrt(1._prt + (uxp_n[ip]*uxp_n[ip] + uyp_n[ip]*uyp_n[ip] + uzp_n[ip]*uzp_n[ip])*inv_c2);
             const amrex::ParticleReal gamma_np1 = std::sqrt(1._prt + (uxp_np1*uxp_np1 + uyp_np1*uyp_np1 + uzp_np1*uzp_np1)*inv_c2);
             const amrex::ParticleReal gaminv = 2.0_prt/(gamma_n + gamma_np1);
 
             const amrex::Real vx  = uxp[ip]*gaminv;
             const amrex::Real vy  = uyp[ip]*gaminv;
             const amrex::Real vz  = uzp[ip]*gaminv;
 
             amrex::Real wq  = q*wp[ip];
             if (do_ionization){
                 wq *= ion_lev[ip];
             }
 
             const amrex::Real relative_time = 0._rt;
             doDepositionShapeNKernel<depos_order>(xp, yp, zp, wq, vx, vy, vz, jx_arr, jy_arr, jz_arr,
                                                   jx_type, jy_type, jz_type,
                                                   relative_time, dinv, xyzmin,
                                                   invvol, lo, n_rz_azimuthal_modes);
 
         }
     );
 }
 
 /**
  * \brief Current Deposition for thread thread_num using shared memory
  * \tparam depos_order deposition order
  * \param GetPosition  A functor for returning the particle position.
  * \param wp           Pointer to array of particle weights.
  * \param uxp,uyp,uzp  Pointer to arrays of particle momentum.
  * \param ion_lev      Pointer to array of particle ionization level. This is
                          required to have the charge of each macroparticle
                          since q is a scalar. For non-ionizable species,
                          ion_lev is a null pointer.
  * \param jx_fab,jy_fab,jz_fab FArrayBox of current density, either full array or tile.
  * \param np_to_deposit Number of particles for which current is deposited.
  * \param dt           Time step for particle level
  * \param relative_time Time at which to deposit J, relative to the time of the
  *                      current positions of the particles. When different than 0,
  *                      the particle position will be temporarily modified to match
  *                      the time of the deposition.
  * \param dinv         3D cell size inverse
  * \param xyzmin       Physical lower bounds of domain.
  * \param lo           Index lower bounds of domain.
  * \param q            species charge.
  * \param n_rz_azimuthal_modes Number of azimuthal modes when using RZ geometry.
  */
 template <int depos_order>
 void doDepositionSharedShapeN (const GetParticlePosition<PIdx>& GetPosition,
                                const amrex::ParticleReal * const wp,
                                const amrex::ParticleReal * const uxp,
                                const amrex::ParticleReal * const uyp,
                                const amrex::ParticleReal * const uzp,
                                const int*  ion_lev,
                                amrex::FArrayBox& jx_fab,
                                amrex::FArrayBox& jy_fab,
                                amrex::FArrayBox& jz_fab,
                                long np_to_deposit,
                                const amrex::Real relative_time,
                                const amrex::XDim3 & dinv,
                                const amrex::XDim3 & xyzmin,
                                amrex::Dim3 lo,
                                amrex::Real q,
                                int n_rz_azimuthal_modes,
                                const amrex::DenseBins<WarpXParticleContainer::ParticleTileType::ParticleTileDataType>& a_bins,
                                const amrex::Box& box,
                                const amrex::Geometry& geom,
                                const amrex::IntVect& a_tbox_max_size)
 {
     using namespace amrex::literals;
 
 #if defined(AMREX_USE_HIP) || defined(AMREX_USE_CUDA)
     using namespace amrex;
 
     auto permutation = a_bins.permutationPtr();
 
     amrex::Array4<amrex::Real> const& jx_arr = jx_fab.array();
     amrex::Array4<amrex::Real> const& jy_arr = jy_fab.array();
     amrex::Array4<amrex::Real> const& jz_arr = jz_fab.array();
     amrex::IntVect const jx_type = jx_fab.box().type();
     amrex::IntVect const jy_type = jy_fab.box().type();
     amrex::IntVect const jz_type = jz_fab.box().type();
 
     constexpr int zdir = WARPX_ZINDEX;
     constexpr int NODE = amrex::IndexType::NODE;
     constexpr int CELL = amrex::IndexType::CELL;
 
     // Loop over particles and deposit into jx_fab, jy_fab and jz_fab
     const auto dxiarr = geom.InvCellSizeArray();
     const auto plo = geom.ProbLoArray();
     const auto domain = geom.Domain();
 
     amrex::Box sample_tbox(IntVect(AMREX_D_DECL(0,0,0)), a_tbox_max_size - 1);
     sample_tbox.grow(depos_order);
 
     amrex::Box sample_tbox_x = convert(sample_tbox, jx_type);
     amrex::Box sample_tbox_y = convert(sample_tbox, jy_type);
     amrex::Box sample_tbox_z = convert(sample_tbox, jz_type);
 
     const auto npts = amrex::max(sample_tbox_x.numPts(), sample_tbox_y.numPts(), sample_tbox_z.numPts());
 
     const int nblocks = a_bins.numBins();
     const int threads_per_block = WarpX::shared_mem_current_tpb;
     const auto offsets_ptr = a_bins.offsetsPtr();
 
     const std::size_t shared_mem_bytes = npts*sizeof(amrex::Real);
     const amrex::IntVect bin_size = WarpX::shared_tilesize;
     const std::size_t max_shared_mem_bytes = amrex::Gpu::Device::sharedMemPerBlock();
     WARPX_ALWAYS_ASSERT_WITH_MESSAGE(shared_mem_bytes <= max_shared_mem_bytes,
                                      "Tile size too big for GPU shared memory current deposition");
 
     amrex::ignore_unused(np_to_deposit);
     // Launch one thread-block per bin
     amrex::launch(
             nblocks, threads_per_block, shared_mem_bytes, amrex::Gpu::gpuStream(),
             [=] AMREX_GPU_DEVICE () noexcept {
         const int bin_id = blockIdx.x;
         const unsigned int bin_start = offsets_ptr[bin_id];
         const unsigned int bin_stop = offsets_ptr[bin_id+1];
 
         if (bin_start == bin_stop) { return; /*this bin has no particles*/ }
 
         // These boxes define the index space for the shared memory buffers
         amrex::Box buffer_box;
         {
             ParticleReal xp, yp, zp;
             GetPosition(permutation[bin_start], xp, yp, zp);
 #if defined(WARPX_DIM_3D)
             IntVect iv = IntVect(int( amrex::Math::floor((xp-plo[0]) * dxiarr[0]) ),
                                  int( amrex::Math::floor((yp-plo[1]) * dxiarr[1]) ),
                                  int( amrex::Math::floor((zp-plo[2]) * dxiarr[2]) ));
 #elif defined(WARPX_DIM_XZ) || defined(WARPX_DIM_RZ)
             IntVect iv = IntVect(int( amrex::Math::floor((xp-plo[0]) * dxiarr[0]) ),
                                  int( amrex::Math::floor((zp-plo[1]) * dxiarr[1]) ));
 #elif defined(WARPX_DIM_1D_Z)
             IntVect iv = IntVect(int( amrex::Math::floor((zp-plo[0]) * dxiarr[0]) ));
 #endif
             iv += domain.smallEnd();
             getTileIndex(iv, box, true, bin_size, buffer_box);
         }
 
         buffer_box.grow(depos_order);
         Box tbox_x = convert(buffer_box, jx_type);
         Box tbox_y = convert(buffer_box, jy_type);
         Box tbox_z = convert(buffer_box, jz_type);
 
         Gpu::SharedMemory<amrex::Real> gsm;
         amrex::Real* const shared = gsm.dataPtr();
 
         amrex::Array4<amrex::Real> const jx_buff(shared,
                 amrex::begin(tbox_x), amrex::end(tbox_x), 1);
         amrex::Array4<amrex::Real> const jy_buff(shared,
                 amrex::begin(tbox_y), amrex::end(tbox_y), 1);
         amrex::Array4<amrex::Real> const jz_buff(shared,
                 amrex::begin(tbox_z), amrex::end(tbox_z), 1);
 
         // Zero-initialize the temporary array in shared memory
         volatile amrex::Real* vs = shared;
         for (int i = threadIdx.x; i < npts; i += blockDim.x){
             vs[i] = 0.0;
         }
         __syncthreads();
         for (unsigned int ip_orig = bin_start+threadIdx.x; ip_orig<bin_stop; ip_orig += blockDim.x)
         {
             const unsigned int ip = permutation[ip_orig];
             depositComponent<depos_order>(GetPosition, wp, uxp, uyp, uzp, ion_lev, jx_buff, jx_type,
                                           relative_time, dinv, xyzmin, lo, q, n_rz_azimuthal_modes,
                                           ip, zdir, NODE, CELL, 0);
         }
 
         __syncthreads();
         addLocalToGlobal(tbox_x, jx_arr, jx_buff);
         for (int i = threadIdx.x; i < npts; i += blockDim.x){
             vs[i] = 0.0;
         }
 
         __syncthreads();
         for (unsigned int ip_orig = bin_start+threadIdx.x; ip_orig<bin_stop; ip_orig += blockDim.x)
         {
             const unsigned int ip = permutation[ip_orig];
             depositComponent<depos_order>(GetPosition, wp, uxp, uyp, uzp, ion_lev, jy_buff, jy_type,
                                           relative_time, dinv, xyzmin, lo, q, n_rz_azimuthal_modes,
                                           ip, zdir, NODE, CELL, 1);
         }
 
         __syncthreads();
         addLocalToGlobal(tbox_y, jy_arr, jy_buff);
         for (int i = threadIdx.x; i < npts; i += blockDim.x){
             vs[i] = 0.0;
         }
 
         __syncthreads();
         for (unsigned int ip_orig = bin_start+threadIdx.x; ip_orig<bin_stop; ip_orig += blockDim.x)
         {
             const unsigned int ip = permutation[ip_orig];
             depositComponent<depos_order>(GetPosition, wp, uxp, uyp, uzp, ion_lev, jz_buff, jz_type,
                                           relative_time, dinv, xyzmin, lo, q, n_rz_azimuthal_modes,
                                           ip, zdir, NODE, CELL, 2);
         }
 
         __syncthreads();
         addLocalToGlobal(tbox_z, jz_arr, jz_buff);
     });
 #else // not using hip/cuda
     // Note, you should never reach this part of the code. This funcion cannot be called unless
     // using HIP/CUDA, and those things are checked prior
     //don't use any args
     ignore_unused(GetPosition, wp, uxp, uyp, uzp, ion_lev, jx_fab, jy_fab, jz_fab, np_to_deposit, relative_time, dinv, xyzmin, lo, q, n_rz_azimuthal_modes, a_bins, box, geom, a_tbox_max_size);
     WARPX_ABORT_WITH_MESSAGE("Shared memory only implemented for HIP/CUDA");
 #endif
 }
 
 /**
  * \brief Esirkepov Current Deposition for thread thread_num
  *
  * \tparam depos_order  deposition order
  * \param GetPosition  A functor for returning the particle position.
  * \param wp           Pointer to array of particle weights.
  * \param uxp,uyp,uzp  Pointer to arrays of particle momentum.
  * \param ion_lev      Pointer to array of particle ionization level. This is
                        required to have the charge of each macroparticle
                        since q is a scalar. For non-ionizable species,
                        ion_lev is a null pointer.
  * \param Jx_arr,Jy_arr,Jz_arr Array4 of current density, either full array or tile.
  * \param np_to_deposit Number of particles for which current is deposited.
  * \param dt           Time step for particle level
  * \param[in] relative_time Time at which to deposit J, relative to the time of the
  *                          current positions of the particles. When different than 0,
  *                          the particle position will be temporarily modified to match
  *                          the time of the deposition.
  * \param dinv         3D cell size inverse
  * \param xyzmin       Physical lower bounds of domain.
  * \param lo           Index lower bounds of domain.
  * \param q            species charge.
  * \param n_rz_azimuthal_modes Number of azimuthal modes when using RZ geometry.
  */
 template <int depos_order>
 void doEsirkepovDepositionShapeN (const GetParticlePosition<PIdx>& GetPosition,
                                   const amrex::ParticleReal * const wp,
                                   const amrex::ParticleReal * const uxp,
                                   const amrex::ParticleReal * const uyp,
                                   const amrex::ParticleReal * const uzp,
                                   const int* ion_lev,
                                   const amrex::Array4<amrex::Real>& Jx_arr,
                                   const amrex::Array4<amrex::Real>& Jy_arr,
                                   const amrex::Array4<amrex::Real>& Jz_arr,
                                   long np_to_deposit,
                                   amrex::Real dt,
                                   amrex::Real relative_time,
                                   const amrex::XDim3 & dinv,
                                   const amrex::XDim3 & xyzmin,
                                   amrex::Dim3 lo,
                                   amrex::Real q,
                                   [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     using namespace amrex;
     using namespace amrex::literals;
 
     // Whether ion_lev is a null pointer (do_ionization=0) or a real pointer
     // (do_ionization=1)
     bool const do_ionization = ion_lev;
 #if !defined(WARPX_DIM_3D)
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z;
 #endif
 
     amrex::XDim3 const invdtd = amrex::XDim3{(1.0_rt/dt)*dinv.y*dinv.z,
                                              (1.0_rt/dt)*dinv.x*dinv.z,
                                              (1.0_rt/dt)*dinv.x*dinv.y};
 
     Real constexpr clightsq = 1.0_rt / ( PhysConst::c * PhysConst::c );
 
 #if !defined(WARPX_DIM_1D_Z)
     Real constexpr one_third = 1.0_rt / 3.0_rt;
     Real constexpr one_sixth = 1.0_rt / 6.0_rt;
 #endif
 
     // Loop over particles and deposit into Jx_arr, Jy_arr and Jz_arr
     amrex::ParallelFor(
         np_to_deposit,
         [=] AMREX_GPU_DEVICE (long const ip) {
             // --- Get particle quantities
             Real const gaminv = 1.0_rt/std::sqrt(1.0_rt + uxp[ip]*uxp[ip]*clightsq
                                                  + uyp[ip]*uyp[ip]*clightsq
                                                  + uzp[ip]*uzp[ip]*clightsq);
 
             Real wq = q*wp[ip];
             if (do_ionization){
                 wq *= ion_lev[ip];
             }
 
             ParticleReal xp, yp, zp;
             GetPosition(ip, xp, yp, zp);
 
             // computes current and old position in grid units
 #if defined(WARPX_DIM_RZ)
             Real const xp_new = xp + (relative_time + 0.5_rt*dt)*uxp[ip]*gaminv;
             Real const yp_new = yp + (relative_time + 0.5_rt*dt)*uyp[ip]*gaminv;
             Real const xp_mid = xp_new - 0.5_rt*dt*uxp[ip]*gaminv;
             Real const yp_mid = yp_new - 0.5_rt*dt*uyp[ip]*gaminv;
             Real const xp_old = xp_new - dt*uxp[ip]*gaminv;
             Real const yp_old = yp_new - dt*uyp[ip]*gaminv;
             Real const rp_new = std::sqrt(xp_new*xp_new + yp_new*yp_new);
             Real const rp_mid = std::sqrt(xp_mid*xp_mid + yp_mid*yp_mid);
             Real const rp_old = std::sqrt(xp_old*xp_old + yp_old*yp_old);
             const amrex::Real costheta_mid = (rp_mid > 0._rt ? xp_mid/rp_mid : 1._rt);
             const amrex::Real sintheta_mid = (rp_mid > 0._rt ? yp_mid/rp_mid : 0._rt);
             const amrex::Real costheta_new = (rp_new > 0._rt ? xp_new/rp_new : 1._rt);
             const amrex::Real sintheta_new = (rp_new > 0._rt ? yp_new/rp_new : 0._rt);
             const amrex::Real costheta_old = (rp_old > 0._rt ? xp_old/rp_old : 1._rt);
             const amrex::Real sintheta_old = (rp_old > 0._rt ? yp_old/rp_old : 0._rt);
             const Complex xy_new0 = Complex{costheta_new, sintheta_new};
             const Complex xy_mid0 = Complex{costheta_mid, sintheta_mid};
             const Complex xy_old0 = Complex{costheta_old, sintheta_old};
             // Keep these double to avoid bug in single precision
             double const x_new = (rp_new - xyzmin.x)*dinv.x;
             double const x_old = (rp_old - xyzmin.x)*dinv.x;
 #else
 #if !defined(WARPX_DIM_1D_Z)
             // Keep these double to avoid bug in single precision
             double const x_new = (xp - xyzmin.x + (relative_time + 0.5_rt*dt)*uxp[ip]*gaminv)*dinv.x;
             double const x_old = x_new - dt*dinv.x*uxp[ip]*gaminv;
 #endif
 #endif
 #if defined(WARPX_DIM_3D)
             // Keep these double to avoid bug in single precision
             double const y_new = (yp - xyzmin.y + (relative_time + 0.5_rt*dt)*uyp[ip]*gaminv)*dinv.y;
             double const y_old = y_new - dt*dinv.y*uyp[ip]*gaminv;
 #endif
             // Keep these double to avoid bug in single precision
             double const z_new = (zp - xyzmin.z + (relative_time + 0.5_rt*dt)*uzp[ip]*gaminv)*dinv.z;
             double const z_old = z_new - dt*dinv.z*uzp[ip]*gaminv;
 
 #if defined(WARPX_DIM_RZ)
             Real const vy = (-uxp[ip]*sintheta_mid + uyp[ip]*costheta_mid)*gaminv;
 #elif defined(WARPX_DIM_XZ)
             Real const vy = uyp[ip]*gaminv;
 #elif defined(WARPX_DIM_1D_Z)
             Real const vx = uxp[ip]*gaminv;
             Real const vy = uyp[ip]*gaminv;
 #endif
 
             // --- Compute shape factors
             // Compute shape factors for position as they are now and at old positions
             // [ijk]_new: leftmost grid point that the particle touches
             const Compute_shape_factor< depos_order > compute_shape_factor;
             const Compute_shifted_shape_factor< depos_order > compute_shifted_shape_factor;
 
             // Shape factor arrays
             // Note that there are extra values above and below
             // to possibly hold the factor for the old particle
             // which can be at a different grid location.
             // Keep these double to avoid bug in single precision
 #if !defined(WARPX_DIM_1D_Z)
             double sx_new[depos_order + 3] = {0.};
             double sx_old[depos_order + 3] = {0.};
             const int i_new = compute_shape_factor(sx_new+1, x_new);
             const int i_old = compute_shifted_shape_factor(sx_old, x_old, i_new);
 #endif
 #if defined(WARPX_DIM_3D)
             double sy_new[depos_order + 3] = {0.};
             double sy_old[depos_order + 3] = {0.};
             const int j_new = compute_shape_factor(sy_new+1, y_new);
             const int j_old = compute_shifted_shape_factor(sy_old, y_old, j_new);
 #endif
             double sz_new[depos_order + 3] = {0.};
             double sz_old[depos_order + 3] = {0.};
             const int k_new = compute_shape_factor(sz_new+1, z_new);
             const int k_old = compute_shifted_shape_factor(sz_old, z_old, k_new);
 
             // computes min/max positions of current contributions
 #if !defined(WARPX_DIM_1D_Z)
             int dil = 1, diu = 1;
             if (i_old < i_new) { dil = 0; }
             if (i_old > i_new) { diu = 0; }
 #endif
 #if defined(WARPX_DIM_3D)
             int djl = 1, dju = 1;
             if (j_old < j_new) { djl = 0; }
             if (j_old > j_new) { dju = 0; }
 #endif
             int dkl = 1, dku = 1;
             if (k_old < k_new) { dkl = 0; }
             if (k_old > k_new) { dku = 0; }
 
 #if defined(WARPX_DIM_3D)
 
             for (int k=dkl; k<=depos_order+2-dku; k++) {
                 for (int j=djl; j<=depos_order+2-dju; j++) {
                     amrex::Real sdxi = 0._rt;
                     for (int i=dil; i<=depos_order+1-diu; i++) {
                         sdxi += wq*invdtd.x*(sx_old[i] - sx_new[i])*(
                             one_third*(sy_new[j]*sz_new[k] + sy_old[j]*sz_old[k])
                            +one_sixth*(sy_new[j]*sz_old[k] + sy_old[j]*sz_new[k]));
                         amrex::Gpu::Atomic::AddNoRet( &Jx_arr(lo.x+i_new-1+i, lo.y+j_new-1+j, lo.z+k_new-1+k), sdxi);
                     }
                 }
             }
             for (int k=dkl; k<=depos_order+2-dku; k++) {
                 for (int i=dil; i<=depos_order+2-diu; i++) {
                     amrex::Real sdyj = 0._rt;
                     for (int j=djl; j<=depos_order+1-dju; j++) {
                         sdyj += wq*invdtd.y*(sy_old[j] - sy_new[j])*(
                             one_third*(sx_new[i]*sz_new[k] + sx_old[i]*sz_old[k])
                            +one_sixth*(sx_new[i]*sz_old[k] + sx_old[i]*sz_new[k]));
                         amrex::Gpu::Atomic::AddNoRet( &Jy_arr(lo.x+i_new-1+i, lo.y+j_new-1+j, lo.z+k_new-1+k), sdyj);
                     }
                 }
             }
             for (int j=djl; j<=depos_order+2-dju; j++) {
                 for (int i=dil; i<=depos_order+2-diu; i++) {
                     amrex::Real sdzk = 0._rt;
                     for (int k=dkl; k<=depos_order+1-dku; k++) {
                         sdzk += wq*invdtd.z*(sz_old[k] - sz_new[k])*(
                             one_third*(sx_new[i]*sy_new[j] + sx_old[i]*sy_old[j])
                            +one_sixth*(sx_new[i]*sy_old[j] + sx_old[i]*sy_new[j]));
                         amrex::Gpu::Atomic::AddNoRet( &Jz_arr(lo.x+i_new-1+i, lo.y+j_new-1+j, lo.z+k_new-1+k), sdzk);
                     }
                 }
             }
 
 #elif defined(WARPX_DIM_XZ) || defined(WARPX_DIM_RZ)
 
             for (int k=dkl; k<=depos_order+2-dku; k++) {
                 amrex::Real sdxi = 0._rt;
                 for (int i=dil; i<=depos_order+1-diu; i++) {
                     sdxi += wq*invdtd.x*(sx_old[i] - sx_new[i])*0.5_rt*(sz_new[k] + sz_old[k]);
                     amrex::Gpu::Atomic::AddNoRet( &Jx_arr(lo.x+i_new-1+i, lo.y+k_new-1+k, 0, 0), sdxi);
 #if defined(WARPX_DIM_RZ)
                     Complex xy_mid = xy_mid0; // Throughout the following loop, xy_mid takes the value e^{i m theta}
                     for (int imode=1 ; imode < n_rz_azimuthal_modes ; imode++) {
                         // The factor 2 comes from the normalization of the modes
                         const Complex djr_cmplx = 2._rt *sdxi*xy_mid;
                         amrex::Gpu::Atomic::AddNoRet( &Jx_arr(lo.x+i_new-1+i, lo.y+k_new-1+k, 0, 2*imode-1), djr_cmplx.real());
                         amrex::Gpu::Atomic::AddNoRet( &Jx_arr(lo.x+i_new-1+i, lo.y+k_new-1+k, 0, 2*imode), djr_cmplx.imag());
                         xy_mid = xy_mid*xy_mid0;
                     }
 #endif
                 }
             }
             for (int k=dkl; k<=depos_order+2-dku; k++) {
                 for (int i=dil; i<=depos_order+2-diu; i++) {
                     Real const sdyj = wq*vy*invvol*(
                         one_third*(sx_new[i]*sz_new[k] + sx_old[i]*sz_old[k])
                        +one_sixth*(sx_new[i]*sz_old[k] + sx_old[i]*sz_new[k]));
                     amrex::Gpu::Atomic::AddNoRet( &Jy_arr(lo.x+i_new-1+i, lo.y+k_new-1+k, 0, 0), sdyj);
 #if defined(WARPX_DIM_RZ)
                     Complex const I = Complex{0._rt, 1._rt};
                     Complex xy_new = xy_new0;
                     Complex xy_mid = xy_mid0;
                     Complex xy_old = xy_old0;
                     // Throughout the following loop, xy_ takes the value e^{i m theta_}
                     for (int imode=1 ; imode < n_rz_azimuthal_modes ; imode++) {
                         // The factor 2 comes from the normalization of the modes
                         // The minus sign comes from the different convention with respect to Davidson et al.
                         const Complex djt_cmplx = -2._rt * I*(i_new-1 + i + xyzmin.x*dinv.x)*wq*invdtd.x/(amrex::Real)imode
                                                   *(Complex(sx_new[i]*sz_new[k], 0._rt)*(xy_new - xy_mid)
                                                   + Complex(sx_old[i]*sz_old[k], 0._rt)*(xy_mid - xy_old));
                         amrex::Gpu::Atomic::AddNoRet( &Jy_arr(lo.x+i_new-1+i, lo.y+k_new-1+k, 0, 2*imode-1), djt_cmplx.real());
                         amrex::Gpu::Atomic::AddNoRet( &Jy_arr(lo.x+i_new-1+i, lo.y+k_new-1+k, 0, 2*imode), djt_cmplx.imag());
                         xy_new = xy_new*xy_new0;
                         xy_mid = xy_mid*xy_mid0;
                         xy_old = xy_old*xy_old0;
                     }
 #endif
                 }
             }
             for (int i=dil; i<=depos_order+2-diu; i++) {
                 Real sdzk = 0._rt;
                 for (int k=dkl; k<=depos_order+1-dku; k++) {
                     sdzk += wq*invdtd.z*(sz_old[k] - sz_new[k])*0.5_rt*(sx_new[i] + sx_old[i]);
                     amrex::Gpu::Atomic::AddNoRet( &Jz_arr(lo.x+i_new-1+i, lo.y+k_new-1+k, 0, 0), sdzk);
 #if defined(WARPX_DIM_RZ)
                     Complex xy_mid = xy_mid0; // Throughout the following loop, xy_mid takes the value e^{i m theta}
                     for (int imode=1 ; imode < n_rz_azimuthal_modes ; imode++) {
                         // The factor 2 comes from the normalization of the modes
                         const Complex djz_cmplx = 2._rt * sdzk * xy_mid;
                         amrex::Gpu::Atomic::AddNoRet( &Jz_arr(lo.x+i_new-1+i, lo.y+k_new-1+k, 0, 2*imode-1), djz_cmplx.real());
                         amrex::Gpu::Atomic::AddNoRet( &Jz_arr(lo.x+i_new-1+i, lo.y+k_new-1+k, 0, 2*imode), djz_cmplx.imag());
                         xy_mid = xy_mid*xy_mid0;
                     }
 #endif
                 }
             }
 #elif defined(WARPX_DIM_1D_Z)
 
             for (int k=dkl; k<=depos_order+2-dku; k++) {
                 amrex::Real const sdxi = wq*vx*invvol*0.5_rt*(sz_old[k] + sz_new[k]);
                 amrex::Gpu::Atomic::AddNoRet( &Jx_arr(lo.x+k_new-1+k, 0, 0, 0), sdxi);
             }
             for (int k=dkl; k<=depos_order+2-dku; k++) {
                 amrex::Real const sdyj = wq*vy*invvol*0.5_rt*(sz_old[k] + sz_new[k]);
                 amrex::Gpu::Atomic::AddNoRet( &Jy_arr(lo.x+k_new-1+k, 0, 0, 0), sdyj);
             }
             amrex::Real sdzk = 0._rt;
             for (int k=dkl; k<=depos_order+1-dku; k++) {
                 sdzk += wq*invdtd.z*(sz_old[k] - sz_new[k]);
                 amrex::Gpu::Atomic::AddNoRet( &Jz_arr(lo.x+k_new-1+k, 0, 0, 0), sdzk);
             }
 #endif
         }
     );
 }
 
 /**
  * \brief Esirkepov Current Deposition for thread thread_num for implicit scheme
  *        The difference from doEsirkepovDepositionShapeN is in how the old and new
  *        particles positions are determined and in how the particle gamma is calculated.
  *
  * \tparam depos_order  deposition order
  * \param xp_n,yp_n,zp_n  Pointer to arrays of particle position at time level n.
  * \param GetPosition  A functor for returning the particle position.
  * \param wp           Pointer to array of particle weights.
  * \param uxp_n,uyp_n,uzp_n  Pointer to arrays of particle momentum at time level n.
  * \param uxp_nph,uyp_nph,uzp_nph  Pointer to arrays of particle momentum at time level n + 1/2.
  * \param ion_lev      Pointer to array of particle ionization level. This is
                        required to have the charge of each macroparticle
                        since q is a scalar. For non-ionizable species,
                        ion_lev is a null pointer.
  * \param Jx_arr,Jy_arr,Jz_arr Array4 of current density, either full array or tile.
  * \param np_to_deposit Number of particles for which current is deposited.
  * \param dt           Time step for particle level
  * \param dinv         3D cell size inverse
  * \param xyzmin       Physical lower bounds of domain.
  * \param lo           Index lower bounds of domain.
  * \param q            species charge.
  * \param n_rz_azimuthal_modes Number of azimuthal modes when using RZ geometry.
  */
 template <int depos_order>
 void doChargeConservingDepositionShapeNImplicit ([[maybe_unused]]const amrex::ParticleReal * const xp_n,
                                                  [[maybe_unused]]const amrex::ParticleReal * const yp_n,
                                                  [[maybe_unused]]const amrex::ParticleReal * const zp_n,
                                                  const GetParticlePosition<PIdx>& GetPosition,
                                                  const amrex::ParticleReal * const wp,
                                                  [[maybe_unused]]const amrex::ParticleReal * const uxp_n,
                                                  [[maybe_unused]]const amrex::ParticleReal * const uyp_n,
                                                  [[maybe_unused]]const amrex::ParticleReal * const uzp_n,
                                                  [[maybe_unused]]const amrex::ParticleReal * const uxp_nph,
                                                  [[maybe_unused]]const amrex::ParticleReal * const uyp_nph,
                                                  [[maybe_unused]]const amrex::ParticleReal * const uzp_nph,
                                                  const int * const ion_lev,
                                                  const amrex::Array4<amrex::Real>& Jx_arr,
                                                  const amrex::Array4<amrex::Real>& Jy_arr,
                                                  const amrex::Array4<amrex::Real>& Jz_arr,
                                                  const long np_to_deposit,
                                                  const amrex::Real dt,
                                                  const amrex::XDim3 & dinv,
                                                  const amrex::XDim3 & xyzmin,
                                                  const amrex::Dim3 lo,
                                                  const amrex::Real q,
                                                  [[maybe_unused]] const int n_rz_azimuthal_modes)
 {
     using namespace amrex;
 
     // Whether ion_lev is a null pointer (do_ionization=0) or a real pointer
     // (do_ionization=1)
     bool const do_ionization = ion_lev;
 
 #if !defined(WARPX_DIM_3D)
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z;
 #endif
 
     amrex::XDim3 const invdtd = amrex::XDim3{(1.0_rt/dt)*dinv.y*dinv.z,
                                              (1.0_rt/dt)*dinv.x*dinv.z,
                                              (1.0_rt/dt)*dinv.x*dinv.y};
 
 #if !defined(WARPX_DIM_1D_Z)
     Real constexpr one_third = 1.0_rt / 3.0_rt;
     Real constexpr one_sixth = 1.0_rt / 6.0_rt;
 #endif
 
     // Loop over particles and deposit into Jx_arr, Jy_arr and Jz_arr
     amrex::ParallelFor(
         np_to_deposit,
         [=] AMREX_GPU_DEVICE (long const ip) {
 #if !defined(WARPX_DIM_3D)
             constexpr amrex::ParticleReal inv_c2 = 1._prt/(PhysConst::c*PhysConst::c);
 
             // Compute inverse Lorentz factor, the average of gamma at time levels n and n+1
             // The uxp,uyp,uzp are the velocities at time level n+1/2
             const amrex::ParticleReal uxp_np1 = 2._prt*uxp_nph[ip] - uxp_n[ip];
             const amrex::ParticleReal uyp_np1 = 2._prt*uyp_nph[ip] - uyp_n[ip];
             const amrex::ParticleReal uzp_np1 = 2._prt*uzp_nph[ip] - uzp_n[ip];
             const amrex::ParticleReal gamma_n = std::sqrt(1._prt + (uxp_n[ip]*uxp_n[ip] + uyp_n[ip]*uyp_n[ip] + uzp_n[ip]*uzp_n[ip])*inv_c2);
             const amrex::ParticleReal gamma_np1 = std::sqrt(1._prt + (uxp_np1*uxp_np1 + uyp_np1*uyp_np1 + uzp_np1*uzp_np1)*inv_c2);
             const amrex::ParticleReal gaminv = 2.0_prt/(gamma_n + gamma_np1);
 #endif
 
             Real wq = q*wp[ip];
             if (do_ionization){
                 wq *= ion_lev[ip];
             }
 
             ParticleReal xp_nph, yp_nph, zp_nph;
             GetPosition(ip, xp_nph, yp_nph, zp_nph);
 
 #if !defined(WARPX_DIM_1D_Z)
             ParticleReal const xp_np1 = 2._prt*xp_nph - xp_n[ip];
 #endif
 #if defined(WARPX_DIM_3D) || defined(WARPX_DIM_RZ)
             ParticleReal const yp_np1 = 2._prt*yp_nph - yp_n[ip];
 #endif
             ParticleReal const zp_np1 = 2._prt*zp_nph - zp_n[ip];
 
             // computes current and old position in grid units
 #if defined(WARPX_DIM_RZ)
             amrex::Real const xp_new = xp_np1;
             amrex::Real const yp_new = yp_np1;
             amrex::Real const xp_mid = xp_nph;
             amrex::Real const yp_mid = yp_nph;
             amrex::Real const xp_old = xp_n[ip];
             amrex::Real const yp_old = yp_n[ip];
             amrex::Real const rp_new = std::sqrt(xp_new*xp_new + yp_new*yp_new);
             amrex::Real const rp_old = std::sqrt(xp_old*xp_old + yp_old*yp_old);
             amrex::Real const rp_mid = (rp_new + rp_old)/2._rt;
             const amrex::Real costheta_mid = (rp_mid > 0._rt ? xp_mid/rp_mid : 1._rt);
             const amrex::Real sintheta_mid = (rp_mid > 0._rt ? yp_mid/rp_mid : 0._rt);
             const amrex::Real costheta_new = (rp_new > 0._rt ? xp_new/rp_new : 1._rt);
             const amrex::Real sintheta_new = (rp_new > 0._rt ? yp_new/rp_new : 0._rt);
             const amrex::Real costheta_old = (rp_old > 0._rt ? xp_old/rp_old : 1._rt);
             const amrex::Real sintheta_old = (rp_old > 0._rt ? yp_old/rp_old : 0._rt);
             const Complex xy_new0 = Complex{costheta_new, sintheta_new};
             const Complex xy_mid0 = Complex{costheta_mid, sintheta_mid};
             const Complex xy_old0 = Complex{costheta_old, sintheta_old};
             // Keep these double to avoid bug in single precision
             double const x_new = (rp_new - xyzmin.x)*dinv.x;
             double const x_old = (rp_old - xyzmin.x)*dinv.x;
 #else
 #if !defined(WARPX_DIM_1D_Z)
             // Keep these double to avoid bug in single precision
             double const x_new = (xp_np1 - xyzmin.x)*dinv.x;
             double const x_old = (xp_n[ip] - xyzmin.x)*dinv.x;
 #endif
 #endif
 #if defined(WARPX_DIM_3D)
             // Keep these double to avoid bug in single precision
             double const y_new = (yp_np1 - xyzmin.y)*dinv.y;
             double const y_old = (yp_n[ip] - xyzmin.y)*dinv.y;
 #endif
             // Keep these double to avoid bug in single precision
             double const z_new = (zp_np1 - xyzmin.z)*dinv.z;
             double const z_old = (zp_n[ip] - xyzmin.z)*dinv.z;
 
 #if defined(WARPX_DIM_RZ)
             amrex::Real const vy = (-uxp_nph[ip]*sintheta_mid + uyp_nph[ip]*costheta_mid)*gaminv;
 #elif defined(WARPX_DIM_XZ)
             amrex::Real const vy = uyp_nph[ip]*gaminv;
 #elif defined(WARPX_DIM_1D_Z)
             amrex::Real const vx = uxp_nph[ip]*gaminv;
             amrex::Real const vy = uyp_nph[ip]*gaminv;
 #endif
 
             // --- Compute shape factors
             // Compute shape factors for position as they are now and at old positions
             // [ijk]_new: leftmost grid point that the particle touches
             const Compute_shape_factor< depos_order > compute_shape_factor;
             const Compute_shifted_shape_factor< depos_order > compute_shifted_shape_factor;
 
             // Shape factor arrays
             // Note that there are extra values above and below
             // to possibly hold the factor for the old particle
             // which can be at a different grid location.
             // Keep these double to avoid bug in single precision
 #if !defined(WARPX_DIM_1D_Z)
             double sx_new[depos_order + 3] = {0.};
             double sx_old[depos_order + 3] = {0.};
             const int i_new = compute_shape_factor(sx_new+1, x_new);
             const int i_old = compute_shifted_shape_factor(sx_old, x_old, i_new);
 #endif
 #if defined(WARPX_DIM_3D)
             double sy_new[depos_order + 3] = {0.};
             double sy_old[depos_order + 3] = {0.};
             const int j_new = compute_shape_factor(sy_new+1, y_new);
             const int j_old = compute_shifted_shape_factor(sy_old, y_old, j_new);
 #endif
             double sz_new[depos_order + 3] = {0.};
             double sz_old[depos_order + 3] = {0.};
             const int k_new = compute_shape_factor(sz_new+1, z_new);
             const int k_old = compute_shifted_shape_factor(sz_old, z_old, k_new);
 
             // computes min/max positions of current contributions
 #if !defined(WARPX_DIM_1D_Z)
             int dil = 1, diu = 1;
             if (i_old < i_new) { dil = 0; }
             if (i_old > i_new) { diu = 0; }
 #endif
 #if defined(WARPX_DIM_3D)
             int djl = 1, dju = 1;
             if (j_old < j_new) { djl = 0; }
             if (j_old > j_new) { dju = 0; }
 #endif
             int dkl = 1, dku = 1;
             if (k_old < k_new) { dkl = 0; }
             if (k_old > k_new) { dku = 0; }
 
 #if defined(WARPX_DIM_3D)
 
             for (int k=dkl; k<=depos_order+2-dku; k++) {
                 for (int j=djl; j<=depos_order+2-dju; j++) {
                     amrex::Real sdxi = 0._rt;
                     for (int i=dil; i<=depos_order+1-diu; i++) {
                         sdxi += wq*invdtd.x*(sx_old[i] - sx_new[i])*(
                             one_third*(sy_new[j]*sz_new[k] + sy_old[j]*sz_old[k])
                            +one_sixth*(sy_new[j]*sz_old[k] + sy_old[j]*sz_new[k]));
                         amrex::Gpu::Atomic::AddNoRet( &Jx_arr(lo.x+i_new-1+i, lo.y+j_new-1+j, lo.z+k_new-1+k), sdxi);
                     }
                 }
             }
             for (int k=dkl; k<=depos_order+2-dku; k++) {
                 for (int i=dil; i<=depos_order+2-diu; i++) {
                     amrex::Real sdyj = 0._rt;
                     for (int j=djl; j<=depos_order+1-dju; j++) {
                         sdyj += wq*invdtd.y*(sy_old[j] - sy_new[j])*(
                             one_third*(sx_new[i]*sz_new[k] + sx_old[i]*sz_old[k])
                            +one_sixth*(sx_new[i]*sz_old[k] + sx_old[i]*sz_new[k]));
                         amrex::Gpu::Atomic::AddNoRet( &Jy_arr(lo.x+i_new-1+i, lo.y+j_new-1+j, lo.z+k_new-1+k), sdyj);
                     }
                 }
             }
             for (int j=djl; j<=depos_order+2-dju; j++) {
                 for (int i=dil; i<=depos_order+2-diu; i++) {
                     amrex::Real sdzk = 0._rt;
                     for (int k=dkl; k<=depos_order+1-dku; k++) {
                         sdzk += wq*invdtd.z*(sz_old[k] - sz_new[k])*(
                             one_third*(sx_new[i]*sy_new[j] + sx_old[i]*sy_old[j])
                            +one_sixth*(sx_new[i]*sy_old[j] + sx_old[i]*sy_new[j]));
                         amrex::Gpu::Atomic::AddNoRet( &Jz_arr(lo.x+i_new-1+i, lo.y+j_new-1+j, lo.z+k_new-1+k), sdzk);
                     }
                 }
             }
 
 #elif defined(WARPX_DIM_XZ) || defined(WARPX_DIM_RZ)
 
             for (int k=dkl; k<=depos_order+2-dku; k++) {
                 amrex::Real sdxi = 0._rt;
                 for (int i=dil; i<=depos_order+1-diu; i++) {
                     sdxi += wq*invdtd.x*(sx_old[i] - sx_new[i])*0.5_rt*(sz_new[k] + sz_old[k]);
                     amrex::Gpu::Atomic::AddNoRet( &Jx_arr(lo.x+i_new-1+i, lo.y+k_new-1+k, 0, 0), sdxi);
 #if defined(WARPX_DIM_RZ)
                     Complex xy_mid = xy_mid0; // Throughout the following loop, xy_mid takes the value e^{i m theta}
                     for (int imode=1 ; imode < n_rz_azimuthal_modes ; imode++) {
                         // The factor 2 comes from the normalization of the modes
                         const Complex djr_cmplx = 2._rt *sdxi*xy_mid;
                         amrex::Gpu::Atomic::AddNoRet( &Jx_arr(lo.x+i_new-1+i, lo.y+k_new-1+k, 0, 2*imode-1), djr_cmplx.real());
                         amrex::Gpu::Atomic::AddNoRet( &Jx_arr(lo.x+i_new-1+i, lo.y+k_new-1+k, 0, 2*imode), djr_cmplx.imag());
                         xy_mid = xy_mid*xy_mid0;
                     }
 #endif
                 }
             }
             for (int k=dkl; k<=depos_order+2-dku; k++) {
                 for (int i=dil; i<=depos_order+2-diu; i++) {
                     Real const sdyj = wq*vy*invvol*(
                         one_third*(sx_new[i]*sz_new[k] + sx_old[i]*sz_old[k])
                        +one_sixth*(sx_new[i]*sz_old[k] + sx_old[i]*sz_new[k]));
                     amrex::Gpu::Atomic::AddNoRet( &Jy_arr(lo.x+i_new-1+i, lo.y+k_new-1+k, 0, 0), sdyj);
 #if defined(WARPX_DIM_RZ)
                     Complex const I = Complex{0._rt, 1._rt};
                     Complex xy_new = xy_new0;
                     Complex xy_mid = xy_mid0;
                     Complex xy_old = xy_old0;
                     // Throughout the following loop, xy_ takes the value e^{i m theta_}
                     for (int imode=1 ; imode < n_rz_azimuthal_modes ; imode++) {
                         // The factor 2 comes from the normalization of the modes
                         // The minus sign comes from the different convention with respect to Davidson et al.
                         const Complex djt_cmplx = -2._rt * I*(i_new-1 + i + xyzmin.x*dinv.x)*wq*invdtd.x/(amrex::Real)imode
                                                   *(Complex(sx_new[i]*sz_new[k], 0._rt)*(xy_new - xy_mid)
                                                   + Complex(sx_old[i]*sz_old[k], 0._rt)*(xy_mid - xy_old));
                         amrex::Gpu::Atomic::AddNoRet( &Jy_arr(lo.x+i_new-1+i, lo.y+k_new-1+k, 0, 2*imode-1), djt_cmplx.real());
                         amrex::Gpu::Atomic::AddNoRet( &Jy_arr(lo.x+i_new-1+i, lo.y+k_new-1+k, 0, 2*imode), djt_cmplx.imag());
                         xy_new = xy_new*xy_new0;
                         xy_mid = xy_mid*xy_mid0;
                         xy_old = xy_old*xy_old0;
                     }
 #endif
                 }
             }
             for (int i=dil; i<=depos_order+2-diu; i++) {
                 Real sdzk = 0._rt;
                 for (int k=dkl; k<=depos_order+1-dku; k++) {
                     sdzk += wq*invdtd.z*(sz_old[k] - sz_new[k])*0.5_rt*(sx_new[i] + sx_old[i]);
                     amrex::Gpu::Atomic::AddNoRet( &Jz_arr(lo.x+i_new-1+i, lo.y+k_new-1+k, 0, 0), sdzk);
 #if defined(WARPX_DIM_RZ)
                     Complex xy_mid = xy_mid0; // Throughout the following loop, xy_mid takes the value e^{i m theta}
                     for (int imode=1 ; imode < n_rz_azimuthal_modes ; imode++) {
                         // The factor 2 comes from the normalization of the modes
                         const Complex djz_cmplx = 2._rt * sdzk * xy_mid;
                         amrex::Gpu::Atomic::AddNoRet( &Jz_arr(lo.x+i_new-1+i, lo.y+k_new-1+k, 0, 2*imode-1), djz_cmplx.real());
                         amrex::Gpu::Atomic::AddNoRet( &Jz_arr(lo.x+i_new-1+i, lo.y+k_new-1+k, 0, 2*imode), djz_cmplx.imag());
                         xy_mid = xy_mid*xy_mid0;
                     }
 #endif
                 }
             }
 #elif defined(WARPX_DIM_1D_Z)
 
             for (int k=dkl; k<=depos_order+2-dku; k++) {
                 amrex::Real const sdxi = wq*vx*invvol*0.5_rt*(sz_old[k] + sz_new[k]);
                 amrex::Gpu::Atomic::AddNoRet( &Jx_arr(lo.x+k_new-1+k, 0, 0, 0), sdxi);
             }
             for (int k=dkl; k<=depos_order+2-dku; k++) {
                 amrex::Real const sdyj = wq*vy*invvol*0.5_rt*(sz_old[k] + sz_new[k]);
                 amrex::Gpu::Atomic::AddNoRet( &Jy_arr(lo.x+k_new-1+k, 0, 0, 0), sdyj);
             }
             amrex::Real sdzk = 0._rt;
             for (int k=dkl; k<=depos_order+1-dku; k++) {
                 sdzk += wq*invdtd.z*(sz_old[k] - sz_new[k]);
                 amrex::Gpu::Atomic::AddNoRet( &Jz_arr(lo.x+k_new-1+k, 0, 0, 0), sdzk);
             }
 #endif
         }
     );
 }
 
 /**
  * \brief Villasenor and Buneman Current Deposition for thread thread_num for implicit scheme.
  *        The specifics for the implicit scheme are in how gamma is determined. This is a charge-
  *        conserving deposition. The difference from Esirkepov is that the deposit is done segment
  *        by segment, where the segments are determined by cell crossings. In general, this results
  *        in a tighter stencil. The implementation is valid for an arbitrary number of cell crossings.
  *
  * \param depos_order  deposition order
  * \param xp_n,yp_n,zp_n  Pointer to arrays of particle position at time level n.
  * \param GetPosition  A functor for returning the particle position.
  * \param wp           Pointer to array of particle weights.
  * \param uxp_n,uyp_n,uzp_n  Pointer to arrays of particle momentum at time level n.
  * \param uxp_nph,uyp_nph,uzp_nph  Pointer to arrays of particle momentum at time level n + 1/2.
  * \param ion_lev      Pointer to array of particle ionization level. This is
                        required to have the charge of each macroparticle
                        since q is a scalar. For non-ionizable species,
                        ion_lev is a null pointer.
  * \param Jx_arr,Jy_arr,Jz_arr  Array4 of current density, either full array or tile.
  * \param np_to_deposit         Number of particles for which current is deposited.
  * \param dt                    Time step for particle level
  * \param dinv                  3D cell size inverse
  * \param xyzmin                Physical lower bounds of domain.
  * \param lo                    Index lower bounds of domain.
  * \param q                     species charge.
  * \param n_rz_azimuthal_modes  Number of azimuthal modes when using RZ geometry.
  */
 template <int depos_order>
 void doVillasenorDepositionShapeNImplicit ([[maybe_unused]]const amrex::ParticleReal * const xp_n,
                                            [[maybe_unused]]const amrex::ParticleReal * const yp_n,
                                            [[maybe_unused]]const amrex::ParticleReal * const zp_n,
                                            const GetParticlePosition<PIdx>& GetPosition,
                                            const amrex::ParticleReal * const wp,
                                            [[maybe_unused]]const amrex::ParticleReal * const uxp_n,
                                            [[maybe_unused]]const amrex::ParticleReal * const uyp_n,
                                            [[maybe_unused]]const amrex::ParticleReal * const uzp_n,
                                            [[maybe_unused]]const amrex::ParticleReal * const uxp_nph,
                                            [[maybe_unused]]const amrex::ParticleReal * const uyp_nph,
                                            [[maybe_unused]]const amrex::ParticleReal * const uzp_nph,
                                            const int * const ion_lev,
                                            const amrex::Array4<amrex::Real>& Jx_arr,
                                            const amrex::Array4<amrex::Real>& Jy_arr,
                                            const amrex::Array4<amrex::Real>& Jz_arr,
                                            const long np_to_deposit,
                                            const amrex::Real dt,
                                            const amrex::XDim3 & dinv,
                                            const amrex::XDim3 & xyzmin,
                                            const amrex::Dim3 lo,
                                            const amrex::Real q,
                                            [[maybe_unused]] const int n_rz_azimuthal_modes)
 {
     using namespace amrex;
 
     // Whether ion_lev is a null pointer (do_ionization=0) or a real pointer
     // (do_ionization=1)
     bool const do_ionization = ion_lev;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z;
 
 #if (AMREX_SPACEDIM > 1)
     Real constexpr one_third = 1.0_rt / 3.0_rt;
     Real constexpr one_sixth = 1.0_rt / 6.0_rt;
 #endif
 
     // Loop over particles and deposit into Jx_arr, Jy_arr and Jz_arr
     amrex::ParallelFor(
         np_to_deposit,
         [=] AMREX_GPU_DEVICE (long const ip) {
 
 #if !defined(WARPX_DIM_3D)
             constexpr amrex::ParticleReal inv_c2 = 1._prt/(PhysConst::c*PhysConst::c);
 
             // Compute inverse Lorentz factor, the average of gamma at time levels n and n+1
             // The uxp,uyp,uzp are the velocities at time level n+1/2
             const amrex::ParticleReal uxp_np1 = 2._prt*uxp_nph[ip] - uxp_n[ip];
             const amrex::ParticleReal uyp_np1 = 2._prt*uyp_nph[ip] - uyp_n[ip];
             const amrex::ParticleReal uzp_np1 = 2._prt*uzp_nph[ip] - uzp_n[ip];
             const amrex::ParticleReal gamma_n = std::sqrt(1._prt + (uxp_n[ip]*uxp_n[ip] + uyp_n[ip]*uyp_n[ip] + uzp_n[ip]*uzp_n[ip])*inv_c2);
             const amrex::ParticleReal gamma_np1 = std::sqrt(1._prt + (uxp_np1*uxp_np1 + uyp_np1*uyp_np1 + uzp_np1*uzp_np1)*inv_c2);
             const amrex::ParticleReal gaminv = 2.0_prt/(gamma_n + gamma_np1);
 #endif
 
             Real wq = q*wp[ip];
             if (do_ionization){
                 wq *= ion_lev[ip];
             }
 
             ParticleReal xp_nph, yp_nph, zp_nph;
             GetPosition(ip, xp_nph, yp_nph, zp_nph);
 
 #if !defined(WARPX_DIM_1D_Z)
             ParticleReal const xp_np1 = 2._prt*xp_nph - xp_n[ip];
 #endif
 #if defined(WARPX_DIM_3D) || defined(WARPX_DIM_RZ)
             ParticleReal const yp_np1 = 2._prt*yp_nph - yp_n[ip];
 #endif
             ParticleReal const zp_np1 = 2._prt*zp_nph - zp_n[ip];
 
             // computes current and old position in grid units
 #if defined(WARPX_DIM_RZ)
             amrex::Real const xp_new = xp_np1;
             amrex::Real const yp_new = yp_np1;
             amrex::Real const xp_mid = xp_nph;
             amrex::Real const yp_mid = yp_nph;
             amrex::Real const xp_old = xp_n[ip];
             amrex::Real const yp_old = yp_n[ip];
             amrex::Real const rp_new = std::sqrt(xp_new*xp_new + yp_new*yp_new);
             amrex::Real const rp_old = std::sqrt(xp_old*xp_old + yp_old*yp_old);
             amrex::Real const rp_mid = (rp_new + rp_old)/2._rt;
             amrex::Real costheta_mid, sintheta_mid;
             if (rp_mid > 0._rt) {
                 costheta_mid = xp_mid/rp_mid;
                 sintheta_mid = yp_mid/rp_mid;
             } else {
                 costheta_mid = 1._rt;
                 sintheta_mid = 0._rt;
             }
             const Complex xy_mid0 = Complex{costheta_mid, sintheta_mid};
 
             // Keep these double to avoid bug in single precision
             double const x_new = (rp_new - xyzmin.x)*dinv.x;
             double const x_old = (rp_old - xyzmin.x)*dinv.x;
             amrex::Real const vx = (rp_new - rp_old)/dt;
             amrex::Real const vy = (-uxp_nph[ip]*sintheta_mid + uyp_nph[ip]*costheta_mid)*gaminv;
 #elif defined(WARPX_DIM_XZ)
             // Keep these double to avoid bug in single precision
             double const x_new = (xp_np1 - xyzmin.x)*dinv.x;
             double const x_old = (xp_n[ip] - xyzmin.x)*dinv.x;
             amrex::Real const vx = (xp_np1 - xp_n[ip])/dt;
             amrex::Real const vy = uyp_nph[ip]*gaminv;
 #elif defined(WARPX_DIM_1D_Z)
             amrex::Real const vx = uxp_nph[ip]*gaminv;
             amrex::Real const vy = uyp_nph[ip]*gaminv;
 #elif defined(WARPX_DIM_3D)
             // Keep these double to avoid bug in single precision
             double const x_new = (xp_np1 - xyzmin.x)*dinv.x;
             double const x_old = (xp_n[ip] - xyzmin.x)*dinv.x;
             double const y_new = (yp_np1 - xyzmin.y)*dinv.y;
             double const y_old = (yp_n[ip] - xyzmin.y)*dinv.y;
             amrex::Real const vx = (xp_np1 - xp_n[ip])/dt;
             amrex::Real const vy = (yp_np1 - yp_n[ip])/dt;
 #endif
 
             // Keep these double to avoid bug in single precision
             double const z_new = (zp_np1 - xyzmin.z)*dinv.z;
             double const z_old = (zp_n[ip] - xyzmin.z)*dinv.z;
             amrex::Real const vz = (zp_np1 - zp_n[ip])/dt;
 
             // Define velocity kernals to deposit
             amrex::Real const wqx = wq*vx*invvol;
             amrex::Real const wqy = wq*vy*invvol;
             amrex::Real const wqz = wq*vz*invvol;
 
             // 1) Determine the number of segments.
             // 2) Loop over segments and deposit current.
 
             // cell crossings are defined at cell edges if depos_order is odd
             // cell crossings are defined at cell centers if depos_order is even
 
             int num_segments = 1;
             double shift = 0.0;
             if ( (depos_order % 2) == 0 ) { shift = 0.5; }
 
 #if defined(WARPX_DIM_3D)
 
             // compute cell crossings in X-direction
             const auto i_old = static_cast<int>(x_old-shift);
             const auto i_new = static_cast<int>(x_new-shift);
             const int cell_crossings_x = std::abs(i_new-i_old);
             num_segments += cell_crossings_x;
 
             // compute cell crossings in Y-direction
             const auto j_old = static_cast<int>(y_old-shift);
             const auto j_new = static_cast<int>(y_new-shift);
             const int cell_crossings_y = std::abs(j_new-j_old);
             num_segments += cell_crossings_y;
 
             // compute cell crossings in Z-direction
             const auto k_old = static_cast<int>(z_old-shift);
             const auto k_new = static_cast<int>(z_new-shift);
             const int cell_crossings_z = std::abs(k_new-k_old);
             num_segments += cell_crossings_z;
 
             // need to assert that the number of cell crossings in each direction
             // is within the range permitted by the number of guard cells
             // e.g., if (num_segments > 7) ...
 
             // compute total change in particle position and the initial cell
             // locations in each direction used to find the position at cell crossings.
             const double dxp = x_new - x_old;
             const double dyp = y_new - y_old;
             const double dzp = z_new - z_old;
             const auto dirX_sign = static_cast<double>(dxp < 0. ? -1. : 1.);
             const auto dirY_sign = static_cast<double>(dyp < 0. ? -1. : 1.);
             const auto dirZ_sign = static_cast<double>(dzp < 0. ? -1. : 1.);
             double Xcell = 0., Ycell = 0., Zcell = 0.;
             if (num_segments > 1) {
                 Xcell = static_cast<double>(i_old) + shift + 0.5*(1.-dirX_sign);
                 Ycell = static_cast<double>(j_old) + shift + 0.5*(1.-dirY_sign);
                 Zcell = static_cast<double>(k_old) + shift + 0.5*(1.-dirZ_sign);
             }
 
             // loop over the number of segments and deposit
             const Compute_shape_factor< depos_order-1 > compute_shape_factor_cell;
             const Compute_shape_factor_pair< depos_order > compute_shape_factors_node;
             double dxp_seg, dyp_seg, dzp_seg;
             double x0_new, y0_new, z0_new;
             double x0_old = x_old;
             double y0_old = y_old;
             double z0_old = z_old;
 
             for (int ns=0; ns<num_segments; ns++) {
 
                 if (ns == num_segments-1) { // final segment
 
                     x0_new = x_new;
                     y0_new = y_new;
                     z0_new = z_new;
                     dxp_seg = x0_new - x0_old;
                     dyp_seg = y0_new - y0_old;
                     dzp_seg = z0_new - z0_old;
 
                 }
                 else {
 
                     x0_new = Xcell + dirX_sign;
                     y0_new = Ycell + dirY_sign;
                     z0_new = Zcell + dirZ_sign;
                     dxp_seg = x0_new - x0_old;
                     dyp_seg = y0_new - y0_old;
                     dzp_seg = z0_new - z0_old;
 
                     if ( (dyp == 0. || std::abs(dxp_seg) < std::abs(dxp/dyp*dyp_seg))
                       && (dzp == 0. || std::abs(dxp_seg) < std::abs(dxp/dzp*dzp_seg)) ) {
                         Xcell = x0_new;
                         dyp_seg = dyp/dxp*dxp_seg;
                         dzp_seg = dzp/dxp*dxp_seg;
                         y0_new = y0_old + dyp_seg;
                         z0_new = z0_old + dzp_seg;
                     }
                     else if (dzp == 0. || std::abs(dyp_seg) < std::abs(dyp/dzp*dzp_seg)) {
                         Ycell = y0_new;
                         dxp_seg = dxp/dyp*dyp_seg;
                         dzp_seg = dzp/dyp*dyp_seg;
                         x0_new = x0_old + dxp_seg;
                         z0_new = z0_old + dzp_seg;
                     }
                     else {
                         Zcell = z0_new;
                         dxp_seg = dxp/dzp*dzp_seg;
                         dyp_seg = dyp/dzp*dzp_seg;
                         x0_new = x0_old + dxp_seg;
                         y0_new = y0_old + dyp_seg;
                     }
 
                 }
 
                 // compute the segment factors (each equal to dt_seg/dt for nonzero dxp, dyp, or dzp)
                 const auto seg_factor_x = static_cast<double>(dxp == 0. ? 1. : dxp_seg/dxp);
                 const auto seg_factor_y = static_cast<double>(dyp == 0. ? 1. : dyp_seg/dyp);
                 const auto seg_factor_z = static_cast<double>(dzp == 0. ? 1. : dzp_seg/dzp);
 
                 // compute cell-based weights using the average segment position
                 double sx_cell[depos_order] = {0.};
                 double sy_cell[depos_order] = {0.};
                 double sz_cell[depos_order] = {0.};
                 double const x0_bar = (x0_new + x0_old)/2.0;
                 double const y0_bar = (y0_new + y0_old)/2.0;
                 double const z0_bar = (z0_new + z0_old)/2.0;
                 const int i0_cell = compute_shape_factor_cell( sx_cell, x0_bar-0.5 );
                 const int j0_cell = compute_shape_factor_cell( sy_cell, y0_bar-0.5 );
                 const int k0_cell = compute_shape_factor_cell( sz_cell, z0_bar-0.5 );
 
                 if constexpr (depos_order >= 3) { // higher-order correction to the cell-based weights
                     const Compute_shape_factor_pair<depos_order-1> compute_shape_factors_cell;
                     double sx_old_cell[depos_order] = {0.};
                     double sx_new_cell[depos_order] = {0.};
                     double sy_old_cell[depos_order] = {0.};
                     double sy_new_cell[depos_order] = {0.};
                     double sz_old_cell[depos_order] = {0.};
                     double sz_new_cell[depos_order] = {0.};
                     const int i0_cell_2 = compute_shape_factors_cell( sx_old_cell, sx_new_cell, x0_old-0.5, x0_new-0.5 );
                     const int j0_cell_2 = compute_shape_factors_cell( sy_old_cell, sy_new_cell, y0_old-0.5, y0_new-0.5 );
                     const int k0_cell_2 = compute_shape_factors_cell( sz_old_cell, sz_new_cell, z0_old-0.5, z0_new-0.5 );
                     ignore_unused(i0_cell_2, j0_cell_2, k0_cell_2);
                     for (int m=0; m<depos_order; m++) {
                         sx_cell[m] = (4.0*sx_cell[m] + sx_old_cell[m] + sx_new_cell[m])/6.0;
                         sy_cell[m] = (4.0*sy_cell[m] + sy_old_cell[m] + sy_new_cell[m])/6.0;
                         sz_cell[m] = (4.0*sz_cell[m] + sz_old_cell[m] + sz_new_cell[m])/6.0;
                     }
                 }
 
                 // compute node-based weights using the old and new segment positions
                 double sx_old_node[depos_order+1] = {0.};
                 double sx_new_node[depos_order+1] = {0.};
                 double sy_old_node[depos_order+1] = {0.};
                 double sy_new_node[depos_order+1] = {0.};
                 double sz_old_node[depos_order+1] = {0.};
                 double sz_new_node[depos_order+1] = {0.};
                 const int i0_node = compute_shape_factors_node( sx_old_node, sx_new_node, x0_old, x0_new );
                 const int j0_node = compute_shape_factors_node( sy_old_node, sy_new_node, y0_old, y0_new );
                 const int k0_node = compute_shape_factors_node( sz_old_node, sz_new_node, z0_old, z0_new );
 
                 // deposit Jx for this segment
                 amrex::Real this_Jx;
                 for (int i=0; i<=depos_order-1; i++) {
                     for (int j=0; j<=depos_order; j++) {
                         for (int k=0; k<=depos_order; k++) {
                             this_Jx = wqx*sx_cell[i]*( sy_old_node[j]*sz_old_node[k]*one_third
                                                      + sy_old_node[j]*sz_new_node[k]*one_sixth
                                                      + sy_new_node[j]*sz_old_node[k]*one_sixth
                                                      + sy_new_node[j]*sz_new_node[k]*one_third )*seg_factor_x;
                             amrex::Gpu::Atomic::AddNoRet( &Jx_arr(lo.x+i0_cell+i, lo.y+j0_node+j, lo.z+k0_node+k), this_Jx);
                         }
                     }
                 }
 
                 // deposit Jy for this segment
                 amrex::Real this_Jy;
                 for (int i=0; i<=depos_order; i++) {
                     for (int j=0; j<=depos_order-1; j++) {
                         for (int k=0; k<=depos_order; k++) {
                             this_Jy = wqy*sy_cell[j]*( sx_old_node[i]*sz_old_node[k]*one_third
                                                      + sx_old_node[i]*sz_new_node[k]*one_sixth
                                                      + sx_new_node[i]*sz_old_node[k]*one_sixth
                                                      + sx_new_node[i]*sz_new_node[k]*one_third )*seg_factor_y;
                             amrex::Gpu::Atomic::AddNoRet( &Jy_arr(lo.x+i0_node+i, lo.y+j0_cell+j, lo.z+k0_node+k), this_Jy);
                         }
                     }
                 }
 
                 // deposit Jz for this segment
                 amrex::Real this_Jz;
                 for (int i=0; i<=depos_order; i++) {
                     for (int j=0; j<=depos_order; j++) {
                         for (int k=0; k<=depos_order-1; k++) {
                             this_Jz = wqz*sz_cell[k]*( sx_old_node[i]*sy_old_node[j]*one_third
                                                      + sx_old_node[i]*sy_new_node[j]*one_sixth
                                                      + sx_new_node[i]*sy_old_node[j]*one_sixth
                                                      + sx_new_node[i]*sy_new_node[j]*one_third )*seg_factor_z;
                             amrex::Gpu::Atomic::AddNoRet( &Jz_arr(lo.x+i0_node+i, lo.y+j0_node+j, lo.z+k0_cell+k), this_Jz);
                         }
                     }
                 }
 
                 // update old segment values
                 if (ns < num_segments-1) {
                     x0_old = x0_new;
                     y0_old = y0_new;
                     z0_old = z0_new;
                 }
 
             } // end loop over segments
 
 #elif defined(WARPX_DIM_XZ) || defined(WARPX_DIM_RZ)
 
             // compute cell crossings in X-direction
             const auto i_old = static_cast<int>(x_old-shift);
             const auto i_new = static_cast<int>(x_new-shift);
             const int cell_crossings_x = std::abs(i_new-i_old);
             num_segments += cell_crossings_x;
 
             // compute cell crossings in Z-direction
             const auto k_old = static_cast<int>(z_old-shift);
             const auto k_new = static_cast<int>(z_new-shift);
             const int cell_crossings_z = std::abs(k_new-k_old);
             num_segments += cell_crossings_z;
 
             // need to assert that the number of cell crossings in each direction
             // is within the range permitted by the number of guard cells
             // e.g., if (num_segments > 5) ...
 
             // compute total change in particle position and the initial cell
             // locations in each direction used to find the position at cell crossings.
             const double dxp = x_new - x_old;
             const double dzp = z_new - z_old;
             const auto dirX_sign = static_cast<double>(dxp < 0. ? -1. : 1.);
             const auto dirZ_sign = static_cast<double>(dzp < 0. ? -1. : 1.);
             double Xcell = 0., Zcell = 0.;
             if (num_segments > 1) {
                 Xcell = static_cast<double>(i_old) + shift + 0.5*(1.-dirX_sign);
                 Zcell = static_cast<double>(k_old) + shift + 0.5*(1.-dirZ_sign);
             }
 
             // loop over the number of segments and deposit
             const Compute_shape_factor< depos_order-1 > compute_shape_factor_cell;
             const Compute_shape_factor_pair< depos_order > compute_shape_factors_node;
             double dxp_seg, dzp_seg;
             double x0_new, z0_new;
             double x0_old = x_old;
             double z0_old = z_old;
 
             for (int ns=0; ns<num_segments; ns++) {
 
                 if (ns == num_segments-1) { // final segment
 
                     x0_new = x_new;
                     z0_new = z_new;
                     dxp_seg = x0_new - x0_old;
                     dzp_seg = z0_new - z0_old;
 
                 }
                 else {
 
                     x0_new = Xcell + dirX_sign;
                     z0_new = Zcell + dirZ_sign;
                     dxp_seg = x0_new - x0_old;
                     dzp_seg = z0_new - z0_old;
 
                     if (dzp == 0. || std::abs(dxp_seg) < std::abs(dxp/dzp*dzp_seg)) {
                         Xcell = x0_new;
                         dzp_seg = dzp/dxp*dxp_seg;
                         z0_new = z0_old + dzp_seg;
                     }
                     else {
                         Zcell = z0_new;
                         dxp_seg = dxp/dzp*dzp_seg;
                         x0_new = x0_old + dxp_seg;
                     }
 
                 }
 
                 // compute the segment factors (each equal to dt_seg/dt for nonzero dxp, or dzp)
                 const auto seg_factor_x = static_cast<double>(dxp == 0. ? 1. : dxp_seg/dxp);
                 const auto seg_factor_z = static_cast<double>(dzp == 0. ? 1. : dzp_seg/dzp);
 
                 // compute cell-based weights using the average segment position
                 double sx_cell[depos_order] = {0.};
                 double sz_cell[depos_order] = {0.};
                 double const x0_bar = (x0_new + x0_old)/2.0;
                 double const z0_bar = (z0_new + z0_old)/2.0;
                 const int i0_cell = compute_shape_factor_cell( sx_cell, x0_bar-0.5 );
                 const int k0_cell = compute_shape_factor_cell( sz_cell, z0_bar-0.5 );
 
                 if constexpr (depos_order >= 3) { // higher-order correction to the cell-based weights
                     const Compute_shape_factor_pair<depos_order-1> compute_shape_factors_cell;
                     double sx_old_cell[depos_order] = {0.};
                     double sx_new_cell[depos_order] = {0.};
                     double sz_old_cell[depos_order] = {0.};
                     double sz_new_cell[depos_order] = {0.};
                     const int i0_cell_2 = compute_shape_factors_cell( sx_old_cell, sx_new_cell, x0_old-0.5, x0_new-0.5 );
                     const int k0_cell_2 = compute_shape_factors_cell( sz_old_cell, sz_new_cell, z0_old-0.5, z0_new-0.5 );
                     ignore_unused(i0_cell_2, k0_cell_2);
                     for (int m=0; m<depos_order; m++) {
                         sx_cell[m] = (4.0*sx_cell[m] + sx_old_cell[m] + sx_new_cell[m])/6.0;
                         sz_cell[m] = (4.0*sz_cell[m] + sz_old_cell[m] + sz_new_cell[m])/6.0;
                     }
                 }
 
                 // compute node-based weights using the old and new segment positions
                 double sx_old_node[depos_order+1] = {0.};
                 double sx_new_node[depos_order+1] = {0.};
                 double sz_old_node[depos_order+1] = {0.};
                 double sz_new_node[depos_order+1] = {0.};
                 const int i0_node = compute_shape_factors_node( sx_old_node, sx_new_node, x0_old, x0_new );
                 const int k0_node = compute_shape_factors_node( sz_old_node, sz_new_node, z0_old, z0_new );
 
                 // deposit Jx for this segment
                 amrex::Real this_Jx;
                 for (int i=0; i<=depos_order-1; i++) {
                     for (int k=0; k<=depos_order; k++) {
                         this_Jx = wqx*sx_cell[i]*(sz_old_node[k] + sz_new_node[k])/2.0_rt*seg_factor_x;
                         amrex::Gpu::Atomic::AddNoRet( &Jx_arr(lo.x+i0_cell+i, lo.y+k0_node+k, 0, 0), this_Jx);
 #if defined(WARPX_DIM_RZ)
                         Complex xy_mid = xy_mid0; // Throughout the following loop, xy_mid takes the value e^{i m theta}
                         for (int imode=1 ; imode < n_rz_azimuthal_modes ; imode++) {
                             // The factor 2 comes from the normalization of the modes
                             const Complex djr_cmplx = 2._rt*this_Jx*xy_mid;
                             amrex::Gpu::Atomic::AddNoRet( &Jx_arr(lo.x+i0_cell+i, lo.y+k0_node+k, 0, 2*imode-1), djr_cmplx.real());
                             amrex::Gpu::Atomic::AddNoRet( &Jx_arr(lo.x+i0_cell+i, lo.y+k0_node+k, 0, 2*imode), djr_cmplx.imag());
                             xy_mid = xy_mid*xy_mid0;
                         }
 #endif
                     }
                 }
 
                 // deposit out-of-plane Jy for this segment
                 const auto seg_factor_y = std::min(seg_factor_x,seg_factor_z);
                 amrex::Real this_Jy;
                 for (int i=0; i<=depos_order; i++) {
                     for (int k=0; k<=depos_order; k++) {
                         this_Jy = wqy*( sx_old_node[i]*sz_old_node[k]*one_third
                                       + sx_old_node[i]*sz_new_node[k]*one_sixth
                                       + sx_new_node[i]*sz_old_node[k]*one_sixth
                                       + sx_new_node[i]*sz_new_node[k]*one_third )*seg_factor_y;
                         amrex::Gpu::Atomic::AddNoRet( &Jy_arr(lo.x+i0_node+i, lo.y+k0_node+k, 0, 0), this_Jy);
 #if defined(WARPX_DIM_RZ)
                         Complex xy_mid = xy_mid0;
                         // Throughout the following loop, xy_ takes the value e^{i m theta_}
                         for (int imode=1 ; imode < n_rz_azimuthal_modes ; imode++) {
                             // The factor 2 comes from the normalization of the modes
                             const Complex djy_cmplx = 2._rt*this_Jy*xy_mid;
                             amrex::Gpu::Atomic::AddNoRet( &Jy_arr(lo.x+i0_node+i, lo.y+k0_node+k, 0, 2*imode-1), djy_cmplx.real());
                             amrex::Gpu::Atomic::AddNoRet( &Jy_arr(lo.x+i0_node+i, lo.y+k0_node+k, 0, 2*imode), djy_cmplx.imag());
                             xy_mid = xy_mid*xy_mid0;
                         }
 #endif
                     }
                 }
 
                 // deposit Jz for this segment
                 amrex::Real this_Jz;
                 for (int i=0; i<=depos_order; i++) {
                     for (int k=0; k<=depos_order-1; k++) {
                         this_Jz = wqz*sz_cell[k]*(sx_old_node[i] + sx_new_node[i])/2.0_rt*seg_factor_z;
                         amrex::Gpu::Atomic::AddNoRet( &Jz_arr(lo.x+i0_node+i, lo.y+k0_cell+k, 0, 0), this_Jz);
 #if defined(WARPX_DIM_RZ)
                         Complex xy_mid = xy_mid0; // Throughout the following loop, xy_mid takes the value e^{i m theta}
                         for (int imode=1 ; imode < n_rz_azimuthal_modes ; imode++) {
                             // The factor 2 comes from the normalization of the modes
                             const Complex djz_cmplx = 2._rt*this_Jz*xy_mid;
                             amrex::Gpu::Atomic::AddNoRet( &Jz_arr(lo.x+i0_node+i, lo.y+k0_cell+k, 0, 2*imode-1), djz_cmplx.real());
                             amrex::Gpu::Atomic::AddNoRet( &Jz_arr(lo.x+i0_node+i, lo.y+k0_cell+k, 0, 2*imode), djz_cmplx.imag());
                             xy_mid = xy_mid*xy_mid0;
                         }
 #endif
                     }
                 }
 
                 // update old segment values
                 if (ns < num_segments-1) {
                     x0_old = x0_new;
                     z0_old = z0_new;
                 }
 
             } // end loop over segments
 
 #elif defined(WARPX_DIM_1D_Z)
 
             // compute cell crossings in Z-direction
             const auto k_old = static_cast<int>(z_old-shift);
             const auto k_new = static_cast<int>(z_new-shift);
             const int cell_crossings_z = std::abs(k_new-k_old);
             num_segments += cell_crossings_z;
 
             // need to assert that the number of cell crossings in each direction
             // is within the range permitted by the number of guard cells
             // e.g., if (num_segments > 3) ...
 
             // compute dzp and the initial cell location used to find the cell crossings.
             double const dzp = z_new - z_old;
             const auto dirZ_sign = static_cast<double>(dzp < 0. ? -1. : 1.);
             double Zcell = static_cast<double>(k_old) + shift + 0.5*(1.-dirZ_sign);
 
             // loop over the number of segments and deposit
             const Compute_shape_factor< depos_order-1 > compute_shape_factor_cell;
             const Compute_shape_factor_pair< depos_order > compute_shape_factors_node;
             double dzp_seg;
             double z0_new;
             double z0_old = z_old;
 
             for (int ns=0; ns<num_segments; ns++) {
 
                 if (ns == num_segments-1) { // final segment
                     z0_new = z_new;
                     dzp_seg = z0_new - z0_old;
                 }
                 else {
                     Zcell = Zcell + dirZ_sign;
                     z0_new = Zcell;
                     dzp_seg = z0_new - z0_old;
                 }
 
                 // compute the segment factor (equal to dt_seg/dt for nonzero dzp)
                 const auto seg_factor = static_cast<double>(dzp == 0. ? 1. : dzp_seg/dzp);
 
                 // compute cell-based weights using the average segment position
                 double sz_cell[depos_order] = {0.};
                 double const z0_bar = (z0_new + z0_old)/2.0;
                 const int k0_cell = compute_shape_factor_cell( sz_cell, z0_bar-0.5 );
 
                 if constexpr (depos_order >= 3) { // higher-order correction to the cell-based weights
                     const Compute_shape_factor_pair<depos_order-1> compute_shape_factors_cell;
                     double sz_old_cell[depos_order] = {0.};
                     double sz_new_cell[depos_order] = {0.};
                     const int k0_cell_2 = compute_shape_factors_cell( sz_old_cell, sz_new_cell, z0_old-0.5, z0_new-0.5 );
                     ignore_unused(k0_cell_2);
                     for (int m=0; m<depos_order; m++) {
                         sz_cell[m] = (4.0*sz_cell[m] + sz_old_cell[m] + sz_new_cell[m])/6.0;
                     }
                 }
 
                 // compute node-based weights using the old and new segment positions
                 double sz_old_node[depos_order+1] = {0.};
                 double sz_new_node[depos_order+1] = {0.};
                 const int k0_node = compute_shape_factors_node( sz_old_node, sz_new_node, z0_old, z0_new );
 
                 // deposit out-of-plane Jx and Jy for this segment
                 for (int k=0; k<=depos_order; k++) {
                     const amrex::Real weight = 0.5_rt*(sz_old_node[k] + sz_new_node[k])*seg_factor;
                     amrex::Gpu::Atomic::AddNoRet( &Jx_arr(lo.x+k0_node+k, 0, 0), wqx*weight);
                     amrex::Gpu::Atomic::AddNoRet( &Jy_arr(lo.x+k0_node+k, 0, 0), wqy*weight);
                 }
 
                 // deposit Jz for this segment
                 for (int k=0; k<=depos_order-1; k++) {
                     const amrex::Real this_Jz = wqz*sz_cell[k]*seg_factor;
                     amrex::Gpu::Atomic::AddNoRet( &Jz_arr(lo.x+k0_cell+k, 0, 0), this_Jz);
                 }
 
                 // update old segment values
                 if (ns < num_segments-1) {
                     z0_old = z0_new;
                 }
 
             }
 
 #endif
         }
     );
 }
 
 inline uint64_t pre_time = 0;
 inline uint64_t step_time = 0;
 inline uint64_t cal_time = 0;
 inline uint64_t nijk_loop_time = 0;
 inline uint64_t trans_martix_time = 0;
 inline uint64_t save_time = 0;
 inline uint64_t save_time1 = 0;
 inline uint64_t save_time2 = 0;
 inline uint64_t save_time3 = 0;
 inline uint64_t post_time = 0;
 inline uint64_t read_time = 0;
 
 template <int depos_order>
 __arm_new("za") inline void VayDepositionSME(
     double sx_new[], double sx_old[],
     double sy_new[], double sy_old[],
     double sz_new[], double sz_old[],
     const amrex::Array4<amrex::Real>& temp_arr,
     int i_new, int j_new, int k_new, int i_old, int j_old, int k_old,
     const amrex::Dim3& lo, double wq, double invvol, double invdt
 )__arm_streaming
 {
         uint64_t tt1 = rdtscm();
         svbool_t p = svwhilele_b64(0,depos_order+1);
         MVec sx_new_v = MVec::Load(p, &sx_new[0]);
         MVec sx_old_v = MVec::Load(p, &sx_old[0]);
         MVec sy_new_v = MVec::Load(p, &sy_new[0]);
         MVec sy_old_v = MVec::Load(p, &sy_old[0]);
         uint64_t tt2 = rdtscm();
         MVec vzero(0);
         cal_time += (tt2-tt1);
 
         for (int k=0; k<=depos_order; k++) {
             
             uint64_t tt0 = rdtscm();
             MVec syn_szn = wq * invvol * invdt * (sy_new_v * sz_new[k]);
             MVec syo_szn = wq * invvol * invdt * (sy_old_v * sz_new[k]);
             MVec syn_szo = wq * invvol * invdt * (sy_new_v * sz_old[k]);
             MVec syo_szo = wq * invvol * invdt * (sy_old_v * sz_old[k]);
 
             svmopa_za64_m(0, p, p, sx_new_v, syn_szn);
             svmopa_za64_m(1, p, p, sx_old_v, syn_szn);
             svmopa_za64_m(2, p, p, sx_new_v, syo_szn);
             svmopa_za64_m(3, p, p, sx_old_v, syo_szn);
             svmopa_za64_m(4, p, p, sx_new_v, syn_szo);
             svmopa_za64_m(5, p, p, sx_old_v, syn_szo);
             svmopa_za64_m(6, p, p, sx_new_v, syo_szo);
             svmopa_za64_m(7, p, p, sx_old_v, syo_szo);
             // MVec sxn_syn_szn = (sx_new_v) * syn_szn;
             // MVec sxo_syn_szn = (sx_old_v) * syn_szn;
             // MVec sxn_syo_szn = (sx_new_v) * syo_szn;
             // MVec sxo_syo_szn = (sx_old_v) * syo_szn;
             // MVec sxn_syn_szo = (sx_new_v) * syn_szo;
             // MVec sxo_syn_szo = (sx_old_v) * syn_szo;
             // MVec sxn_syo_szo = (sx_new_v) * syo_szo;
             // MVec sxo_syo_szo = (sx_old_v) * syo_szo;
             uint64_t t2 = rdtscm();
             cal_time += (t2-tt0);
 
             for (int j=0; j<=depos_order; j++) {
                 uint64_t read1 = rdtscm();
                 MVec sxn_syn_szn = svread_hor_za64_m(vzero,p,0,j);
                 MVec sxo_syn_szn = svread_hor_za64_m(vzero,p,1,j);
                 MVec sxn_syo_szn = svread_hor_za64_m(vzero,p,2,j);
                 MVec sxo_syo_szn = svread_hor_za64_m(vzero,p,3,j);
                 MVec sxn_syn_szo = svread_hor_za64_m(vzero,p,4,j);
                 MVec sxo_syn_szo = svread_hor_za64_m(vzero,p,5,j);
                 MVec sxn_syo_szo = svread_hor_za64_m(vzero,p,6,j);
                 MVec sxo_syo_szo = svread_hor_za64_m(vzero,p,7,j);
                 uint64_t read2 = rdtscm();
                 read_time+=(read2-read1);
                 if (i_new == i_old && j_new == j_old && k_new == k_old) {
                     uint64_t save1 = rdtscm();
                     MVec save_0 = (sxn_syn_szn - sxo_syo_szo);
                     MVec save_1 = (sxn_syn_szo - sxo_syo_szn);
                     MVec save_2 = (sxn_syo_szn - sxo_syn_szo);
                     MVec save_3 = (sxo_syn_szn - sxn_syo_szo);
                     double* ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 0);
                     MVec v0=MVec::Load(p,ptr);
                     (v0+save_0).Store(p,ptr);
                     ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 1);
                     MVec v1=MVec::Load(p,ptr);
                     (v1+save_1).Store(p,ptr);
                     ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 2);
                     MVec v2=MVec::Load(p,ptr);
                     (v2+save_2).Store(p,ptr);
                     ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 3);
                     MVec v3=MVec::Load(p,ptr);
                     (v3+save_3).Store(p,ptr);
                     uint64_t save2 = rdtscm();
                     save_time1 += (save2-save1);
                     // temp arrays for Dx, Dy and Dz
                     // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 0),
                     //     wq * invvol * invdt * (sxn_syn_szn - sxo_syo_szo));
 
                     // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 1),
                     //     wq * invvol * invdt * (sxn_syn_szo - sxo_syo_szn));
 
                     // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 2),
                     //     wq * invvol * invdt * (sxn_syo_szn - sxo_syn_szo));
 
                     // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 3),
                     //     wq * invvol * invdt * (sxo_syn_szn - sxn_syo_szo));
                 } else {
                     uint64_t save3 = rdtscm();
                     MVec save_00 =sxn_syn_szn;
                     MVec save_01 =- sxo_syo_szo;
                     MVec save_10 =  sxn_syn_szo;
                     MVec save_11 =- sxo_syo_szn;
                     MVec save_20 =  sxn_syo_szn;
                     MVec save_21 =- sxo_syn_szo;
                     MVec save_30 =  sxo_syn_szn;
                     MVec save_31 =- sxn_syo_szo;
                     double* ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 0);
                     MVec v0=MVec::Load(p,ptr);
                     (v0+save_00).Store(p,ptr);
                     (v0+save_01).Store(p,ptr);
                     ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 1);
                     MVec v1=MVec::Load(p,ptr);
                     (v1+save_10).Store(p,ptr);
                     (v1+save_11).Store(p,ptr);
                     ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 2);
                     MVec v2=MVec::Load(p,ptr);
                     (v2+save_20).Store(p,ptr);
                     (v2+save_21).Store(p,ptr);
                     ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 3);
                     MVec v3=MVec::Load(p,ptr);
                     (v3+save_30).Store(p,ptr);                        
                     (v3+save_31).Store(p,ptr); 
                     uint64_t save4 = rdtscm();
                     save_time2 += (save4-save3);
                     // temp arrays for Dx, Dy and Dz
                     // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 0),
                     //     wq * invvol * invdt * sxn_syn_szn);
 
                     // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_old + j, lo.z + k_old + k, 0),
                     //     - wq * invvol * invdt * sxo_syo_szo);
 
                     // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_old + k, 1),
                     //     wq * invvol * invdt * sxn_syn_szo);
 
                     // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_old + j, lo.z + k_new + k, 1),
                     //     - wq * invvol * invdt * sxo_syo_szn);
 
                     // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_old + j, lo.z + k_new + k, 2),
                     //     wq * invvol * invdt * sxn_syo_szn);
 
                     // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_new + j, lo.z + k_old + k, 2),
                     //     - wq * invvol * invdt * sxo_syn_szo);
 
                     // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_new + j, lo.z + k_new + k, 3),
                     //     wq * invvol * invdt * sxo_syn_szn);
 
                     // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_old + j, lo.z + k_old + k, 3),
                     //     - wq * invvol * invdt * sxn_syo_szo);
                 }
                 uint64_t t3 = rdtscm();
                 save_time += (t3-read2);
 
                 // }
             }
         }
 }
 
 template <int depos_order>
 __arm_new("za") inline void VayDepositionSME2(
     double sx_new[], double sx_old[],
     double sy_new[], double sy_old[],
     double sz_new[], double sz_old[],
     const amrex::Array4<amrex::Real>& temp_arr,
     int i_new, int j_new, int k_new, int i_old, int j_old, int k_old,
     const amrex::Dim3& lo, double wq, double invvol, double invdt
 )__arm_streaming
 {
         uint64_t tt1 = rdtscm();
         svbool_t p = svwhilelt_b64(0,depos_order+1);
         svbool_t p1 = svwhilelt_b64(depos_order+1, 8);
         svbool_t p2 = svwhilelt_b64(0, 8);
         // MVec sx_no=svdup_f64(9);
         MVec sx_no = MVec::Load(p, &sx_new[0]);
         MVec sx_o = MVec::Load(p1, &sx_old[0]);
         MVec sy_no = MVec::Load(p, &sy_new[0]);
         MVec sy_o = MVec::Load(p1, &sy_old[0]);
         sx_no=svsel(p1,sx_o,sx_no);
         sy_no=svsel(p1,sy_o,sy_no);
         uint64_t tt2 = rdtscm();
         MVec vzero(0);
         cal_time += (tt2-tt1);
 
         for (int k=0; k<=depos_order; k++) {
             
             uint64_t tt0 = rdtscm();
             MVec syno_szn = wq * invvol * invdt * (sy_no * sz_new[k]);
             // MVec syo_szn = wq * invvol * invdt * (sy_old_v * sz_new[k]);
             MVec syno_szo = wq * invvol * invdt * (sy_no * sz_old[k]);
             // MVec syo_szo = wq * invvol * invdt * (sy_old_v * sz_old[k]);
 
             svmopa_za64_m(0, p2, p2, sx_no, syno_szn);
             // svmopa_za64_m(1, p, p, sx_old_v, syn_szn);
             svmopa_za64_m(1, p2, p2, sx_no, syno_szo);
             // svmopa_za64_m(3, p, p, sx_old_v, syo_szn);
             // svmopa_za64_m(2, p2, p2, sx_no, syno_szo);
             // svmopa_za64_m(5, p, p, sx_old_v, syn_szo);
             // svmopa_za64_m(3, p2, p2, sx_no, syno_szo);
             // svmopa_za64_m(7, p, p, sx_old_v, syo_szo);
 
             uint64_t t2 = rdtscm();
             cal_time += (t2-tt0);
 
             for (int j=0; j<=depos_order; j++) {
                 uint64_t read1 = rdtscm();
                 MVec sxn_syn_szn = svread_hor_za64_m(vzero,p,0,j);
                 MVec sxo_syn_szn = svread_hor_za64_m(vzero,p,0,j+4);
                 MVec sxn_syo_szn = svread_hor_za64_m(vzero,p1,0,j);
                 MVec sxo_syo_szn = svread_hor_za64_m(vzero,p1,0,j+4);
                 MVec sxn_syn_szo = svread_hor_za64_m(vzero,p,1,j);
                 MVec sxo_syn_szo = svread_hor_za64_m(vzero,p,1,j+4);
                 MVec sxn_syo_szo = svread_hor_za64_m(vzero,p1,1,j);
                 MVec sxo_syo_szo = svread_hor_za64_m(vzero,p1,1,j+4);
                 // MVec sxn_syn_szn = svread_hor_za64_m(vzero,p,0,j);
                 // MVec sxo_syn_szn = svread_hor_za64_m(vzero,p,1,j);
                 // MVec sxn_syo_szn = svread_hor_za64_m(vzero,p,2,j);
                 // MVec sxo_syo_szn = svread_hor_za64_m(vzero,p,3,j);
                 // MVec sxn_syn_szo = svread_hor_za64_m(vzero,p,4,j);
                 // MVec sxo_syn_szo = svread_hor_za64_m(vzero,p,5,j);
                 // MVec sxn_syo_szo = svread_hor_za64_m(vzero,p,6,j);
                 // MVec sxo_syo_szo = svread_hor_za64_m(vzero,p,7,j);
                 uint64_t read2 = rdtscm();
                 read_time+=(read2-read1);
                 if (i_new == i_old && j_new == j_old && k_new == k_old) {
                     uint64_t save1 = rdtscm();
                     MVec save_0 = (sxn_syn_szn - sxo_syo_szo);
                     MVec save_1 = (sxn_syn_szo - sxo_syo_szn);
                     MVec save_2 = (sxn_syo_szn - sxo_syn_szo);
                     MVec save_3 = (sxo_syn_szn - sxn_syo_szo);
                     double* ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 0);
                     MVec v0=MVec::Load(p,ptr);
                     (v0+save_0).Store(p,ptr);
                     ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 1);
                     MVec v1=MVec::Load(p,ptr);
                     (v1+save_1).Store(p,ptr);
                     ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 2);
                     MVec v2=MVec::Load(p,ptr);
                     (v2+save_2).Store(p,ptr);
                     ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 3);
                     MVec v3=MVec::Load(p,ptr);
                     (v3+save_3).Store(p,ptr);
                     uint64_t save2 = rdtscm();
                     save_time1 += (save2-save1);
                 } else {
                     uint64_t save3 = rdtscm();
                     MVec save_00 =sxn_syn_szn;
                     MVec save_01 =- sxo_syo_szo;
                     MVec save_10 =  sxn_syn_szo;
                     MVec save_11 =- sxo_syo_szn;
                     MVec save_20 =  sxn_syo_szn;
                     MVec save_21 =- sxo_syn_szo;
                     MVec save_30 =  sxo_syn_szn;
                     MVec save_31 =- sxn_syo_szo;
                     double* ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 0);
                     MVec v0=MVec::Load(p,ptr);
                     (v0+save_00).Store(p,ptr);
                     (v0+save_01).Store(p,ptr);
                     ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 1);
                     MVec v1=MVec::Load(p,ptr);
                     (v1+save_10).Store(p,ptr);
                     (v1+save_11).Store(p,ptr);
                     ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 2);
                     MVec v2=MVec::Load(p,ptr);
                     (v2+save_20).Store(p,ptr);
                     (v2+save_21).Store(p,ptr);
                     ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 3);
                     MVec v3=MVec::Load(p,ptr);
                     (v3+save_30).Store(p,ptr);                        
                     (v3+save_31).Store(p,ptr); 
                     uint64_t save4 = rdtscm();
                     save_time2 += (save4-save3);
                 }
                 uint64_t t3 = rdtscm();
                 save_time += (t3-read2);
 
                 // }
             }
         }
 }
 // const amrex::Array4<amrex::Real>& temp_arr,
 template <int depos_order>
 __arm_new("za") inline void VayDepositionSME3(
     double sx_new[], double sx_old[],
     double sy_new[], double sy_old[],
     double sz_new[], double sz_old[],
     double* temp_arr0,double* temp_arr1,double* temp_arr2,double* temp_arr3,
     int i_new, int j_new, int k_new, int i_old, int j_old, int k_old,
     const amrex::Dim3& lo, double wq, double invvol, double invdt
 )__arm_streaming
 {
         uint64_t tt1 = rdtscm();
         svbool_t p = svwhilelt_b64(0,depos_order+1);
         svbool_t p1 = svwhilelt_b64(depos_order+1, 8);
         svbool_t p2 = svwhilelt_b64(0, 8);
         // MVec sx_no=svdup_f64(9);
         MVec sx_no = MVec::Load(p, &sx_new[0]);
         MVec sx_o = MVec::Load(p1, &sx_old[0]);
         MVec sy_no = MVec::Load(p, &sy_new[0]);
         MVec sy_o = MVec::Load(p1, &sy_old[0]);
         sx_no=svsel(p1,sx_o,sx_no);
         sy_no=svsel(p1,sy_o,sy_no);
         MVec sx_on = MVec::Load(p1, &sx_new[0]);
         sx_o = MVec::Load(p, &sx_old[0]);
         MVec sy_on = MVec::Load(p1, &sy_new[0]);
         sy_o = MVec::Load(p, &sy_old[0]);
         sx_on=svsel(p1,sx_o,sx_on);
         sy_on=svsel(p1,sy_o,sy_on);
 
         uint64_t tt2 = rdtscm();
         MVec vzero(0);
         cal_time += (tt2-tt1);
         if (i_new == i_old && j_new == j_old && k_new == k_old) {
             for (int k=0; k<=depos_order; k++) {          
                 uint64_t tt0 = rdtscm();
                 MVec syno_szn = wq * invvol * invdt * (sy_no * sz_new[k]);
                 // MVec syo_szn = wq * invvol * invdt * (sy_old_v * sz_new[k]);
                 MVec syon_szo = wq * invvol * invdt * (sy_on * sz_old[k]);
                 // MVec syo_szo = wq * invvol * invdt * (sy_old_v * sz_old[k]);
 
                 svmopa_za64_m(0, p2, p2, sx_no, syno_szn);
                 // svmopa_za64_m(1, p, p, sx_old_v, syn_szn);
                 svmopa_za64_m(1, p2, p2, sx_on, syon_szo);
                 // svmopa_za64_m(3, p, p, sx_old_v, syo_szn);
                 // svmopa_za64_m(2, p2, p2, sx_no, syno_szo);
                 // svmopa_za64_m(5, p, p, sx_old_v, syn_szo);
                 // svmopa_za64_m(3, p2, p2, sx_no, syno_szo);
                 // svmopa_za64_m(7, p, p, sx_old_v, syo_szo);
 
                 uint64_t t2 = rdtscm();
                 cal_time += (t2-tt0);
 
                 for (int j=0; j<=depos_order; j++) {
                     uint64_t read1 = rdtscm();
                     // MVec sxn_syn_szn = svread_hor_za64_m(vzero,p,0,j);
                     // MVec sxo_syn_szn = svread_hor_za64_m(vzero,p,0,j+4);
                     // MVec sxn_syo_szn = svread_hor_za64_m(vzero,p1,0,j);
                     // MVec sxo_syo_szn = svread_hor_za64_m(vzero,p1,0,j+4);
                     // MVec sxn_syn_szo = svread_hor_za64_m(vzero,p,1,j);
                     // MVec sxo_syn_szo = svread_hor_za64_m(vzero,p,1,j+4);
                     // MVec sxn_syo_szo = svread_hor_za64_m(vzero,p1,1,j);
                     // MVec sxo_syo_szo = svread_hor_za64_m(vzero,p1,1,j+4);
                     MVec sxn_syn_szn_non = svread_hor_za64_m(vzero,p2,0,j);
                     MVec sxo_syn_szn_oon = svread_hor_za64_m(vzero,p2,0,j+4);
                     MVec sxo_syo_szo_ono = svread_hor_za64_m(vzero,p2,1,j);
                     MVec sxn_syo_szo_nno = svread_hor_za64_m(vzero,p2,1,j+4);
 
                     uint64_t read2 = rdtscm();
                     read_time+=(read2-read1);
                     uint64_t save1 = rdtscm();
                     MVec save_0 = (sxn_syn_szn_non - sxo_syo_szo_ono);
                     MVec save_1 = (sxo_syn_szn_oon - sxn_syo_szo_nno);
 
                     // double* ptr = &temp_arr0;
                     // MVec v0=MVec::Load(p,temp_arr0);
                     // v0=MVec::Load(p1,temp_arr1);
                     // MVec save=v0+save_0;
                     save_0.Store(p,temp_arr0);
                     save_0.Store(p1,temp_arr1);
                     save_1.Store(p,temp_arr2);
                     save_1.Store(p1,temp_arr3);
 
                     // ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 2);
                     // MVec v1=MVec::Load(p,ptr);
                     // ptr1 = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 3);
                     // v1=MVec::Load(p1,ptr1);
                     // (v1+save_1).Store(p,ptr);
                     // (v1+save_1).Store(p1,ptr1);
 
 
                     // double* ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 0);
                     // MVec v0=MVec::Load(p,ptr);
                     // double* ptr1 = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 1);
                     // v0=MVec::Load(p1,ptr1);
                     // (v0+save_0).Store(p,ptr);
                     // (v0+save_0).Store(p1,ptr1);
 
                     // ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 2);
                     // MVec v1=MVec::Load(p,ptr);
                     // ptr1 = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 3);
                     // v1=MVec::Load(p1,ptr1);
                     // (v1+save_1).Store(p,ptr);
                     // (v1+save_1).Store(p1,ptr1);
 
                     // double* ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 0);
                     // MVec v0=MVec::Load(p,ptr);
                     // (v0+save_0).Store(p,ptr);
                     // ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 1);
                     // MVec v1=MVec::Load(p,ptr);
                     // (v1+save_1).Store(p,ptr);
                     // ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 2);
                     // MVec v2=MVec::Load(p,ptr);
                     // (v2+save_2).Store(p,ptr);
                     // ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 3);
                     // MVec v3=MVec::Load(p,ptr);
                     // (v3+save_3).Store(p,ptr);
                     uint64_t save2 = rdtscm();
                     save_time1 += (save2-save1);
                     uint64_t t3 = rdtscm();
                     save_time += (t3-read2);
                 }
             }
         } else {
             for (int k=0; k<=depos_order; k++) {
     
                 uint64_t tt0 = rdtscm();
                 MVec syno_szn = wq * invvol * invdt * (sy_no * sz_new[k]);
                 // MVec syo_szn = wq * invvol * invdt * (sy_old_v * sz_new[k]);
                 MVec syno_szo = wq * invvol * invdt * (sy_no * sz_old[k]);
                 // MVec syo_szo = wq * invvol * invdt * (sy_old_v * sz_old[k]);
 
                 svmopa_za64_m(0, p2, p2, sx_no, syno_szn);
                 // svmopa_za64_m(1, p, p, sx_old_v, syn_szn);
                 svmopa_za64_m(1, p2, p2, sx_no, syno_szo);                  
 
                 uint64_t t2 = rdtscm();
                 cal_time += (t2-tt0);
 
                 for (int j=0; j<=depos_order; j++) {
                     uint64_t read1 = rdtscm();
                     MVec sxn_syn_szn = svread_hor_za64_m(vzero,p,0,j);
                     MVec sxo_syn_szn = svread_hor_za64_m(vzero,p,0,j+4);
                     MVec sxn_syo_szn = svread_hor_za64_m(vzero,p1,0,j);
                     MVec sxo_syo_szn = svread_hor_za64_m(vzero,p1,0,j+4);
                     MVec sxn_syn_szo = svread_hor_za64_m(vzero,p,1,j);
                     MVec sxo_syn_szo = svread_hor_za64_m(vzero,p,1,j+4);
                     MVec sxn_syo_szo = svread_hor_za64_m(vzero,p1,1,j);
                     MVec sxo_syo_szo = svread_hor_za64_m(vzero,p1,1,j+4);
             
                     // uint64_t read2 = rdtscm();
                     // read_time+=(read2-read1);
                     // uint64_t save3 = rdtscm();
                     // MVec save_00 =sxn_syn_szn;
                     // MVec save_01 =- sxo_syo_szo;
                     // MVec save_10 =  sxn_syn_szo;
                     // MVec save_11 =- sxo_syo_szn;
                     // MVec save_20 =  sxn_syo_szn;
                     // MVec save_21 =- sxo_syn_szo;
                     // MVec save_30 =  sxo_syn_szn;
                     // MVec save_31 =- sxn_syo_szo;
                     // double* ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 0);
                     // MVec v0=MVec::Load(p,ptr);
                     // (v0+save_00).Store(p,ptr);
                     // (v0+save_01).Store(p,ptr);
                     // ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 1);
                     // MVec v1=MVec::Load(p,ptr);
                     // (v1+save_10).Store(p,ptr);
                     // (v1+save_11).Store(p,ptr);
                     // ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 2);
                     // MVec v2=MVec::Load(p,ptr);
                     // (v2+save_20).Store(p,ptr);
                     // (v2+save_21).Store(p,ptr);
                     // ptr = &temp_arr.atSME(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 3);
                     // MVec v3=MVec::Load(p,ptr);
                     // (v3+save_30).Store(p,ptr);                        
                     // (v3+save_31).Store(p,ptr); 
                     // uint64_t save4 = rdtscm();
                     // save_time2 += (save4-save3);
                     // uint64_t t3 = rdtscm();
                     // save_time += (t3-read2);
                 }
             }
         }
 }
 
 /**
  * \brief Vay current deposition
  * (<a href="https://doi.org/10.1016/j.jcp.2013.03.010"> Vay et al, 2013</a>)
  * for thread \c thread_num: deposit \c D in real space and store the result in
  * \c Dx_fab, \c Dy_fab, \c Dz_fab
  *
  * \tparam depos_order  deposition order
  * \param[in] GetPosition  Functor that returns the particle position
  * \param[in] wp           Pointer to array of particle weights
  * \param[in] uxp,uyp,uzp  Pointer to arrays of particle momentum along \c x
  * \param[in] ion_lev      Pointer to array of particle ionization level. This is
                            required to have the charge of each macroparticle since \c q
                            is a scalar. For non-ionizable species, \c ion_lev is \c null
  * \param[in,out] Dx_fab,Dy_fab,Dz_fab FArrayBox of Vay current density, either full array or tile
  * \param[in] np_to_deposit Number of particles for which current is deposited
  * \param[in] dt           Time step for particle level
  * \param[in] relative_time Time at which to deposit D, relative to the time of the
  *                          current positions of the particles. When different than 0,
  *                          the particle position will be temporarily modified to match
  *                          the time of the deposition.
  * \param[in] dinv         3D cell size inverse
  * \param[in] xyzmin       3D lower bounds of physical domain
  * \param[in] lo           Dimension-agnostic lower bounds of index domain
  * \param[in] q            Species charge
  * \param[in] n_rz_azimuthal_modes Number of azimuthal modes in RZ geometry
  */
 template <int depos_order>
 void doVayDepositionShapeN_2 (const GetParticlePosition<PIdx>& GetPosition,
                             const amrex::ParticleReal* const wp,
                             const amrex::ParticleReal* const uxp,
                             const amrex::ParticleReal* const uyp,
                             const amrex::ParticleReal* const uzp,
                             const int* const ion_lev,
                             amrex::FArrayBox& Dx_fab,
                             amrex::FArrayBox& Dy_fab,
                             amrex::FArrayBox& Dz_fab,
                             long np_to_deposit,
                             amrex::Real dt,
                             amrex::Real relative_time,
                             const amrex::XDim3 & dinv,
                             const amrex::XDim3 & xyzmin,
                             amrex::Dim3 lo,
                             amrex::Real q,
                             [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     uint64_t step0=rdtscv();
     using namespace amrex::literals;
 
     // If ion_lev is a null pointer, then do_ionization=0, else do_ionization=1
     const bool do_ionization = ion_lev;
 
     // Inverse of time step
     const amrex::Real invdt = 1._rt / dt;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z;
 
     // Allocate temporary arrays
     AMREX_ALWAYS_ASSERT(Dx_fab.box() == Dy_fab.box() && Dx_fab.box() == Dz_fab.box());
     amrex::FArrayBox temp_fab{Dx_fab.box(), 4};
 
     temp_fab.setVal<amrex::RunOn::Device>(0._rt);
     amrex::Array4<amrex::Real> const& temp_arr = temp_fab.array();
 
     // Inverse of light speed squared
     const amrex::Real invcsq = 1._rt / (PhysConst::c * PhysConst::c);
 
     // Arrays where D will be stored
     amrex::Array4<amrex::Real> const& Dx_arr = Dx_fab.array();
     amrex::Array4<amrex::Real> const& Dy_arr = Dy_fab.array();
     amrex::Array4<amrex::Real> const& Dz_arr = Dz_fab.array();
 
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
 
     auto compute_shape_factor_v = [](int64_t* i_new, double* sx[], Vec xmid, svbool_t p) {
         Vec j = svrintz_x(p, xmid);
         Vec xint = xmid - j;
         Vec temp = 1.0 - xint;
         Vec sx0 = (1.0 / 6.0) * temp * temp * temp;
         Vec sx1 = (2.0 / 3.0) - xint * xint * (1.0 - xint * 0.5);
         Vec sx2 = (2.0 / 3.0) - temp * temp * (1.0 - 0.5 *temp);
         Vec sx3 = (1.0 / 6.0) * xint * xint * xint;
         sx0.Store(p, sx[0]);
         sx1.Store(p, sx[1]);
         sx2.Store(p, sx[2]);
         sx3.Store(p, sx[3]);
         svst1(p, i_new, svsub_x(p, svcvt_s64_x(p,j), svdup_s64(1)));
     };
     // Loop over particles and deposit (Dx,Dy,Dz) into Dx_fab, Dy_fab and Dz_fab
     // amrex::ParallelFor(np_to_deposit, [&] AMREX_GPU_DEVICE (long ip)
     const int block_size=256;
     long n_blocks=np_to_deposit/block_size;
     int vl=svcntd();
     // for(int ip=0;ip<np_to_deposit;ip++)
 // #pragma omp parallel for 
     for(int block_id=0;block_id<n_blocks;block_id++)
     {
         uint64_t t0 = rdtscv();
         double wq[block_size];
         // double xp_test[256];
         // double x_newv[256];
         // double inv_test[256];
 
         double sx_new_m[depos_order + 1][block_size] = {0.};
         double sx_old_m[depos_order + 1][block_size] = {0.};
         double sy_new_m[depos_order + 1][block_size] = {0.};
         double sy_old_m[depos_order + 1][block_size] = {0.};
         double sz_new_m[depos_order + 1][block_size] = {0.};
         double sz_old_m[depos_order + 1][block_size] = {0.};
 
         int64_t i_new[block_size];
         int64_t i_old[block_size];
         int64_t j_new[block_size];
         int64_t j_old[block_size];
         int64_t k_new[block_size];
         int64_t k_old[block_size];
         // uint64_t branch_index[block_size];
 
         // uint64_t indices0[block_size];
         // uint64_t indices1[block_size];
         // uint64_t indices2[block_size];
         // uint64_t indices3[block_size];
         // uint64_t indices0old[block_size];
         // uint64_t indices1old[block_size];
         // uint64_t indices2old[block_size];
         // uint64_t indices3old[block_size];
 
         // svuint64_t ones=svdup_u64(1);
         // svuint64_t zeros=svdup_u64(0);
 
         for(int iip=0;iip<block_size/vl;iip+=vl){
             long ip=iip+block_id*block_size;
             // uint64_t t0 = rdtscv();
             svbool_t p_ip=svwhilele_b64(ip,np_to_deposit);
             // Inverse of Lorentz factor gamma
             Vec uxp_v=Vec::Load(p_ip,&uxp[ip]);
             Vec uyp_v=Vec::Load(p_ip,&uyp[ip]);
             Vec uzp_v=Vec::Load(p_ip,&uzp[ip]);
             Vec invgam = 1._rt / (1._rt +  uxp_v * uxp_v * invcsq
                                         + uyp_v * uyp_v * invcsq
                                         + uzp_v * uzp_v * invcsq).Sqrt();
             // Product of particle charges and weights
             Vec wp_v=Vec::Load(p_ip,&wp[ip]);
             Vec wq_v = q * wp_v;
             // if (do_ionization) { 
             //     svint64_t ion_lev_v=svld1_s64(p_ip,&ion_lev[ip]);
             //     wq_v *= svcvt_f64_x(p_ip, ion_lev_v);
             //     // wq_v *= ion_lev_v; 
             // }
             wq_v.Store(p_ip, &wq[iip]);
 
             // Current particle positions (in physical units)
             Vec xp = Vec::Load(p_ip, &mx[ip]);
             Vec yp = Vec::Load(p_ip, &my[ip]);
             Vec zp = Vec::Load(p_ip, &mz[ip]);
 
             // Particle velocities
             Vec vx = uxp_v * invgam;
             Vec vy = uyp_v * invgam;
             Vec vz = uzp_v * invgam;
             // double vx_test[8];
             // vx.Store(p_ip,&vx_test[0]);
 
             // Modify the particle position to match the time of the deposition
             xp += relative_time * vx;
             yp += relative_time * vy;
             zp += relative_time * vz;
             // xp.Store(p_ip,&xp_test[iip]);
             // invgam.Store(p_ip,&inv_test[iip]);
 
             // Current and old particle positions in grid units
             // Keep these double to avoid bug in single precision.
             Vec x_new = (xp - xyzmin.x + 0.5_rt*dt*vx) * dinv.x;
             Vec x_old = (xp - xyzmin.x - 0.5_rt*dt*vx) * dinv.x;
             Vec y_new = (yp - xyzmin.y + 0.5_rt*dt*vy) * dinv.y;
             Vec y_old = (yp - xyzmin.y - 0.5_rt*dt*vy) * dinv.y;
             Vec z_new = (zp - xyzmin.z + 0.5_rt*dt*vz) * dinv.z;
             Vec z_old = (zp - xyzmin.z - 0.5_rt*dt*vz) * dinv.z;
             double* sx_new_temp[4] = {&sx_new_m[0][iip], &sx_new_m[1][iip], &sx_new_m[2][iip], &sx_new_m[3][iip]};
             double* sx_old_temp[4] = {&sx_old_m[0][iip], &sx_old_m[1][iip], &sx_old_m[2][iip], &sx_old_m[3][iip]};
             // svint64_t i_newv=compute_shape_factor_v2(&i_new[iip], sx_new_temp, x_new, p_ip);
             // svint64_t i_oldv=compute_shape_factor_v2(&i_old[iip], sx_old_temp, x_old, p_ip);
             compute_shape_factor_v(&i_new[iip], sx_new_temp, x_new, p_ip);
             compute_shape_factor_v(&i_old[iip], sx_old_temp, x_old, p_ip);
 
             double* sy_new_temp[4] = {&sy_new_m[0][iip], &sy_new_m[1][iip], &sy_new_m[2][iip], &sy_new_m[3][iip]};
             double* sy_old_temp[4] = {&sy_old_m[0][iip], &sy_old_m[1][iip], &sy_old_m[2][iip], &sy_old_m[3][iip]};
             // svint64_t j_newv=compute_shape_factor_v2(&j_new[iip], sy_new_temp, y_new, p_ip);
             // svint64_t j_oldv=compute_shape_factor_v2(&j_old[iip], sy_old_temp, y_old, p_ip);
             compute_shape_factor_v(&j_new[iip], sy_new_temp, y_new, p_ip);
             compute_shape_factor_v(&j_old[iip], sy_old_temp, y_old, p_ip);
 
             double* sz_new_temp[4] = {&sz_new_m[0][iip], &sz_new_m[1][iip], &sz_new_m[2][iip], &sz_new_m[3][iip]};
             double* sz_old_temp[4] = {&sz_old_m[0][iip], &sz_old_m[1][iip], &sz_old_m[2][iip], &sz_old_m[3][iip]};
             // svint64_t k_newv=compute_shape_factor_v2(&k_new[iip], sz_new_temp, z_new, p_ip);
             // svint64_t k_oldv=compute_shape_factor_v2(&k_old[iip], sz_old_temp, z_old, p_ip);
             compute_shape_factor_v(&k_new[iip], sz_new_temp, z_new, p_ip);
             compute_shape_factor_v(&k_old[iip], sz_old_temp, z_old, p_ip);
         }
         uint64_t t1 = rdtscv();
         pre_time += (t1-t0);
         // Deposit current into Dx_arr, Dy_arr and Dz_arr
 #if 0 // Orgin Unroll
         for (int k=0; k<=depos_order; k++) {
             for (int j=0; j<=depos_order; j++) {
             uint64_t tt0 = rdtscv();
                 auto const syn_szn = static_cast<amrex::Real>(sy_new[j] * sz_new[k]);
                 auto const syo_szn = static_cast<amrex::Real>(sy_old[j] * sz_new[k]);
                 auto const syn_szo = static_cast<amrex::Real>(sy_new[j] * sz_old[k]);
                 auto const syo_szo = static_cast<amrex::Real>(sy_old[j] * sz_old[k]);
             // uint64_t tt1 = rdtscv();
             // cal_time += (tt1-tt0);
                 // for (int i=0; i<=depos_order; i++) {
             // uint64_t tt2 = rdtscv();
                     auto const sxn_syn_szn = static_cast<amrex::Real>(sx_new[0]) * syn_szn;
                     auto const sxo_syn_szn = static_cast<amrex::Real>(sx_old[0]) * syn_szn;
                     auto const sxn_syo_szn = static_cast<amrex::Real>(sx_new[0]) * syo_szn;
                     auto const sxo_syo_szn = static_cast<amrex::Real>(sx_old[0]) * syo_szn;
                     auto const sxn_syn_szo = static_cast<amrex::Real>(sx_new[0]) * syn_szo;
                     auto const sxo_syn_szo = static_cast<amrex::Real>(sx_old[0]) * syn_szo;
                     auto const sxn_syo_szo = static_cast<amrex::Real>(sx_new[0]) * syo_szo;
                     auto const sxo_syo_szo = static_cast<amrex::Real>(sx_old[0]) * syo_szo;
                     //1
                     auto const sxn_syn_szn1 = static_cast<amrex::Real>(sx_new[1]) * syn_szn;
                     auto const sxo_syn_szn1 = static_cast<amrex::Real>(sx_old[1]) * syn_szn;
                     auto const sxn_syo_szn1 = static_cast<amrex::Real>(sx_new[1]) * syo_szn;
                     auto const sxo_syo_szn1 = static_cast<amrex::Real>(sx_old[1]) * syo_szn;
                     auto const sxn_syn_szo1 = static_cast<amrex::Real>(sx_new[1]) * syn_szo;
                     auto const sxo_syn_szo1 = static_cast<amrex::Real>(sx_old[1]) * syn_szo;
                     auto const sxn_syo_szo1 = static_cast<amrex::Real>(sx_new[1]) * syo_szo;
                     auto const sxo_syo_szo1 = static_cast<amrex::Real>(sx_old[1]) * syo_szo;
                     //2
                     auto const sxn_syn_szn2 = static_cast<amrex::Real>(sx_new[2]) * syn_szn;
                     auto const sxo_syn_szn2 = static_cast<amrex::Real>(sx_old[2]) * syn_szn;
                     auto const sxn_syo_szn2 = static_cast<amrex::Real>(sx_new[2]) * syo_szn;
                     auto const sxo_syo_szn2 = static_cast<amrex::Real>(sx_old[2]) * syo_szn;
                     auto const sxn_syn_szo2 = static_cast<amrex::Real>(sx_new[2]) * syn_szo;
                     auto const sxo_syn_szo2 = static_cast<amrex::Real>(sx_old[2]) * syn_szo;
                     auto const sxn_syo_szo2 = static_cast<amrex::Real>(sx_new[2]) * syo_szo;
                     auto const sxo_syo_szo2 = static_cast<amrex::Real>(sx_old[2]) * syo_szo;
                     //3
                     auto const sxn_syn_szn3 = static_cast<amrex::Real>(sx_new[3]) * syn_szn;
                     auto const sxo_syn_szn3 = static_cast<amrex::Real>(sx_old[3]) * syn_szn;
                     auto const sxn_syo_szn3 = static_cast<amrex::Real>(sx_new[3]) * syo_szn;
                     auto const sxo_syo_szn3 = static_cast<amrex::Real>(sx_old[3]) * syo_szn;
                     auto const sxn_syn_szo3 = static_cast<amrex::Real>(sx_new[3]) * syn_szo;
                     auto const sxo_syn_szo3 = static_cast<amrex::Real>(sx_old[3]) * syn_szo;
                     auto const sxn_syo_szo3 = static_cast<amrex::Real>(sx_new[3]) * syo_szo;
                     auto const sxo_syo_szo3 = static_cast<amrex::Real>(sx_old[3]) * syo_szo;
 
             uint64_t t2 = rdtscv();
             cal_time += (t2-tt0);
 
                     if (i_new == i_old && j_new == j_old && k_new == k_old) {
                         // temp arrays for Dx, Dy and Dz
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_new + j, lo.z + k_new + k, 0),
                             wq * invvol * invdt * (sxn_syn_szn - sxo_syo_szo));
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_new + j, lo.z + k_new + k, 1),
                             wq * invvol * invdt * (sxn_syn_szo - sxo_syo_szn));
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_new + j, lo.z + k_new + k, 2),
                             wq * invvol * invdt * (sxn_syo_szn - sxo_syn_szo));
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_new + j, lo.z + k_new + k, 3),
                             wq * invvol * invdt * (sxo_syn_szn - sxn_syo_szo));
                         // 1
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_new + j, lo.z + k_new + k, 0),
                             wq * invvol * invdt * (sxn_syn_szn1 - sxo_syo_szo1));
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_new + j, lo.z + k_new + k, 1),
                             wq * invvol * invdt * (sxn_syn_szo1 - sxo_syo_szn1));
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_new + j, lo.z + k_new + k, 2),
                             wq * invvol * invdt * (sxn_syo_szn1 - sxo_syn_szo1));
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_new + j, lo.z + k_new + k, 3),
                             wq * invvol * invdt * (sxo_syn_szn1 - sxn_syo_szo1));
                         //2
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_new + j, lo.z + k_new + k, 0),
                             wq * invvol * invdt * (sxn_syn_szn2 - sxo_syo_szo2));
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_new + j, lo.z + k_new + k, 1),
                             wq * invvol * invdt * (sxn_syn_szo2 - sxo_syo_szn2));
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_new + j, lo.z + k_new + k, 2),
                             wq * invvol * invdt * (sxn_syo_szn2 - sxo_syn_szo2));
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_new + j, lo.z + k_new + k, 3),
                             wq * invvol * invdt * (sxo_syn_szn2 - sxn_syo_szo2));
                         //3
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_new + j, lo.z + k_new + k, 0),
                             wq * invvol * invdt * (sxn_syn_szn3 - sxo_syo_szo3));
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_new + j, lo.z + k_new + k, 1),
                             wq * invvol * invdt * (sxn_syn_szo3 - sxo_syo_szn3));
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_new + j, lo.z + k_new + k, 2),
                             wq * invvol * invdt * (sxn_syo_szn3 - sxo_syn_szo3));
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_new + j, lo.z + k_new + k, 3),
                             wq * invvol * invdt * (sxo_syn_szn3 - sxn_syo_szo3));
                     } else {
                         // temp arrays for Dx, Dy and Dz
                         //0
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_new + j, lo.z + k_new + k, 0),
                             wq * invvol * invdt * sxn_syn_szn);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 0, lo.y + j_old + j, lo.z + k_old + k, 0),
                             - wq * invvol * invdt * sxo_syo_szo);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_new + j, lo.z + k_old + k, 1),
                             wq * invvol * invdt * sxn_syn_szo);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 0, lo.y + j_old + j, lo.z + k_new + k, 1),
                             - wq * invvol * invdt * sxo_syo_szn);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_old + j, lo.z + k_new + k, 2),
                             wq * invvol * invdt * sxn_syo_szn);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 0, lo.y + j_new + j, lo.z + k_old + k, 2),
                             - wq * invvol * invdt * sxo_syn_szo);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 0, lo.y + j_new + j, lo.z + k_new + k, 3),
                             wq * invvol * invdt * sxo_syn_szn);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_old + j, lo.z + k_old + k, 3),
                             - wq * invvol * invdt * sxn_syo_szo);
                         //1
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_new + j, lo.z + k_new + k, 0),
                             wq * invvol * invdt * sxn_syn_szn1);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 1, lo.y + j_old + j, lo.z + k_old + k, 0),
                             - wq * invvol * invdt * sxo_syo_szo1);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_new + j, lo.z + k_old + k, 1),
                             wq * invvol * invdt * sxn_syn_szo1);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 1, lo.y + j_old + j, lo.z + k_new + k, 1),
                             - wq * invvol * invdt * sxo_syo_szn1);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_old + j, lo.z + k_new + k, 2),
                             wq * invvol * invdt * sxn_syo_szn1);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 1, lo.y + j_new + j, lo.z + k_old + k, 2),
                             - wq * invvol * invdt * sxo_syn_szo1);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 1, lo.y + j_new + j, lo.z + k_new + k, 3),
                             wq * invvol * invdt * sxo_syn_szn1);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_old + j, lo.z + k_old + k, 3),
                             - wq * invvol * invdt * sxn_syo_szo1);
                         //2
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_new + j, lo.z + k_new + k, 0),
                             wq * invvol * invdt * sxn_syn_szn2);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 2, lo.y + j_old + j, lo.z + k_old + k, 0),
                             - wq * invvol * invdt * sxo_syo_szo2);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_new + j, lo.z + k_old + k, 1),
                             wq * invvol * invdt * sxn_syn_szo2);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 2, lo.y + j_old + j, lo.z + k_new + k, 1),
                             - wq * invvol * invdt * sxo_syo_szn2);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_old + j, lo.z + k_new + k, 2),
                             wq * invvol * invdt * sxn_syo_szn2);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 2, lo.y + j_new + j, lo.z + k_old + k, 2),
                             - wq * invvol * invdt * sxo_syn_szo2);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 2, lo.y + j_new + j, lo.z + k_new + k, 3),
                             wq * invvol * invdt * sxo_syn_szn2);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_old + j, lo.z + k_old + k, 3),
                             - wq * invvol * invdt * sxn_syo_szo2);
                         //3
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_new + j, lo.z + k_new + k, 0),
                             wq * invvol * invdt * sxn_syn_szn3);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 3, lo.y + j_old + j, lo.z + k_old + k, 0),
                             - wq * invvol * invdt * sxo_syo_szo3);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_new + j, lo.z + k_old + k, 1),
                             wq * invvol * invdt * sxn_syn_szo3);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 3, lo.y + j_old + j, lo.z + k_new + k, 1),
                             - wq * invvol * invdt * sxo_syo_szn3);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_old + j, lo.z + k_new + k, 2),
                             wq * invvol * invdt * sxn_syo_szn3);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 3, lo.y + j_new + j, lo.z + k_old + k, 2),
                             - wq * invvol * invdt * sxo_syn_szo3);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 3, lo.y + j_new + j, lo.z + k_new + k, 3),
                             wq * invvol * invdt * sxo_syn_szn3);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_old + j, lo.z + k_old + k, 3),
                             - wq * invvol * invdt * sxn_syo_szo3);
                     }
             uint64_t t3 = rdtscv();
             save_time += (t3-t2);
 
                 // }
             }
         }
 #elif 0 // orgin
         for (int k=0; k<=depos_order; k++) {
             for (int j=0; j<=depos_order; j++) {
                 uint64_t tt0 = rdtscv();
                 auto const syn_szn = static_cast<amrex::Real>(sy_new[j] * sz_new[k]);
                 auto const syo_szn = static_cast<amrex::Real>(sy_old[j] * sz_new[k]);
                 auto const syn_szo = static_cast<amrex::Real>(sy_new[j] * sz_old[k]);
                 auto const syo_szo = static_cast<amrex::Real>(sy_old[j] * sz_old[k]);
                 uint64_t tt1 = rdtscv();
                 cal_time += (tt1-tt0);
                 for (int i=0; i<=depos_order; i++) {
                     uint64_t tt2 = rdtscv();
                     auto const sxn_syn_szn = static_cast<amrex::Real>(sx_new[i]) * syn_szn;
                     auto const sxo_syn_szn = static_cast<amrex::Real>(sx_old[i]) * syn_szn;
                     auto const sxn_syo_szn = static_cast<amrex::Real>(sx_new[i]) * syo_szn;
                     auto const sxo_syo_szn = static_cast<amrex::Real>(sx_old[i]) * syo_szn;
                     auto const sxn_syn_szo = static_cast<amrex::Real>(sx_new[i]) * syn_szo;
                     auto const sxo_syn_szo = static_cast<amrex::Real>(sx_old[i]) * syn_szo;
                     auto const sxn_syo_szo = static_cast<amrex::Real>(sx_new[i]) * syo_szo;
                     auto const sxo_syo_szo = static_cast<amrex::Real>(sx_old[i]) * syo_szo;
                     uint64_t t2 = rdtscv();
                     cal_time += (t2-tt2);
                     if (i_new == i_old && j_new == j_old && k_new == k_old) {
                         // temp arrays for Dx, Dy and Dz
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 0),
                             wq * invvol * invdt * (sxn_syn_szn - sxo_syo_szo));
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 1),
                             wq * invvol * invdt * (sxn_syn_szo - sxo_syo_szn));
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 2),
                             wq * invvol * invdt * (sxn_syo_szn - sxo_syn_szo));
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 3),
                             wq * invvol * invdt * (sxo_syn_szn - sxn_syo_szo));
                     } else {
                         // temp arrays for Dx, Dy and Dz
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 0),
                             wq * invvol * invdt * sxn_syn_szn);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_old + j, lo.z + k_old + k, 0),
                             - wq * invvol * invdt * sxo_syo_szo);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_old + k, 1),
                             wq * invvol * invdt * sxn_syn_szo);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_old + j, lo.z + k_new + k, 1),
                             - wq * invvol * invdt * sxo_syo_szn);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_old + j, lo.z + k_new + k, 2),
                             wq * invvol * invdt * sxn_syo_szn);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_new + j, lo.z + k_old + k, 2),
                             - wq * invvol * invdt * sxo_syn_szo);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_new + j, lo.z + k_new + k, 3),
                             wq * invvol * invdt * sxo_syn_szn);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_old + j, lo.z + k_old + k, 3),
                             - wq * invvol * invdt * sxn_syo_szo);
                     }
                 uint64_t t3 = rdtscv();
                 save_time += (t3-t2);
                 }
             }
         }
 
 #elif 0 // SVE
         uint64_t tt1 = rdtscv();
         svbool_t p = svwhilele_b64(0,depos_order+1);
         Vec sx_new_v = Vec::Load(p, &sx_new[0]);
         Vec sx_old_v = Vec::Load(p, &sx_old[0]);
         uint64_t tt2 = rdtscv();
         cal_time += (tt2-tt1);
 
         for (int k=0; k<=depos_order; k++) {
             for (int j=0; j<=depos_order; j++) {
             
                 uint64_t tt0 = rdtscv();
                 auto const syn_szn = static_cast<amrex::Real>(sy_new[j] * sz_new[k]);
                 auto const syo_szn = static_cast<amrex::Real>(sy_old[j] * sz_new[k]);
                 auto const syn_szo = static_cast<amrex::Real>(sy_new[j] * sz_old[k]);
                 auto const syo_szo = static_cast<amrex::Real>(sy_old[j] * sz_old[k]);
 
                 
                 Vec sxn_syn_szn = (sx_new_v) * syn_szn;
                 Vec sxo_syn_szn = (sx_old_v) * syn_szn;
                 Vec sxn_syo_szn = (sx_new_v) * syo_szn;
                 Vec sxo_syo_szn = (sx_old_v) * syo_szn;
                 Vec sxn_syn_szo = (sx_new_v) * syn_szo;
                 Vec sxo_syn_szo = (sx_old_v) * syn_szo;
                 Vec sxn_syo_szo = (sx_new_v) * syo_szo;
                 Vec sxo_syo_szo = (sx_old_v) * syo_szo;
                 uint64_t t2 = rdtscv();
                 cal_time += (t2-tt0);
 
                     if (i_new == i_old && j_new == j_old && k_new == k_old) {
                         Vec save_0 = wq * invvol * invdt * (sxn_syn_szn - sxo_syo_szo);
                         Vec save_1 = wq * invvol * invdt * (sxn_syn_szo - sxo_syo_szn);
                         Vec save_2 = wq * invvol * invdt * (sxn_syo_szn - sxo_syn_szo);
                         Vec save_3 = wq * invvol * invdt * (sxo_syn_szn - sxn_syo_szo);
                         double* ptr = &temp_arr(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 0);
                         Vec v0=Vec::Load(p,ptr);
                         (v0+save_0).Store(p,ptr);
                         ptr = &temp_arr(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 1);
                         Vec v1=Vec::Load(p,ptr);
                         (v1+save_1).Store(p,ptr);
                         ptr = &temp_arr(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 2);
                         Vec v2=Vec::Load(p,ptr);
                         (v2+save_2).Store(p,ptr);
                         ptr = &temp_arr(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 3);
                         Vec v3=Vec::Load(p,ptr);
                         (v3+save_3).Store(p,ptr);
                         // temp arrays for Dx, Dy and Dz
                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 0),
                         //     wq * invvol * invdt * (sxn_syn_szn - sxo_syo_szo));
 
                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 1),
                         //     wq * invvol * invdt * (sxn_syn_szo - sxo_syo_szn));
 
                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 2),
                         //     wq * invvol * invdt * (sxn_syo_szn - sxo_syn_szo));
 
                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 3),
                         //     wq * invvol * invdt * (sxo_syn_szn - sxn_syo_szo));
                     } else {
                         Vec save_00 =wq * invvol * invdt * sxn_syn_szn;
                         Vec save_01 =- wq * invvol * invdt * sxo_syo_szo;
                         Vec save_10 =wq * invvol * invdt * sxn_syn_szo;
                         Vec save_11 =- wq * invvol * invdt * sxo_syo_szn;
                         Vec save_20 =wq * invvol * invdt * sxn_syo_szn;
                         Vec save_21 =- wq * invvol * invdt * sxo_syn_szo;
                         Vec save_30 =wq * invvol * invdt * sxo_syn_szn;
                         Vec save_31 =- wq * invvol * invdt * sxn_syo_szo;
                         double* ptr = &temp_arr(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 0);
                         Vec v0=Vec::Load(p,ptr);
                         (v0+save_00).Store(p,ptr);
                         (v0+save_01).Store(p,ptr);
                         ptr = &temp_arr(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 1);
                         Vec v1=Vec::Load(p,ptr);
                         (v1+save_10).Store(p,ptr);
                         (v1+save_11).Store(p,ptr);
                         ptr = &temp_arr(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 2);
                         Vec v2=Vec::Load(p,ptr);
                         (v2+save_20).Store(p,ptr);
                         (v2+save_21).Store(p,ptr);
                         ptr = &temp_arr(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 3);
                         Vec v3=Vec::Load(p,ptr);
                         (v3+save_30).Store(p,ptr);                        
                         (v3+save_31).Store(p,ptr);                        
                         // temp arrays for Dx, Dy and Dz
                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 0),
                         //     wq * invvol * invdt * sxn_syn_szn);
 
                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_old + j, lo.z + k_old + k, 0),
                         //     - wq * invvol * invdt * sxo_syo_szo);
 
                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_old + k, 1),
                         //     wq * invvol * invdt * sxn_syn_szo);
 
                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_old + j, lo.z + k_new + k, 1),
                         //     - wq * invvol * invdt * sxo_syo_szn);
 
                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_old + j, lo.z + k_new + k, 2),
                         //     wq * invvol * invdt * sxn_syo_szn);
 
                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_new + j, lo.z + k_old + k, 2),
                         //     - wq * invvol * invdt * sxo_syn_szo);
 
                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_new + j, lo.z + k_new + k, 3),
                         //     wq * invvol * invdt * sxo_syn_szn);
 
                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_old + j, lo.z + k_old + k, 3),
                         //     - wq * invvol * invdt * sxn_syo_szo);
                     }
             uint64_t t3 = rdtscv();
             save_time += (t3-t2);
 
                 // }
             }
         }
 
 #elif 0 //SME
         VayDepositionSME<depos_order>(
             sx_new,sx_old,
             sy_new,sy_old,
             sz_new,sz_old,
             temp_arr, i_new,j_new,k_new, i_old,j_old,k_old,
             lo, wq, invvol, invdt);
 #elif 0 //SME2
         VayDepositionSME2<depos_order>(
             sx_new,sx_old,
             sy_new,sy_old,
             sz_new,sz_old,
             temp_arr, i_new,j_new,k_new, i_old,j_old,k_old,
             lo, wq, invvol, invdt);
 #elif 0 //SME3
         double sx_new_mT[block_size][depos_order + 1] = {0.};
         double sx_old_mT[block_size][depos_order + 1] = {0.};
         double sy_new_mT[block_size][depos_order + 1] = {0.};
         double sy_old_mT[block_size][depos_order + 1] = {0.};
         double sz_new_mT[block_size][depos_order + 1] = {0.};
         double sz_old_mT[block_size][depos_order + 1] = {0.};
         uint64_t trans_time0=rdtscv();
         for(int i=0;i<block_size;i++){
             for(int j=0;j<4;j++){
                 sx_new_mT[i][j]=sx_new_m[j][i];
                 sx_old_mT[i][j]=sx_old_m[j][i];
                 sy_new_mT[i][j]=sy_new_m[j][i];
                 sy_old_mT[i][j]=sy_old_m[j][i];
                 sz_new_mT[i][j]=sz_new_m[j][i];
                 sz_old_mT[i][j]=sz_old_m[j][i];
             }
         }
         uint64_t trans_time1=rdtscv();
         trans_martix_time+=(trans_time1-trans_time0);
 
         double temp_arr0[4*block_size] = {0.};
         double temp_arr1[4*block_size] = {0.};
         double temp_arr2[4*block_size] = {0.};
         double temp_arr3[4*block_size] = {0.};
 
 #pragma omp parallel for num_threads(2)
         for(int iip=0;iip<block_size;iip++){
             __asm__ volatile("smstart sm");
             __asm__ volatile("smstart za");
             VayDepositionSME3<depos_order>(
                 sx_new_mT[iip], sx_old_mT[iip],
                 sy_new_mT[iip], sy_old_mT[iip],
                 sz_new_mT[iip], sz_old_mT[iip],
                 &temp_arr0[4*iip], &temp_arr1[4*iip],&temp_arr2[4*iip],&temp_arr3[4*iip],
                 i_new[iip], j_new[iip], k_new[iip], 
                 i_old[iip], j_old[iip], k_old[iip],
                 lo, wq[iip], invvol, invdt);
             __asm__ volatile("smstop sm");
             __asm__ volatile("smstop za");
         }
         uint64_t indices0[4*block_size];
         uint64_t indices1[4*block_size];
         uint64_t indices2[4*block_size];
         uint64_t indices3[4*block_size];
         uint64_t save0=rdtscv();
         for(int k=0;k<=depos_order;k++){
             for(int j=0;j<=depos_order;j++){
                 for(int iip=0;iip<block_size;iip++){
                     double* base0 = &temp_arr(lo.x + i_new[iip], lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 0);
                     svbool_t p=svwhilele_b64(0,3);
                     Vec v0=Vec::Load(p,&temp_arr(lo.x + i_new[iip], lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 0));
                     Vec save0=Vec::Load(p,&temp_arr0[iip]);
                     v0+=save0;
                     double* base1 = &temp_arr(lo.x + i_new[iip], lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 1);
                     Vec v1=Vec::Load(p,&temp_arr(lo.x + i_new[iip], lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 1));
                     Vec save1=Vec::Load(p,&temp_arr1[iip]);
                     v1+=save1;
                     double* base2 = &temp_arr(lo.x + i_new[iip], lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 2);
                     // svbool_t p=svwhilele_b64(2,3);
                     Vec v2=Vec::Load(p,&temp_arr(lo.x + i_new[iip], lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 2));
                     Vec save2=Vec::Load(p,&temp_arr2[iip]);
                     v2+=save2;
                     double* base3 = &temp_arr(lo.x + i_new[iip], lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 3);
                     // svbool_t p=svwhilele_b64(3,3);
                     Vec v3=Vec::Load(p,&temp_arr(lo.x + i_new[iip], lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 3));
                     Vec save3=Vec::Load(p,&temp_arr3[iip]);
                     v3+=save3;
 
                     v0.Store(p,&temp_arr(lo.x + i_new[iip], lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 0));
                     v1.Store(p,&temp_arr(lo.x + i_new[iip], lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 1));  
                     v2.Store(p,&temp_arr(lo.x + i_new[iip], lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 2));                   
                     v3.Store(p,&temp_arr(lo.x + i_new[iip], lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 3));      
                 }
             }
         }
         uint64_t save1=rdtscv();
         save_time1+=(save1-save0);
         // save_time+=save_time1;
 
 #endif
     }
     //  );
 
     uint64_t t4 = rdtscv();
     const amrex::Box& bx=Dx_fab.box();
     const amrex::IntVect Dxlo=bx.smallEnd();
     const amrex::IntVect Dxhi=bx.bigEnd();
     for(int k=Dxlo[2];k<=Dxhi[2];++k){
         for(int j=Dxlo[1];j<=Dxhi[1];++j){
             // for(int i=Dxlo[0];i<=Dxhi[0];i++){
             for(int i=Dxlo[0];i<=Dxhi[0];i+=vl){
 
                 svbool_t p = svwhilele_b64(i,Dxhi[0]);
                 Vec t_av=Vec::Load(p,&temp_arr(i,j,k,0));
                 Vec t_bv=Vec::Load(p,&temp_arr(i,j,k,1));
                 Vec t_cv=Vec::Load(p,&temp_arr(i,j,k,2));
                 Vec t_dv=Vec::Load(p,&temp_arr(i,j,k,3));
 
                 Vec Dx_arrv=Vec::Load(p,&Dx_arr(i,j,k));
                 Vec Dy_arrv=Vec::Load(p,&Dy_arr(i,j,k));
                 Vec Dz_arrv=Vec::Load(p,&Dz_arr(i,j,k));
                 Dx_arrv += (1._rt/6._rt)*(2_rt*t_av       + t_bv       + t_cv - 2._rt*t_dv);
                 Dy_arrv += (1._rt/6._rt)*(2_rt*t_av       + t_bv - 2._rt*t_cv       + t_dv);
                 Dz_arrv += (1._rt/6._rt)*(2_rt*t_av - 2._rt*t_bv       + t_cv       + t_dv);
 
                 Dx_arrv.Store(p,&Dx_arr(i,j,k));
                 Dy_arrv.Store(p,&Dy_arr(i,j,k));
                 Dz_arrv.Store(p,&Dz_arr(i,j,k));
             }
         }
     }    
     uint64_t t5 = rdtscv();
     post_time += (t5-t4);
     // Synchronize so that temp_fab can be safely deallocated in its destructor
     amrex::Gpu::streamSynchronize();
 
     uint64_t step1=rdtscv();
     step_time=(step1-step0);
     printf("\n Step_time: %d, pre_time: %d,  trans_time: %d, cal_time: %d,  read_time: %d, save_time1: %d,save_time2: %d,save_time: %d,  post_time: %d \n", 
                step_time,     pre_time,   trans_martix_time, cal_time,      read_time,     save_time1,    save_time2,    save_time,      post_time);
     amrex::Abort("No Trans Test Over!");
 }
 
 template <int depos_order>
 void doVayDepositionShapeN (const GetParticlePosition<PIdx>& GetPosition,
                             const amrex::ParticleReal* const wp,
                             const amrex::ParticleReal* const uxp,
                             const amrex::ParticleReal* const uyp,
                             const amrex::ParticleReal* const uzp,
                             const int* const ion_lev,
                             amrex::FArrayBox& Dx_fab,
                             amrex::FArrayBox& Dy_fab,
                             amrex::FArrayBox& Dz_fab,
                             long np_to_deposit,
                             amrex::Real dt,
                             amrex::Real relative_time,
                             const amrex::XDim3 & dinv,
                             const amrex::XDim3 & xyzmin,
                             amrex::Dim3 lo,
                             amrex::Real q,
                             [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     using namespace amrex::literals;
 
 #if defined(WARPX_DIM_RZ)
     amrex::ignore_unused(GetPosition,
         wp, uxp, uyp, uzp, ion_lev, Dx_fab, Dy_fab, Dz_fab,
         np_to_deposit, dt, relative_time, dinv, xyzmin, lo, q);
     WARPX_ABORT_WITH_MESSAGE("Vay deposition not implemented in RZ geometry");
 #endif
 
 #if defined(WARPX_DIM_1D_Z)
     amrex::ignore_unused(GetPosition,
         wp, uxp, uyp, uzp, ion_lev, Dx_fab, Dy_fab, Dz_fab,
         np_to_deposit, dt, relative_time, dinv, xyzmin, lo, q);
     WARPX_ABORT_WITH_MESSAGE("Vay deposition not implemented in 1D geometry");
 #endif
 
 #if !(defined WARPX_DIM_RZ || defined WARPX_DIM_1D_Z)
 
     // If ion_lev is a null pointer, then do_ionization=0, else do_ionization=1
     const bool do_ionization = ion_lev;
 
     // Inverse of time step
     const amrex::Real invdt = 1._rt / dt;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z;
 
     // Allocate temporary arrays
 #if defined(WARPX_DIM_3D)
     AMREX_ALWAYS_ASSERT(Dx_fab.box() == Dy_fab.box() && Dx_fab.box() == Dz_fab.box());
     amrex::FArrayBox temp_fab{Dx_fab.box(), 4};
 #elif defined(WARPX_DIM_XZ)
     AMREX_ALWAYS_ASSERT(Dx_fab.box() == Dz_fab.box());
     amrex::FArrayBox temp_fab{Dx_fab.box(), 2};
 #endif
     temp_fab.setVal<amrex::RunOn::Device>(0._rt);
     amrex::Array4<amrex::Real> const& temp_arr = temp_fab.array();
 
     // Inverse of light speed squared
     const amrex::Real invcsq = 1._rt / (PhysConst::c * PhysConst::c);
 
     // Arrays where D will be stored
     amrex::Array4<amrex::Real> const& Dx_arr = Dx_fab.array();
     amrex::Array4<amrex::Real> const& Dy_arr = Dy_fab.array();
     amrex::Array4<amrex::Real> const& Dz_arr = Dz_fab.array();
 
     // Loop over particles and deposit (Dx,Dy,Dz) into Dx_fab, Dy_fab and Dz_fab
     amrex::ParallelFor(np_to_deposit, [=] AMREX_GPU_DEVICE (long ip)
     {
         // Inverse of Lorentz factor gamma
         const amrex::Real invgam = 1._rt / std::sqrt(1._rt + uxp[ip] * uxp[ip] * invcsq
                                                            + uyp[ip] * uyp[ip] * invcsq
                                                            + uzp[ip] * uzp[ip] * invcsq);
         // Product of particle charges and weights
         amrex::Real wq = q * wp[ip];
         if (do_ionization) { wq *= ion_lev[ip]; }
 
         // Current particle positions (in physical units)
         amrex::ParticleReal xp, yp, zp;
         GetPosition(ip, xp, yp, zp);
 
         // Particle velocities
         const amrex::Real vx = uxp[ip] * invgam;
         const amrex::Real vy = uyp[ip] * invgam;
         const amrex::Real vz = uzp[ip] * invgam;
 
         // Modify the particle position to match the time of the deposition
         xp += relative_time * vx;
         yp += relative_time * vy;
         zp += relative_time * vz;
 
         // Current and old particle positions in grid units
         // Keep these double to avoid bug in single precision.
         double const x_new = (xp - xyzmin.x + 0.5_rt*dt*vx) * dinv.x;
         double const x_old = (xp - xyzmin.x - 0.5_rt*dt*vx) * dinv.x;
 #if defined(WARPX_DIM_3D)
         // Keep these double to avoid bug in single precision.
         double const y_new = (yp - xyzmin.y + 0.5_rt*dt*vy) * dinv.y;
         double const y_old = (yp - xyzmin.y - 0.5_rt*dt*vy) * dinv.y;
 #endif
         // Keep these double to avoid bug in single precision.
         double const z_new = (zp - xyzmin.z + 0.5_rt*dt*vz) * dinv.z;
         double const z_old = (zp - xyzmin.z - 0.5_rt*dt*vz) * dinv.z;
 
         // Shape factor arrays for current and old positions (nodal)
         // Keep these double to avoid bug in single precision.
         double sx_new[depos_order+1] = {0.};
         double sx_old[depos_order+1] = {0.};
 #if defined(WARPX_DIM_3D)
         // Keep these double to avoid bug in single precision.
         double sy_new[depos_order+1] = {0.};
         double sy_old[depos_order+1] = {0.};
 #endif
         // Keep these double to avoid bug in single precision.
         double sz_new[depos_order+1] = {0.};
         double sz_old[depos_order+1] = {0.};
 
         // Compute shape factors for current positions
 
         // i_new leftmost grid point in x that the particle touches
         // sx_new shape factor along x for the centering of each current
         Compute_shape_factor< depos_order > const compute_shape_factor;
         const int i_new = compute_shape_factor(sx_new, x_new);
 #if defined(WARPX_DIM_3D)
         // j_new leftmost grid point in y that the particle touches
         // sy_new shape factor along y for the centering of each current
         const int j_new = compute_shape_factor(sy_new, y_new);
 #endif
         // k_new leftmost grid point in z that the particle touches
         // sz_new shape factor along z for the centering of each current
         const int k_new = compute_shape_factor(sz_new, z_new);
 
         // Compute shape factors for old positions
 
         // i_old leftmost grid point in x that the particle touches
         // sx_old shape factor along x for the centering of each current
         const int i_old = compute_shape_factor(sx_old, x_old);
 #if defined(WARPX_DIM_3D)
         // j_old leftmost grid point in y that the particle touches
         // sy_old shape factor along y for the centering of each current
         const int j_old = compute_shape_factor(sy_old, y_old);
 #endif
         // k_old leftmost grid point in z that the particle touches
         // sz_old shape factor along z for the centering of each current
         const int k_old = compute_shape_factor(sz_old, z_old);
 
         // Deposit current into Dx_arr, Dy_arr and Dz_arr
 #if defined(WARPX_DIM_XZ)
 
         const amrex::Real wqy = wq * vy * invvol;
         for (int k=0; k<=depos_order; k++) {
             for (int i=0; i<=depos_order; i++) {
 
                 // Re-casting sx_new and sz_new from double to amrex::Real so that
                 // Atomic::Add has consistent types in its argument
                 auto const sxn_szn = static_cast<amrex::Real>(sx_new[i] * sz_new[k]);
                 auto const sxo_szn = static_cast<amrex::Real>(sx_old[i] * sz_new[k]);
                 auto const sxn_szo = static_cast<amrex::Real>(sx_new[i] * sz_old[k]);
                 auto const sxo_szo = static_cast<amrex::Real>(sx_old[i] * sz_old[k]);
 
                 if (i_new == i_old && k_new == k_old) {
                     // temp arrays for Dx and Dz
                     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + k_new + k, 0, 0),
                         wq * invvol * invdt * (sxn_szn - sxo_szo));
 
                     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + k_new + k, 0, 1),
                         wq * invvol * invdt * (sxn_szo - sxo_szn));
 
                     // Dy
                     amrex::Gpu::Atomic::AddNoRet(&Dy_arr(lo.x + i_new + i, lo.y + k_new + k, 0, 0),
                         wqy * 0.25_rt * (sxn_szn + sxn_szo + sxo_szn + sxo_szo));
                 } else {
                     // temp arrays for Dx and Dz
                     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + k_new + k, 0, 0),
                         wq * invvol * invdt * sxn_szn);
 
                     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + k_old + k, 0, 0),
                         - wq * invvol * invdt * sxo_szo);
 
                     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + k_old + k, 0, 1),
                         wq * invvol * invdt * sxn_szo);
 
                     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + k_new + k, 0, 1),
                         - wq * invvol * invdt * sxo_szn);
 
                     // Dy
                     amrex::Gpu::Atomic::AddNoRet(&Dy_arr(lo.x + i_new + i, lo.y + k_new + k, 0, 0),
                         wqy * 0.25_rt * sxn_szn);
 
                     amrex::Gpu::Atomic::AddNoRet(&Dy_arr(lo.x + i_new + i, lo.y + k_old + k, 0, 0),
                         wqy * 0.25_rt * sxn_szo);
 
                     amrex::Gpu::Atomic::AddNoRet(&Dy_arr(lo.x + i_old + i, lo.y + k_new + k, 0, 0),
                         wqy * 0.25_rt * sxo_szn);
 
                     amrex::Gpu::Atomic::AddNoRet(&Dy_arr(lo.x + i_old + i, lo.y + k_old + k, 0, 0),
                         wqy * 0.25_rt * sxo_szo);
                 }
 
             }
         }
 
 #elif defined(WARPX_DIM_3D)
 
         for (int k=0; k<=depos_order; k++) {
             for (int j=0; j<=depos_order; j++) {
 
                 auto const syn_szn = static_cast<amrex::Real>(sy_new[j] * sz_new[k]);
                 auto const syo_szn = static_cast<amrex::Real>(sy_old[j] * sz_new[k]);
                 auto const syn_szo = static_cast<amrex::Real>(sy_new[j] * sz_old[k]);
                 auto const syo_szo = static_cast<amrex::Real>(sy_old[j] * sz_old[k]);
 
                 for (int i=0; i<=depos_order; i++) {
 
                     auto const sxn_syn_szn = static_cast<amrex::Real>(sx_new[i]) * syn_szn;
                     auto const sxo_syn_szn = static_cast<amrex::Real>(sx_old[i]) * syn_szn;
                     auto const sxn_syo_szn = static_cast<amrex::Real>(sx_new[i]) * syo_szn;
                     auto const sxo_syo_szn = static_cast<amrex::Real>(sx_old[i]) * syo_szn;
                     auto const sxn_syn_szo = static_cast<amrex::Real>(sx_new[i]) * syn_szo;
                     auto const sxo_syn_szo = static_cast<amrex::Real>(sx_old[i]) * syn_szo;
                     auto const sxn_syo_szo = static_cast<amrex::Real>(sx_new[i]) * syo_szo;
                     auto const sxo_syo_szo = static_cast<amrex::Real>(sx_old[i]) * syo_szo;
 
                     if (i_new == i_old && j_new == j_old && k_new == k_old) {
                         // temp arrays for Dx, Dy and Dz
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 0),
                             wq * invvol * invdt * (sxn_syn_szn - sxo_syo_szo));
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 1),
                             wq * invvol * invdt * (sxn_syn_szo - sxo_syo_szn));
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 2),
                             wq * invvol * invdt * (sxn_syo_szn - sxo_syn_szo));
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 3),
                             wq * invvol * invdt * (sxo_syn_szn - sxn_syo_szo));
                     } else {
                         // temp arrays for Dx, Dy and Dz
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 0),
                             wq * invvol * invdt * sxn_syn_szn);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_old + j, lo.z + k_old + k, 0),
                             - wq * invvol * invdt * sxo_syo_szo);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_old + k, 1),
                             wq * invvol * invdt * sxn_syn_szo);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_old + j, lo.z + k_new + k, 1),
                             - wq * invvol * invdt * sxo_syo_szn);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_old + j, lo.z + k_new + k, 2),
                             wq * invvol * invdt * sxn_syo_szn);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_new + j, lo.z + k_old + k, 2),
                             - wq * invvol * invdt * sxo_syn_szo);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_new + j, lo.z + k_new + k, 3),
                             wq * invvol * invdt * sxo_syn_szn);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_old + j, lo.z + k_old + k, 3),
                             - wq * invvol * invdt * sxn_syo_szo);
                     }
                 }
             }
         }
 #endif
     } );
 
 #if defined(WARPX_DIM_3D)
     amrex::ParallelFor(Dx_fab.box(), [=] AMREX_GPU_DEVICE (int i, int j, int k) noexcept
     {
         const amrex::Real t_a = temp_arr(i,j,k,0);
         const amrex::Real t_b = temp_arr(i,j,k,1);
         const amrex::Real t_c = temp_arr(i,j,k,2);
         const amrex::Real t_d = temp_arr(i,j,k,3);
         Dx_arr(i,j,k) += (1._rt/6._rt)*(2_rt*t_a       + t_b       + t_c - 2._rt*t_d);
         Dy_arr(i,j,k) += (1._rt/6._rt)*(2_rt*t_a       + t_b - 2._rt*t_c       + t_d);
         Dz_arr(i,j,k) += (1._rt/6._rt)*(2_rt*t_a - 2._rt*t_b       + t_c       + t_d);
     });
 #elif defined(WARPX_DIM_XZ)
     amrex::ParallelFor(Dx_fab.box(), [=] AMREX_GPU_DEVICE (int i, int j, int) noexcept
     {
         const amrex::Real t_a = temp_arr(i,j,0,0);
         const amrex::Real t_b = temp_arr(i,j,0,1);
         Dx_arr(i,j,0) += (0.5_rt)*(t_a + t_b);
         Dz_arr(i,j,0) += (0.5_rt)*(t_a - t_b);
     });
 #endif
     // Synchronize so that temp_fab can be safely deallocated in its destructor
     amrex::Gpu::streamSynchronize();
 
 #endif // #if !(defined WARPX_DIM_RZ || defined WARPX_DIM_1D_Z)
 }
 
 // template <int depos_order>
 // void doVayDepositionShapeN (const GetParticlePosition<PIdx>& GetPosition,
 //                             const amrex::ParticleReal* const wp,
 //                             const amrex::ParticleReal* const uxp,
 //                             const amrex::ParticleReal* const uyp,
 //                             const amrex::ParticleReal* const uzp,
 //                             const int* const ion_lev,
 //                             amrex::FArrayBox& Dx_fab,
 //                             amrex::FArrayBox& Dy_fab,
 //                             amrex::FArrayBox& Dz_fab,
 //                             long np_to_deposit,
 //                             amrex::Real dt,
 //                             amrex::Real relative_time,
 //                             const amrex::XDim3 & dinv,
 //                             const amrex::XDim3 & xyzmin,
 //                             amrex::Dim3 lo,
 //                             amrex::Real q,
 //                             [[maybe_unused]]int n_rz_azimuthal_modes)
 // {
 //     uint64_t step0=rdtscv();
 //     using namespace amrex::literals;
 
 //     // If ion_lev is a null pointer, then do_ionization=0, else do_ionization=1
 //     const bool do_ionization = ion_lev;
 
 //     // Inverse of time step
 //     const amrex::Real invdt = 1._rt / dt;
 
 //     const amrex::Real invvol = dinv.x*dinv.y*dinv.z;
 
 //     // Allocate temporary arrays
 //     AMREX_ALWAYS_ASSERT(Dx_fab.box() == Dy_fab.box() && Dx_fab.box() == Dz_fab.box());
 //     amrex::FArrayBox temp_fab{Dx_fab.box(), 4};
 
 //     temp_fab.setVal<amrex::RunOn::Device>(0._rt);
 //     amrex::Array4<amrex::Real> const& temp_arr = temp_fab.array();
 
 //     // Inverse of light speed squared
 //     const amrex::Real invcsq = 1._rt / (PhysConst::c * PhysConst::c);
 
 //     // Arrays where D will be stored
 //     amrex::Array4<amrex::Real> const& Dx_arr = Dx_fab.array();
 //     amrex::Array4<amrex::Real> const& Dy_arr = Dy_fab.array();
 //     amrex::Array4<amrex::Real> const& Dz_arr = Dz_fab.array();
 
 
 //     // Loop over particles and deposit (Dx,Dy,Dz) into Dx_fab, Dy_fab and Dz_fab
 //     // amrex::ParallelFor(np_to_deposit, [&] AMREX_GPU_DEVICE (long ip)
 //     for(int ip=0;ip<np_to_deposit;ip++)
 //     {
 //         uint64_t t0 = rdtscv();
 //         // Inverse of Lorentz factor gamma
 //         const amrex::Real invgam = 1._rt / std::sqrt(1._rt + uxp[ip] * uxp[ip] * invcsq
 //                                                            + uyp[ip] * uyp[ip] * invcsq
 //                                                            + uzp[ip] * uzp[ip] * invcsq);
 //         // Product of particle charges and weights
 //         amrex::Real wq = q * wp[ip];
 //         if (do_ionization) { wq *= ion_lev[ip]; }
 
 //         // Current particle positions (in physical units)
 //         amrex::ParticleReal xp, yp, zp;
 //         GetPosition(ip, xp, yp, zp);
 
 //         // Particle velocities
 //         const amrex::Real vx = uxp[ip] * invgam;
 //         const amrex::Real vy = uyp[ip] * invgam;
 //         const amrex::Real vz = uzp[ip] * invgam;
 
 //         // Modify the particle position to match the time of the deposition
 //         xp += relative_time * vx;
 //         yp += relative_time * vy;
 //         zp += relative_time * vz;
 
 //         // Current and old particle positions in grid units
 //         // Keep these double to avoid bug in single precision.
 //         double const x_new = (xp - xyzmin.x + 0.5_rt*dt*vx) * dinv.x;
 //         double const x_old = (xp - xyzmin.x - 0.5_rt*dt*vx) * dinv.x;
 //         // Keep these double to avoid bug in single precision.
 //         double const y_new = (yp - xyzmin.y + 0.5_rt*dt*vy) * dinv.y;
 //         double const y_old = (yp - xyzmin.y - 0.5_rt*dt*vy) * dinv.y;
 //         // Keep these double to avoid bug in single precision.
 //         double const z_new = (zp - xyzmin.z + 0.5_rt*dt*vz) * dinv.z;
 //         double const z_old = (zp - xyzmin.z - 0.5_rt*dt*vz) * dinv.z;
 //         if(x_new<0)
 //         {
 //             printf("X new < 0 %f\n", x_new);
 //             amrex::Abort("END");
 //         }
 
 //         // Shape factor arrays for current and old positions (nodal)
 //         // Keep these double to avoid bug in single precision.
 //         double sx_new[depos_order+1] = {0.};
 //         double sx_old[depos_order+1] = {0.};
 //         // Keep these double to avoid bug in single precision.
 //         double sy_new[depos_order+1] = {0.};
 //         double sy_old[depos_order+1] = {0.};
 //         // Keep these double to avoid bug in single precision.
 //         double sz_new[depos_order+1] = {0.};
 //         double sz_old[depos_order+1] = {0.};
 
 //         // Compute shape factors for current positions
 
 //         // i_new leftmost grid point in x that the particle touches
 //         // sx_new shape factor along x for the centering of each current
 //         Compute_shape_factor< depos_order > const compute_shape_factor;
 //         const int i_new = compute_shape_factor(sx_new, x_new);
 //         // j_new leftmost grid point in y that the particle touches
 //         // sy_new shape factor along y for the centering of each current
 //         const int j_new = compute_shape_factor(sy_new, y_new);
 //         // k_new leftmost grid point in z that the particle touches
 //         // sz_new shape factor along z for the centering of each current
 //         const int k_new = compute_shape_factor(sz_new, z_new);
 
 //         if(i_new<0)
 //         {
 //             printf("i new < 0 %f\n", i_new);
 //             amrex::Abort("i new <0");
 //         }
 //         // Compute shape factors for old positions
 
 //         // i_old leftmost grid point in x that the particle touches
 //         // sx_old shape factor along x for the centering of each current
 //         const int i_old = compute_shape_factor(sx_old, x_old);
 //         // j_old leftmost grid point in y that the particle touches
 //         // sy_old shape factor along y for the centering of each current
 //         const int j_old = compute_shape_factor(sy_old, y_old);
 //         // k_old leftmost grid point in z that the particle touches
 //         // sz_old shape factor along z for the centering of each current
 //         const int k_old = compute_shape_factor(sz_old, z_old);
 //         uint64_t t1 = rdtscv();
 //         pre_time += (t1-t0);
 //         // Deposit current into Dx_arr, Dy_arr and Dz_arr
 // #if 0 // Orgin Unroll
 //         for (int k=0; k<=depos_order; k++) {
 //             for (int j=0; j<=depos_order; j++) {
 //             uint64_t tt0 = rdtscv();
 //                 auto const syn_szn = static_cast<amrex::Real>(sy_new[j] * sz_new[k]);
 //                 auto const syo_szn = static_cast<amrex::Real>(sy_old[j] * sz_new[k]);
 //                 auto const syn_szo = static_cast<amrex::Real>(sy_new[j] * sz_old[k]);
 //                 auto const syo_szo = static_cast<amrex::Real>(sy_old[j] * sz_old[k]);
 //             // uint64_t tt1 = rdtscv();
 //             // cal_time += (tt1-tt0);
 //                 // for (int i=0; i<=depos_order; i++) {
 //             // uint64_t tt2 = rdtscv();
 //                     auto const sxn_syn_szn = static_cast<amrex::Real>(sx_new[0]) * syn_szn;
 //                     auto const sxo_syn_szn = static_cast<amrex::Real>(sx_old[0]) * syn_szn;
 //                     auto const sxn_syo_szn = static_cast<amrex::Real>(sx_new[0]) * syo_szn;
 //                     auto const sxo_syo_szn = static_cast<amrex::Real>(sx_old[0]) * syo_szn;
 //                     auto const sxn_syn_szo = static_cast<amrex::Real>(sx_new[0]) * syn_szo;
 //                     auto const sxo_syn_szo = static_cast<amrex::Real>(sx_old[0]) * syn_szo;
 //                     auto const sxn_syo_szo = static_cast<amrex::Real>(sx_new[0]) * syo_szo;
 //                     auto const sxo_syo_szo = static_cast<amrex::Real>(sx_old[0]) * syo_szo;
 //                     //1
 //                     auto const sxn_syn_szn1 = static_cast<amrex::Real>(sx_new[1]) * syn_szn;
 //                     auto const sxo_syn_szn1 = static_cast<amrex::Real>(sx_old[1]) * syn_szn;
 //                     auto const sxn_syo_szn1 = static_cast<amrex::Real>(sx_new[1]) * syo_szn;
 //                     auto const sxo_syo_szn1 = static_cast<amrex::Real>(sx_old[1]) * syo_szn;
 //                     auto const sxn_syn_szo1 = static_cast<amrex::Real>(sx_new[1]) * syn_szo;
 //                     auto const sxo_syn_szo1 = static_cast<amrex::Real>(sx_old[1]) * syn_szo;
 //                     auto const sxn_syo_szo1 = static_cast<amrex::Real>(sx_new[1]) * syo_szo;
 //                     auto const sxo_syo_szo1 = static_cast<amrex::Real>(sx_old[1]) * syo_szo;
 //                     //2
 //                     auto const sxn_syn_szn2 = static_cast<amrex::Real>(sx_new[2]) * syn_szn;
 //                     auto const sxo_syn_szn2 = static_cast<amrex::Real>(sx_old[2]) * syn_szn;
 //                     auto const sxn_syo_szn2 = static_cast<amrex::Real>(sx_new[2]) * syo_szn;
 //                     auto const sxo_syo_szn2 = static_cast<amrex::Real>(sx_old[2]) * syo_szn;
 //                     auto const sxn_syn_szo2 = static_cast<amrex::Real>(sx_new[2]) * syn_szo;
 //                     auto const sxo_syn_szo2 = static_cast<amrex::Real>(sx_old[2]) * syn_szo;
 //                     auto const sxn_syo_szo2 = static_cast<amrex::Real>(sx_new[2]) * syo_szo;
 //                     auto const sxo_syo_szo2 = static_cast<amrex::Real>(sx_old[2]) * syo_szo;
 //                     //3
 //                     auto const sxn_syn_szn3 = static_cast<amrex::Real>(sx_new[3]) * syn_szn;
 //                     auto const sxo_syn_szn3 = static_cast<amrex::Real>(sx_old[3]) * syn_szn;
 //                     auto const sxn_syo_szn3 = static_cast<amrex::Real>(sx_new[3]) * syo_szn;
 //                     auto const sxo_syo_szn3 = static_cast<amrex::Real>(sx_old[3]) * syo_szn;
 //                     auto const sxn_syn_szo3 = static_cast<amrex::Real>(sx_new[3]) * syn_szo;
 //                     auto const sxo_syn_szo3 = static_cast<amrex::Real>(sx_old[3]) * syn_szo;
 //                     auto const sxn_syo_szo3 = static_cast<amrex::Real>(sx_new[3]) * syo_szo;
 //                     auto const sxo_syo_szo3 = static_cast<amrex::Real>(sx_old[3]) * syo_szo;
 
 //             uint64_t t2 = rdtscv();
 //             cal_time += (t2-tt0);
 
 //                     if (i_new == i_old && j_new == j_old && k_new == k_old) {
 //                         // temp arrays for Dx, Dy and Dz
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_new + j, lo.z + k_new + k, 0),
 //                             wq * invvol * invdt * (sxn_syn_szn - sxo_syo_szo));
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_new + j, lo.z + k_new + k, 1),
 //                             wq * invvol * invdt * (sxn_syn_szo - sxo_syo_szn));
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_new + j, lo.z + k_new + k, 2),
 //                             wq * invvol * invdt * (sxn_syo_szn - sxo_syn_szo));
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_new + j, lo.z + k_new + k, 3),
 //                             wq * invvol * invdt * (sxo_syn_szn - sxn_syo_szo));
 //                         // 1
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_new + j, lo.z + k_new + k, 0),
 //                             wq * invvol * invdt * (sxn_syn_szn1 - sxo_syo_szo1));
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_new + j, lo.z + k_new + k, 1),
 //                             wq * invvol * invdt * (sxn_syn_szo1 - sxo_syo_szn1));
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_new + j, lo.z + k_new + k, 2),
 //                             wq * invvol * invdt * (sxn_syo_szn1 - sxo_syn_szo1));
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_new + j, lo.z + k_new + k, 3),
 //                             wq * invvol * invdt * (sxo_syn_szn1 - sxn_syo_szo1));
 //                         //2
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_new + j, lo.z + k_new + k, 0),
 //                             wq * invvol * invdt * (sxn_syn_szn2 - sxo_syo_szo2));
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_new + j, lo.z + k_new + k, 1),
 //                             wq * invvol * invdt * (sxn_syn_szo2 - sxo_syo_szn2));
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_new + j, lo.z + k_new + k, 2),
 //                             wq * invvol * invdt * (sxn_syo_szn2 - sxo_syn_szo2));
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_new + j, lo.z + k_new + k, 3),
 //                             wq * invvol * invdt * (sxo_syn_szn2 - sxn_syo_szo2));
 //                         //3
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_new + j, lo.z + k_new + k, 0),
 //                             wq * invvol * invdt * (sxn_syn_szn3 - sxo_syo_szo3));
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_new + j, lo.z + k_new + k, 1),
 //                             wq * invvol * invdt * (sxn_syn_szo3 - sxo_syo_szn3));
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_new + j, lo.z + k_new + k, 2),
 //                             wq * invvol * invdt * (sxn_syo_szn3 - sxo_syn_szo3));
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_new + j, lo.z + k_new + k, 3),
 //                             wq * invvol * invdt * (sxo_syn_szn3 - sxn_syo_szo3));
 //                     } else {
 //                         // temp arrays for Dx, Dy and Dz
 //                         //0
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_new + j, lo.z + k_new + k, 0),
 //                             wq * invvol * invdt * sxn_syn_szn);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 0, lo.y + j_old + j, lo.z + k_old + k, 0),
 //                             - wq * invvol * invdt * sxo_syo_szo);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_new + j, lo.z + k_old + k, 1),
 //                             wq * invvol * invdt * sxn_syn_szo);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 0, lo.y + j_old + j, lo.z + k_new + k, 1),
 //                             - wq * invvol * invdt * sxo_syo_szn);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_old + j, lo.z + k_new + k, 2),
 //                             wq * invvol * invdt * sxn_syo_szn);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 0, lo.y + j_new + j, lo.z + k_old + k, 2),
 //                             - wq * invvol * invdt * sxo_syn_szo);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 0, lo.y + j_new + j, lo.z + k_new + k, 3),
 //                             wq * invvol * invdt * sxo_syn_szn);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_old + j, lo.z + k_old + k, 3),
 //                             - wq * invvol * invdt * sxn_syo_szo);
 //                         //1
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_new + j, lo.z + k_new + k, 0),
 //                             wq * invvol * invdt * sxn_syn_szn1);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 1, lo.y + j_old + j, lo.z + k_old + k, 0),
 //                             - wq * invvol * invdt * sxo_syo_szo1);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_new + j, lo.z + k_old + k, 1),
 //                             wq * invvol * invdt * sxn_syn_szo1);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 1, lo.y + j_old + j, lo.z + k_new + k, 1),
 //                             - wq * invvol * invdt * sxo_syo_szn1);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_old + j, lo.z + k_new + k, 2),
 //                             wq * invvol * invdt * sxn_syo_szn1);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 1, lo.y + j_new + j, lo.z + k_old + k, 2),
 //                             - wq * invvol * invdt * sxo_syn_szo1);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 1, lo.y + j_new + j, lo.z + k_new + k, 3),
 //                             wq * invvol * invdt * sxo_syn_szn1);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_old + j, lo.z + k_old + k, 3),
 //                             - wq * invvol * invdt * sxn_syo_szo1);
 //                         //2
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_new + j, lo.z + k_new + k, 0),
 //                             wq * invvol * invdt * sxn_syn_szn2);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 2, lo.y + j_old + j, lo.z + k_old + k, 0),
 //                             - wq * invvol * invdt * sxo_syo_szo2);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_new + j, lo.z + k_old + k, 1),
 //                             wq * invvol * invdt * sxn_syn_szo2);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 2, lo.y + j_old + j, lo.z + k_new + k, 1),
 //                             - wq * invvol * invdt * sxo_syo_szn2);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_old + j, lo.z + k_new + k, 2),
 //                             wq * invvol * invdt * sxn_syo_szn2);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 2, lo.y + j_new + j, lo.z + k_old + k, 2),
 //                             - wq * invvol * invdt * sxo_syn_szo2);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 2, lo.y + j_new + j, lo.z + k_new + k, 3),
 //                             wq * invvol * invdt * sxo_syn_szn2);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_old + j, lo.z + k_old + k, 3),
 //                             - wq * invvol * invdt * sxn_syo_szo2);
 //                         //3
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_new + j, lo.z + k_new + k, 0),
 //                             wq * invvol * invdt * sxn_syn_szn3);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 3, lo.y + j_old + j, lo.z + k_old + k, 0),
 //                             - wq * invvol * invdt * sxo_syo_szo3);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_new + j, lo.z + k_old + k, 1),
 //                             wq * invvol * invdt * sxn_syn_szo3);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 3, lo.y + j_old + j, lo.z + k_new + k, 1),
 //                             - wq * invvol * invdt * sxo_syo_szn3);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_old + j, lo.z + k_new + k, 2),
 //                             wq * invvol * invdt * sxn_syo_szn3);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 3, lo.y + j_new + j, lo.z + k_old + k, 2),
 //                             - wq * invvol * invdt * sxo_syn_szo3);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 3, lo.y + j_new + j, lo.z + k_new + k, 3),
 //                             wq * invvol * invdt * sxo_syn_szn3);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_old + j, lo.z + k_old + k, 3),
 //                             - wq * invvol * invdt * sxn_syo_szo3);
 //                     }
 //             uint64_t t3 = rdtscv();
 //             save_time += (t3-t2);
 
 //                 // }
 //             }
 //         }
 // #elif 0 // orgin
 //         for (int k=0; k<=depos_order; k++) {
 //             for (int j=0; j<=depos_order; j++) {
 //                 uint64_t tt0 = rdtscv();
 //                 auto const syn_szn = static_cast<amrex::Real>(sy_new[j] * sz_new[k]);
 //                 auto const syo_szn = static_cast<amrex::Real>(sy_old[j] * sz_new[k]);
 //                 auto const syn_szo = static_cast<amrex::Real>(sy_new[j] * sz_old[k]);
 //                 auto const syo_szo = static_cast<amrex::Real>(sy_old[j] * sz_old[k]);
 //                 uint64_t tt1 = rdtscv();
 //                 cal_time += (tt1-tt0);
 //                 for (int i=0; i<=depos_order; i++) {
 //                     uint64_t tt2 = rdtscv();
 //                     auto const sxn_syn_szn = static_cast<amrex::Real>(sx_new[i]) * syn_szn;
 //                     auto const sxo_syn_szn = static_cast<amrex::Real>(sx_old[i]) * syn_szn;
 //                     auto const sxn_syo_szn = static_cast<amrex::Real>(sx_new[i]) * syo_szn;
 //                     auto const sxo_syo_szn = static_cast<amrex::Real>(sx_old[i]) * syo_szn;
 //                     auto const sxn_syn_szo = static_cast<amrex::Real>(sx_new[i]) * syn_szo;
 //                     auto const sxo_syn_szo = static_cast<amrex::Real>(sx_old[i]) * syn_szo;
 //                     auto const sxn_syo_szo = static_cast<amrex::Real>(sx_new[i]) * syo_szo;
 //                     auto const sxo_syo_szo = static_cast<amrex::Real>(sx_old[i]) * syo_szo;
 //                     uint64_t t2 = rdtscv();
 //                     cal_time += (t2-tt2);
 //                     if (i_new == i_old && j_new == j_old && k_new == k_old) {
 //                         // temp arrays for Dx, Dy and Dz
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 0),
 //                             wq * invvol * invdt * (sxn_syn_szn - sxo_syo_szo));
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 1),
 //                             wq * invvol * invdt * (sxn_syn_szo - sxo_syo_szn));
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 2),
 //                             wq * invvol * invdt * (sxn_syo_szn - sxo_syn_szo));
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 3),
 //                             wq * invvol * invdt * (sxo_syn_szn - sxn_syo_szo));
 //                     } else {
 //                         // temp arrays for Dx, Dy and Dz
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 0),
 //                             wq * invvol * invdt * sxn_syn_szn);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_old + j, lo.z + k_old + k, 0),
 //                             - wq * invvol * invdt * sxo_syo_szo);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_old + k, 1),
 //                             wq * invvol * invdt * sxn_syn_szo);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_old + j, lo.z + k_new + k, 1),
 //                             - wq * invvol * invdt * sxo_syo_szn);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_old + j, lo.z + k_new + k, 2),
 //                             wq * invvol * invdt * sxn_syo_szn);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_new + j, lo.z + k_old + k, 2),
 //                             - wq * invvol * invdt * sxo_syn_szo);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_new + j, lo.z + k_new + k, 3),
 //                             wq * invvol * invdt * sxo_syn_szn);
 
 //                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_old + j, lo.z + k_old + k, 3),
 //                             - wq * invvol * invdt * sxn_syo_szo);
 //                     }
 //                 uint64_t t3 = rdtscv();
 //                 save_time += (t3-t2);
 //                 }
 //             }
 //         }
 // #elif 0 // SVE
 //         uint64_t tt1 = rdtscv();
 //         svbool_t p = svwhilele_b64(0,depos_order+1);
 //         Vec sx_new_v = Vec::Load(p, &sx_new[0]);
 //         Vec sx_old_v = Vec::Load(p, &sx_old[0]);
 //         uint64_t tt2 = rdtscv();
 //         cal_time += (tt2-tt1);
 
 //         for (int k=0; k<=depos_order; k++) {
 //             for (int j=0; j<=depos_order; j++) {
             
 //                 uint64_t tt0 = rdtscv();
 //                 auto const syn_szn = static_cast<amrex::Real>(sy_new[j] * sz_new[k]);
 //                 auto const syo_szn = static_cast<amrex::Real>(sy_old[j] * sz_new[k]);
 //                 auto const syn_szo = static_cast<amrex::Real>(sy_new[j] * sz_old[k]);
 //                 auto const syo_szo = static_cast<amrex::Real>(sy_old[j] * sz_old[k]);
 
                 
 //                 Vec sxn_syn_szn = (sx_new_v) * syn_szn;
 //                 Vec sxo_syn_szn = (sx_old_v) * syn_szn;
 //                 Vec sxn_syo_szn = (sx_new_v) * syo_szn;
 //                 Vec sxo_syo_szn = (sx_old_v) * syo_szn;
 //                 Vec sxn_syn_szo = (sx_new_v) * syn_szo;
 //                 Vec sxo_syn_szo = (sx_old_v) * syn_szo;
 //                 Vec sxn_syo_szo = (sx_new_v) * syo_szo;
 //                 Vec sxo_syo_szo = (sx_old_v) * syo_szo;
 //                 uint64_t t2 = rdtscv();
 //                 cal_time += (t2-tt0);
 
 //                     if (i_new == i_old && j_new == j_old && k_new == k_old) {
 //                         Vec save_0 = wq * invvol * invdt * (sxn_syn_szn - sxo_syo_szo);
 //                         Vec save_1 = wq * invvol * invdt * (sxn_syn_szo - sxo_syo_szn);
 //                         Vec save_2 = wq * invvol * invdt * (sxn_syo_szn - sxo_syn_szo);
 //                         Vec save_3 = wq * invvol * invdt * (sxo_syn_szn - sxn_syo_szo);
 //                         double* ptr = &temp_arr(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 0);
 //                         Vec v0=Vec::Load(p,ptr);
 //                         (v0+save_0).Store(p,ptr);
 //                         ptr = &temp_arr(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 1);
 //                         Vec v1=Vec::Load(p,ptr);
 //                         (v1+save_1).Store(p,ptr);
 //                         ptr = &temp_arr(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 2);
 //                         Vec v2=Vec::Load(p,ptr);
 //                         (v2+save_2).Store(p,ptr);
 //                         ptr = &temp_arr(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 3);
 //                         Vec v3=Vec::Load(p,ptr);
 //                         (v3+save_3).Store(p,ptr);
 //                         // temp arrays for Dx, Dy and Dz
 //                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 0),
 //                         //     wq * invvol * invdt * (sxn_syn_szn - sxo_syo_szo));
 
 //                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 1),
 //                         //     wq * invvol * invdt * (sxn_syn_szo - sxo_syo_szn));
 
 //                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 2),
 //                         //     wq * invvol * invdt * (sxn_syo_szn - sxo_syn_szo));
 
 //                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 3),
 //                         //     wq * invvol * invdt * (sxo_syn_szn - sxn_syo_szo));
 //                     } else {
 //                         Vec save_00 =wq * invvol * invdt * sxn_syn_szn;
 //                         Vec save_01 =- wq * invvol * invdt * sxo_syo_szo;
 //                         Vec save_10 =wq * invvol * invdt * sxn_syn_szo;
 //                         Vec save_11 =- wq * invvol * invdt * sxo_syo_szn;
 //                         Vec save_20 =wq * invvol * invdt * sxn_syo_szn;
 //                         Vec save_21 =- wq * invvol * invdt * sxo_syn_szo;
 //                         Vec save_30 =wq * invvol * invdt * sxo_syn_szn;
 //                         Vec save_31 =- wq * invvol * invdt * sxn_syo_szo;
 //                         double* ptr = &temp_arr(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 0);
 //                         Vec v0=Vec::Load(p,ptr);
 //                         (v0+save_00).Store(p,ptr);
 //                         (v0+save_01).Store(p,ptr);
 //                         ptr = &temp_arr(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 1);
 //                         Vec v1=Vec::Load(p,ptr);
 //                         (v1+save_10).Store(p,ptr);
 //                         (v1+save_11).Store(p,ptr);
 //                         ptr = &temp_arr(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 2);
 //                         Vec v2=Vec::Load(p,ptr);
 //                         (v2+save_20).Store(p,ptr);
 //                         (v2+save_21).Store(p,ptr);
 //                         ptr = &temp_arr(lo.x + i_new, lo.y + j_new + j, lo.z + k_new + k, 3);
 //                         Vec v3=Vec::Load(p,ptr);
 //                         (v3+save_30).Store(p,ptr);                        
 //                         (v3+save_31).Store(p,ptr);                        
 //                         // temp arrays for Dx, Dy and Dz
 //                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 0),
 //                         //     wq * invvol * invdt * sxn_syn_szn);
 
 //                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_old + j, lo.z + k_old + k, 0),
 //                         //     - wq * invvol * invdt * sxo_syo_szo);
 
 //                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_old + k, 1),
 //                         //     wq * invvol * invdt * sxn_syn_szo);
 
 //                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_old + j, lo.z + k_new + k, 1),
 //                         //     - wq * invvol * invdt * sxo_syo_szn);
 
 //                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_old + j, lo.z + k_new + k, 2),
 //                         //     wq * invvol * invdt * sxn_syo_szn);
 
 //                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_new + j, lo.z + k_old + k, 2),
 //                         //     - wq * invvol * invdt * sxo_syn_szo);
 
 //                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_new + j, lo.z + k_new + k, 3),
 //                         //     wq * invvol * invdt * sxo_syn_szn);
 
 //                         // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_old + j, lo.z + k_old + k, 3),
 //                         //     - wq * invvol * invdt * sxn_syo_szo);
 //                     }
 //             uint64_t t3 = rdtscv();
 //             save_time += (t3-t2);
 
 //                 // }
 //             }
 //         }
 
 // #elif 0 //SME
 //         VayDepositionSME<depos_order>(
 //             sx_new,sx_old,
 //             sy_new,sy_old,
 //             sz_new,sz_old,
 //             temp_arr, i_new,j_new,k_new, i_old,j_old,k_old,
 //             lo, wq, invvol, invdt);
 // #elif 1 //SME2
 //         VayDepositionSME2<depos_order>(
 //             sx_new,sx_old,
 //             sy_new,sy_old,
 //             sz_new,sz_old,
 //             temp_arr, i_new,j_new,k_new, i_old,j_old,k_old,
 //             lo, wq, invvol, invdt);
 // #endif
 //     }
 //     //  );
 
 //     uint64_t t4 = rdtscv();
 //     amrex::ParallelFor(Dx_fab.box(), [&] AMREX_GPU_DEVICE (int i, int j, int k) noexcept
 //     {
 //         const amrex::Real t_a = temp_arr(i,j,k,0);
 //         const amrex::Real t_b = temp_arr(i,j,k,1);
 //         const amrex::Real t_c = temp_arr(i,j,k,2);
 //         const amrex::Real t_d = temp_arr(i,j,k,3);
 //         Dx_arr(i,j,k) += (1._rt/6._rt)*(2_rt*t_a       + t_b       + t_c - 2._rt*t_d);
 //         Dy_arr(i,j,k) += (1._rt/6._rt)*(2_rt*t_a       + t_b - 2._rt*t_c       + t_d);
 //         Dz_arr(i,j,k) += (1._rt/6._rt)*(2_rt*t_a - 2._rt*t_b       + t_c       + t_d);
 //     });
 //     uint64_t t5 = rdtscv();
 //     post_time += (t5-t4);
 //     // Synchronize so that temp_fab can be safely deallocated in its destructor
 //     amrex::Gpu::streamSynchronize();
 
 // uint64_t step1=rdtscv();
 // step_time=(step1-step0);
 // printf("\n Step_time: %d, pre_time: %d,  cal_time: %d,  read_time: %d, save_time1: %d,save_time2: %d,save_time: %d,  post_time: %d \n", step_time,pre_time, cal_time,  read_time, save_time1,save_time2,save_time,  post_time);
 // amrex::Abort("No Trans Test Over!");
 // }
 
 __arm_new("za") inline svint64_t csf_sme(int64_t* i_new,double* sx[], MVec xmid, svbool_t p) __arm_streaming {
         MVec j = svrintz_x(p, xmid);
         MVec xint = xmid - j;
         MVec temp = 1.0 - xint;
         MVec sx0 = (1.0 / 6.0) * temp * temp * temp;
         MVec sx1 = (2.0 / 3.0) - xint * xint * (1.0 - xint * 0.5);
         MVec sx2 = (2.0 / 3.0) - temp * temp * (1.0 - 0.5 *temp);
         MVec sx3 = (1.0 / 6.0) * xint * xint * xint;
         sx0.Store(p, sx[0]);
         sx1.Store(p, sx[1]);
         sx2.Store(p, sx[2]);
         sx3.Store(p, sx[3]);
         svint64_t i_newv=svsub_x(p, svcvt_s64_x(p,j), svdup_s64(1));
         svst1(p, i_new, i_newv);
         return i_newv;
     };
 
 template <int depos_order>
 __arm_new("za") inline void VayDepositionSME_trans(
                             const GetParticlePosition<PIdx>& GetPosition,
                             const amrex::ParticleReal* const wp,
                             const amrex::ParticleReal* const uxp,
                             const amrex::ParticleReal* const uyp,
                             const amrex::ParticleReal* const uzp,
                             const int* const ion_lev,
                             long np_to_deposit,
                             amrex::Real dt,
                             amrex::Real relative_time,
                             const amrex::XDim3 & dinv,
                             const amrex::XDim3 & xyzmin,
                             amrex::Dim3 lo,
                             amrex::Real q,  double invvol, double invdt,
                             const amrex::Real invcsq, const amrex::Array4<amrex::Real>& temp_arr,
                             amrex::Array4<amrex::Real> const& Dx_arr, 
                             amrex::Array4<amrex::Real> const& Dy_arr,
                             amrex::Array4<amrex::Real> const& Dz_arr,
                             amrex::FArrayBox& Dx_fab
 )__arm_streaming
 {
     using namespace amrex::literals;
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
 
     // auto compute_shape_factor_v = __arm_new("za") [](int64_t* i_new, double* sx[], MVec xmid, svbool_t p) __arm_streaming {
     //     MVec j = svrintz_x(p, xmid);
     //     MVec xint = xmid - j;
     //     MVec temp = 1.0 - xint;
     //     MVec sx0 = (1.0 / 6.0) * temp * temp * temp;
     //     MVec sx1 = (2.0 / 3.0) - xint * xint * (1.0 - xint * 0.5);
     //     MVec sx2 = (2.0 / 3.0) - temp * temp * (1.0 - 0.5 *temp);
     //     MVec sx3 = (1.0 / 6.0) * xint * xint * xint;
     //     sx0.Store(p, sx[0]);
     //     sx1.Store(p, sx[1]);
     //     sx2.Store(p, sx[2]);
     //     sx3.Store(p, sx[3]);
     //     svst1(p, i_new, svsub_x(p, svcvt_s64_x(p,j), svdup_s64(1)));
     // };
     // auto compute_shape_factor_v2 = [](int64_t* i_new,double* sx[], MVec xmid, svbool_t p) __arm_streaming {
     //     MVec j = svrintz_x(p, xmid);
     //     MVec xint = xmid - j;
     //     MVec temp = 1.0 - xint;
     //     MVec sx0 = (1.0 / 6.0) * temp * temp * temp;
     //     MVec sx1 = (2.0 / 3.0) - xint * xint * (1.0 - xint * 0.5);
     //     MVec sx2 = (2.0 / 3.0) - temp * temp * (1.0 - 0.5 *temp);
     //     MVec sx3 = (1.0 / 6.0) * xint * xint * xint;
     //     sx0.Store(p, sx[0]);
     //     sx1.Store(p, sx[1]);
     //     sx2.Store(p, sx[2]);
     //     sx3.Store(p, sx[3]);
     //     svint64_t i_newv=svsub_x(p, svcvt_s64_x(p,j), svdup_s64(1));
     //     svst1(p, i_new, i_newv);
     //     return i_newv;
     // };
     auto compute_shape_factor_v2 = csf_sme;
     MVec vzero(0);
     const int block_size=256;
     long n_blocks=np_to_deposit/block_size;
     int vl=svcntd();
 
     // std::MVector<double> x_newv(np_to_deposit,0);
     for(int block_id=0;block_id<n_blocks;block_id++){
 
         double wq[block_size];
 
         double sx_new_m[depos_order + 1][block_size] = {0.};
         double sx_old_m[depos_order + 1][block_size] = {0.};
         double sy_new_m[depos_order + 1][block_size] = {0.};
         double sy_old_m[depos_order + 1][block_size] = {0.};
         double sz_new_m[depos_order + 1][block_size] = {0.};
         double sz_old_m[depos_order + 1][block_size] = {0.};
 
         int64_t i_new[block_size];
         int64_t i_old[block_size];
         int64_t j_new[block_size];
         int64_t j_old[block_size];
         int64_t k_new[block_size];
         int64_t k_old[block_size];
         uint64_t branch_index[block_size];
 
         // uint64_t indices0[block_size];
         // uint64_t indices1[block_size];
         // uint64_t indices2[block_size];
         // uint64_t indices3[block_size];
         // uint64_t indices0old[block_size];
         // uint64_t indices1old[block_size];
         // uint64_t indices2old[block_size];
         // uint64_t indices3old[block_size];
 
         // double sxn_syn_szn_v[4][block_size] = {0.};
         // double sxo_syn_szn_v[4][block_size] = {0.};
         // double sxn_syo_szn_v[4][block_size] = {0.};
         // double sxo_syo_szn_v[4][block_size] = {0.};
         // double sxn_syn_szo_v[4][block_size] = {0.};
         // double sxo_syn_szo_v[4][block_size] = {0.};
         // double sxn_syo_szo_v[4][block_size] = {0.};
         // double sxo_syo_szo_v[4][block_size] = {0.};
 
         svuint64_t ones=svdup_u64(1);
         svuint64_t zeros=svdup_u64(0);
 
         for(int iip=0;iip<block_size/vl;iip+=vl){
             long ip=iip+block_id*block_size;
             uint64_t t0 = rdtscm();
             svbool_t p_ip=svwhilele_b64(ip,np_to_deposit);
             // Inverse of Lorentz factor gamma
             MVec uxp_v=MVec::Load(p_ip,&uxp[ip]);
             MVec uyp_v=MVec::Load(p_ip,&uyp[ip]);
             MVec uzp_v=MVec::Load(p_ip,&uzp[ip]);
             MVec invgam = 1.0 / (1.0 +  uxp_v * uxp_v * invcsq
                                         + uyp_v * uyp_v * invcsq
                                         + uzp_v * uzp_v * invcsq).Sqrt();
             // Product of particle charges and weights
             MVec wp_v=MVec::Load(p_ip,&wp[ip]);
             MVec wq_v = q * wp_v;
             wq_v.Store(p_ip, &wq[iip]);
 
             // Current particle positions (in physical units)
             MVec xp = MVec::Load(p_ip, &mx[ip]);
             MVec yp = MVec::Load(p_ip, &my[ip]);
             MVec zp = MVec::Load(p_ip, &mz[ip]);
 
             // Particle velocities
             MVec vx = uxp_v * invgam;
             MVec vy = uyp_v * invgam;
             MVec vz = uzp_v * invgam;
 
             // Modify the particle position to match the time of the deposition
             xp += relative_time * vx;
             yp += relative_time * vy;
             zp += relative_time * vz;
 
             // Current and old particle positions in grid units
             // Keep these double to avoid bug in single precision.
             MVec x_new = (xp - xyzmin.x + 0.5_rt*dt*vx) * dinv.x;
             MVec x_old = (xp - xyzmin.x - 0.5_rt*dt*vx) * dinv.x;
             MVec y_new = (yp - xyzmin.y + 0.5_rt*dt*vy) * dinv.y;
             MVec y_old = (yp - xyzmin.y - 0.5_rt*dt*vy) * dinv.y;
             MVec z_new = (zp - xyzmin.z + 0.5_rt*dt*vz) * dinv.z;
             MVec z_old = (zp - xyzmin.z - 0.5_rt*dt*vz) * dinv.z;
 
             double* sx_new_temp[4] = {&sx_new_m[0][iip], &sx_new_m[1][iip], &sx_new_m[2][iip], &sx_new_m[3][iip]};
             double* sx_old_temp[4] = {&sx_old_m[0][iip], &sx_old_m[1][iip], &sx_old_m[2][iip], &sx_old_m[3][iip]};
             svint64_t i_newv=compute_shape_factor_v2(&i_new[iip], sx_new_temp, x_new, p_ip);
             svint64_t i_oldv=compute_shape_factor_v2(&i_old[iip], sx_old_temp, x_old, p_ip);
             double* sy_new_temp[4] = {&sy_new_m[0][iip], &sy_new_m[1][iip], &sy_new_m[2][iip], &sy_new_m[3][iip]};
             double* sy_old_temp[4] = {&sy_old_m[0][iip], &sy_old_m[1][iip], &sy_old_m[2][iip], &sy_old_m[3][iip]};
             svint64_t j_newv=compute_shape_factor_v2(&j_new[iip], sy_new_temp, y_new, p_ip);
             svint64_t j_oldv=compute_shape_factor_v2(&j_old[iip], sy_old_temp, y_old, p_ip);
 
             double* sz_new_temp[4] = {&sz_new_m[0][iip], &sz_new_m[1][iip], &sz_new_m[2][iip], &sz_new_m[3][iip]};
             double* sz_old_temp[4] = {&sz_old_m[0][iip], &sz_old_m[1][iip], &sz_old_m[2][iip], &sz_old_m[3][iip]};
             svint64_t k_newv=compute_shape_factor_v2(&k_new[iip], sz_new_temp, z_new, p_ip);
             svint64_t k_oldv=compute_shape_factor_v2(&k_old[iip], sz_old_temp, z_old, p_ip);
             svbool_t p_i=svcmpeq_s64(p_ip,i_newv,i_oldv);
             svbool_t p_j=svcmpeq_s64(p_ip,j_newv,j_oldv);
             svbool_t p_k=svcmpeq_s64(p_ip,k_newv,k_oldv);
             p_i=svand_z(p_ip,p_i,p_j);
             p_i=svand_z(p_ip,p_i,p_k);
             svuint64_t p_bran=svsel(p_i,ones,zeros);
             svst1(p_ip,&branch_index[iip],p_bran);
             
             uint64_t t1 = rdtscm();
             pre_time += (t1-t0);
         }
         double sx_new_mT[block_size][depos_order + 1] = {0.};
         double sx_old_mT[block_size][depos_order + 1] = {0.};
         double sx_no_mT[block_size][2*(depos_order + 1)] = {0.};
 
         uint64_t transtime0=rdtscm();
         for(int i=0;i<block_size;i++){
             for(int j=0;j<depos_order + 1;j++){
                 sx_new_mT[i][j]=sx_new_m[j][i];
                 sx_old_mT[i][j]=sx_old_m[j][i];
             }
             for(int j=0;j<depos_order + 1;j++){
                 sx_no_mT[i][j]=sx_new_m[j][i];
                 sx_no_mT[i][4+j]=sx_old_m[j][i];
             }
     
         }
         uint64_t transtime1=rdtscm();
         trans_martix_time+=(transtime1-transtime0);
 
         uint64_t loop0=rdtscm();
         double coef0 = invvol * invdt;
         for (int k=0; k<=depos_order; k++) {
             double* sz_new_v=sz_new_m[k];
             double* sz_old_v=sz_old_m[k];
             for (int j=0; j<=depos_order; j++) {
                 double* sy_new_v=sy_new_m[j];
                 double* sy_old_v=sy_old_m[j];
                 // for (int i=0; i<=depos_order; i++) {
                 //     double* sx_new_v=sx_new_m[i];
                 //     double* sx_old_v=sx_old_m[i];
                     for(int iip=0;iip<block_size/vl;iip+=vl) {
                         uint64_t tt0 = rdtscm();
                         long ip1=iip+block_id*block_size;
                         svbool_t p=svwhilele_b64(ip1,np_to_deposit);
                         // svbool_t p1 = svwhilele_b64(0,depos_order+1);
                         // MVec sx_new = MVec::Load(p, &sx_new_v[iip]);
                         // MVec sx_old = MVec::Load(p, &sx_old_v[iip]);
 
                         MVec sy_new = MVec::Load(p, &sy_new_v[iip]);
                         MVec sy_old = MVec::Load(p, &sy_old_v[iip]);
                         MVec sz_new = MVec::Load(p, &sz_new_v[iip]);
                         MVec sz_old = MVec::Load(p, &sz_old_v[iip]);
                         MVec wq_v = MVec::Load(p, &wq[iip]);
 
                         MVec coef = wq_v * coef0;
                         MVec syn_szn = coef * (sy_new * sz_new);
                         MVec syo_szn = coef * (sy_old * sz_new);
                         MVec syn_szo = coef * (sy_new * sz_old);
                         MVec syo_szo = coef * (sy_old * sz_old);
                         
                         // MVec sxn_syn_szn_v = (sx_new) * syn_szn;
                         // MVec sxo_syn_szn_v = (sx_old) * syn_szn;
                         // MVec sxn_syo_szn_v = (sx_new) * syo_szn;
                         // MVec sxo_syo_szn_v = (sx_old) * syo_szn;
                         // MVec sxn_syn_szo_v = (sx_new) * syn_szo;
                         // MVec sxo_syn_szo_v = (sx_old) * syn_szo;
                         // MVec sxn_syo_szo_v = (sx_new) * syo_szo;
                         // MVec sxo_syo_szo_v = (sx_old) * syo_szo;
                         uint64_t cal1 = rdtscm();
                         cal_time += (cal1-tt0);
                         for(int ii=0;ii<vl;ii++){
                             // MVec sx_new = MVec::Load(p1, &sx_new_mT[iip+ii][0]);
                             // MVec sx_old = MVec::Load(p1, &sx_old_mT[iip+ii][0]);
                             uint64_t cal2 = rdtscm();
                             svbool_t p1 = svwhilelt_b64(0,2*(depos_order+1));
                             MVec sxno = MVec::Load(p1, &sx_no_mT[iip+ii][0]);
                             
                             svmopa_za64_m(0, p1, p, sxno, syn_szn);
                             svmopa_za64_m(1, p1, p, sxno, syo_szn);
                             svmopa_za64_m(2, p1, p, sxno, syn_szo);
                             svmopa_za64_m(3, p1, p, sxno, syo_szo);
                             // svmopa_za64_m(0, p1, p, sx_new, syn_szn);
                             // svmopa_za64_m(1, p1, p, sx_old, syn_szn);
                             // svmopa_za64_m(2, p1, p, sx_new, syo_szn);
                             // svmopa_za64_m(3, p1, p, sx_old, syo_szn);
                             // svmopa_za64_m(4, p1, p, sx_new, syn_szo);
                             // svmopa_za64_m(5, p1, p, sx_old, syn_szo);
                             // svmopa_za64_m(6, p1, p, sx_new, syo_szo);
                             // svmopa_za64_m(7, p1, p, sx_old, syo_szo);
                         
                             uint64_t t2 = rdtscm();
                             cal_time += (t2-cal2);
 
                             svbool_t pf = svwhilelt_b64(0,4);
                             svbool_t pe = svwhilelt_b64(4,8);
                             uint64_t read0 = rdtscm();
                             MVec sxn_syn_szn = svread_ver_za64_m(vzero,pf,0,ii);
                             MVec sxo_syn_szn = svread_ver_za64_m(vzero,pe,0,ii);
                             MVec sxn_syo_szn = svread_ver_za64_m(vzero,pf,1,ii);
                             MVec sxo_syo_szn = svread_ver_za64_m(vzero,pe,1,ii);
                             MVec sxn_syn_szo = svread_ver_za64_m(vzero,pf,2,ii);
                             MVec sxo_syn_szo = svread_ver_za64_m(vzero,pe,2,ii);
                             MVec sxn_syo_szo = svread_ver_za64_m(vzero,pf,3,ii);
                             MVec sxo_syo_szo = svread_ver_za64_m(vzero,pe,3,ii);
                             uint64_t read1 = rdtscm();
                             read_time+=(read1-read0);
                             long ip=iip+ii;
                             double* ptr = &temp_arr.atSME(lo.x + i_new[ip], lo.y + j_new[ip] + j, lo.z + k_new[ip] + k, 0);
                             MVec v0=MVec::Load(pf,ptr);
                             (v0+sxn_syn_szn-sxo_syo_szo).Store(pf,ptr);
                             
                             ptr = &temp_arr.atSME(lo.x + i_new[ip], lo.y + j_new[ip] + j, lo.z + k_new[ip] + k, 1);
                             v0=MVec::Load(pf,ptr);
                             (v0+sxn_syn_szo - sxo_syo_szn).Store(pf,ptr);
                             
                             ptr = &temp_arr.atSME(lo.x + i_new[ip], lo.y + j_new[ip] + j, lo.z + k_new[ip] + k, 2);
                             v0=MVec::Load(pf,ptr);
                             (v0+sxn_syo_szn - sxo_syn_szo).Store(pf,ptr);
                             
                             ptr = &temp_arr.atSME(lo.x + i_new[ip], lo.y + j_new[ip] + j, lo.z + k_new[ip] + k, 3);
                             v0=MVec::Load(pf,ptr);
                             (v0+sxo_syn_szn - sxn_syo_szo).Store(pf,ptr);
 
                             // for(int i=0;i<depos_order+1;i++){
                             //     uint64_t read0 = rdtscm();
                             //     // svst1_hor_za64(0, i, p, &sxn_syn_szn_v[i][iip]);
                             //     // svst1_hor_za64(0, i+4, p, &sxo_syn_szn_v[i][iip]);
                             //     // svst1_hor_za64(1, i, p, &sxn_syo_szn_v[i][iip]);
                             //     // svst1_hor_za64(1, i+4, p, &sxo_syo_szn_v[i][iip]);
                             //     // svst1_hor_za64(2, i, p, &sxn_syn_szo_v[i][iip]);
                             //     // svst1_hor_za64(2, i+4, p, &sxo_syn_szo_v[i][iip]);
                             //     // svst1_hor_za64(3, i, p, &sxn_syo_szo_v[i][iip]);
                             //     // svst1_hor_za64(3, i+4, p, &sxo_syo_szo_v[i][iip]);
                             //     // MVec sxn_syn_szn = svread_hor_za64_m(vzero,p,0,i);
                             //     // MVec sxo_syn_szn = svread_hor_za64_m(vzero,p,0,i+4);
                             //     // MVec sxn_syo_szn = svread_hor_za64_m(vzero,p,1,i);
                             //     // MVec sxo_syo_szn = svread_hor_za64_m(vzero,p,1,i+4);
                             //     // MVec sxn_syn_szo = svread_hor_za64_m(vzero,p,2,i);
                             //     // MVec sxo_syn_szo = svread_hor_za64_m(vzero,p,2,i+4);
                             //     // MVec sxn_syo_szo = svread_hor_za64_m(vzero,p,3,i);
                             //     // MVec sxo_syo_szo = svread_hor_za64_m(vzero,p,3,i+4);
                             //     uint64_t read1 = rdtscm();
                             //     read_time+=(read1-read0);
                             //     // svuint64_t p_bran=svld1_u64(p, &branch_index[iip]);
                             //     // svbool_t p_b=svcmpeq_u64(p,p_bran,ones);
                             //     // if(svptest_any(p,p_b))
                             //     // {                          
                             //     //     uint64_t save1 = rdtscm();
                             //     //     double* base0 = &temp_arr.atSME(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 0);
                             //     //     double* base1 = &temp_arr.atSME(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 1);
                             //     //     double* base2 = &temp_arr.atSME(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 2);
                             //     //     double* base3 = &temp_arr.atSME(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 3);
                             //     //     for(int i=iip;i<vl;i++){
                             //     //         indices0[iip+i] =  &temp_arr.atSME(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 0) - base0;
                             //     //         indices1[iip+i] =  &temp_arr.atSME(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 1) - base1;
                             //     //         indices2[iip+i] =  &temp_arr.atSME(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 2) - base2;
                             //     //         indices3[iip+i] =  &temp_arr.atSME(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 3) - base3;
                             //     //     }
                     
                             //     //     svuint64_t indices_v0=svld1_u64(p,&indices0[iip]);
                             //     //     double* ptr=&temp_arr.atSME(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 0);
                             //     //     MVec v0(svld1_gather_index(p,ptr,indices_v0));
                             //     //     v0+= (sxn_syn_szn - sxo_syo_szo);
                             //     //     svst1_scatter_index(p,ptr,indices_v0,v0);
                                     
                             //     //     svuint64_t indices_v1=svld1_u64(p,&indices1[iip]);
                             //     //     ptr=&temp_arr.atSME(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 1);
                             //     //     MVec v1(svld1_gather_index(p,ptr,indices_v1));
                             //     //     v1+= (sxn_syn_szo - sxo_syo_szn);
                             //     //     svst1_scatter_index(p,ptr,indices_v1,v1);
                                     
                             //     //     svuint64_t indices_v2=svld1_u64(p,&indices2[iip]);
                             //     //     ptr=&temp_arr.atSME(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 2);
                             //     //     MVec v2(svld1_gather_index(p,ptr,indices_v2));
                             //     //     v2+= (sxn_syo_szn - sxo_syn_szo);
                             //     //     svst1_scatter_index(p,ptr,indices_v2,v2);
                                     
                             //     //     svuint64_t indices_v3=svld1_u64(p,&indices3[iip]);
                             //     //     ptr=&temp_arr.atSME(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 3);
                             //     //     MVec v3(svld1_gather_index(p,ptr,indices_v3));
                             //     //     v3+= (sxo_syn_szn - sxn_syo_szo);
                             //     //     svst1_scatter_index(p,ptr,indices_v3,v3);
 
                             //     //     uint64_t save2 = rdtscm();
                             //     //     save_time1 += (save2-save1);
                             //     // } 
                             //     // else {
                             //     // //     uint64_t save3 = rdtscm();
 
                             //     // //     double* base0 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 0);
                             //     // //     double* base1 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 1);
                             //     // //     double* base2 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 2);
                             //     // //     double* base3 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 3);
                             //     // //     double* base0old = &temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 0);
                             //     // //     double* base1old = &temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 1);
                             //     // //     double* base2old = &temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 2);
                             //     // //     double* base3old = &temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 3);
                             //     // //     for(int i=iip;i<vl;i++){
                             //     // //         indices0[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 0) - base0;
                             //     // //         indices1[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 1) - base1;
                             //     // //         indices2[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 2) - base2;
                             //     // //         indices3[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 3) - base3;
                             //     // //         indices0old[iip+i] =  &temp_arr(lo.x + i_old[iip+i] + i, lo.y + j_old[iip+i] + j, lo.z + k_old[iip+i] + k, 0) - base0old;
                             //     // //         indices1old[iip+i] =  &temp_arr(lo.x + i_old[iip+i] + i, lo.y + j_old[iip+i] + j, lo.z + k_old[iip+i] + k, 1) - base1old;
                             //     // //         indices2old[iip+i] =  &temp_arr(lo.x + i_old[iip+i] + i, lo.y + j_old[iip+i] + j, lo.z + k_old[iip+i] + k, 2) - base2old;
                             //     // //         indices3old[iip+i] =  &temp_arr(lo.x + i_old[iip+i] + i, lo.y + j_old[iip+i] + j, lo.z + k_old[iip+i] + k, 3) - base3old;
                             //     // //     }
                     
                             //     // //     svuint64_t indices_v0=svld1_u64(p,&indices0[iip]);
                             //     // //     MVec v0(svld1_gather_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 0),indices_v0));
                             //     // //     v0+= (sxn_syn_szn_v);
                             //     // //     svst1_scatter_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 0),indices_v0,v0);
                                     
                             //     // //     svuint64_t indices_v1=svld1_u64(p,&indices1[iip]);
                             //     // //     MVec v1(svld1_gather_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 1),indices_v1));
                             //     // //     v1+= (sxn_syn_szo_v );
                             //     // //     svst1_scatter_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 1),indices_v1,v1);
                                     
                             //     // //     svuint64_t indices_v2=svld1_u64(p,&indices2[iip]);
                             //     // //     MVec v2(svld1_gather_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 2),indices_v2));
                             //     // //     v2+= (sxn_syo_szn_v);
                             //     // //     svst1_scatter_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 2),indices_v2,v2);
                                     
                             //     // //     svuint64_t indices_v3=svld1_u64(p,&indices3[iip]);
                             //     // //     MVec v3(svld1_gather_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 3),indices_v3));
                             //     // //     v3+= (sxo_syn_szn_v);
                             //     // //     svst1_scatter_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 3),indices_v3,v3);
                                     
                             //     // //     svuint64_t indices_v0old=svld1_u64(p,&indices0old[iip]);
                             //     // //     MVec v0old(svld1_gather_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 0),indices_v0old));
                             //     // //     v0old+= ( - sxo_syo_szo_v);
                             //     // //     svst1_scatter_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 0),indices_v0,v0);
                                     
                             //     // //     svuint64_t indices_v1old=svld1_u64(p,&indices1old[iip]);
                             //     // //     MVec v1old(svld1_gather_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 1),indices_v1old));
                             //     // //     v1old+= ( - sxo_syo_szn_v);
                             //     // //     svst1_scatter_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 1),indices_v1,v1);
                                     
                             //     // //     svuint64_t indices_v2old=svld1_u64(p,&indices2old[iip]);
                             //     // //     MVec v2old(svld1_gather_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 2),indices_v2old));
                             //     // //     v2old+= ( - sxo_syn_szo_v);
                             //     // //     svst1_scatter_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 2),indices_v2,v2);
                                     
                             //     // //     svuint64_t indices_v3old=svld1_u64(p,&indices3old[iip]);
                             //     // //     MVec v3old(svld1_gather_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 3),indices_v3old));
                             //     // //     v3old+= ( - sxn_syo_szo_v);
                             //     // //     svst1_scatter_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 3),indices_v3,v3);
                             //     // //     uint64_t save4 = rdtscm();
                             //     // //     save_time2 += (save4-save3);
                             //     // }
                             // }
                             
 
                             uint64_t t3 = rdtscm();
                             save_time += (t3-t2);
                         }
                     }
                 // }
             }
         }
         uint64_t loop1=rdtscm();
         nijk_loop_time+=(loop1-loop0);
         // amrex::Abort("END BLOCK");
     }
 
 
     uint64_t t4 = rdtscm();
     const amrex::Box& bx=Dx_fab.box();
     const amrex::IntVect Dxlo=bx.smallEnd();
     const amrex::IntVect Dxhi=bx.bigEnd();
 
     for(int k=Dxlo.atSME(2);k<=Dxhi.atSME(2);++k){
         for(int j=Dxlo.atSME(1);j<=Dxhi.atSME(1);++j){
             for(int i=Dxlo.atSME(0);i<=Dxhi.atSME(0);i+=vl){
 
                 svbool_t p = svwhilele_b64(i,Dxhi.atSME(0));
                 MVec t_av=MVec::Load(p,&temp_arr.atSME(i,j,k,0));
                 MVec t_bv=MVec::Load(p,&temp_arr.atSME(i,j,k,1));
                 MVec t_cv=MVec::Load(p,&temp_arr.atSME(i,j,k,2));
                 MVec t_dv=MVec::Load(p,&temp_arr.atSME(i,j,k,3));
 
                 MVec Dx_arrv=MVec::Load(p,&Dx_arr.atSME(i,j,k));
                 MVec Dy_arrv=MVec::Load(p,&Dy_arr.atSME(i,j,k));
                 MVec Dz_arrv=MVec::Load(p,&Dz_arr.atSME(i,j,k));
                 Dx_arrv += (1._rt/6._rt)*(2_rt*t_av       + t_bv       + t_cv - 2._rt*t_dv);
                 Dy_arrv += (1._rt/6._rt)*(2_rt*t_av       + t_bv - 2._rt*t_cv       + t_dv);
                 Dz_arrv += (1._rt/6._rt)*(2_rt*t_av - 2._rt*t_bv       + t_cv       + t_dv);
 
                 Dx_arrv.Store(p,&Dx_arr.atSME(i,j,k));
                 Dy_arrv.Store(p,&Dy_arr.atSME(i,j,k));
                 Dz_arrv.Store(p,&Dz_arr.atSME(i,j,k));
 
             }
         }
     }
     uint64_t t5 = rdtscm();
     post_time += (t5-t4);
 }
 
 template <int depos_order>
 void doVayDepositionShapeN_trans_N1 (const GetParticlePosition<PIdx>& GetPosition,
                             const amrex::ParticleReal* const wp,
                             const amrex::ParticleReal* const uxp,
                             const amrex::ParticleReal* const uyp,
                             const amrex::ParticleReal* const uzp,
                             const int* const ion_lev,
                             amrex::FArrayBox& Dx_fab,
                             amrex::FArrayBox& Dy_fab,
                             amrex::FArrayBox& Dz_fab,
                             long np_to_deposit,
                             amrex::Real dt,
                             amrex::Real relative_time,
                             const amrex::XDim3 & dinv,
                             const amrex::XDim3 & xyzmin,
                             amrex::Dim3 lo,
                             amrex::Real q,
                             [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     uint64_t step0=rdtscv();
     using namespace amrex::literals;
     // If ion_lev is a null pointer, then do_ionization=0, else do_ionization=1
     const bool do_ionization = ion_lev;
 
     // Inverse of time step
     const amrex::Real invdt = 1._rt / dt;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z;
 
     // Allocate temporary arrays
     AMREX_ALWAYS_ASSERT(Dx_fab.box() == Dy_fab.box() && Dx_fab.box() == Dz_fab.box());
     amrex::FArrayBox temp_fab{Dx_fab.box(), 4};
 
     temp_fab.setVal<amrex::RunOn::Device>(0._rt);
     amrex::Array4<amrex::Real> const& temp_arr = temp_fab.array();
 
     // Inverse of light speed squared
     const amrex::Real invcsq = 1._rt / (PhysConst::c * PhysConst::c);
 
     // Arrays where D will be stored
     amrex::Array4<amrex::Real> const& Dx_arr = Dx_fab.array();
     amrex::Array4<amrex::Real> const& Dy_arr = Dy_fab.array();
     amrex::Array4<amrex::Real> const& Dz_arr = Dz_fab.array();
 
     std::vector<long> inewv(np_to_deposit,0);
     std::vector<double> xnewv(np_to_deposit,0);
     std::vector<double> tmpv(np_to_deposit,0);
     std::vector<double> xpv(np_to_deposit,0);
     std::vector<double> wqv(np_to_deposit,0);
     std::vector<double> sxnew(np_to_deposit,0);
     std::vector<double> invgamv(np_to_deposit,0);
     std::vector<double> sxn(np_to_deposit,0);
 
 #if 0 // Orgin 
     // Loop over particles and deposit (Dx,Dy,Dz) into Dx_fab, Dy_fab and Dz_fab
     amrex::ParallelFor(np_to_deposit, [&] AMREX_GPU_DEVICE (long ip)
     {
         uint64_t t0 = rdtscv();
         // Inverse of Lorentz factor gamma
         const amrex::Real invgam = 1._rt / std::sqrt(1._rt + uxp[ip] * uxp[ip] * invcsq
                                                            + uyp[ip] * uyp[ip] * invcsq
                                                            + uzp[ip] * uzp[ip] * invcsq);
         // Product of particle charges and weights
         amrex::Real wq = q * wp[ip];
         if (do_ionization) { wq *= ion_lev[ip]; }
 
         // Current particle positions (in physical units)
         amrex::ParticleReal xp, yp, zp;
         GetPosition(ip, xp, yp, zp);
 
         // Particle velocities
         const amrex::Real vx = uxp[ip] * invgam;
         const amrex::Real vy = uyp[ip] * invgam;
         const amrex::Real vz = uzp[ip] * invgam;
 
         // Modify the particle position to match the time of the deposition
         xp += relative_time * vx;
         yp += relative_time * vy;
         zp += relative_time * vz;
 
         // Current and old particle positions in grid units
         // Keep these double to avoid bug in single precision.
         double const x_new = (xp - xyzmin.x + 0.5_rt*dt*vx) * dinv.x;
         double const x_old = (xp - xyzmin.x - 0.5_rt*dt*vx) * dinv.x;
         // Keep these double to avoid bug in single precision.
         double const y_new = (yp - xyzmin.y + 0.5_rt*dt*vy) * dinv.y;
         double const y_old = (yp - xyzmin.y - 0.5_rt*dt*vy) * dinv.y;
         // Keep these double to avoid bug in single precision.
         double const z_new = (zp - xyzmin.z + 0.5_rt*dt*vz) * dinv.z;
         double const z_old = (zp - xyzmin.z - 0.5_rt*dt*vz) * dinv.z;
 
         // Shape factor arrays for current and old positions (nodal)
         // Keep these double to avoid bug in single precision.
         double sx_new[depos_order+1] = {0.};
         double sx_old[depos_order+1] = {0.};
         // Keep these double to avoid bug in single precision.
         double sy_new[depos_order+1] = {0.};
         double sy_old[depos_order+1] = {0.};
         // Keep these double to avoid bug in single precision.
         double sz_new[depos_order+1] = {0.};
         double sz_old[depos_order+1] = {0.};
 
         // Compute shape factors for current positions
 
         // i_new leftmost grid point in x that the particle touches
         // sx_new shape factor along x for the centering of each current
         Compute_shape_factor< depos_order > const compute_shape_factor;
         const int i_new = compute_shape_factor(sx_new, x_new);
         // j_new leftmost grid point in y that the particle touches
         // sy_new shape factor along y for the centering of each current
         const int j_new = compute_shape_factor(sy_new, y_new);
         // k_new leftmost grid point in z that the particle touches
         // sz_new shape factor along z for the centering of each current
         const int k_new = compute_shape_factor(sz_new, z_new);
 
         // Compute shape factors for old positions
 
         // i_old leftmost grid point in x that the particle touches
         // sx_old shape factor along x for the centering of each current
         const int i_old = compute_shape_factor(sx_old, x_old);
         // j_old leftmost grid point in y that the particle touches
         // sy_old shape factor along y for the centering of each current
         const int j_old = compute_shape_factor(sy_old, y_old);
         // k_old leftmost grid point in z that the particle touches
         // sz_old shape factor along z for the centering of each current
         const int k_old = compute_shape_factor(sz_old, z_old);
         uint64_t t1 = rdtscv();
         pre_time += (t1-t0);
         // Deposit current into Dx_arr, Dy_arr and Dz_arr
         if(ip==0){        
         for (int k=0; k<=depos_order; k++) {
             for (int j=0; j<=depos_order; j++) {
                 uint64_t tt0 = rdtscv();
                 auto const syn_szn = static_cast<amrex::Real>(sy_new[j] * sz_new[k]);
                 auto const syo_szn = static_cast<amrex::Real>(sy_old[j] * sz_new[k]);
                 auto const syn_szo = static_cast<amrex::Real>(sy_new[j] * sz_old[k]);
                 auto const syo_szo = static_cast<amrex::Real>(sy_old[j] * sz_old[k]);
                 for (int i=0; i<=depos_order; i++) {
                     uint64_t tt2 = rdtscv();
                     auto const sxn_syn_szn = static_cast<amrex::Real>(sx_new[i]) * syn_szn;
                     auto const sxo_syn_szn = static_cast<amrex::Real>(sx_old[i]) * syn_szn;
                     auto const sxn_syo_szn = static_cast<amrex::Real>(sx_new[i]) * syo_szn;
                     auto const sxo_syo_szn = static_cast<amrex::Real>(sx_old[i]) * syo_szn;
                     auto const sxn_syn_szo = static_cast<amrex::Real>(sx_new[i]) * syn_szo;
                     auto const sxo_syn_szo = static_cast<amrex::Real>(sx_old[i]) * syn_szo;
                     auto const sxn_syo_szo = static_cast<amrex::Real>(sx_new[i]) * syo_szo;
                     auto const sxo_syo_szo = static_cast<amrex::Real>(sx_old[i]) * syo_szo;
                     uint64_t t2 = rdtscv();
                     cal_time += (t2-tt2);
                     if (i_new == i_old && j_new == j_old && k_new == k_old) {
                         sxnew[ip]=sx_new[0];
                         wqv[ip]=wq;
                         inewv[ip]=i_new;
                         xnewv[ip]=x_new;
                         xpv[ip]=xp;
                         invgamv[ip]=invgam;
                         sxn[ip]=sxn_syn_szn;
                         tmpv[ip]=wq * invvol * invdt *  (sxn_syn_szn - sxo_syo_szo);
                         // temp arrays for Dx, Dy and Dz
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 0),
                             wq * invvol * invdt * (sxn_syn_szn - sxo_syo_szo));
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 1),
                             wq * invvol * invdt * (sxn_syn_szo - sxo_syo_szn));
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 2),
                             wq * invvol * invdt * (sxn_syo_szn - sxo_syn_szo));
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 3),
                             wq * invvol * invdt * (sxo_syn_szn - sxn_syo_szo));
                     } else {
                         // temp arrays for Dx, Dy and Dz
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_new + k, 0),
                             wq * invvol * invdt * sxn_syn_szn);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_old + j, lo.z + k_old + k, 0),
                             - wq * invvol * invdt * sxo_syo_szo);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_new + j, lo.z + k_old + k, 1),
                             wq * invvol * invdt * sxn_syn_szo);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_old + j, lo.z + k_new + k, 1),
                             - wq * invvol * invdt * sxo_syo_szn);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_old + j, lo.z + k_new + k, 2),
                             wq * invvol * invdt * sxn_syo_szn);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_new + j, lo.z + k_old + k, 2),
                             - wq * invvol * invdt * sxo_syn_szo);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + i, lo.y + j_new + j, lo.z + k_new + k, 3),
                             wq * invvol * invdt * sxo_syn_szn);
 
                         amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + i, lo.y + j_old + j, lo.z + k_old + k, 3),
                             - wq * invvol * invdt * sxn_syo_szo);
                     }
                 uint64_t t3 = rdtscv();
                 save_time += (t3-t0);
                 }
                 // auto const sxn_syn_szn = static_cast<amrex::Real>(sx_new[0]) * syn_szn;
                 // auto const sxo_syn_szn = static_cast<amrex::Real>(sx_old[0]) * syn_szn;
                 // auto const sxn_syo_szn = static_cast<amrex::Real>(sx_new[0]) * syo_szn;
                 // auto const sxo_syo_szn = static_cast<amrex::Real>(sx_old[0]) * syo_szn;
                 // auto const sxn_syn_szo = static_cast<amrex::Real>(sx_new[0]) * syn_szo;
                 // auto const sxo_syn_szo = static_cast<amrex::Real>(sx_old[0]) * syn_szo;
                 // auto const sxn_syo_szo = static_cast<amrex::Real>(sx_new[0]) * syo_szo;
                 // auto const sxo_syo_szo = static_cast<amrex::Real>(sx_old[0]) * syo_szo;
 
                 
                 // //1
                 // auto const sxn_syn_szn1 = static_cast<amrex::Real>(sx_new[1]) * syn_szn;
                 // auto const sxo_syn_szn1 = static_cast<amrex::Real>(sx_old[1]) * syn_szn;
                 // auto const sxn_syo_szn1 = static_cast<amrex::Real>(sx_new[1]) * syo_szn;
                 // auto const sxo_syo_szn1 = static_cast<amrex::Real>(sx_old[1]) * syo_szn;
                 // auto const sxn_syn_szo1 = static_cast<amrex::Real>(sx_new[1]) * syn_szo;
                 // auto const sxo_syn_szo1 = static_cast<amrex::Real>(sx_old[1]) * syn_szo;
                 // auto const sxn_syo_szo1 = static_cast<amrex::Real>(sx_new[1]) * syo_szo;
                 // auto const sxo_syo_szo1 = static_cast<amrex::Real>(sx_old[1]) * syo_szo;
                 // //2
                 // auto const sxn_syn_szn2 = static_cast<amrex::Real>(sx_new[2]) * syn_szn;
                 // auto const sxo_syn_szn2 = static_cast<amrex::Real>(sx_old[2]) * syn_szn;
                 // auto const sxn_syo_szn2 = static_cast<amrex::Real>(sx_new[2]) * syo_szn;
                 // auto const sxo_syo_szn2 = static_cast<amrex::Real>(sx_old[2]) * syo_szn;
                 // auto const sxn_syn_szo2 = static_cast<amrex::Real>(sx_new[2]) * syn_szo;
                 // auto const sxo_syn_szo2 = static_cast<amrex::Real>(sx_old[2]) * syn_szo;
                 // auto const sxn_syo_szo2 = static_cast<amrex::Real>(sx_new[2]) * syo_szo;
                 // auto const sxo_syo_szo2 = static_cast<amrex::Real>(sx_old[2]) * syo_szo;
                 // //3
                 // auto const sxn_syn_szn3 = static_cast<amrex::Real>(sx_new[3]) * syn_szn;
                 // auto const sxo_syn_szn3 = static_cast<amrex::Real>(sx_old[3]) * syn_szn;
                 // auto const sxn_syo_szn3 = static_cast<amrex::Real>(sx_new[3]) * syo_szn;
                 // auto const sxo_syo_szn3 = static_cast<amrex::Real>(sx_old[3]) * syo_szn;
                 // auto const sxn_syn_szo3 = static_cast<amrex::Real>(sx_new[3]) * syn_szo;
                 // auto const sxo_syn_szo3 = static_cast<amrex::Real>(sx_old[3]) * syn_szo;
                 // auto const sxn_syo_szo3 = static_cast<amrex::Real>(sx_new[3]) * syo_szo;
                 // auto const sxo_syo_szo3 = static_cast<amrex::Real>(sx_old[3]) * syo_szo;
                 // if(ip<256){
                 //     sxnew[ip]=sx_new[0];
                 //     wqv[ip]=wq;
                 //     inewv[ip]=i_new;
                 //     xnewv[ip]=x_new;
                 //     xpv[ip]=xp;
                 //     invgamv[ip]=invgam;
                 //     sxn[ip]=sxn_syn_szn;
                 //     tmpv[ip]=wq * invvol * invdt *  (sxn_syn_szn1 - sxo_syo_szo1);
 
                 //     // temp=sxn_syn_szn*wq * invvol * invdt;
                 // // printf("sxn %f, temp=%f, wq %f * invvol %f * invdt %f\n",sxn_syn_szn,temp,wq, invvol, invdt);
                 // }
                 // uint64_t t2 = rdtscv();
                 // cal_time += (t2-tt0);
 
                 // if (i_new == i_old && j_new == j_old && k_new == k_old) {
                 //     // temp arrays for Dx, Dy and Dz
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_new + j, lo.z + k_new + k, 0),
                 //         wq * invvol * invdt * (sxn_syn_szn - sxo_syo_szo));
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_new + j, lo.z + k_new + k, 1),
                 //         wq * invvol * invdt * (sxn_syn_szo - sxo_syo_szn));
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_new + j, lo.z + k_new + k, 2),
                 //         wq * invvol * invdt * (sxn_syo_szn - sxo_syn_szo));
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_new + j, lo.z + k_new + k, 3),
                 //         wq * invvol * invdt * (sxo_syn_szn - sxn_syo_szo));
                 //     // 1
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_new + j, lo.z + k_new + k, 0),
                 //         wq * invvol * invdt * (sxn_syn_szn1 - sxo_syo_szo1));
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_new + j, lo.z + k_new + k, 1),
                 //         wq * invvol * invdt * (sxn_syn_szo1 - sxo_syo_szn1));
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_new + j, lo.z + k_new + k, 2),
                 //         wq * invvol * invdt * (sxn_syo_szn1 - sxo_syn_szo1));
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_new + j, lo.z + k_new + k, 3),
                 //         wq * invvol * invdt * (sxo_syn_szn1 - sxn_syo_szo1));
                 //     //2
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_new + j, lo.z + k_new + k, 0),
                 //         wq * invvol * invdt * (sxn_syn_szn2 - sxo_syo_szo2));
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_new + j, lo.z + k_new + k, 1),
                 //         wq * invvol * invdt * (sxn_syn_szo2 - sxo_syo_szn2));
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_new + j, lo.z + k_new + k, 2),
                 //         wq * invvol * invdt * (sxn_syo_szn2 - sxo_syn_szo2));
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_new + j, lo.z + k_new + k, 3),
                 //         wq * invvol * invdt * (sxo_syn_szn2 - sxn_syo_szo2));
                 //     //3
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_new + j, lo.z + k_new + k, 0),
                 //         wq * invvol * invdt * (sxn_syn_szn3 - sxo_syo_szo3));
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_new + j, lo.z + k_new + k, 1),
                 //         wq * invvol * invdt * (sxn_syn_szo3 - sxo_syo_szn3));
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_new + j, lo.z + k_new + k, 2),
                 //         wq * invvol * invdt * (sxn_syo_szn3 - sxo_syn_szo3));
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_new + j, lo.z + k_new + k, 3),
                 //         wq * invvol * invdt * (sxo_syn_szn3 - sxn_syo_szo3));
                 // } else {
                 //     // temp arrays for Dx, Dy and Dz
                 //     //0
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_new + j, lo.z + k_new + k, 0),
                 //         wq * invvol * invdt * sxn_syn_szn);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 0, lo.y + j_old + j, lo.z + k_old + k, 0),
                 //         - wq * invvol * invdt * sxo_syo_szo);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_new + j, lo.z + k_old + k, 1),
                 //         wq * invvol * invdt * sxn_syn_szo);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 0, lo.y + j_old + j, lo.z + k_new + k, 1),
                 //         - wq * invvol * invdt * sxo_syo_szn);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_old + j, lo.z + k_new + k, 2),
                 //         wq * invvol * invdt * sxn_syo_szn);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 0, lo.y + j_new + j, lo.z + k_old + k, 2),
                 //         - wq * invvol * invdt * sxo_syn_szo);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 0, lo.y + j_new + j, lo.z + k_new + k, 3),
                 //         wq * invvol * invdt * sxo_syn_szn);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 0, lo.y + j_old + j, lo.z + k_old + k, 3),
                 //         - wq * invvol * invdt * sxn_syo_szo);
                 //     //1
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_new + j, lo.z + k_new + k, 0),
                 //         wq * invvol * invdt * sxn_syn_szn1);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 1, lo.y + j_old + j, lo.z + k_old + k, 0),
                 //         - wq * invvol * invdt * sxo_syo_szo1);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_new + j, lo.z + k_old + k, 1),
                 //         wq * invvol * invdt * sxn_syn_szo1);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 1, lo.y + j_old + j, lo.z + k_new + k, 1),
                 //         - wq * invvol * invdt * sxo_syo_szn1);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_old + j, lo.z + k_new + k, 2),
                 //         wq * invvol * invdt * sxn_syo_szn1);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 1, lo.y + j_new + j, lo.z + k_old + k, 2),
                 //         - wq * invvol * invdt * sxo_syn_szo1);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 1, lo.y + j_new + j, lo.z + k_new + k, 3),
                 //         wq * invvol * invdt * sxo_syn_szn1);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 1, lo.y + j_old + j, lo.z + k_old + k, 3),
                 //         - wq * invvol * invdt * sxn_syo_szo1);
                 //     //2
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_new + j, lo.z + k_new + k, 0),
                 //         wq * invvol * invdt * sxn_syn_szn2);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 2, lo.y + j_old + j, lo.z + k_old + k, 0),
                 //         - wq * invvol * invdt * sxo_syo_szo2);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_new + j, lo.z + k_old + k, 1),
                 //         wq * invvol * invdt * sxn_syn_szo2);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 2, lo.y + j_old + j, lo.z + k_new + k, 1),
                 //         - wq * invvol * invdt * sxo_syo_szn2);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_old + j, lo.z + k_new + k, 2),
                 //         wq * invvol * invdt * sxn_syo_szn2);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 2, lo.y + j_new + j, lo.z + k_old + k, 2),
                 //         - wq * invvol * invdt * sxo_syn_szo2);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 2, lo.y + j_new + j, lo.z + k_new + k, 3),
                 //         wq * invvol * invdt * sxo_syn_szn2);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 2, lo.y + j_old + j, lo.z + k_old + k, 3),
                 //         - wq * invvol * invdt * sxn_syo_szo2);
                 //     //3
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_new + j, lo.z + k_new + k, 0),
                 //         wq * invvol * invdt * sxn_syn_szn3);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 3, lo.y + j_old + j, lo.z + k_old + k, 0),
                 //         - wq * invvol * invdt * sxo_syo_szo3);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_new + j, lo.z + k_old + k, 1),
                 //         wq * invvol * invdt * sxn_syn_szo3);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 3, lo.y + j_old + j, lo.z + k_new + k, 1),
                 //         - wq * invvol * invdt * sxo_syo_szn3);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_old + j, lo.z + k_new + k, 2),
                 //         wq * invvol * invdt * sxn_syo_szn3);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 3, lo.y + j_new + j, lo.z + k_old + k, 2),
                 //         - wq * invvol * invdt * sxo_syn_szo3);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old + 3, lo.y + j_new + j, lo.z + k_new + k, 3),
                 //         wq * invvol * invdt * sxo_syn_szn3);
 
                 //     amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new + 3, lo.y + j_old + j, lo.z + k_old + k, 3),
                 //         - wq * invvol * invdt * sxn_syo_szo3);
                 // }
                 // uint64_t t3 = rdtscv();
                 // save_time += (t3-t0);
             }   
         } 
         }
     });
 #elif 0 // SVE
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
 
 
     // Loop over particles and deposit (Dx,Dy,Dz) into Dx_fab, Dy_fab and Dz_fab
     // amrex::ParallelFor(np_to_deposit, [&] AMREX_GPU_DEVICE (long ip)
 
     auto compute_shape_factor_v = [](int64_t* i_new, double* sx[], Vec xmid, svbool_t p) {
         Vec j = svrintz_x(p, xmid);
         Vec xint = xmid - j;
         Vec temp = 1.0 - xint;
         Vec sx0 = (1.0 / 6.0) * temp * temp * temp;
         Vec sx1 = (2.0 / 3.0) - xint * xint * (1.0 - xint * 0.5);
         Vec sx2 = (2.0 / 3.0) - temp * temp * (1.0 - 0.5 *temp);
         Vec sx3 = (1.0 / 6.0) * xint * xint * xint;
         sx0.Store(p, sx[0]);
         sx1.Store(p, sx[1]);
         sx2.Store(p, sx[2]);
         sx3.Store(p, sx[3]);
         svst1(p, i_new, svsub_x(p, svcvt_s64_x(p,j), svdup_s64(1)));
     };
     auto compute_shape_factor_v2 = [](int64_t* i_new,double* sx[], Vec xmid, svbool_t p) {
         Vec j = svrintz_x(p, xmid);
         Vec xint = xmid - j;
         Vec temp = 1.0 - xint;
         Vec sx0 = (1.0 / 6.0) * temp * temp * temp;
         Vec sx1 = (2.0 / 3.0) - xint * xint * (1.0 - xint * 0.5);
         Vec sx2 = (2.0 / 3.0) - temp * temp * (1.0 - 0.5 *temp);
         Vec sx3 = (1.0 / 6.0) * xint * xint * xint;
         sx0.Store(p, sx[0]);
         sx1.Store(p, sx[1]);
         sx2.Store(p, sx[2]);
         sx3.Store(p, sx[3]);
         svint64_t i_newv=svsub_x(p, svcvt_s64_x(p,j), svdup_s64(1));
         svst1(p, i_new, i_newv);
         return i_newv;
     };
 
     const int block_size=256;
     long n_blocks=np_to_deposit/block_size;
     int vl=svcntd();
     // std::vector<double> x_newv(np_to_deposit,0);
     // #pragma omp parallel for
     for(int block_id=0;block_id<n_blocks;block_id++){
 
         double wq[block_size];
         // double xp_test[256];
         // double x_newv[256];
         // double inv_test[256];
 
         double sx_new_m[depos_order + 1][block_size] = {0.};
         double sx_old_m[depos_order + 1][block_size] = {0.};
         double sy_new_m[depos_order + 1][block_size] = {0.};
         double sy_old_m[depos_order + 1][block_size] = {0.};
         double sz_new_m[depos_order + 1][block_size] = {0.};
         double sz_old_m[depos_order + 1][block_size] = {0.};
 
         int64_t i_new[block_size];
         int64_t i_old[block_size];
         int64_t j_new[block_size];
         int64_t j_old[block_size];
         int64_t k_new[block_size];
         int64_t k_old[block_size];
         uint64_t branch_index[block_size];
 
         uint64_t indices0[block_size];
         uint64_t indices1[block_size];
         uint64_t indices2[block_size];
         uint64_t indices3[block_size];
         uint64_t indices0old[block_size];
         uint64_t indices1old[block_size];
         uint64_t indices2old[block_size];
         uint64_t indices3old[block_size];
 
         svuint64_t ones=svdup_u64(1);
         svuint64_t zeros=svdup_u64(0);
 
 
 
         for(int iip=0;iip<block_size/vl;iip+=vl){
             long ip=iip+block_id*block_size;
             uint64_t t0 = rdtscv();
             svbool_t p_ip=svwhilele_b64(ip,np_to_deposit);
             // Inverse of Lorentz factor gamma
             Vec uxp_v=Vec::Load(p_ip,&uxp[ip]);
             Vec uyp_v=Vec::Load(p_ip,&uyp[ip]);
             Vec uzp_v=Vec::Load(p_ip,&uzp[ip]);
             Vec invgam = 1._rt / (1._rt +  uxp_v * uxp_v * invcsq
                                         + uyp_v * uyp_v * invcsq
                                         + uzp_v * uzp_v * invcsq).Sqrt();
             // Product of particle charges and weights
             Vec wp_v=Vec::Load(p_ip,&wp[ip]);
             Vec wq_v = q * wp_v;
             // if (do_ionization) { 
             //     svint64_t ion_lev_v=svld1_s64(p_ip,&ion_lev[ip]);
             //     wq_v *= svcvt_f64_x(p_ip, ion_lev_v);
             //     // wq_v *= ion_lev_v; 
             // }
             wq_v.Store(p_ip, &wq[iip]);
 
             // Current particle positions (in physical units)
             Vec xp = Vec::Load(p_ip, &mx[ip]);
             Vec yp = Vec::Load(p_ip, &my[ip]);
             Vec zp = Vec::Load(p_ip, &mz[ip]);
 
             // Particle velocities
             Vec vx = uxp_v * invgam;
             Vec vy = uyp_v * invgam;
             Vec vz = uzp_v * invgam;
             // double vx_test[8];
             // vx.Store(p_ip,&vx_test[0]);
 
             // Modify the particle position to match the time of the deposition
             xp += relative_time * vx;
             yp += relative_time * vy;
             zp += relative_time * vz;
             // xp.Store(p_ip,&xp_test[iip]);
             // invgam.Store(p_ip,&inv_test[iip]);
 
             // Current and old particle positions in grid units
             // Keep these double to avoid bug in single precision.
             Vec x_new = (xp - xyzmin.x + 0.5_rt*dt*vx) * dinv.x;
             Vec x_old = (xp - xyzmin.x - 0.5_rt*dt*vx) * dinv.x;
             Vec y_new = (yp - xyzmin.y + 0.5_rt*dt*vy) * dinv.y;
             Vec y_old = (yp - xyzmin.y - 0.5_rt*dt*vy) * dinv.y;
             Vec z_new = (zp - xyzmin.z + 0.5_rt*dt*vz) * dinv.z;
             Vec z_old = (zp - xyzmin.z - 0.5_rt*dt*vz) * dinv.z;
 
             // double x_new_test[8];
             // double x_old_test[8];
             // x_new.Store(p_ip,&x_new_test[0]);
             // x_old.Store(p_ip,&x_old_test[0]);
             // double y_new_test[8];
             // double y_old_test[8];
             // y_new.Store(p_ip,&y_new_test[0]);
             // y_old.Store(p_ip,&y_old_test[0]);
             // double z_new_test[8];
             // double z_old_test[8];
             // z_new.Store(p_ip,&z_new_test[0]);
             // z_old.Store(p_ip,&z_old_test[0]);
             // for(int x=0;x<8;x++){
             //     // x_newv[iip+x]=x_new_test[x];
             //     double sx_new[depos_order+1] = {0.};
             //     double sx_old[depos_order+1] = {0.};
             //     // Keep these double to avoid bug in single precision.
             //     double sy_new[depos_order+1] = {0.};
             //     double sy_old[depos_order+1] = {0.};
             //     // Keep these double to avoid bug in single precision.
             //     double sz_new[depos_order+1] = {0.};
             //     double sz_old[depos_order+1] = {0.};
             //     Compute_shape_factor< depos_order > const compute_shape_factor;
             //     i_new[iip+x] = compute_shape_factor(sx_new, x_new_test[x]);
             //     // printf("\n ip %d; org inew %d , sve inew %d ",ip+x,inewv[ip+x],i_new[iip+x]);
             //     // printf("\n ip %d; org xnew %f , sve xnew %f \n",ip+x,xnewv[ip+x],x_newv[iip+x]);
             //     // j_new leftmost grid point in y that the particle touches
             //     // sy_new shape factor along y for the centering of each current
             //     j_new[iip+x] = compute_shape_factor(sy_new, y_new_test[x]);
             //     // k_new leftmost grid point in z that the particle touches
             //     // sz_new shape factor along z for the centering of each current
             //     k_new[iip+x] = compute_shape_factor(sz_new, z_new_test[x]);
 
             //     // Compute shape factors for old positions
 
             //     // i_old leftmost grid point in x that the particle touches
             //     // sx_old shape factor along x for the centering of each current
             //     i_old[iip+x] = compute_shape_factor(sx_old, x_old_test[x]);
             //     // j_old leftmost grid point in y that the particle touches
             //     // sy_old shape factor along y for the centering of each current
             //     j_old[iip+x] = compute_shape_factor(sy_old, y_old_test[x]);
             //     // k_old leftmost grid point in z that the particle touches
             //     // sz_old shape factor along z for the centering of each current
             //     k_old[iip+x] = compute_shape_factor(sz_old, z_old_test[x]);
 
             //     sx_new_m[0][iip+x]=sx_new[0];
             //     sx_new_m[1][iip+x]=sx_new[1];
             //     sx_new_m[2][iip+x]=sx_new[2];
             //     sx_new_m[3][iip+x]=sx_new[3];
             //     sx_old_m[0][iip+x]=sx_old[0];
             //     sx_old_m[1][iip+x]=sx_old[1];
             //     sx_old_m[2][iip+x]=sx_old[2];
             //     sx_old_m[3][iip+x]=sx_old[3];
 
             //     sy_new_m[0][iip+x]=sy_new[0];
             //     sy_new_m[1][iip+x]=sy_new[1];
             //     sy_new_m[2][iip+x]=sy_new[2];
             //     sy_new_m[3][iip+x]=sy_new[3];
             //     sy_old_m[0][iip+x]=sy_old[0];
             //     sy_old_m[1][iip+x]=sy_old[1];
             //     sy_old_m[2][iip+x]=sy_old[2];
             //     sy_old_m[3][iip+x]=sy_old[3];
 
             //     sz_new_m[0][iip+x]=sz_new[0];
             //     sz_new_m[1][iip+x]=sz_new[1];
             //     sz_new_m[2][iip+x]=sz_new[2];
             //     sz_new_m[3][iip+x]=sz_new[3];
             //     sz_old_m[0][iip+x]=sz_old[0];
             //     sz_old_m[1][iip+x]=sz_old[1];
             //     sz_old_m[2][iip+x]=sz_old[2];
             //     sz_old_m[3][iip+x]=sz_old[3];
             // }
 
             // for(int x=0;x<8;x++){
             //     if(x_new_test[x]<1){
             //         printf("xnew: %f, ip: %d\n",x_new_test[x],ip+x);
             //         amrex::Abort("X new <1!");
             //     }
             // }
             // double sx_new_m1[depos_order + 1][block_size] = {0.};
             // double sx_old_m1[depos_order + 1][block_size] = {0.};
 
             // int64_t i_new1[block_size];
             // int64_t i_old1[block_size];
             // double* sx_new_temp[4] = {&sx_new_m1[0][iip], &sx_new_m1[1][iip], &sx_new_m1[2][iip], &sx_new_m1[3][iip]};
             // double* sx_old_temp[4] = {&sx_old_m1[0][iip], &sx_old_m1[1][iip], &sx_old_m1[2][iip], &sx_old_m1[3][iip]};
             // compute_shape_factor_v(&i_new1[iip], sx_new_temp, x_new, p_ip);
             // compute_shape_factor_v(&i_old1[iip], sx_old_temp, x_old, p_ip);
             // for(int x=0;x<8;x++){
             //     printf("\n ip %d; org inew %d , sve inew %d ",ip+x,i_new[ip+x],i_new1[iip+x]);
             //     printf("\n ip %d; org sxnew %f , sve sxnew %f \n",ip+x,sx_new_m[0][iip+x],sx_new_m1[0][iip+x]);
             //     printf("\n ip %d; org sxnew %f , sve sxnew %f \n",ip+x,sx_new_m[1][iip+x],sx_new_m1[1][iip+x]);
             //     printf("\n ip %d; org sxnew %f , sve sxnew %f \n",ip+x,sx_new_m[2][iip+x],sx_new_m1[2][iip+x]);
             //     printf("\n ip %d; org sxnew %f , sve sxnew %f \n",ip+x,sx_new_m[3][iip+x],sx_new_m1[3][iip+x]);
             // }
             // amrex::Abort("Stop");
 
             double* sx_new_temp[4] = {&sx_new_m[0][iip], &sx_new_m[1][iip], &sx_new_m[2][iip], &sx_new_m[3][iip]};
             double* sx_old_temp[4] = {&sx_old_m[0][iip], &sx_old_m[1][iip], &sx_old_m[2][iip], &sx_old_m[3][iip]};
             svint64_t i_newv=compute_shape_factor_v2(&i_new[iip], sx_new_temp, x_new, p_ip);
             svint64_t i_oldv=compute_shape_factor_v2(&i_old[iip], sx_old_temp, x_old, p_ip);
             // compute_shape_factor_v(&i_new[iip], sx_new_temp, x_new, p_ip);
             // compute_shape_factor_v(&i_old[iip], sx_old_temp, x_old, p_ip);
             
             // for(int x=0;x<8;x++){
             //     if(i_new[x+iip*vl]<0){
             //         printf("i new: %d, ip: %d\n",i_new[x+iip*vl],ip+x);
             //         printf("i old: %d, ip: %d\n",i_old[x+iip*vl],ip+x);
             //         printf("xnew: %f, ip: %d\n",x_new_test[x],ip+x);
             //         printf("xold: %f, ip: %d\n",x_old_test[x],ip+x);
             //         printf("xp: %f,vx: %f,mx: %f\n",xp_test[x],vx_test[x],mx[0]);
             //         printf("uxp: %f\n",uxp[ip]);
             //         amrex::Abort("i new <0!");
             //     }
             // }
 
             double* sy_new_temp[4] = {&sy_new_m[0][iip], &sy_new_m[1][iip], &sy_new_m[2][iip], &sy_new_m[3][iip]};
             double* sy_old_temp[4] = {&sy_old_m[0][iip], &sy_old_m[1][iip], &sy_old_m[2][iip], &sy_old_m[3][iip]};
             svint64_t j_newv=compute_shape_factor_v2(&j_new[iip], sy_new_temp, y_new, p_ip);
             svint64_t j_oldv=compute_shape_factor_v2(&j_old[iip], sy_old_temp, y_old, p_ip);
             // compute_shape_factor_v(&j_new[iip], sy_new_temp, y_new, p_ip);
             // compute_shape_factor_v(&j_old[iip], sy_old_temp, y_old, p_ip);
 
             double* sz_new_temp[4] = {&sz_new_m[0][iip], &sz_new_m[1][iip], &sz_new_m[2][iip], &sz_new_m[3][iip]};
             double* sz_old_temp[4] = {&sz_old_m[0][iip], &sz_old_m[1][iip], &sz_old_m[2][iip], &sz_old_m[3][iip]};
             svint64_t k_newv=compute_shape_factor_v2(&k_new[iip], sz_new_temp, z_new, p_ip);
             svint64_t k_oldv=compute_shape_factor_v2(&k_old[iip], sz_old_temp, z_old, p_ip);
             // compute_shape_factor_v(&k_new[iip], sz_new_temp, z_new, p_ip);
             // compute_shape_factor_v(&k_old[iip], sz_old_temp, z_old, p_ip);
             svbool_t p_i=svcmpeq_s64(p_ip,i_newv,i_oldv);
             svbool_t p_j=svcmpeq_s64(p_ip,j_newv,j_oldv);
             svbool_t p_k=svcmpeq_s64(p_ip,k_newv,k_oldv);
             p_i=svand_z(p_ip,p_i,p_j);
             p_i=svand_z(p_ip,p_i,p_k);
             svuint64_t p_bran=svsel(p_i,ones,zeros);
             svst1(p_ip,&branch_index[iip],p_bran);
             
 
 
             // {
             //     // Shape factor arrays for current and old positions (nodal)
             //     // Keep these double to avoid bug in single precision.
 
             //     // Compute shape factors for current positions
 
             //     // i_new leftmost grid point in x that the particle touches
             //     // sx_new shape factor along x for the centering of each current
             //     Compute_shape_factor< depos_order > const compute_shape_factor;
             //     const int i_new = compute_shape_factor(sx_new, x_new);
             //     // j_new leftmost grid point in y that the particle touches
             //     // sy_new shape factor along y for the centering of each current
             //     const int j_new = compute_shape_factor(sy_new, y_new);
             //     // k_new leftmost grid point in z that the particle touches
             //     // sz_new shape factor along z for the centering of each current
             //     const int k_new = compute_shape_factor(sz_new, z_new);
 
             //     // Compute shape factors for old positions
 
             //     // i_old leftmost grid point in x that the particle touches
             //     // sx_old shape factor along x for the centering of each current
             //     const int i_old = compute_shape_factor(sx_old, x_old);
             //     // j_old leftmost grid point in y that the particle touches
             //     // sy_old shape factor along y for the centering of each current
             //     const int j_old = compute_shape_factor(sy_old, y_old);
             //     // k_old leftmost grid point in z that the particle touches
             //     // sz_old shape factor along z for the centering of each current
             //     const int k_old = compute_shape_factor(sz_old, z_old);
             // }
             // double* base0 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 0);
             // double* base1 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 1);
             // double* base2 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 2);
             // double* base3 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 3);
             // for(int i=iip;i<vl;i++){
             //     indices0[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 0) - base0;
             //     indices1[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 1) - base1;
             //     indices2[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 2) - base2;
             //     indices3[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 3) - base3;
             // }
 
             uint64_t t1 = rdtscv();
             pre_time += (t1-t0);
         }
 
             // Deposit current into Dx_arr, Dy_arr and Dz_arr
 
         // uint64_t tt1 = rdtscv();
         // svbool_t p = svwhilele_b64(0,depos_order+1);
         // Vec sx_new_v = Vec::Load(p, &sx_new[0]);
         // Vec sx_old_v = Vec::Load(p, &sx_old[0]);
         // uint64_t tt2 = rdtscv();
         // cal_time += (tt2-tt1);
         double sxn_syn_szn[vl];
         double sxo_syn_szn[vl];
         double sxn_syo_szn[vl];
         double sxo_syo_szn[vl];
         double sxn_syn_szo[vl];
         double sxo_syn_szo[vl];
         double sxn_syo_szo[vl];
         double sxo_syo_szo[vl];
         double coef0 = invvol * invdt;
         uint64_t loop0=rdtscv();
         for (int k=0; k<=depos_order; k++) {
             double* sz_new_v=sz_new_m[k];
             double* sz_old_v=sz_old_m[k];
             for (int j=0; j<=depos_order; j++) {
                 double* sy_new_v=sy_new_m[j];
                 double* sy_old_v=sy_old_m[j];
                 for (int i=0; i<=depos_order; i++) {
                     double* sx_new_v=sx_new_m[i];
                     double* sx_old_v=sx_old_m[i];
                     for(int iip=0;iip<block_size/vl;iip+=vl) {
                         long ip1=iip+block_id*block_size;
                         svbool_t p=svwhilele_b64(ip1,np_to_deposit);
                         uint64_t tt0 = rdtscv();
                         Vec sx_new = Vec::Load(p, &sx_new_v[iip]);
                         Vec sx_old = Vec::Load(p, &sx_old_v[iip]);
                         Vec sy_new = Vec::Load(p, &sy_new_v[iip]);
                         Vec sy_old = Vec::Load(p, &sy_old_v[iip]);
                         Vec sz_new = Vec::Load(p, &sz_new_v[iip]);
                         Vec sz_old = Vec::Load(p, &sz_old_v[iip]);
                         Vec wq_v = Vec::Load(p, &wq[iip]);
 
                         Vec coef = wq_v * coef0;
                         Vec syn_szn = coef * (sy_new * sz_new);
                         Vec syo_szn = coef * (sy_old * sz_new);
                         Vec syn_szo = coef * (sy_new * sz_old);
                         Vec syo_szo = coef * (sy_old * sz_old);
                         // Vec temp0_v=sx_new * sy_new * sz_new;
                         // double temp0[8];
                         // temp0_v.Store(p,&temp0[0]);
 
                         
                         Vec sxn_syn_szn_v = (sx_new) * syn_szn;
                         Vec sxo_syn_szn_v = (sx_old) * syn_szn;
                         Vec sxn_syo_szn_v = (sx_new) * syo_szn;
                         Vec sxo_syo_szn_v = (sx_old) * syo_szn;
                         Vec sxn_syn_szo_v = (sx_new) * syn_szo;
                         Vec sxo_syn_szo_v = (sx_old) * syn_szo;
                         Vec sxn_syo_szo_v = (sx_new) * syo_szo;
                         Vec sxo_syo_szo_v = (sx_old) * syo_szo;
 
                         // sxn_syn_szn_v.Store(p, &sxn_syn_szn[0]);
                         // sxo_syn_szn_v.Store(p, &sxo_syn_szn[0]);
                         // sxn_syo_szn_v.Store(p, &sxn_syo_szn[0]);
                         // sxo_syo_szn_v.Store(p, &sxo_syo_szn[0]);
                         // sxn_syn_szo_v.Store(p, &sxn_syn_szo[0]);
                         // sxo_syn_szo_v.Store(p, &sxo_syn_szo[0]);
                         // sxn_syo_szo_v.Store(p, &sxn_syo_szo[0]);
                         // sxo_syo_szo_v.Store(p, &sxo_syo_szo[0]);
                         uint64_t t2 = rdtscv();
                         cal_time += (t2-tt0);
 
                         svuint64_t p_bran=svld1_u64(p, &branch_index[iip]);
                         // for(int in=0;in<8;in++){
                         //     printf("branch %d\n",branch_index[iip+in]);
                         // }
                         svbool_t p_b=svcmpeq_u64(p,p_bran,ones);
                         // svbool_t p_bt=svcmpeq_u64(p,p_bran,zeros);
                         if(svptest_any(p,p_b))
                         {                          
                             // if (i_new[ip] == i_old[ip] && j_new[ip] == j_old[ip] && k_new[ip] == k_old[ip]) 
                             // if (i_new[0] == i_old[0] && j_new[0] == j_old[0] && k_new[0] == k_old[0]) 
                             // {
                                 uint64_t save1 = rdtscv();
                                 // if ((lo.x+i_new[ip]+i)<temp_arr.begin.x || 
                                 //     (lo.x+i_new[ip]+i)>=temp_arr.end.x || 
                                 //     (lo.y+j_new[ip]+j)<temp_arr.begin.y || 
                                 //     (lo.y+j_new[ip]+j)>=temp_arr.end.y || 
                                 //     (lo.z+k_new[ip]+k)<temp_arr.begin.z || 
                                 //     (lo.z+k_new[ip]+k)>=temp_arr.end.z) {
                                 //     // AMREX_IF_ON_DEVICE((
                                 //     //     AMREX_DEVICE_PRINTF(" (%d,%d,%d,%d) is out of bound (%d:%d,%d:%d,%d:%d,0:%d)\n",
                                 //     //                         (lo.x+i_new[ip]-1+i), (lo.y+j_new[ip]-1+j), (lo.z+k_new[ip]-1+k), n, temp_arr.begin.x, temp_arr.end.x-1, temp_arr.begin.y, temp_arr.end.y-1,
                                 //     //                         temp_arr.begin.z, temp_arr.end.z-1, ncomp-1);
                                 //     //     amrex::Abort();
                                 //     // ))
                                 //                         // amrex::Print()<<"dilv: "<< dil[ip]<<std::endl;
                                 //                         // amrex::Print()<<"djlv: "<< djl[ip]<<std::endl;
 
                                 //     // amrex::Print() << lo.x << ", " << i_new[ip] << ", "<< m << ", "<< ip << ", " << i << std::endl;
                                 //     amrex::Print() << lo.x << ", " << i_new[ip] << ", "<< ip << ", " << j << std::endl;
                                 //     AMREX_IF_ON_HOST((
                                 //         std::stringstream ss;
                                 //         ss << " (" << (lo.x+i_new[ip]+i) << "," << (lo.y+j_new[ip]+j) << "," << (lo.z+k_new[ip]+k)  
                                 //         << ") is out of bound ("
                                 //         << temp_arr.begin.x << ":" << temp_arr.end.x-1 << ","
                                 //         << temp_arr.begin.y << ":" << temp_arr.end.y-1 << ","
                                 //         << temp_arr.begin.z << ":" << temp_arr.end.z-1 << ")";
                                 //         // amrex::Gpu::Atomic::AddNoRet( &temp_arr(lo.x+i_new[ip]+i, lo.y+j_new[ip]+j, lo.z+k_new[ip]-1+k), temp2[m]);
                                 //         // amrex::Print()<<ss.str()<<std::endl;
                                 //         amrex::Abort(ss.str());
                                 //     ))
                                 // }
                                 // temp arrays for Dx, Dy and Dz
                                 // double ERR1=temp_arr(lo.x + i_new[ip] + i, lo.y + j_new[ip] + j, lo.z + k_new[ip] + k, 0)- (sxn_syn_szn[index] - sxo_syo_szo[index]);
                                 // double ERR2=temp_arr(lo.x + i_new[ip] + i, lo.y + j_new[ip] + j, lo.z + k_new[ip] + k, 1)- (sxn_syn_szo[index] - sxo_syo_szn[index]);
                                 // double ERR3=temp_arr(lo.x + i_new[ip] + i, lo.y + j_new[ip] + j, lo.z + k_new[ip] + k, 2)- (sxn_syo_szn[index] - sxo_syn_szo[index]);
                                 // double ERR4=temp_arr(lo.x + i_new[ip] + i, lo.y + j_new[ip] + j, lo.z + k_new[ip] + k, 3)- (sxo_syn_szn[index] - sxn_syo_szo[index]);
 
                                 double* base0 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 0);
                                 double* base1 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 1);
                                 double* base2 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 2);
                                 double* base3 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 3);
                                 for(int i=iip;i<vl;i++){
                                     indices0[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 0) - base0;
                                     indices1[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 1) - base1;
                                     indices2[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 2) - base2;
                                     indices3[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 3) - base3;
                                 }
                 
                                 svuint64_t indices_v0=svld1_u64(p,&indices0[iip]);
                                 Vec v0(svld1_gather_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 0),indices_v0));
                                 v0+= (sxn_syn_szn_v - sxo_syo_szo_v);
                                 svst1_scatter_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 0),indices_v0,v0);
                                 
                                 svuint64_t indices_v1=svld1_u64(p,&indices1[iip]);
                                 Vec v1(svld1_gather_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 1),indices_v1));
                                 v1+= (sxn_syn_szo_v - sxo_syo_szn_v);
                                 svst1_scatter_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 1),indices_v1,v1);
                                 
                                 svuint64_t indices_v2=svld1_u64(p,&indices2[iip]);
                                 Vec v2(svld1_gather_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 2),indices_v2));
                                 v2+= (sxn_syo_szn_v - sxo_syn_szo_v);
                                 svst1_scatter_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 2),indices_v2,v2);
                                 
                                 svuint64_t indices_v3=svld1_u64(p,&indices3[iip]);
                                 Vec v3(svld1_gather_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 3),indices_v3));
                                 v3+= (sxo_syn_szn_v - sxn_syo_szo_v);
                                 svst1_scatter_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 3),indices_v3,v3);
 
 
                                 // if(0&&std::abs(ERR1)>1e-9){
                                 //     printf("\ni:%d, j:%d, k:%d, block:%d, temp: %f, org: %f, ERR1 : %f, ip: %d \n",i,j,k,block_id,
                                 //             temp_arr(lo.x + i_new[ip] + i, lo.y + j_new[ip] + j, lo.z + k_new[ip] + k, 0), (sxn_syn_szn[index] - sxo_syo_szo[index]),ERR1,ip+block_id*block_size);
                                 //     printf(" ORG IP %d: sxnew=%f,wqv=%f,inew=%d,xnew=%f,xpv=%f,invgamv=%f,sxn=%f, tmpv= %f \n",
                                 //         ip+block_id*block_size,sxnew[ip+block_id*block_size],wqv[ip+block_id*block_size],
                                 //         inewv[ip+block_id*block_size], xnewv[ip+block_id*block_size], 
                                 //         xpv[ip+block_id*block_size],invgamv[ip+block_id*block_size],
                                 //         sxn[ip+block_id*block_size],tmpv[ip+block_id*block_size]);
 
                                 //     printf(" SVE IP %d: sxnew=%f,wqv=%f,inew=%d,xnew=%f,xpv=%f,invgamv=%f,sxn=%f, tmpv= %f \n",
                                 //         ip+block_id*block_size,sx_new_v[ip],wq[ip],i_new[ip], 
                                 //         x_newv[ip], xp_test[ip],inv_test[ip],temp0[index],(sxn_syn_szn[index] - sxo_syo_szo[index]));
                                 //         amrex::Abort("ERR 1!");
                                 // }
                                 // if(std::abs(ERR2)>1e-9){printf("\ni:%d, j:%d, k:%d, block:%d, ERR2 : %f, ip: %d",i,j,k,block_id,ERR2,ip);}
                                 // if(std::abs(ERR3)>1e-9){printf("\ni:%d, j:%d, k:%d, block:%d, ERR3 : %f, ip: %d",i,j,k,block_id,ERR3,ip);}
                                 // if(std::abs(ERR4)>1e-9){printf("\ni:%d, j:%d, k:%d, block:%d, ERR4 : %f, ip: %d",i,j,k,block_id,ERR4,ip);}
                                                                                      
                                 
                                 // if(0&&(std::abs(ERR1)>1e-9||std::abs(ERR2)>1e-9||std::abs(ERR3)>1e-9||std::abs(ERR4)>1e-9)&&ip<256&&i==1){
                                 //     printf("\n ORG IP %d: sxnew=%f,wqv=%f,inew=%f,xnew=%f,xpv=%f,invgamv=%f,sxn=%f,tmpv= %f \n",
                                 //         ip,sxnew[ip],wqv[ip],inewv[ip], xnewv[ip], xpv[ip],invgamv[ip],sxn[ip],tmpv[ip]);
                                 //     printf(" SVE IP %d: sxnew=%f,wqv=%f,inew=%f,xnew=%f,xpv=%f,invgamv=%f,sxn=%f,tmpv= %f \n",
                                 //         ip,sx_new_v[ip],wq[ip],i_new[ip], x_newv[ip], xp_test[ip],inv_test[ip],temp0[index],(sxn_syn_szo[ip] - sxo_syo_szn[ip]));
                                 //     // temp=sxn_syn_szn*wq * invvol * invdt;
                                 //     // printf("sxn %f, temp=%f, wq %f * invvol %f * invdt %f\n",sxn_syn_szn,temp,wq, invvol, invdt);
                                 // }
                                 // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new[ip] + i, lo.y + j_new[ip] + j, lo.z + k_new[ip] + k, 0),
                                 //     (sxn_syn_szn[index] - sxo_syo_szo[index]));
 
                                 // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new[ip] + i, lo.y + j_new[ip] + j, lo.z + k_new[ip] + k, 1),
                                 //     (sxn_syn_szo[index] - sxo_syo_szn[index]));
 
                                 // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new[ip] + i, lo.y + j_new[ip] + j, lo.z + k_new[ip] + k, 2),
                                 //     (sxn_syo_szn[index] - sxo_syn_szo[index]));
 
                                 // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new[ip] + i, lo.y + j_new[ip] + j, lo.z + k_new[ip] + k, 3),
                                 //     (sxo_syn_szn[index] - sxn_syo_szo[index]));
                                 uint64_t save2 = rdtscv();
                                 save_time1 += (save2-save1);
                             } 
                             else {
                             //     sxn_syn_szn_v.Store(p, &sxn_syn_szn[0]);
                             //     sxo_syn_szn_v.Store(p, &sxo_syn_szn[0]);
                             //     sxn_syo_szn_v.Store(p, &sxn_syo_szn[0]);
                             //     sxo_syo_szn_v.Store(p, &sxo_syo_szn[0]);
                             //     sxn_syn_szo_v.Store(p, &sxn_syn_szo[0]);
                             //     sxo_syn_szo_v.Store(p, &sxo_syn_szo[0]);
                             //     sxn_syo_szo_v.Store(p, &sxn_syo_szo[0]);
                             //     sxo_syo_szo_v.Store(p, &sxo_syo_szo[0]);
                             // for(int index=0;index<vl;index++){
                             //     int ip = index + iip;
                                 uint64_t save3 = rdtscv();
                                 // if ((lo.x+i_new[ip]+i)<temp_arr.begin.x || 
                                 //     (lo.x+i_new[ip]+i)>=temp_arr.end.x || 
                                 //     (lo.y+j_new[ip]+j)<temp_arr.begin.y || 
                                 //     (lo.y+j_new[ip]+j)>=temp_arr.end.y || 
                                 //     (lo.z+k_new[ip]+k)<temp_arr.begin.z || 
                                 //     (lo.z+k_new[ip]+k)>=temp_arr.end.z) {
                                 //     // AMREX_IF_ON_DEVICE((
                                 //     //     AMREX_DEVICE_PRINTF(" (%d,%d,%d,%d) is out of bound (%d:%d,%d:%d,%d:%d,0:%d)\n",
                                 //     //                         (lo.x+i_new[ip]-1+i), (lo.y+j_new[ip]-1+j), (lo.z+k_new[ip]-1+k), n, temp_arr.begin.x, temp_arr.end.x-1, temp_arr.begin.y, temp_arr.end.y-1,
                                 //     //                         temp_arr.begin.z, temp_arr.end.z-1, ncomp-1);
                                 //     //     amrex::Abort();
                                 //     // ))
                                 //                         // amrex::Print()<<"dilv: "<< dil[ip]<<std::endl;
                                 //                         // amrex::Print()<<"djlv: "<< djl[ip]<<std::endl;
 
                                 //     // amrex::Print() << lo.x << ", " << i_new[ip] << ", "<< m << ", "<< ip << ", " << i << std::endl;
                                 //     amrex::Print() << lo.y << ", " << j_new[ip] << ", " << ", "<< ip << ", " << j << std::endl;
                                 //     AMREX_IF_ON_HOST((
                                 //         std::stringstream ss;
                                 //         ss << " (" << (lo.x+i_new[ip]+i) << "," << (lo.y+j_new[ip]+j) << "," << (lo.z+k_new[ip]+k)  
                                 //         << ") is out of bound ("
                                 //         << temp_arr.begin.x << ":" << temp_arr.end.x-1 << ","
                                 //         << temp_arr.begin.y << ":" << temp_arr.end.y-1 << ","
                                 //         << temp_arr.begin.z << ":" << temp_arr.end.z-1 << ")";
                                 //         // amrex::Gpu::Atomic::AddNoRet( &temp_arr(lo.x+i_new[ip]+i, lo.y+j_new[ip]+j, lo.z+k_new[ip]-1+k), temp2[m]);
                                 //         // amrex::Print()<<ss.str()<<std::endl;
                                 //         amrex::Abort(ss.str());
                                 //     ))
                                 // }
 
 
                                 double* base0 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 0);
                                 double* base1 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 1);
                                 double* base2 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 2);
                                 double* base3 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 3);
                                 double* base0old = &temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 0);
                                 double* base1old = &temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 1);
                                 double* base2old = &temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 2);
                                 double* base3old = &temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 3);
                                 for(int i=iip;i<vl;i++){
                                     indices0[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 0) - base0;
                                     indices1[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 1) - base1;
                                     indices2[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 2) - base2;
                                     indices3[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 3) - base3;
                                     indices0old[iip+i] =  &temp_arr(lo.x + i_old[iip+i] + i, lo.y + j_old[iip+i] + j, lo.z + k_old[iip+i] + k, 0) - base0old;
                                     indices1old[iip+i] =  &temp_arr(lo.x + i_old[iip+i] + i, lo.y + j_old[iip+i] + j, lo.z + k_old[iip+i] + k, 1) - base1old;
                                     indices2old[iip+i] =  &temp_arr(lo.x + i_old[iip+i] + i, lo.y + j_old[iip+i] + j, lo.z + k_old[iip+i] + k, 2) - base2old;
                                     indices3old[iip+i] =  &temp_arr(lo.x + i_old[iip+i] + i, lo.y + j_old[iip+i] + j, lo.z + k_old[iip+i] + k, 3) - base3old;
                                 }
                 
                                 svuint64_t indices_v0=svld1_u64(p,&indices0[iip]);
                                 Vec v0(svld1_gather_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 0),indices_v0));
                                 v0+= (sxn_syn_szn_v);
                                 svst1_scatter_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 0),indices_v0,v0);
                                 
                                 svuint64_t indices_v1=svld1_u64(p,&indices1[iip]);
                                 Vec v1(svld1_gather_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 1),indices_v1));
                                 v1+= (sxn_syn_szo_v );
                                 svst1_scatter_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 1),indices_v1,v1);
                                 
                                 svuint64_t indices_v2=svld1_u64(p,&indices2[iip]);
                                 Vec v2(svld1_gather_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 2),indices_v2));
                                 v2+= (sxn_syo_szn_v);
                                 svst1_scatter_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 2),indices_v2,v2);
                                 
                                 svuint64_t indices_v3=svld1_u64(p,&indices3[iip]);
                                 Vec v3(svld1_gather_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 3),indices_v3));
                                 v3+= (sxo_syn_szn_v);
                                 svst1_scatter_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 3),indices_v3,v3);
                                 
                                 svuint64_t indices_v0old=svld1_u64(p,&indices0old[iip]);
                                 Vec v0old(svld1_gather_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 0),indices_v0old));
                                 v0old+= ( - sxo_syo_szo_v);
                                 svst1_scatter_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 0),indices_v0,v0);
                                 
                                 svuint64_t indices_v1old=svld1_u64(p,&indices1old[iip]);
                                 Vec v1old(svld1_gather_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 1),indices_v1old));
                                 v1old+= ( - sxo_syo_szn_v);
                                 svst1_scatter_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 1),indices_v1,v1);
                                 
                                 svuint64_t indices_v2old=svld1_u64(p,&indices2old[iip]);
                                 Vec v2old(svld1_gather_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 2),indices_v2old));
                                 v2old+= ( - sxo_syn_szo_v);
                                 svst1_scatter_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 2),indices_v2,v2);
                                 
                                 svuint64_t indices_v3old=svld1_u64(p,&indices3old[iip]);
                                 Vec v3old(svld1_gather_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 3),indices_v3old));
                                 v3old+= ( - sxn_syo_szo_v);
                                 svst1_scatter_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 3),indices_v3,v3);
 
                                 // temp arrays for Dx, Dy and Dz
                                 // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new[ip] + i, lo.y + j_new[ip] + j, lo.z + k_new[ip] + k, 0),
                                 //     sxn_syn_szn[index]);
 
                                 // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old[ip] + i, lo.y + j_old[ip] + j, lo.z + k_old[ip] + k, 0),
                                 //     - sxo_syo_szo[index]);
 
                                 // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new[ip] + i, lo.y + j_new[ip] + j, lo.z + k_old[ip] + k, 1),
                                 //     sxn_syn_szo[index]);
 
                                 // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old[ip] + i, lo.y + j_old[ip] + j, lo.z + k_new[ip] + k, 1),
                                 //     - sxo_syo_szn[index]);
 
                                 // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new[ip] + i, lo.y + j_old[ip] + j, lo.z + k_new[ip] + k, 2),
                                 //     sxn_syo_szn[index]);
 
                                 // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old[ip] + i, lo.y + j_new[ip] + j, lo.z + k_old[ip] + k, 2),
                                 //     - sxo_syn_szo[index]);
 
                                 // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_old[ip] + i, lo.y + j_new[ip] + j, lo.z + k_new[ip] + k, 3),
                                 //     sxo_syn_szn[index]);
 
                                 // amrex::Gpu::Atomic::AddNoRet(&temp_arr(lo.x + i_new[ip] + i, lo.y + j_old[ip] + j, lo.z + k_old[ip] + k, 3),
                                 //     - sxn_syo_szo[index]);
                                 uint64_t save4 = rdtscv();
                                 save_time2 += (save4-save3);
                             // }
                         }
                         uint64_t t3 = rdtscv();
                         save_time += (t3-t2);
 
                     }
                 }
             }
         }
         uint64_t loop1=rdtscv();
         nijk_loop_time+=(loop1-loop0);
         // amrex::Abort("END BLOCK");
     }
     uint64_t t4 = rdtscv();
     const amrex::Box& bx=Dx_fab.box();
     const amrex::IntVect Dxlo=bx.smallEnd();
     const amrex::IntVect Dxhi=bx.bigEnd();
     // amrex::Array4<amrex::Real> const& Dx_arr = Dx_fab.array();
     // amrex::Array4<amrex::Real> const& Dy_arr = Dy_fab.array();
     // amrex::Array4<amrex::Real> const& Dz_arr = Dz_fab.array();
     // int count=0;
     // printf("\ni= %d ,leni =%d", Dxhi[0], Dxhi[0]-Dxlo[0]);
     // printf("\ni= %d ,leni =%d", Dxhi[1], Dxhi[1]-Dxlo[1]);
     // printf("\ni= %d ,leni =%d", Dxhi[2], Dxhi[2]-Dxlo[2]);
     for(int k=Dxlo[2];k<=Dxhi[2];++k){
         for(int j=Dxlo[1];j<=Dxhi[1];++j){
             // for(int i=Dxlo[0];i<=Dxhi[0];i++){
             for(int i=Dxlo[0];i<=Dxhi[0];i+=vl){
     // amrex::ParallelFor(Dx_fab.box(), [&] AMREX_GPU_DEVICE (int i, int j, int k) noexcept
     // {
                 // const amrex::Real t_a = temp_arr(i,j,k,0);
                 // const amrex::Real t_b = temp_arr(i,j,k,1);
                 // const amrex::Real t_c = temp_arr(i,j,k,2);
                 // const amrex::Real t_d = temp_arr(i,j,k,3);
                 // Dx_arr(i,j,k) += (1._rt/6._rt)*(2_rt*t_a       + t_b       + t_c - 2._rt*t_d);
                 // Dy_arr(i,j,k) += (1._rt/6._rt)*(2_rt*t_a       + t_b - 2._rt*t_c       + t_d);
                 // Dz_arr(i,j,k) += (1._rt/6._rt)*(2_rt*t_a - 2._rt*t_b       + t_c       + t_d);
 
                 svbool_t p = svwhilele_b64(i,Dxhi[0]);
                 Vec t_av=Vec::Load(p,&temp_arr(i,j,k,0));
                 Vec t_bv=Vec::Load(p,&temp_arr(i,j,k,1));
                 Vec t_cv=Vec::Load(p,&temp_arr(i,j,k,2));
                 Vec t_dv=Vec::Load(p,&temp_arr(i,j,k,3));
 
                 Vec Dx_arrv=Vec::Load(p,&Dx_arr(i,j,k));
                 Vec Dy_arrv=Vec::Load(p,&Dy_arr(i,j,k));
                 Vec Dz_arrv=Vec::Load(p,&Dz_arr(i,j,k));
                 Dx_arrv += (1._rt/6._rt)*(2_rt*t_av       + t_bv       + t_cv - 2._rt*t_dv);
                 Dy_arrv += (1._rt/6._rt)*(2_rt*t_av       + t_bv - 2._rt*t_cv       + t_dv);
                 Dz_arrv += (1._rt/6._rt)*(2_rt*t_av - 2._rt*t_bv       + t_cv       + t_dv);
 
                 // double tempdx[vl];
                 // double tempdy[vl];
                 // double tempdz[vl];
                 // for(int xind = 0;xind<vl&&(xind+i)<=Dxhi[0];xind++){
                 //     const amrex::Real t_a = temp_arr(i+xind,j,k,0);
                 //     const amrex::Real t_b = temp_arr(i+xind,j,k,1);
                 //     const amrex::Real t_c = temp_arr(i+xind,j,k,2);
                 //     const amrex::Real t_d = temp_arr(i+xind,j,k,3);
                 //     tempdx[xind]=Dx_arr(i+xind,j,k) + (1._rt/6._rt)*(2_rt*t_a       + t_b       + t_c - 2._rt*t_d);
                 //     tempdy[xind]=Dy_arr(i+xind,j,k) + (1._rt/6._rt)*(2_rt*t_a       + t_b - 2._rt*t_c       + t_d);
                 //     tempdz[xind]=Dz_arr(i+xind,j,k) + (1._rt/6._rt)*(2_rt*t_a - 2._rt*t_b       + t_c       + t_d);
                 //     // printf("dx %f\n ",Dx_arr(i+xind,j,k) + (1._rt/6._rt)*(2_rt*t_a       + t_b       + t_c - 2._rt*t_d));
                 //     // printf("yx %f\n ",Dy_arr(i+xind,j,k) + (1._rt/6._rt)*(2_rt*t_a       + t_b - 2._rt*t_c       + t_d));
                 //     // printf("zx %f\n ",Dz_arr(i+xind,j,k) + (1._rt/6._rt)*(2_rt*t_a - 2._rt*t_b       + t_c       + t_d));
                 // }
 
                 Dx_arrv.Store(p,&Dx_arr(i,j,k));
                 Dy_arrv.Store(p,&Dy_arr(i,j,k));
                 Dz_arrv.Store(p,&Dz_arr(i,j,k));
                 // for(int xind = 0;xind<vl&&(xind+i)<=Dxhi[0];xind++){
                 //     double ERR1=Dx_arr(i+xind,j,k)-tempdx[xind];
                 //     double ERR2=Dy_arr(i+xind,j,k)-tempdy[xind];
                 //     double ERR3=Dz_arr(i+xind,j,k)-tempdz[xind];
                 //     if(ERR1>1e-9||ERR2>1e-9||ERR3>1e-9){
                 //         printf("ERRx %f\n ",Dx_arr(i+xind,j,k)-tempdx[xind]);
                 //         printf("ERRy %f\n ",Dy_arr(i+xind,j,k)-tempdy[xind]);
                 //         printf("ERRz %f\n ",Dz_arr(i+xind,j,k)-tempdz[xind]);
                 //     }
                     // printf("dx %f\n ",Dx_arr(i+xind,j,k));
                     // printf("yx %f\n ",Dy_arr(i+xind,j,k));
                     // printf("zx %f\n ",Dz_arr(i+xind,j,k));
                 // }
                 // amrex::Abort("Test Over!");
                 
                 // printf("i %d, j %d, k %d count %d \n",i,j,k,count);
     // });
             }
         }
     }
     uint64_t t5 = rdtscv();
     post_time += (t5-t4);
 #elif 0 //SME
         VayDepositionSME_trans<depos_order>(
            GetPosition,wp,uxp,uyp,uzp,ion_lev,np_to_deposit,dt,relative_time,dinv,xyzmin,lo,q, invvol, invdt,invcsq, temp_arr,
            Dx_arr,Dy_arr,Dz_arr,Dx_fab);
 
 #endif 
     // Synchronize so that temp_fab can be safely deallocated in its destructor
     amrex::Gpu::streamSynchronize();
 
 uint64_t step1 = rdtscv();
 step_time = (step1-step0);
     printf("\n Step_time: %d, pre_time: %d,  trans_time: %d, loop_time: %d, cal_time: %d,  read_time: %d, save_time1: %d,save_time2: %d,save_time: %d,  post_time: %d \n", 
                step_time,     pre_time,   trans_martix_time, nijk_loop_time, cal_time,      read_time,     save_time1,    save_time2,    save_time,      post_time);
 // amrex::Abort("Test Over!");
 }
 
 template <int depos_order>
 void doVayDepositionShapeN_trans (const GetParticlePosition<PIdx>& GetPosition,
                             const amrex::ParticleReal* const wp,
                             const amrex::ParticleReal* const uxp,
                             const amrex::ParticleReal* const uyp,
                             const amrex::ParticleReal* const uzp,
                             const int* const ion_lev,
                             amrex::FArrayBox& Dx_fab,
                             amrex::FArrayBox& Dy_fab,
                             amrex::FArrayBox& Dz_fab,
                             long np_to_deposit,
                             amrex::Real dt,
                             amrex::Real relative_time,
                             const amrex::XDim3 & dinv,
                             const amrex::XDim3 & xyzmin,
                             amrex::Dim3 lo,
                             amrex::Real q,
                             [[maybe_unused]]int n_rz_azimuthal_modes)
 {
     // uint64_t step0=rdtscv();
     using namespace amrex::literals;
     // If ion_lev is a null pointer, then do_ionization=0, else do_ionization=1
     const bool do_ionization = ion_lev;
 
     // Inverse of time step
     const amrex::Real invdt = 1._rt / dt;
 
     const amrex::Real invvol = dinv.x*dinv.y*dinv.z;
 
     // Allocate temporary arrays
     AMREX_ALWAYS_ASSERT(Dx_fab.box() == Dy_fab.box() && Dx_fab.box() == Dz_fab.box());
     amrex::FArrayBox temp_fab{Dx_fab.box(), 4};
 
     temp_fab.setVal<amrex::RunOn::Device>(0._rt);
     amrex::Array4<amrex::Real> const& temp_arr = temp_fab.array();
 
     // Inverse of light speed squared
     const amrex::Real invcsq = 1._rt / (PhysConst::c * PhysConst::c);
 
     // Arrays where D will be stored
     amrex::Array4<amrex::Real> const& Dx_arr = Dx_fab.array();
     amrex::Array4<amrex::Real> const& Dy_arr = Dy_fab.array();
     amrex::Array4<amrex::Real> const& Dz_arr = Dz_fab.array();
 
     std::vector<long> inewv(np_to_deposit,0);
     std::vector<double> xnewv(np_to_deposit,0);
     std::vector<double> tmpv(np_to_deposit,0);
     std::vector<double> xpv(np_to_deposit,0);
     std::vector<double> wqv(np_to_deposit,0);
     std::vector<double> sxnew(np_to_deposit,0);
     std::vector<double> invgamv(np_to_deposit,0);
     std::vector<double> sxn(np_to_deposit,0);
 
     const amrex::ParticleReal* mx = GetPosition.m_x;
     const amrex::ParticleReal* my = GetPosition.m_y;
     const amrex::ParticleReal* mz = GetPosition.m_z;
 
 
     // Loop over particles and deposit (Dx,Dy,Dz) into Dx_fab, Dy_fab and Dz_fab
     // amrex::ParallelFor(np_to_deposit, [&] AMREX_GPU_DEVICE (long ip)
 
     // auto compute_shape_factor_v = [](int64_t* i_new, double* sx[], Vec xmid, svbool_t p) {
     //     Vec j = svrintz_x(p, xmid);
     //     Vec xint = xmid - j;
     //     Vec temp = 1.0 - xint;
     //     Vec sx0 = (1.0 / 6.0) * temp * temp * temp;
     //     Vec sx1 = (2.0 / 3.0) - xint * xint * (1.0 - xint * 0.5);
     //     Vec sx2 = (2.0 / 3.0) - temp * temp * (1.0 - 0.5 *temp);
     //     Vec sx3 = (1.0 / 6.0) * xint * xint * xint;
     //     sx0.Store(p, sx[0]);
     //     sx1.Store(p, sx[1]);
     //     sx2.Store(p, sx[2]);
     //     sx3.Store(p, sx[3]);
     //     svst1(p, i_new, svsub_x(p, svcvt_s64_x(p,j), svdup_s64(1)));
     // };
 
     auto compute_shape_factor_v2 = [](int64_t* i_new,double* sx[], Vec xmid, svbool_t p) {
         Vec j = svrintz_x(p, xmid);
         Vec xint = xmid - j;
         Vec temp = 1.0 - xint;
         Vec sx0 = (1.0 / 6.0) * temp * temp * temp;
         Vec sx1 = (2.0 / 3.0) - xint * xint * (1.0 - xint * 0.5);
         Vec sx2 = (2.0 / 3.0) - temp * temp * (1.0 - 0.5 *temp);
         Vec sx3 = (1.0 / 6.0) * xint * xint * xint;
         sx0.Store(p, sx[0]);
         sx1.Store(p, sx[1]);
         sx2.Store(p, sx[2]);
         sx3.Store(p, sx[3]);
         svint64_t i_newv=svsub_x(p, svcvt_s64_x(p,j), svdup_s64(1));
         svst1(p, i_new, i_newv);
         return i_newv;
     };
 
     const int block_size=256;
     long n_blocks=np_to_deposit/block_size;
     int vl=svcntd();
     // #pragma omp parallel for
     for(int block_id=0;block_id<n_blocks;block_id++){
 
         double wq[block_size];
 
         double sx_new_m[depos_order + 1][block_size] = {0.};
         double sx_old_m[depos_order + 1][block_size] = {0.};
         double sy_new_m[depos_order + 1][block_size] = {0.};
         double sy_old_m[depos_order + 1][block_size] = {0.};
         double sz_new_m[depos_order + 1][block_size] = {0.};
         double sz_old_m[depos_order + 1][block_size] = {0.};
 
         int64_t i_new[block_size];
         int64_t i_old[block_size];
         int64_t j_new[block_size];
         int64_t j_old[block_size];
         int64_t k_new[block_size];
         int64_t k_old[block_size];
         uint64_t branch_index[block_size];
 
         uint64_t indices0[block_size];
         uint64_t indices1[block_size];
         uint64_t indices2[block_size];
         uint64_t indices3[block_size];
         uint64_t indices0old[block_size];
         uint64_t indices1old[block_size];
         uint64_t indices2old[block_size];
         uint64_t indices3old[block_size];
 
         svuint64_t ones=svdup_u64(1);
         svuint64_t zeros=svdup_u64(0);
 
         for(int iip=0;iip<block_size/vl;iip+=vl){
             long ip=iip+block_id*block_size;
             // uint64_t t0 = rdtscv();
             svbool_t p_ip=svwhilele_b64(ip,np_to_deposit);
             // Inverse of Lorentz factor gamma
             Vec uxp_v=Vec::Load(p_ip,&uxp[ip]);
             Vec uyp_v=Vec::Load(p_ip,&uyp[ip]);
             Vec uzp_v=Vec::Load(p_ip,&uzp[ip]);
             Vec invgam = 1._rt / (1._rt +  uxp_v * uxp_v * invcsq
                                         + uyp_v * uyp_v * invcsq
                                         + uzp_v * uzp_v * invcsq).Sqrt();
             // Product of particle charges and weights
             Vec wp_v=Vec::Load(p_ip,&wp[ip]);
             Vec wq_v = q * wp_v;
             // if (do_ionization) { 
             //     svint64_t ion_lev_v=svld1_s64(p_ip,&ion_lev[ip]);
             //     wq_v *= svcvt_f64_x(p_ip, ion_lev_v);
             //     // wq_v *= ion_lev_v; 
             // }
             wq_v.Store(p_ip, &wq[iip]);
 
             // Current particle positions (in physical units)
             Vec xp = Vec::Load(p_ip, &mx[ip]);
             Vec yp = Vec::Load(p_ip, &my[ip]);
             Vec zp = Vec::Load(p_ip, &mz[ip]);
 
             // Particle velocities
             Vec vx = uxp_v * invgam;
             Vec vy = uyp_v * invgam;
             Vec vz = uzp_v * invgam;
             // double vx_test[8];
             // vx.Store(p_ip,&vx_test[0]);
 
             // Modify the particle position to match the time of the deposition
             xp += relative_time * vx;
             yp += relative_time * vy;
             zp += relative_time * vz;
             // xp.Store(p_ip,&xp_test[iip]);
             // invgam.Store(p_ip,&inv_test[iip]);
 
             // Current and old particle positions in grid units
             // Keep these double to avoid bug in single precision.
             Vec x_new = (xp - xyzmin.x + 0.5_rt*dt*vx) * dinv.x;
             Vec x_old = (xp - xyzmin.x - 0.5_rt*dt*vx) * dinv.x;
             Vec y_new = (yp - xyzmin.y + 0.5_rt*dt*vy) * dinv.y;
             Vec y_old = (yp - xyzmin.y - 0.5_rt*dt*vy) * dinv.y;
             Vec z_new = (zp - xyzmin.z + 0.5_rt*dt*vz) * dinv.z;
             Vec z_old = (zp - xyzmin.z - 0.5_rt*dt*vz) * dinv.z;
 
             double* sx_new_temp[4] = {&sx_new_m[0][iip], &sx_new_m[1][iip], &sx_new_m[2][iip], &sx_new_m[3][iip]};
             double* sx_old_temp[4] = {&sx_old_m[0][iip], &sx_old_m[1][iip], &sx_old_m[2][iip], &sx_old_m[3][iip]};
             svint64_t i_newv=compute_shape_factor_v2(&i_new[iip], sx_new_temp, x_new, p_ip);
             svint64_t i_oldv=compute_shape_factor_v2(&i_old[iip], sx_old_temp, x_old, p_ip);
 
             double* sy_new_temp[4] = {&sy_new_m[0][iip], &sy_new_m[1][iip], &sy_new_m[2][iip], &sy_new_m[3][iip]};
             double* sy_old_temp[4] = {&sy_old_m[0][iip], &sy_old_m[1][iip], &sy_old_m[2][iip], &sy_old_m[3][iip]};
             svint64_t j_newv=compute_shape_factor_v2(&j_new[iip], sy_new_temp, y_new, p_ip);
             svint64_t j_oldv=compute_shape_factor_v2(&j_old[iip], sy_old_temp, y_old, p_ip);
             // compute_shape_factor_v(&j_new[iip], sy_new_temp, y_new, p_ip);
             // compute_shape_factor_v(&j_old[iip], sy_old_temp, y_old, p_ip);
 
             double* sz_new_temp[4] = {&sz_new_m[0][iip], &sz_new_m[1][iip], &sz_new_m[2][iip], &sz_new_m[3][iip]};
             double* sz_old_temp[4] = {&sz_old_m[0][iip], &sz_old_m[1][iip], &sz_old_m[2][iip], &sz_old_m[3][iip]};
             svint64_t k_newv=compute_shape_factor_v2(&k_new[iip], sz_new_temp, z_new, p_ip);
             svint64_t k_oldv=compute_shape_factor_v2(&k_old[iip], sz_old_temp, z_old, p_ip);
             // compute_shape_factor_v(&k_new[iip], sz_new_temp, z_new, p_ip);
             // compute_shape_factor_v(&k_old[iip], sz_old_temp, z_old, p_ip);
             svbool_t p_i=svcmpeq_s64(p_ip,i_newv,i_oldv);
             svbool_t p_j=svcmpeq_s64(p_ip,j_newv,j_oldv);
             svbool_t p_k=svcmpeq_s64(p_ip,k_newv,k_oldv);
             p_i=svand_z(p_ip,p_i,p_j);
             p_i=svand_z(p_ip,p_i,p_k);
             svuint64_t p_bran=svsel(p_i,ones,zeros);
             svst1(p_ip,&branch_index[iip],p_bran);
             
             // uint64_t t1 = rdtscv();
             // pre_time += (t1-t0);
         }
 
         double sxn_syn_szn[vl];
         double sxo_syn_szn[vl];
         double sxn_syo_szn[vl];
         double sxo_syo_szn[vl];
         double sxn_syn_szo[vl];
         double sxo_syn_szo[vl];
         double sxn_syo_szo[vl];
         double sxo_syo_szo[vl];
         double coef0 = invvol * invdt;
         // reduce method
         // double vv0[block_size][8]={0.};
         // double vv1[block_size][8]={0.};
         // double vv2[block_size][8]={0.};
         // double vv3[block_size][8]={0.};
         // uint64_t loop0=rdtscv();
         for (int k=0; k<=depos_order; k++) {
             double* sz_new_v=sz_new_m[k];
             double* sz_old_v=sz_old_m[k];
             for (int j=0; j<=depos_order; j++) {
                 double* sy_new_v=sy_new_m[j];
                 double* sy_old_v=sy_old_m[j];
                 for (int i=0; i<=depos_order; i++) {
                     double* sx_new_v=sx_new_m[i];
                     double* sx_old_v=sx_old_m[i];
                     for(int iip=0;iip<block_size/vl;iip+=vl) {
                         long ip1=iip+block_id*block_size;
                         svbool_t p=svwhilele_b64(ip1,np_to_deposit);
                         // uint64_t tt0 = rdtscv();
                         Vec sx_new = Vec::Load(p, &sx_new_v[iip]);
                         Vec sx_old = Vec::Load(p, &sx_old_v[iip]);
                         Vec sy_new = Vec::Load(p, &sy_new_v[iip]);
                         Vec sy_old = Vec::Load(p, &sy_old_v[iip]);
                         Vec sz_new = Vec::Load(p, &sz_new_v[iip]);
                         Vec sz_old = Vec::Load(p, &sz_old_v[iip]);
                         Vec wq_v = Vec::Load(p, &wq[iip]);
 
                         Vec coef = wq_v * coef0;
                         Vec syn_szn = coef * (sy_new * sz_new);
                         Vec syo_szn = coef * (sy_old * sz_new);
                         Vec syn_szo = coef * (sy_new * sz_old);
                         Vec syo_szo = coef * (sy_old * sz_old);
                         
                         Vec sxn_syn_szn_v = (sx_new) * syn_szn;
                         Vec sxo_syn_szn_v = (sx_old) * syn_szn;
                         Vec sxn_syo_szn_v = (sx_new) * syo_szn;
                         Vec sxo_syo_szn_v = (sx_old) * syo_szn;
                         Vec sxn_syn_szo_v = (sx_new) * syn_szo;
                         Vec sxo_syn_szo_v = (sx_old) * syn_szo;
                         Vec sxn_syo_szo_v = (sx_new) * syo_szo;
                         Vec sxo_syo_szo_v = (sx_old) * syo_szo;
                         
                         // uint64_t t2 = rdtscv();
                         // cal_time += (t2-tt0);
 
                         svuint64_t p_bran=svld1_u64(p, &branch_index[iip]);
                         svbool_t p_b=svcmpeq_u64(p,p_bran,ones);
                         if(svptest_any(p,p_b))
                         {                          
                             uint64_t save1 = rdtscv();
 
                             // double* base0 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 0);
                             // double* base1 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 1);
                             // double* base2 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 2);
                             // double* base3 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 3);
                             int64_t base_offset = (lo.x + i_new[iip] + i - temp_arr.begin.x) + \
                                                 (lo.y + j_new[iip] + j - temp_arr.begin.y) * temp_arr.jstride + \
                                                 (lo.z + k_new[iip] + k - temp_arr.begin.z) * temp_arr.kstride;
                             int64_t offset0 = base_offset + 0 * temp_arr.nstride;
                             int64_t offset1 = base_offset + 1 * temp_arr.nstride;
                             int64_t offset2 = base_offset + 2 * temp_arr.nstride;
                             int64_t offset3 = base_offset + 3 * temp_arr.nstride;
                             // for(int i=iip;i<vl;i++){
                             //     indices0[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 0) - base0;
                             //     indices1[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 1) - base1;
                             //     indices2[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 2) - base2;
                             //     indices3[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 3) - base3;
                             // }
                             intVec i_newv = intVec::Load(p, &i_new[iip]);
                             intVec j_newv = intVec::Load(p, &j_new[iip]);
                             intVec k_newv = intVec::Load(p, &k_new[iip]);
                             intVec base_indicesv = (lo.x + i_newv + i - temp_arr.begin.x) + \
                                                 (lo.y + j_newv + j - temp_arr.begin.y) * temp_arr.jstride + \
                                                 (lo.z + k_newv + k - temp_arr.begin.z) * temp_arr.kstride;
                             intVec indices_v0 = base_indicesv + 0 * temp_arr.nstride - offset0;
                             intVec indices_v1 = base_indicesv + 1 * temp_arr.nstride - offset1;
                             intVec indices_v2 = base_indicesv + 2 * temp_arr.nstride - offset2;
                             intVec indices_v3 = base_indicesv + 3 * temp_arr.nstride - offset3;
             
                             // svuint64_t indices_v0=svld1_u64(p,&indices0[iip]);
                             Vec v0(svld1_gather_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 0),indices_v0));
                             v0+= (sxn_syn_szn_v - sxo_syo_szo_v);
                             svst1_scatter_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 0),indices_v0,v0);
                             
                             // svuint64_t indices_v1=svld1_u64(p,&indices1[iip]);
                             Vec v1(svld1_gather_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 1),indices_v1));
                             v1+= (sxn_syn_szo_v - sxo_syo_szn_v);
                             svst1_scatter_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 1),indices_v1,v1);
                             
                             // svuint64_t indices_v2=svld1_u64(p,&indices2[iip]);
                             Vec v2(svld1_gather_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 2),indices_v2));
                             v2+= (sxn_syo_szn_v - sxo_syn_szo_v);
                             svst1_scatter_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 2),indices_v2,v2);
                             
                             // svuint64_t indices_v3=svld1_u64(p,&indices3[iip]);
                             Vec v3(svld1_gather_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 3),indices_v3));
                             v3+= (sxo_syn_szn_v - sxn_syo_szo_v);
                             svst1_scatter_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 3),indices_v3,v3);
 
                             uint64_t save2 = rdtscv();
                             save_time1 += (save2-save1);
                             
                             // Ser-write
                             double v0_s[8]={0.};
                             double v1_s[8]={0.};
                             double v2_s[8]={0.};
                             double v3_s[8]={0.};
                             (sxn_syn_szn_v - sxo_syo_szo_v).Store(p,&v0_s[0]);
                             (sxn_syn_szo_v - sxo_syo_szn_v).Store(p,&v1_s[0]);
                             (sxn_syo_szn_v - sxo_syn_szo_v).Store(p,&v2_s[0]);
                             (sxo_syn_szn_v - sxn_syo_szo_v).Store(p,&v3_s[0]);
                              for(int i=iip;i<vl;i++){
                                 temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 0)+=v0_s[i];
                                 temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 1)+=v1_s[i];
                                 temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 2)+=v2_s[i];
                                 temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 3)+=v3_s[i];
                             }
                             uint64_t save3 = rdtscv();
                             save_time2 += (save3-save2);
                         } 
                         else {
                             uint64_t save4 = rdtscv();
 
                             double* base0 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 0);
                             double* base1 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 1);
                             double* base2 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 2);
                             double* base3 = &temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 3);
                             double* base0old = &temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 0);
                             double* base1old = &temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 1);
                             double* base2old = &temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 2);
                             double* base3old = &temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 3);
                             for(int i=iip;i<vl;i++){
                                 indices0[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 0) - base0;
                                 indices1[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 1) - base1;
                                 indices2[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 2) - base2;
                                 indices3[iip+i] =  &temp_arr(lo.x + i_new[iip+i] + i, lo.y + j_new[iip+i] + j, lo.z + k_new[iip+i] + k, 3) - base3;
                                 indices0old[iip+i] =  &temp_arr(lo.x + i_old[iip+i] + i, lo.y + j_old[iip+i] + j, lo.z + k_old[iip+i] + k, 0) - base0old;
                                 indices1old[iip+i] =  &temp_arr(lo.x + i_old[iip+i] + i, lo.y + j_old[iip+i] + j, lo.z + k_old[iip+i] + k, 1) - base1old;
                                 indices2old[iip+i] =  &temp_arr(lo.x + i_old[iip+i] + i, lo.y + j_old[iip+i] + j, lo.z + k_old[iip+i] + k, 2) - base2old;
                                 indices3old[iip+i] =  &temp_arr(lo.x + i_old[iip+i] + i, lo.y + j_old[iip+i] + j, lo.z + k_old[iip+i] + k, 3) - base3old;
                             }
             
                             svuint64_t indices_v0=svld1_u64(p,&indices0[iip]);
                             Vec v0(svld1_gather_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 0),indices_v0));
                             v0+= (sxn_syn_szn_v);
                             svst1_scatter_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 0),indices_v0,v0);
                             
                             svuint64_t indices_v1=svld1_u64(p,&indices1[iip]);
                             Vec v1(svld1_gather_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 1),indices_v1));
                             v1+= (sxn_syn_szo_v );
                             svst1_scatter_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 1),indices_v1,v1);
                             
                             svuint64_t indices_v2=svld1_u64(p,&indices2[iip]);
                             Vec v2(svld1_gather_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 2),indices_v2));
                             v2+= (sxn_syo_szn_v);
                             svst1_scatter_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 2),indices_v2,v2);
                             
                             svuint64_t indices_v3=svld1_u64(p,&indices3[iip]);
                             Vec v3(svld1_gather_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 3),indices_v3));
                             v3+= (sxo_syn_szn_v);
                             svst1_scatter_index(p,&temp_arr(lo.x + i_new[iip] + i, lo.y + j_new[iip] + j, lo.z + k_new[iip] + k, 3),indices_v3,v3);
                             
                             svuint64_t indices_v0old=svld1_u64(p,&indices0old[iip]);
                             Vec v0old(svld1_gather_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 0),indices_v0old));
                             v0old+= ( - sxo_syo_szo_v);
                             svst1_scatter_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 0),indices_v0,v0);
                             
                             svuint64_t indices_v1old=svld1_u64(p,&indices1old[iip]);
                             Vec v1old(svld1_gather_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 1),indices_v1old));
                             v1old+= ( - sxo_syo_szn_v);
                             svst1_scatter_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 1),indices_v1,v1);
                             
                             svuint64_t indices_v2old=svld1_u64(p,&indices2old[iip]);
                             Vec v2old(svld1_gather_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 2),indices_v2old));
                             v2old+= ( - sxo_syn_szo_v);
                             svst1_scatter_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 2),indices_v2,v2);
                             
                             svuint64_t indices_v3old=svld1_u64(p,&indices3old[iip]);
                             Vec v3old(svld1_gather_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 3),indices_v3old));
                             v3old+= ( - sxn_syo_szo_v);
                             svst1_scatter_index(p,&temp_arr(lo.x + i_old[iip] + i, lo.y + j_old[iip] + j, lo.z + k_old[iip] + k, 3),indices_v3,v3);
 
                             uint64_t save5 = rdtscv();
                             save_time3 += (save5-save4);
                             // }
                         }
                         printf("\n  save_time1: %d,save_time2: %d,save_time3: %d \n", 
                                       save_time1,    save_time2,    save_time3    );
                         // uint64_t t3 = rdtscv();
                         // save_time += (t3-t2);
 
                     }
                 }
             }
         }
         // uint64_t loop1=rdtscv();
         // nijk_loop_time+=(loop1-loop0);
         // amrex::Abort("END BLOCK");
     }
     // uint64_t t4 = rdtscv();
     const amrex::Box& bx=Dx_fab.box();
     const amrex::IntVect Dxlo=bx.smallEnd();
     const amrex::IntVect Dxhi=bx.bigEnd();
     
     for(int k=Dxlo[2];k<=Dxhi[2];++k){
         for(int j=Dxlo[1];j<=Dxhi[1];++j){
             // for(int i=Dxlo[0];i<=Dxhi[0];i++){
             for(int i=Dxlo[0];i<=Dxhi[0];i+=vl){
             // amrex::ParallelFor(Dx_fab.box(), [&] AMREX_GPU_DEVICE (int i, int j, int k) noexcept
             // {
                 svbool_t p = svwhilele_b64(i,Dxhi[0]);
                 Vec t_av=Vec::Load(p,&temp_arr(i,j,k,0));
                 Vec t_bv=Vec::Load(p,&temp_arr(i,j,k,1));
                 Vec t_cv=Vec::Load(p,&temp_arr(i,j,k,2));
                 Vec t_dv=Vec::Load(p,&temp_arr(i,j,k,3));
 
                 Vec Dx_arrv=Vec::Load(p,&Dx_arr(i,j,k));
                 Vec Dy_arrv=Vec::Load(p,&Dy_arr(i,j,k));
                 Vec Dz_arrv=Vec::Load(p,&Dz_arr(i,j,k));
                 Dx_arrv += (1._rt/6._rt)*(2_rt*t_av       + t_bv       + t_cv - 2._rt*t_dv);
                 Dy_arrv += (1._rt/6._rt)*(2_rt*t_av       + t_bv - 2._rt*t_cv       + t_dv);
                 Dz_arrv += (1._rt/6._rt)*(2_rt*t_av - 2._rt*t_bv       + t_cv       + t_dv);
 
                 Dx_arrv.Store(p,&Dx_arr(i,j,k));
                 Dy_arrv.Store(p,&Dy_arr(i,j,k));
                 Dz_arrv.Store(p,&Dz_arr(i,j,k));               
             // });
             }
         }
     }
     // uint64_t t5 = rdtscv();
     // post_time += (t5-t4);
     // Synchronize so that temp_fab can be safely deallocated in its destructor
     amrex::Gpu::streamSynchronize();
 
 // uint64_t step1 = rdtscv();
 // step_time = (step1-step0);
 // printf("\n Step_time: %d, pre_time: %d,  trans_time: %d, loop_time: %d, cal_time: %d,  read_time: %d, save_time1: %d,save_time2: %d,save_time: %d,  post_time: %d \n", 
 //             step_time,     pre_time,   trans_martix_time, nijk_loop_time, cal_time,      read_time,     save_time1,    save_time2,    save_time,      post_time);
 // amrex::Abort("Test Over!");
 }
 
 
 #endif // WARPX_CURRENTDEPOSITION_H_
 
 